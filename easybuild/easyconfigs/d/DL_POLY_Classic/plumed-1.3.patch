# patch plumed 1.3 in dl poly. Generated with the scripts found in the
# plumed-1.3 tarball. Makefile adjusted to use the EB generated values
# by Ward Poelmans <ward.poelmans@ugent.be>
diff -urN dl_class_1.9.orig/build/MakePAR dl_class_1.9/build/MakePAR
--- dl_class_1.9.orig/build/MakePAR	2011-02-22 12:46:11.000000000 +0100
+++ dl_class_1.9/build/MakePAR	2015-11-07 16:58:03.510055438 +0100
@@ -6,7 +6,8 @@
 #=======================================================================
 
 BINROOT = ../execute
-CC  = gcc
+CC  = mpicc
+CPP = mpicxx
 EX = DLPOLY.X
 EXE = $(BINROOT)/$(EX)
 FC=undefined
@@ -39,6 +40,12 @@
 
 OBJ_PAR = basic_comms.o merge_tools.o pass_tools.o
 
+HEAD_METAD = Plumed/metadyn.h
+
+include Plumed/plumed.inc
+
+OBJ_METAD = $(PLUMED_OBJECTS) images.o
+
 #=====================================================================
 # Define targets
 all:
@@ -68,8 +75,8 @@
 #=====================================================================
 # Default code for parallel (MPI) execution
 
-par: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
-	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
+par: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(OBJ_SRC)
+	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(RECON_LIBS) $(OBJ_SRC)
 	mv $(EX) $(EXE)
 
 #=====================================================================
@@ -83,16 +90,26 @@
 #=====================================================================
 # Clean up the source directory
 clean:
-	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC) *.mod
+	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(OBJ_SRC) *.mod
 
 #=====================================================================
 # Declare dependencies
 .f.o: 
 	$(FC) $(FFLAGS) $*.f
-.c.o: 
-	$(CC) -c $*.c
+
+.c.o: $(HEAD_METAD) 
+	$(CC) -DDL_POLY $(RECON_FLAGS) -DMPI -c $(CFLAGS) $< -o $@
+
+%.o: %.cpp $(HEAD_RECON) 
+	$(CPP) -DMPI $(RECON_FLAGS) -c $(CFLAGS) $< -o $@
 
 #=====================================================================
 # Declare dependency on module files
 
 $(OBJ_SRC): $(OBJ_MOD)
+
+#=====================================================================
+# Declare dependency for C header files
+
+$(OBJ_METAD): $(HEAD_METAD)
+$(OBJ_RECON): $(HEAD_RECON)
diff -urN dl_class_1.9.orig/build/MakePAR.preplumed dl_class_1.9/build/MakePAR.preplumed
--- dl_class_1.9.orig/build/MakePAR.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/build/MakePAR.preplumed	2011-02-22 12:46:11.000000000 +0100
@@ -0,0 +1,98 @@
+# Master makefile for DL_POLY Classic
+# Author: W. Smith January Dec 2010
+# 
+#=======================================================================
+# Define default settings
+#=======================================================================
+
+BINROOT = ../execute
+CC  = gcc
+EX = DLPOLY.X
+EXE = $(BINROOT)/$(EX)
+FC=undefined
+SHELL=/bin/sh
+TYPE=par
+
+#=====================================================================
+# Define object files
+
+OBJ_MOD = parse_module.o setup_module.o error_module.o \
+	site_module.o config_module.o pair_module.o utility_module.o \
+	metafreeze_module.o solvation_module.o tether_module.o \
+	vdw_module.o property_module.o rigid_body_module.o \
+	angles_module.o bonds_module.o shake_module.o \
+	inversion_module.o dihedral_module.o core_shell_module.o \
+	exclude_module.o ewald_module.o coulomb_module.o\
+	external_field_module.o four_body_module.o \
+	hkewald_module.o metal_module.o ensemble_tools_module.o \
+	temp_scalers_module.o three_body_module.o spme_module.o \
+	tersoff_module.o neu_coul_module.o \
+	nlist_builders_module.o forces_module.o \
+	lf_motion_module.o lf_rotation1_module.o \
+	lf_rotation2_module.o vv_motion_module.o \
+	vv_rotation1_module.o vv_rotation2_module.o \
+	pmf_module.o integrator_module.o optimiser_module.o \
+	hyper_dynamics_module.o driver_module.o \
+	define_system_module.o
+
+OBJ_SRC = dlpoly.o
+
+OBJ_PAR = basic_comms.o merge_tools.o pass_tools.o
+
+#=====================================================================
+# Define targets
+all:
+	@echo "Error - please specify a target machine!"
+	@echo "Permissible targets for this Makefile are:"
+	@echo "                                          "
+	@echo "gfortran                   (parallel)"
+	@echo "woodcrest                  (parallel)"
+	@echo "         "
+	@echo "Please examine Makefile for details"
+
+# system specific targets follow :
+
+#================== GNU Fortran, MPI version ==============================
+gfortran:
+	$(MAKE) FC="mpif90" LD="mpif90 -o" \
+	LDFLAGS="-O2 -ffast-math" \
+	FFLAGS="-c -O2 -ffast-math" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#================= Woodcrest =========================================
+woodcrest:
+	$(MAKE) LD="mpif90 -o" LDFLAGS="" \
+	FC=mpif90 FFLAGS="-c -O3" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#=====================================================================
+# Default code for parallel (MPI) execution
+
+par: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
+	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
+	mv $(EX) $(EXE)
+
+#=====================================================================
+# Check that a machine has been specified
+check:
+	@if test $(FC) = "undefined";\
+	then echo "You must specify a target machine!"; \
+	exit 99;\
+	fi
+
+#=====================================================================
+# Clean up the source directory
+clean:
+	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC) *.mod
+
+#=====================================================================
+# Declare dependencies
+.f.o: 
+	$(FC) $(FFLAGS) $*.f
+.c.o: 
+	$(CC) -c $*.c
+
+#=====================================================================
+# Declare dependency on module files
+
+$(OBJ_SRC): $(OBJ_MOD)
diff -urN dl_class_1.9.orig/build/MakeSEQ dl_class_1.9/build/MakeSEQ
--- dl_class_1.9.orig/build/MakeSEQ	2011-02-22 12:46:11.000000000 +0100
+++ dl_class_1.9/build/MakeSEQ	2015-11-07 16:58:03.504055262 +0100
@@ -7,6 +7,7 @@
 
 BINROOT = ../execute
 CC  = gcc
+CPP = g++
 EX = DLPOLY.X
 EXE = $(BINROOT)/$(EX)
 FC=undefined
@@ -39,6 +40,12 @@
 
 OBJ_PAR = serial.o
 
+HEAD_METAD = Plumed/metadyn.h
+
+include Plumed/plumed.inc
+
+OBJ_METAD = $(PLUMED_OBJECTS) images.o
+
 #=====================================================================
 # Define targets
 all:
@@ -80,8 +87,8 @@
 #=====================================================================
 # Default code for sequential execution
 
-seq: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
-	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
+seq: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(OBJ_SRC)
+	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(RECON_LIBS) $(OBJ_SRC)
 	mv $(EX) $(EXE)
 
 #=====================================================================
@@ -95,16 +102,26 @@
 #=====================================================================
 # Clean up the source directory
 clean:
-	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC) *.mod
+	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(OBJ_SRC) *.mod
 
 #=====================================================================
 # Declare dependencies
 .f.o: 
 	$(FC) $(FFLAGS) $*.f
-.c.o: 
-	$(CC) -c $*.c
+
+.c.o: $(HEAD_METAD)
+	$(CC) -DDL_POLY $(RECON_FLAGS) -c $(CFLAGS) $< -o $@
+
+%.o: %.cpp $(HEAD_RECON)
+	$(CPP) -c $(CFLAGS) $(RECON_FLAGS) $< -o $@
 
 #=====================================================================
 # Declare dependency on module files
 
 $(OBJ_SRC): $(OBJ_MOD)
+
+#=====================================================================
+# Declare dependency for C header files
+
+$(OBJ_METAD): $(HEAD_METAD)
+$(OBJ_RECON): $(HEAD_RECON)
diff -urN dl_class_1.9.orig/build/MakeSEQ.preplumed dl_class_1.9/build/MakeSEQ.preplumed
--- dl_class_1.9.orig/build/MakeSEQ.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/build/MakeSEQ.preplumed	2011-02-22 12:46:11.000000000 +0100
@@ -0,0 +1,110 @@
+# Master makefile for DL_POLY Classic
+# Author: W. Smith December 2010
+# 
+#=======================================================================
+# Define default settings
+#=======================================================================
+
+BINROOT = ../execute
+CC  = gcc
+EX = DLPOLY.X
+EXE = $(BINROOT)/$(EX)
+FC=undefined
+SHELL=/bin/sh
+TYPE=seq
+
+#=====================================================================
+# Define object files
+
+OBJ_MOD = parse_module.o setup_module.o error_module.o \
+	site_module.o config_module.o pair_module.o utility_module.o \
+	metafreeze_module.o solvation_module.o tether_module.o \
+	vdw_module.o property_module.o rigid_body_module.o \
+	angles_module.o bonds_module.o shake_module.o \
+	inversion_module.o dihedral_module.o core_shell_module.o \
+	exclude_module.o ewald_module.o coulomb_module.o\
+	external_field_module.o four_body_module.o \
+	hkewald_module.o metal_module.o ensemble_tools_module.o \
+	temp_scalers_module.o three_body_module.o spme_module.o \
+	tersoff_module.o neu_coul_module.o \
+	nlist_builders_module.o forces_module.o \
+	lf_motion_module.o lf_rotation1_module.o \
+	lf_rotation2_module.o vv_motion_module.o \
+	vv_rotation1_module.o vv_rotation2_module.o \
+	pmf_module.o integrator_module.o optimiser_module.o \
+	hyper_dynamics_module.o driver_module.o \
+	define_system_module.o
+
+OBJ_SRC = dlpoly.o
+
+OBJ_PAR = serial.o
+
+#=====================================================================
+# Define targets
+all:
+	@echo "Error - please specify a target machine!"
+	@echo "Permissible targets for this Makefile are:"
+	@echo "                                          "
+	@echo "nag-f95                    (serial)"
+	@echo "gfortran                   (serial)"
+	@echo "macosx                     (serial)"
+	@echo "intel-linux-ifc            (serial)"
+	@echo "         "
+	@echo "Please examine Makefile for details"
+
+# system specific targets follow :
+
+#========================== NAG Fortran 95 ===========================
+nag-f95:
+	$(MAKE) LD="f95 -o" LDFLAGS="" \
+	FC=f95 FFLAGS="-c -O -fixed -kind=byte" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#========== GNU Fortran =================================================
+gfortran:
+	$(MAKE) LD="gfortran -o" LDFLAGS="" FC=gfortran \
+	FFLAGS="-c -O2 -ffast-math" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#============= MacOSX (Darwin) version: derived from AIX ===============
+macosx: 
+	$(MAKE) LD="xlf -o" LDFLAGS="" FC=xlf FFLAGS="-c -O3 -qstrict -qarch=g5 -qnosave"\
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#========== Intel Linux IFC =============================================
+intel-linux-ifc: 
+	$(MAKE) FC=ifc LD="ifc -o" FFLAGS="-c -O3 -w95 -w" \
+	LDFLAGS="-Vaxlib -static" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#=====================================================================
+# Default code for sequential execution
+
+seq: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
+	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
+	mv $(EX) $(EXE)
+
+#=====================================================================
+# Check that a machine has been specified
+check:
+	@if test $(FC) = "undefined";\
+	then echo "You must specify a target machine!"; \
+	exit 99;\
+	fi
+
+#=====================================================================
+# Clean up the source directory
+clean:
+	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC) *.mod
+
+#=====================================================================
+# Declare dependencies
+.f.o: 
+	$(FC) $(FFLAGS) $*.f
+.c.o: 
+	$(CC) -c $*.c
+
+#=====================================================================
+# Declare dependency on module files
+
+$(OBJ_SRC): $(OBJ_MOD)
diff -urN dl_class_1.9.orig/build/MakeWIN dl_class_1.9/build/MakeWIN
--- dl_class_1.9.orig/build/MakeWIN	2014-03-24 12:25:53.000000000 +0100
+++ dl_class_1.9/build/MakeWIN	2015-11-07 16:58:03.499055116 +0100
@@ -7,6 +7,7 @@
 
 BINROOT = ../execute
 CC  = gcc
+CPP = g++
 EX = DLPOLY.X
 EXE = $(BINROOT)/$(EX)
 FC=undefined
@@ -39,6 +40,12 @@
 
 OBJ_PAR = serial.o
 
+HEAD_METAD = Plumed/metadyn.h
+
+include Plumed/plumed.inc
+
+OBJ_METAD = $(PLUMED_OBJECTS) images.o
+
 #=====================================================================
 # Define targets
 all:
@@ -66,8 +73,8 @@
 #=====================================================================
 # Default code for Windows execution
 
-win: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
-	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
+win: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(OBJ_SRC)
+	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(RECON_LIBS) $(OBJ_SRC)
 	mv $(EX) $(EXE)
 
 #=====================================================================
@@ -81,16 +88,26 @@
 #=====================================================================
 # Clean up the source directory
 clean:
-	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC) *.mod
+	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(OBJ_SRC) *.mod
 
 #=====================================================================
 # Declare dependencies
 .f.o: 
 	$(FC) $(FFLAGS) $*.f
-.c.o: 
-	$(CC) -c $*.c
+
+.c.o: $(HEAD_METAD)
+	$(CC) -DDL_POLY $(RECON_FLAGS) -c $(CFLAGS) $< -o $@
+
+%.o: %.cpp $(HEAD_RECON)
+	$(CPP) -c $(RECON_FLAGS) $(CFLAGS) $< -o $@
 
 #=====================================================================
 # Declare dependency on module files
 
 $(OBJ_SRC): $(OBJ_MOD)
+
+#=====================================================================
+# Declare dependency for C header files
+
+$(OBJ_METAD): $(HEAD_METAD)
+$(OBJ_RECON): $(HEAD_RECON)
diff -urN dl_class_1.9.orig/build/MakeWIN.preplumed dl_class_1.9/build/MakeWIN.preplumed
--- dl_class_1.9.orig/build/MakeWIN.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/build/MakeWIN.preplumed	2014-03-24 12:25:53.000000000 +0100
@@ -0,0 +1,96 @@
+# Master makefile for DL_POLY Classic
+# Author: W. Smith December 2010
+# 
+#=======================================================================
+# Define default settings
+#=======================================================================
+
+BINROOT = ../execute
+CC  = gcc
+EX = DLPOLY.X
+EXE = $(BINROOT)/$(EX)
+FC=undefined
+SHELL=/bin/sh
+TYPE=win
+
+#=====================================================================
+# Define object files
+
+OBJ_MOD = parse_module.o setup_module.o error_module.o \
+	site_module.o config_module.o pair_module.o utility_module.o \
+	metafreeze_module.o solvation_module.o tether_module.o \
+	vdw_module.o property_module.o rigid_body_module.o \
+	angles_module.o bonds_module.o shake_module.o \
+	inversion_module.o dihedral_module.o core_shell_module.o \
+	exclude_module.o ewald_module.o coulomb_module.o\
+	external_field_module.o four_body_module.o \
+	hkewald_module.o metal_module.o ensemble_tools_module.o \
+	temp_scalers_module.o three_body_module.o spme_module.o \
+	tersoff_module.o neu_coul_module.o \
+	nlist_builders_module.o forces_module.o \
+	lf_motion_module.o lf_rotation1_module.o \
+	lf_rotation2_module.o vv_motion_module.o \
+	vv_rotation1_module.o vv_rotation2_module.o \
+	pmf_module.o integrator_module.o optimiser_module.o \
+	hyper_dynamics_module.o driver_module.o \
+	define_system_module.o
+
+OBJ_SRC = dlpoly.o
+
+OBJ_PAR = serial.o
+
+#=====================================================================
+# Define targets
+all:
+	@echo "Error - please specify a target machine!"
+	@echo "Permissible targets for this Makefile are:"
+	@echo "                                          "
+	@echo "gfortran                     (serial)"
+	@echo "cygwin-g95                   (serial)"
+	@echo "         "
+	@echo "Please examine Makefile for details"
+
+# system specific targets follow :
+
+#======== Windows XP/Cygwin/MinGW GNU Fortran ========================
+gfortran:
+	$(MAKE) LD="gfortran -o" LDFLAGS="" FC=gfortran \
+	FFLAGS="-c -O2 -ffast-math" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#======== Windows XP/Cygwin/G95 ======================================
+cygwin-g95:
+	$(MAKE) LD="g95 -o" LDFLAGS= FC=g95 FFLAGS=-c EX=$(EX) \
+	BINROOT=$(BINROOT) $(TYPE)
+
+#=====================================================================
+# Default code for Windows execution
+
+win: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
+	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC)
+	mv $(EX) $(EXE)
+
+#=====================================================================
+# Check that a machine has been specified
+check:
+	@if test $(FC) = "undefined";\
+	then echo "You must specify a target machine!"; \
+	exit 99;\
+	fi
+
+#=====================================================================
+# Clean up the source directory
+clean:
+	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_SRC) *.mod
+
+#=====================================================================
+# Declare dependencies
+.f.o: 
+	$(FC) $(FFLAGS) $*.f
+.c.o: 
+	$(CC) -c $*.c
+
+#=====================================================================
+# Declare dependency on module files
+
+$(OBJ_SRC): $(OBJ_MOD)
diff -urN dl_class_1.9.orig/PLUMED_PATCH dl_class_1.9/PLUMED_PATCH
--- dl_class_1.9.orig/PLUMED_PATCH	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/PLUMED_PATCH	2015-11-07 16:58:03.438053327 +0100
@@ -0,0 +1,3 @@
+#Please do not remove or modify this file
+#It is keeps track of patched versions of the PLUMED package
+1.3
diff -urN dl_class_1.9.orig/srcmod/angles_module.f dl_class_1.9/srcmod/angles_module.f
--- dl_class_1.9.orig/srcmod/angles_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/angles_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,741 @@
+      module angles_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining valence angle potentials
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     modified  - p.-a.cazade      oct 2007 : solvation etc.
+c     modified  - d. quigley           2010 : metadynamics
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use metafreeze_module
+      use parse_module
+      use property_module
+      use setup_module
+      use site_module
+      use solvation_module
+      use utility_module
+
+      implicit none
+
+      real(8), allocatable :: prmang(:,:)
+      integer, allocatable :: listang(:,:)
+      integer, allocatable :: numang(:),keyang(:),lstang(:,:)
+
+      save prmang,listang,numang,keyang,lstang
+
+      contains
+      
+      subroutine alloc_ang_arrays(idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining valence angle potential arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer i,fail,idnode
+      dimension fail(5)
+
+      do i=1,5
+        fail(i)=0
+      enddo
+
+      allocate (prmang(mxtang,mxpang),stat=fail(1))
+      allocate (numang(mxtmls),stat=fail(2))
+      allocate (keyang(mxtang),stat=fail(3))
+      allocate (lstang(mxtang,3),stat=fail(4))
+      allocate (listang(mxangl,4),stat=fail(5))
+
+      do i=1,5
+        if(fail(i).gt.0)call error(idnode,1010)
+      enddo
+
+      do i=1,mxtmls
+         numang(i)=0
+      enddo
+
+      end subroutine alloc_ang_arrays
+
+      subroutine define_angles
+     x  (safe,idnode,itmols,nangle,nsite,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining bond angles
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe
+      character*8 keyword
+      character*1 message(80)
+      integer idnode,itmols,nangle,nsite,ntmp,i,iang,iang1
+      integer idum,iatm1,iatm2,iatm3,isite1,isite2,isite3,ia,ja
+      real(8) engunit
+
+      ntmp=intstr(record,lenrec,idum)
+      numang(itmols)=numang(itmols)+ntmp
+      if(idnode.eq.0)then
+        write(nrite,"(/,1x,'number of bond angles',
+     x    10x,i10)")ntmp
+        write(nrite,"(/,/,1x,'bond angle details:',
+     x    /,/,21x,7x,'key',5x,'index',5x,'index',5x,
+     x    'index',5x,'f-const',7x,'angle',/)")
+      endif
+      
+      iang1=numang(itmols)
+      do iang=1,iang1
+
+c     read bond angle potential parameters
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        call copystring(record,message,80)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+        iatm1=intstr(record,lenrec,idum)
+        iatm2=intstr(record,lenrec,idum)
+        iatm3=intstr(record,lenrec,idum)
+
+c     test for frozen atom pairs
+
+        isite1=nsite-numsit(itmols)+iatm1
+        isite2=nsite-numsit(itmols)+iatm2
+        isite3=nsite-numsit(itmols)+iatm3
+
+        if(lfzsit(isite1)*lfzsit(isite2)*
+     x    lfzsit(isite3).ne.0)then
+          
+          numang(itmols)=numang(itmols)-1
+          if(idnode.eq.0)write(nrite,'(14x,a16,40a1)')
+     x      '*** frozen *** ',(message(i),i=1,40)
+
+        else
+
+          nangle=nangle+1
+          
+          if(nangle.gt.mxtang)call error(idnode,50)
+          
+          if(keyword(1:4).eq.'harm')then
+            keyang(nangle)=1
+          elseif(keyword(1:4).eq.'-hrm')then
+            keyang(nangle)=-1
+          elseif(keyword(1:4).eq.'quar')then
+            keyang(nangle)=2
+          elseif(keyword(1:4).eq.'-qur')then
+            keyang(nangle)=-2
+          elseif(keyword(1:4).eq.'thrm')then
+            keyang(nangle)=3
+          elseif(keyword(1:4).eq.'-thm')then
+            keyang(nangle)=-3
+          elseif(keyword(1:4).eq.'shrm')then
+            keyang(nangle)=4
+          elseif(keyword(1:4).eq.'-shm')then
+            keyang(nangle)=-4
+          elseif(keyword(1:4).eq.'bvs1')then
+            keyang(nangle)=5
+          elseif(keyword(1:4).eq.'-bv1')then
+            keyang(nangle)=-5
+          elseif(keyword(1:4).eq.'bvs2')then
+            keyang(nangle)=6
+          elseif(keyword(1:4).eq.'-bv2')then
+            keyang(nangle)=-6
+          elseif(keyword(1:4).eq.'hcos')then
+            keyang(nangle)=7
+          elseif(keyword(1:4).eq.'-hcs')then
+            keyang(nangle)=-7
+          elseif(keyword(1:4).eq.'cos ')then
+            keyang(nangle)=8
+          elseif(keyword(1:4).eq.'-cos')then
+            keyang(nangle)=-8
+          elseif(keyword(1:4).eq.'mmsb')then
+            keyang(nangle)=9
+          elseif(keyword(1:4).eq.'-msb')then
+            keyang(nangle)=-9
+          elseif(keyword(1:4).eq.'stst') then
+            keyang(nangle)=10
+          elseif(keyword(1:4).eq.'-sts') then
+            keyang(nangle)=-10
+          elseif(keyword(1:4).eq.'stbe') then
+            keyang(nangle)=11
+          elseif(keyword(1:4).eq.'-stb') then
+            keyang(nangle)=-11
+          elseif(keyword(1:4).eq.'cmps') then
+            keyang(nangle)=12
+          elseif(keyword(1:4).eq.'-cmp') then
+            keyang(nangle)=-12
+          else
+            if(idnode.eq.0)write(nrite,*)message
+            call error(idnode,440)
+          endif
+
+          lstang(nangle,1)=iatm1
+          lstang(nangle,2)=iatm2
+          lstang(nangle,3)=iatm3
+          prmang(nangle,1)=dblstr(record,lenrec,idum)
+          prmang(nangle,2)=dblstr(record,lenrec,idum)
+          prmang(nangle,3)=dblstr(record,lenrec,idum)
+          prmang(nangle,4)=dblstr(record,lenrec,idum)
+          prmang(nangle,5)=dblstr(record,lenrec,idum)
+          prmang(nangle,6)=dblstr(record,lenrec,idum)
+          
+          if(idnode.eq.0) 
+     x      write(nrite,"(27x,a4,3i10,1p,e12.4,0p,9f12.6)")
+     x      keyword(1:4),(lstang(nangle,ia),ia=1,3),
+     x      (prmang(nangle,ja),ja=1,mxpang)
+
+c     convert energies to internal units
+          
+          prmang(nangle,1)=prmang(nangle,1)*engunit
+          if(abs(keyang(nangle)).eq.2)then
+            prmang(nangle,3)=prmang(nangle,3)*engunit
+            prmang(nangle,4)=prmang(nangle,4)*engunit
+          elseif(abs(keyang(nangle)).eq.12)then
+            prmang(nangle,2)=prmang(nangle,2)*engunit            
+            prmang(nangle,3)=prmang(nangle,3)*engunit
+          endif
+
+c     convert angles to radians
+          
+          if(abs(keyang(nangle)).eq.12)then
+            prmang(nangle,4)=prmang(nangle,4)*(pi/180.d0)
+          elseif(abs(keyang(nangle)).ne.10)then
+            prmang(nangle,2)=prmang(nangle,2)*(pi/180.d0) 
+          endif
+
+        endif
+
+      enddo
+      
+      return
+      end subroutine define_angles
+
+      subroutine angfrc
+     x  (lsolva,lfree,lexcite,idnode,imcon,mxnode,ntangl,engang,virang)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating bond angle energy and 
+c     force terms in molecular dynamics.
+c     
+c     replicated data - blocked version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith         may 1992
+c     modified  - t. forester      feb 1993
+c     modified  - t. forester      nov 1994 : block data
+c     modified  - t. forester      may 1995 : stress tensor 
+c     modified  - p.-a.cazade      oct 2007 : solvation etc.
+c     modified  - d. quigley       nov 2010 : metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lsolva,lfree,lexcite,lselect
+      logical idrive,jdrive,kdrive
+      integer idnode,mxnode,imcon,ntangl,fail1,fail2
+      integer ii,iang1,iang2,i,ia,ib,ic,kk,keya
+      real(8) engang,virang,theta,fxc,fyc,fzc,rab,xab
+      real(8) yab,zab,rbc,xbc,ybc,zbc,sint,cost,pterm,vterm
+      real(8) gamma,gamsa,gamsc,rrbc,rrab,fxa,fya,fza
+      real(8) strs(6),strs_loc(6)
+      real(8), allocatable :: xdab(:),ydab(:),zdab(:)
+      real(8), allocatable :: xdbc(:),ydbc(:),zdbc(:)
+      
+      allocate (xdab(msbad),ydab(msbad),zdab(msbad),stat=fail1)
+      allocate (xdbc(msbad),ydbc(msbad),zdbc(msbad),stat=fail2)
+      if(fail1.ne.fail2)call error(idnode,1020)
+
+c     flag for undefined potentials
+
+      safe=.true.
+
+c     check size of work arrays
+
+      if((ntangl-mxnode+1)/mxnode.gt.msbad)call error(idnode,419)
+
+c     block indices
+      
+      iang1=(idnode*ntangl)/mxnode+1
+      iang2=((idnode+1)*ntangl)/mxnode
+
+c     zero accumulators
+      
+      engang=0.d0
+      virang=0.d0
+      ang_fre=0.d0
+      ang_vir=0.d0
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+      if(lsolva)then
+        
+        lcomp(2)=.true.
+        ang_sol(:)=0.d0
+        if(lexcite)ang_exc(:)=0.d0
+        
+      endif
+      
+c     calculate atom separation vectors
+      
+      ii=0
+      do i=iang1,iang2
+        
+        ii=ii+1
+
+c     indices of bonded atoms
+        
+        ia=listang(ii,2)
+        ib=listang(ii,3)
+        ic=listang(ii,4)
+
+c     components of first bond vector
+        
+        xdab(ii)=xxx(ia)-xxx(ib)
+        ydab(ii)=yyy(ia)-yyy(ib)
+        zdab(ii)=zzz(ia)-zzz(ib)
+
+c     components of second bond vector
+        
+        xdbc(ii)=xxx(ic)-xxx(ib)
+        ydbc(ii)=yyy(ic)-yyy(ib)
+        zdbc(ii)=zzz(ic)-zzz(ib)
+        
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,0,1,ii,cell,xdab,ydab,zdab)
+      call images(imcon,0,1,ii,cell,xdbc,ydbc,zdbc)
+
+c     loop over all specified angle potentials
+      
+      ii=0
+      do i=iang1,iang2
+        
+        ii=ii+1
+
+c     define components of first bond vector
+        
+        rab=sqrt(xdab(ii)**2+ydab(ii)**2+zdab(ii)**2)
+        rrab=1.d0/rab
+        
+        xab=xdab(ii)*rrab
+        yab=ydab(ii)*rrab
+        zab=zdab(ii)*rrab
+
+c     define components of second bond vector
+        
+        rbc=sqrt(xdbc(ii)**2+ydbc(ii)**2+zdbc(ii)**2)
+        rrbc=1.d0/rbc
+        
+        xbc=xdbc(ii)*rrbc
+        ybc=ydbc(ii)*rrbc
+        zbc=zdbc(ii)*rrbc
+
+c     index of potential function parameters
+        
+        kk=listang(ii,1)
+
+c     determine bond angle and calculate potential energy
+        
+        cost=(xab*xbc+yab*ybc+zab*zbc)
+        theta=acos(cost)
+        sint=max(1.d-8,sqrt(1.d0-cost**2))
+        
+        keya=abs(keyang(kk))
+        
+        if(keya.eq.1)then
+          
+c     harmonic potential
+          
+          pterm=0.5d0*prmang(kk,1)*(theta-prmang(kk,2))**2
+          gamma=prmang(kk,1)*(theta-prmang(kk,2))/sint
+          vterm=0.d0
+          gamsa=0.d0
+          gamsc=0.d0
+          
+        elseif(keya.eq.2)then
+
+c     quartic potential
+          
+          pterm=0.5d0*prmang(kk,1)*(theta-prmang(kk,2))**2+
+     x      1.d0/3.d0*prmang(kk,3)*(theta-prmang(kk,2))**3+
+     x      0.25d0*prmang(kk,4)*(theta-prmang(kk,2))**4
+          gamma=(prmang(kk,1)*(theta-prmang(kk,2))+
+     x      prmang(kk,3)*(theta-prmang(kk,2))**2+
+     x      prmang(kk,4)*(theta-prmang(kk,2))**3)/sint
+          vterm=0.d0
+          gamsa=0.d0
+          gamsc=0.d0
+          
+        elseif(keya.eq.3)then
+
+c     truncated harmonic potential
+      
+          pterm=0.5d0*prmang(kk,1)*(theta-prmang(kk,2))**2*
+     x      exp(-(rab**8+rbc**8)/prmang(kk,3)**8)
+          gamma=prmang(kk,1)*(theta-prmang(kk,2))*
+     x      exp(-(rab**8+rbc**8)/prmang(kk,3)**8)/sint
+          vterm=-8.d0*pterm*(rab**8+rbc**8)/prmang(kk,3)**8
+          gamsa=(8.d0*pterm/prmang(kk,3)**8)*rab**7
+          gamsc=(8.d0*pterm/prmang(kk,3)**8)*rbc**7
+          
+        elseif(keya.eq.4)then
+
+c     screened harmonic potential
+          
+          pterm=0.5d0*prmang(kk,1)*(theta-prmang(kk,2))**2*
+     x      exp(-(rab/prmang(kk,3)+rbc/prmang(kk,4)))
+          gamma=prmang(kk,1)*(theta-prmang(kk,2))*
+     x      exp(-(rab/prmang(kk,3)+rbc/prmang(kk,4)))/sint
+          vterm=-pterm*(rab/prmang(kk,3)+rbc/prmang(kk,4))
+          gamsa=(pterm/prmang(kk,3))
+          gamsc=(pterm/prmang(kk,4))
+          
+        elseif(keya.eq.5)then
+
+c     screened vessal potential (type 1)
+      
+          pterm=(prmang(kk,1)/(8.d0*(prmang(kk,2)-pi)**2)*
+     x      (((prmang(kk,2)-pi)**2-(theta-pi)**2)**2))*
+     x      exp(-(rab/prmang(kk,3)+rbc/prmang(kk,4)))
+          gamma=(prmang(kk,1)/(2.d0*(prmang(kk,2)-pi)**2)*
+     x      ((prmang(kk,2)-pi)**2-(theta-pi)**2)*(theta-pi))*
+     x      exp(-(rab/prmang(kk,3)+rbc/prmang(kk,4)))/sint
+          vterm=-pterm*(rab/prmang(kk,3)+rbc/prmang(kk,4))
+          gamsa=(pterm/prmang(kk,3))
+          gamsc=(pterm/prmang(kk,4))
+          
+        elseif(keya.eq.6)then
+
+c     truncated vessal potential (type 2)
+          
+          pterm=prmang(kk,1)*(theta**prmang(kk,3)*(theta-prmang(kk,2))
+     x      **2*(theta+prmang(kk,2)-2.d0*pi)**2-0.5d0*prmang(kk,3)*pi
+     x      **(prmang(kk,3)-1.d0)*(theta-prmang(kk,2))**2*(pi-prmang(kk,
+     x      2))**3)*exp(-(rab**8+rbc**8)/prmang(kk,4)**8)
+          gamma=prmang(kk,1)*(theta**(prmang(kk,3)-1.d0)*(theta-prmang
+     x      (kk,2))*(theta+prmang(kk,2)-2.d0*pi)*((prmang(kk,3)+4.d0)*
+     x      theta**2-2.d0*pi*(prmang(kk,3)+2.d0)*theta+prmang(kk,3)*
+     x      prmang(kk,2)*(2.d0*pi-prmang(kk,2)))-prmang(kk,3)*pi**
+     x      (prmang(kk,3)-1.d0)*(theta-prmang(kk,2))*(pi-prmang(kk,2))
+     x      **3)*exp(-(rab**8+rbc**8)/prmang(kk,4)**8)/sint
+          vterm=-8.d0*pterm*(rab**8+rbc**8)/prmang(kk,4)**8
+          gamsa=(8.d0*pterm/prmang(kk,4)**8)*rab**7
+          gamsc=(8.d0*pterm/prmang(kk,4)**8)*rbc**7
+
+        elseif(keya.eq.7)then
+          
+c     harmonic cosine potential
+          
+          pterm=0.5d0*prmang(kk,1)*(cos(theta)-cos(prmang(kk,2)))**2
+          gamma=-prmang(kk,1)*(cos(theta)-cos(prmang(kk,2)))
+          vterm=0.d0
+          gamsa=0.d0
+          gamsc=0.d0
+          
+        elseif(keya.eq.8)then
+          
+c     ordinary cosine potential
+          
+          pterm=prmang(kk,1)*(1+cos(prmang(kk,3)*theta-prmang(kk,2)))
+          gamma=-prmang(kk,1)*prmang(kk,3)*sin(prmang(kk,3)*theta-
+     x      prmang(kk,2))/sint
+          vterm=0.d0
+          gamsa=0.d0
+          gamsc=0.d0
+          
+        elseif(keya.eq.9)then
+
+c     mm3 stretch-bend potential
+
+          pterm=prmang(kk,1)*(theta-prmang(kk,2))*
+     x      (rab-prmang(kk,3))*(rbc-prmang(kk,4))
+          gamma=prmang(kk,1)*(rab-prmang(kk,3))*(rbc-
+     x      prmang(kk,4))/sint
+          gamsa=-prmang(kk,1)*(theta-prmang(kk,2))*(rbc-prmang(kk,4))
+          gamsc=-prmang(kk,1)*(theta-prmang(kk,2))*(rab-prmang(kk,3))
+          vterm=-(gamsa*rab+gamsc*rbc)
+
+        elseif(keya.eq.10)then
+
+c     compass stretch-stretch potential
+
+          pterm=prmang(kk,1)*(rab-prmang(kk,2))*(rbc-prmang(kk,3))
+          gamma=0.d0
+          gamsa=-prmang(kk,1)*(rbc-prmang(kk,3))
+          gamsc=-prmang(kk,1)*(rab-prmang(kk,2))
+          vterm=-(gamsa*rab+gamsc*rbc)
+
+        elseif(keya.eq.11)then
+
+c     compass stretch-bend potential
+
+          pterm=prmang(kk,1)*(theta-prmang(kk,2))*(rab-prmang(kk,3))
+          gamma=prmang(kk,1)*(rab-prmang(kk,3))/sint
+          gamsa=-prmang(kk,1)*(theta-prmang(kk,2))
+          gamsc=0.d0
+          vterm=-gamsa*rab
+
+        elseif(keya.eq.12)then
+
+c     combined compass angle potential with 3 coupling terms
+
+          pterm=prmang(kk,1)*(rab-prmang(kk,5))*(rbc-prmang(kk,6))+
+     x          (theta-prmang(kk,4))*(prmang(kk,2)*(rab-prmang(kk,5))+
+     x          prmang(kk,3)*(rbc-prmang(kk,6)))
+          gamma=(prmang(kk,2)*(rab-prmang(kk,5))+
+     x           prmang(kk,3)*(rbc-prmang(kk,6)))/sint
+          gamsa=-prmang(kk,2)*(theta-prmang(kk,4))-
+     x           prmang(kk,1)*(rbc-prmang(kk,6))
+          gamsc=-prmang(kk,3)*(theta-prmang(kk,4))-
+     x           prmang(kk,1)*(rab-prmang(kk,5))
+          vterm=-(gamsa*rab+gamsc*rbc)
+
+        else
+
+c     undefined potential
+
+          safe=.false.
+          pterm=0.d0
+          vterm=0.d0
+          gamma=0.d0
+          gamsa=0.d0
+          gamsc=0.d0
+          
+        endif
+        
+c     indices of bonded atoms
+        
+        ia=listang(ii,2)
+        ib=listang(ii,3)
+        ic=listang(ii,4)
+
+c     metadynamics local definitions
+        
+        if(lmetadyn)then
+          
+          idrive=driven(ltype(ia))
+          jdrive=driven(ltype(ib))
+          kdrive=driven(ltype(ic))
+          
+        endif
+
+c     set selection control
+        
+        lselect=.true.
+        
+        if(lexcite)then
+          
+c     selected excitation option
+        
+          if((atm_fre(ia).ne.1).and.(atm_fre(ib).ne.1).and.
+     x      (atm_fre(ic).ne.1))then
+            
+c     reset selection control
+            
+            lselect=(atm_fre(ia)+atm_fre(ib)+atm_fre(ic).eq.0)
+            
+            if(lsolva)then
+              ang_exc(atmolt(ia))=ang_exc(atmolt(ia))+pterm
+            endif
+            
+          endif
+          
+        elseif(lfree)then
+          
+c     selected free energy option
+          
+          if((atm_fre(ia).eq.1).or.(atm_fre(ib).eq.1).or.
+     x        (atm_fre(ic).eq.1))then
+            
+c     set hamiltonian mixing parameter
+
+            ang_fre=ang_fre-pterm
+            ang_vir=ang_vir-vterm
+            pterm=lambda1*pterm
+            vterm=lambda1*vterm
+            gamma=lambda1*gamma
+            gamsa=lambda1*gamsa
+            gamsc=lambda1*gamsc
+            
+          elseif((atm_fre(ia).eq.2).or.(atm_fre(ib).eq.2).or.
+     x        (atm_fre(ic).eq.2))then
+            
+c     set hamiltonian mixing parameter
+
+            ang_fre=ang_fre+pterm
+            ang_vir=ang_vir+vterm
+            pterm=lambda2*pterm
+            vterm=lambda2*vterm
+            gamma=lambda2*gamma
+            gamsa=lambda2*gamsa
+            gamsc=lambda2*gamsc
+                        
+          endif
+          
+        endif
+        
+        if(lselect)then
+          
+c     sum potential energy and virial
+          
+          engang=engang+pterm
+          virang=virang+vterm
+          
+c     calculate solvation energy
+        
+          if(lsolva)then
+            ang_sol(atmolt(ia))=ang_sol(atmolt(ia))+pterm
+          endif
+          
+c     calculate atomic forces
+        
+          fxa=gamma*(xbc-xab*cost)*rrab+gamsa*xab
+          fya=gamma*(ybc-yab*cost)*rrab+gamsa*yab
+          fza=gamma*(zbc-zab*cost)*rrab+gamsa*zab
+          
+          fxc=gamma*(xab-xbc*cost)*rrbc+gamsc*xbc
+          fyc=gamma*(yab-ybc*cost)*rrbc+gamsc*ybc
+          fzc=gamma*(zab-zbc*cost)*rrbc+gamsc*zbc
+          
+c     sum atomic forces
+
+          fxx(ia)=fxx(ia)+fxa
+          fyy(ia)=fyy(ia)+fya
+          fzz(ia)=fzz(ia)+fza
+          
+          fxx(ib)=fxx(ib)-fxa-fxc
+          fyy(ib)=fyy(ib)-fya-fyc
+          fzz(ib)=fzz(ib)-fza-fzc
+          
+          fxx(ic)=fxx(ic)+fxc
+          fyy(ic)=fyy(ic)+fyc
+          fzz(ic)=fzz(ic)+fzc
+          
+c     calculate stress tensor
+          
+          strs(1)=strs(1)+rab*xab*fxa+rbc*xbc*fxc
+          strs(2)=strs(2)+rab*xab*fya+rbc*xbc*fyc
+          strs(3)=strs(3)+rab*xab*fza+rbc*xbc*fzc
+          strs(4)=strs(4)+rab*yab*fya+rbc*ybc*fyc
+          strs(5)=strs(5)+rab*yab*fza+rbc*ybc*fzc
+          strs(6)=strs(6)+rab*zab*fza+rbc*zbc*fzc
+          
+        endif
+        
+c     metadynamics local parameters
+        
+        if(lmetadyn.and.(idrive.or.jdrive.or.kdrive))then
+          
+c     local energy and virial
+          
+          eng_loc=eng_loc+pterm
+          vir_loc=vir_loc+vterm
+          
+c     local forces
+          
+          fxx_loc(ia)=fxx_loc(ia)+fxa
+          fyy_loc(ia)=fyy_loc(ia)+fya
+          fzz_loc(ia)=fzz_loc(ia)+fza
+          
+          fxx_loc(ib)=fxx_loc(ib)-fxa-fxc
+          fyy_loc(ib)=fyy_loc(ib)-fya-fyc
+          fzz_loc(ib)=fzz_loc(ib)-fza-fzc
+          
+          fxx_loc(ic)=fxx_loc(ic)+fxc
+          fyy_loc(ic)=fyy_loc(ic)+fyc
+          fzz_loc(ic)=fzz_loc(ic)+fzc
+          
+c     local stress tensor
+          
+          strs_loc(1)=strs_loc(1)+rab*xab*fxa+rbc*xbc*fxc
+          strs_loc(2)=strs_loc(2)+rab*xab*fya+rbc*xbc*fyc
+          strs_loc(3)=strs_loc(3)+rab*xab*fza+rbc*xbc*fzc
+          strs_loc(4)=strs_loc(4)+rab*yab*fya+rbc*ybc*fyc
+          strs_loc(5)=strs_loc(5)+rab*yab*fza+rbc*ybc*fzc
+          strs_loc(6)=strs_loc(6)+rab*zab*fza+rbc*zbc*fzc
+
+        endif
+        
+      enddo
+
+c     check for undefined potentials
+
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)call error(idnode,440)
+
+c     complete stress tensor
+        
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+      
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+c     sum up contributions to potential and virial
+      
+      if(mxnode.gt.1)then
+
+        buffer(1)=engang
+        buffer(2)=virang
+        buffer(3)=ang_fre
+        buffer(4)=ang_vir
+        call gdsum(buffer(1),4,buffer(5))
+        engang=buffer(1)
+        virang=buffer(2)
+        ang_fre=buffer(3)
+        ang_vir=buffer(4)
+
+c     sum up solvation energies
+        
+        if(lsolva)then
+
+          call gdsum(ang_sol(1),mxtmls,buffer(1))
+          if(lexcite)call gdsum(ang_exc(1),mxtmls,buffer(1))
+          
+        endif
+        
+      endif
+      
+      deallocate (xdab,ydab,zdab,stat=fail1)
+      deallocate (xdbc,ydbc,zdbc,stat=fail2)
+      
+      return
+      end subroutine angfrc
+      
+      end module angles_module
diff -urN dl_class_1.9.orig/srcmod/basic_comms.f dl_class_1.9/srcmod/basic_comms.f
--- dl_class_1.9.orig/srcmod/basic_comms.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/basic_comms.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,373 @@
+      subroutine initcomms()
+      
+c*********************************************************************
+c     
+c     communication harness initialisation
+c     
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      include "comms.inc"
+      
+      integer ierr
+
+CMPIU      define MPI_init MPI_init_
+
+      call MPI_init(ierr)
+
+      return
+      end
+
+      subroutine machine(idnode,mxnode)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for obtaining charcteristics of
+c     the computer on which the program is being run
+c     
+c     copyright daresbury laboratory 1992
+c     author - w.smith july 1992
+c     
+c     MPI version - t.forester may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,mynode,numnodes
+
+      idnode=mynode()
+      mxnode=numnodes()
+
+      return
+      end
+
+      integer function mynode()
+
+c*********************************************************************
+c
+c     routine to determine identity of processing node 
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer ierr
+
+CMPIU define MPI_COMM_RANK MPI_COMM_RANK_
+
+      call MPI_COMM_RANK(MPI_COMM_WORLD, mynode ,ierr)
+
+      return
+      end
+
+      integer function nodedim()
+
+c*********************************************************************
+c
+c     calculate dimension of hypercube
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer i,n,ierr,mxnode
+
+CMPIU      define MPI_COMM_SIZE MPI_COMM_SIZE_
+
+      call MPI_COMM_SIZE(MPI_COMM_WORLD, mxnode ,ierr)
+      n=1
+      nodedim = -1
+      do i=0,16
+
+         if(n.eq.mxnode)nodedim=i
+         n=2*n
+
+      enddo
+
+      return
+      end
+
+      integer function numnodes()
+
+c*********************************************************************
+c
+c     calculate number of nodes
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer ierr
+
+CMPIU      define MPI_COMM_SIZE MPI_COMM_SIZE_
+
+      call MPI_COMM_SIZE(MPI_COMM_WORLD, numnodes, ierr)
+
+      return
+      end
+
+      subroutine csend(tagmsg,buf,length,pe,idum)
+
+c*********************************************************************
+c
+c     Intel-like  csend (double precision)
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer tagmsg,length,pe,idum
+
+      integer ierr
+      real(8) buf(*)
+
+CMPIU      define MPI_send MPI_send_
+
+      call MPI_send(buf,length,MPI_DOUBLE_PRECISION,pe,tagmsg,
+     x     MPI_COMM_WORLD,ierr)
+
+      return
+      end
+
+      subroutine crecv(tagmsg,buf,length)
+
+c*********************************************************************
+c
+c     Intel-like  crecv (double precision)
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer tagmsg,length
+
+      integer ierr
+      integer status(MPI_STATUS_SIZE)
+      real(8) buf(*)
+
+CMPIU      define MPI_RECV MPI_RECV_
+
+      call MPI_RECV(buf,length,MPI_DOUBLE_PRECISION,MPI_ANY_SOURCE,
+     x     tagmsg,MPI_COMM_WORLD,status,ierr)
+
+      return 
+      end
+
+      subroutine gisum(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dl_poly global summation subroutine for hypercube - MPI version
+c     integer version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+      
+      use setup_module
+
+      implicit none
+
+      integer nnn,i,ierror,iii,kk,k,k0,k1,k2,msg1,msg2
+      integer aaa(nnn),bbb(nnn)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE)
+
+CMPIU      define MPI_allreduce MPI_allreduce_
+
+      call MPI_allreduce(aaa,bbb,nnn,MPI_INTEGER,
+     x  MPI_SUM,MPI_COMM_WORLD,ierror)
+
+      do i = 1,nnn
+        aaa(i) = bbb(i)
+      enddo
+
+      return
+      end
+
+      subroutine gdsum(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dl_poly global summation subroutine for MPI - hypercube assumed
+c     double precision version
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - w. smith march 1992.
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer nnn,i,iii,kk,k1,k2,ierror
+      real(8) aaa(nnn),bbb(nnn)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE)
+
+CMPIU      define MPI_allreduce MPI_allreduce_
+
+      call MPI_allreduce(aaa,bbb,nnn,MPI_DOUBLE_PRECISION,
+     x  MPI_SUM,MPI_COMM_WORLD,ierror)
+
+        do i = 1,nnn
+          aaa(i) = bbb(i)
+        enddo
+
+      return
+      end
+
+      subroutine gimax(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dl_poly global maximum subroutine for hypercube - MPI version
+c     integer version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+      
+      use setup_module
+
+      implicit none
+
+      integer nnn,i,iii,kk,k1,k2,k,k0msg1,msg2,ierror
+      integer aaa(nnn),bbb(nnn)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE)
+CMPIU      define MPI_allreduce MPI_allreduce_
+      
+      call MPI_allreduce(aaa,bbb,nnn,MPI_INTEGER,
+     x   MPI_MAX,MPI_COMM_WORLD,ierror)
+      
+      do i = 1,nnn
+        aaa(i) = bbb(i)
+      enddo
+
+      return
+      end
+
+      subroutine gstate(check)
+
+c***********************************************************************
+c     
+c     dl_poly global status subroutine : gisum version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith       march 1992
+c     MPI version -  t. forester may 1995
+c     
+c***********************************************************************
+
+
+      implicit none
+
+      logical check
+      integer i,idum
+
+      i = 0
+      if(.not.check) i = 1
+
+      call gisum(i,1,idum)
+      
+      check = (i.eq.0)
+
+      return
+      end
+
+      subroutine gsync()
+
+c*********************************************************************
+c     
+c     barrier / synchronization routine
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer ierr
+
+      include "comms.inc"
+
+CMPIU      define MPI_BARRIER MPI_BARRIER_
+
+      call  MPI_BARRIER(MPI_COMM_WORLD,ierr)
+
+      return
+      end
+
+      subroutine exitcomms()
+
+c*********************************************************************
+c
+c     exitcomms: exit from communication harness
+c
+c     copyright - daresbury laboratory
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      implicit none
+
+      include "comms.inc"
+
+      integer ierr
+CMPIU      define MPI_FINALIZE MPI_FINALIZE_
+
+      call MPI_FINALIZE(ierr)
+      call exit(0)
+
+      return
+      end
diff -urN dl_class_1.9.orig/srcmod/bonds_module.f dl_class_1.9/srcmod/bonds_module.f
--- dl_class_1.9.orig/srcmod/bonds_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/bonds_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,579 @@
+      module bonds_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining bond potential arrays
+c     copyright - daresbury laboratory
+c     
+c     author    - w. smith    sep 2003
+c     adapted for solvation, free energy and excitation
+c               - p.-a. cazade oct 2007
+c     adapted for metadynamics
+c               - d. quigley 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use metafreeze_module
+      use parse_module
+      use setup_module
+      use site_module
+      use solvation_module
+      use utility_module
+      
+      implicit none
+      
+      real(8), allocatable :: prmbnd(:,:)
+      integer, allocatable :: listbnd(:,:)
+      integer, allocatable :: numbonds(:),keybnd(:),lstbnd(:,:)
+      
+      save prmbnd,listbnd,numbonds,keybnd,lstbnd
+      
+      contains
+      
+      subroutine alloc_bnd_arrays(idnode)
+      
+      implicit none
+      
+      integer i,fail,idnode
+      dimension fail(5)
+      
+      do i=1,5
+        fail(i)=0
+      enddo
+      
+      allocate (prmbnd(mxtbnd,mxpbnd),stat=fail(1))
+      allocate (numbonds(mxtmls),stat=fail(2))
+      allocate (keybnd(mxtbnd),stat=fail(3))
+      allocate (lstbnd(mxtbnd,3),stat=fail(4))
+      allocate (listbnd(mxbond,4),stat=fail(5))
+      
+      do i=1,5
+        if(fail(i).gt.0)call error(idnode,1030)
+      enddo
+      
+      do i=1,mxtmls
+        numbonds(i)=0
+      enddo
+      
+      end subroutine alloc_bnd_arrays
+      
+      subroutine define_bonds
+     x  (safe,idnode,itmols,nbonds,nsite,engunit)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining bonds
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe
+      character*8 keyword
+      character*1 message(80)
+      integer idnode,itmols,nbonds,nsite,ntmp,ibond,ibond1
+      integer iatm1,iatm2,isite1,isite2,idum,i,j
+      real(8) engunit
+      
+      ntmp=intstr(record,lenrec,idum)
+      numbonds(itmols)=numbonds(itmols)+ntmp
+      if(idnode.eq.0)then
+        write(nrite,"(/,1x,'number of chemical bonds',
+     x    7x,i10)")ntmp
+        write(nrite,"(/,/,1x,'chemical bond details:',
+     x    /,/,21x,7x,'key',5x,'index',5x,'index',28x,
+     x    'parameters', /)")
+      endif
+      
+      ibond1=numbonds(itmols)
+      do ibond=1,ibond1
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        
+        call copystring(record,message,80)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+        iatm1=intstr(record,lenrec,idum)
+        iatm2=intstr(record,lenrec,idum)
+        
+c     test for frozen atom pairs
+        
+        isite1=nsite-numsit(itmols)+iatm1
+        isite2=nsite-numsit(itmols)+iatm2
+        
+        if(lfzsit(isite1)*lfzsit(isite2).ne.0)then
+          
+          numbonds(itmols)=numbonds(itmols)-1
+          if(idnode.eq.0)write(nrite,'(12x,a16,40a1)')
+     x      '*** frozen *** ',(message(i),i=1,40)
+          
+        else
+          
+          nbonds=nbonds+1
+          if(nbonds.gt.mxtbnd)call error(idnode,30)
+          
+          if(keyword(1:4).eq.'harm')then
+            keybnd(nbonds)=1
+          elseif(keyword(1:4).eq.'-hrm')then
+            keybnd(nbonds)=-1
+          elseif(keyword(1:4).eq.'mors')then
+            keybnd(nbonds)=2
+          elseif(keyword(1:4).eq.'-mrs')then
+            keybnd(nbonds)=-2
+          elseif(keyword(1:4).eq.'12-6')then
+            keybnd(nbonds)=3
+          elseif(keyword(1:4).eq.'-126')then
+            keybnd(nbonds)=-3
+          elseif(keyword(1:4).eq.'rhrm')then
+            keybnd(nbonds)=4
+          elseif(keyword(1:4).eq.'-rhm')then
+            keybnd(nbonds)=-4
+          elseif(keyword(1:4).eq.'quar')then
+            keybnd(nbonds)=5
+          elseif(keyword(1:4).eq.'-qur')then
+            keybnd(nbonds)=-5
+          elseif(keyword(1:4).eq.'buck')then
+            keybnd(nbonds)=6
+          elseif(keyword(1:4).eq.'-bck')then
+            keybnd(nbonds)=-6
+          elseif(keyword(1:4).eq.'fene')then
+            keybnd(nbonds)=7
+          elseif(keyword(1:4).eq.'-fen')then
+            keybnd(nbonds)=-7
+          elseif(keyword(1:4).eq.'coul')then
+            keybnd(nbonds)=8
+          elseif(keyword(1:4).eq.'-cou')then
+            keybnd(nbonds)=-8
+          else
+            if(idnode.eq.0)write(nrite,*)message
+            call error(idnode,444)
+          endif
+          
+          lstbnd(nbonds,1)=iatm1
+          lstbnd(nbonds,2)=iatm2
+          prmbnd(nbonds,1)=dblstr(record,lenrec,idum)
+          prmbnd(nbonds,2)=dblstr(record,lenrec,idum)
+          prmbnd(nbonds,3)=dblstr(record,lenrec,idum)
+          prmbnd(nbonds,4)=dblstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(27x,a4,2i10,2x,1p,10e15.6)")
+     x      keyword(1:4),lstbnd(nbonds,1),
+     x      lstbnd(nbonds,2),(prmbnd(nbonds,j),j=1,mxpbnd)
+c     
+c     convert energy units to internal units
+          
+          if(abs(keybnd(nbonds)).eq.3)then
+            prmbnd(nbonds,2)=prmbnd(nbonds,2)*engunit
+          endif
+          if(abs(keybnd(nbonds)).eq.5)then
+            prmbnd(nbonds,3)=prmbnd(nbonds,3)*engunit
+            prmbnd(nbonds,4)=prmbnd(nbonds,4)*engunit
+          endif
+          if(abs(keybnd(nbonds)).eq.6)then
+            prmbnd(nbonds,3)=prmbnd(nbonds,3)*engunit
+          endif
+          
+          if(abs(keybnd(nbonds)).ne.8)
+     x      prmbnd(nbonds,1)=prmbnd(nbonds,1)*engunit
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine define_bonds
+      
+      subroutine bndfrc
+     x  (lsolva,lfree,lexcite,idnode,imcon,mxnode,ntbond,epsq,
+     x  engbnd,virbnd)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating chemical bond energy and 
+c     force terms in molecular dynamics.
+c     
+c     replicated data - blocked  data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith        july 1992
+c     modified  - t. forester    march 1993 
+c     modified  - t. forester    march 1994 
+c     modified  - t. forester    may   1994 
+c     modified  - t. forester    nov   1994 
+c     modified  - w. smith       nov   2006
+c     modified  - p.-a. cazade   oct   2007, solvation etc.
+c     modified  - d. quigley           2007, metdynamics
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lsolva,lfree,lexcite,lselect
+      logical idrive,jdrive
+      integer i,fail,ibnd1,ibnd2,idnode,mxnode,ii,ia,ib,imcon
+      integer keyb,kk,ntbond
+      real(8) strs(6),strs_loc(6)
+      real(8) rab,rrab,omega,gamma,fx,fy,fz,engbnd,virbnd,epsq
+      real(8), allocatable :: xdab(:),ydab(:),zdab(:)
+      
+      allocate (xdab(msbad),ydab(msbad),zdab(msbad),stat=fail)
+      if(fail.ne.0)call error(idnode,1040)
+      
+c     flag for undefined potential
+      
+      safe=.true.
+      
+c     check size of work arrays
+      
+      if((ntbond-mxnode+1)/mxnode.gt.msbad)call error(idnode,418)
+      
+c     block indices
+      
+      ibnd1=(idnode*ntbond)/mxnode+1
+      ibnd2=((idnode+1)*ntbond)/mxnode
+      
+c     initialise accumulators
+      
+      engbnd=0.d0
+      virbnd=0.d0
+      bnd_fre=0.d0
+      bnd_vir=0.d0
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+      if(lsolva)then
+        
+        lcomp(1)=.true.
+        bnd_sol(:)=0.d0
+        if(lexcite)bnd_exc(:)=0.d0
+        
+      endif
+      
+c     calculate atom separation vectors
+      
+      ii=0
+      do i=ibnd1,ibnd2
+        
+        ii=ii+1
+        
+c     indices of bonded atoms
+        
+        ia=listbnd(ii,2)
+        ib=listbnd(ii,3)
+        
+c     metadynamics local definitions
+        
+        if(lmetadyn)then
+          
+          idrive=driven(ltype(ia))
+          jdrive=driven(ltype(ib))
+          
+        endif
+
+c     components of bond vector
+        
+        xdab(ii)=xxx(ia)-xxx(ib)
+        ydab(ii)=yyy(ia)-yyy(ib)
+        zdab(ii)=zzz(ia)-zzz(ib)
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,0,1,ii,cell,xdab,ydab,zdab)
+      
+c     loop over all specified chemical bond potentials
+      
+      ii=0
+      do i=ibnd1,ibnd2
+        
+        ii=ii+1
+        
+c     define components of bond vector
+        
+        rrab=0.d0
+        rab=sqrt(xdab(ii)**2+ydab(ii)**2+zdab(ii)**2)
+        if(rab.gt.1.d-6)rrab=1.d0/rab
+        
+c     index of potential function parameters
+        
+        kk=listbnd(ii,1)
+        keyb=abs(keybnd(kk))
+        
+c     calculate scalar constant terms
+        
+        if(keyb.eq.0)then
+          
+c     null interaction
+          
+          omega=0.d0
+          gamma=0.d0
+          
+        elseif(keyb.eq.1)then
+          
+c     harmonic potential
+          
+          omega=0.5d0*prmbnd(kk,1)*(rab-prmbnd(kk,2))**2
+          gamma=prmbnd(kk,1)*(rab-prmbnd(kk,2))*rrab
+          
+        else if(keyb.eq.2)then
+          
+c     morse potential
+          
+          omega=prmbnd(kk,1)*((1.d0-exp(-prmbnd(kk,3)*
+     x      (rab-prmbnd(kk,2))))**2-1.d0)
+          gamma=2.d0*prmbnd(kk,1)*prmbnd(kk,3)*(1.d0-
+     x      exp(-prmbnd(kk,3)*(rab-prmbnd(kk,2))))*
+     x      exp(-prmbnd(kk,3)*(rab-prmbnd(kk,2)))*rrab
+          
+        else if(keyb.eq.3)then
+          
+c     12-6 potential
+          
+          omega=(prmbnd(kk,1)*rrab**6-prmbnd(kk,2))*rrab**6
+          gamma=(6.d0*prmbnd(kk,2)-12.d0*prmbnd(kk,1)*rrab**6)*
+     x      rrab**8
+          
+        elseif(keyb.eq.4)then
+          
+c     restrained harmonic
+          
+          rab=rab-prmbnd(kk,2)
+          omega=0.5d0*prmbnd(kk,1)*(min(abs(rab),prmbnd(kk,3)))**2
+     x      +prmbnd(kk,1)*prmbnd(kk,3)*max(abs(rab)-prmbnd(kk,3),0.d0)
+          gamma=rrab*prmbnd(kk,1)*(sign(min(abs(rab),prmbnd(kk,3)),rab))
+          
+        elseif(keyb.eq.5)then
+          
+c     quartic potential
+          
+          omega=0.5d0*prmbnd(kk,1)*(rab-prmbnd(kk,2))**2+
+     x      1.d0/3.d0*prmbnd(kk,3)*(rab-prmbnd(kk,2))**3+
+     x      0.25d0*prmbnd(kk,4)*(rab-prmbnd(kk,2))**4
+          gamma=rrab*(prmbnd(kk,1)*(rab-prmbnd(kk,2))+
+     x      prmbnd(kk,3)*(rab-prmbnd(kk,2))**2+
+     x      prmbnd(kk,4)*(rab-prmbnd(kk,2))**3)
+          
+        else if(keyb.eq.6)then
+          
+c     buckingham exp-6 potential
+          
+          omega=prmbnd(kk,1)*exp(-rab/prmbnd(kk,2))-prmbnd(kk,3)*
+     x      rrab**6
+          gamma=-rrab*prmbnd(kk,1)*exp(-rab/prmbnd(kk,2))/prmbnd(kk,2)+
+     x      6.d0*prmbnd(kk,3)*rrab**8
+          
+        else if(keyb.eq.7)then
+          
+c     FENE bond potential
+          
+          omega=-0.5d0*prmbnd(kk,1)*prmbnd(kk,2)**2*log(1.d0-
+     x      ((rab-prmbnd(kk,3))/prmbnd(kk,2))**2)
+          gamma=rrab*prmbnd(kk,1)*(rab-prmbnd(kk,3))/
+     x      (1.d0-((rab-prmbnd(kk,3))/prmbnd(kk,2))**2)
+          
+        else if(keyb.eq.8)then
+          
+c     coulomb bond potential
+          
+          omega=prmbnd(kk,1)*prmbnd(kk,2)*rrab*r4pie0/epsq
+          gamma=-omega*rrab*rrab
+          
+        else
+          
+c     undefined potential
+          
+          omega=0.d0
+          gamma=0.d0
+          safe=.false.
+          
+        endif
+        
+c     indices of bonded atoms
+        
+        ia=listbnd(ii,2)
+        ib=listbnd(ii,3)
+        
+c     set selection control
+        
+        lselect=.true.
+        
+        if(lexcite)then
+          
+c     selected excitation option
+          
+          if((atm_fre(ia).ne.1).and.(atm_fre(ib).ne.1))then
+            
+c     reset selection control
+            
+            lselect=(atm_fre(ia)+atm_fre(ib).eq.0)
+            
+            if(lsolva)then
+              bnd_exc(atmolt(ia))=bnd_exc(atmolt(ia))+omega
+            endif
+            
+          endif
+          
+        elseif(lfree)then
+          
+c     selected free energy option
+          
+          if((atm_fre(ia).eq.1).or.(atm_fre(ib).eq.1))then
+            
+c     set hamiltonian mixing parameter
+            
+            bnd_fre=bnd_fre-omega
+            bnd_vir=bnd_vir-gamma*rab*rab
+            omega=lambda1*omega
+            gamma=lambda1*gamma
+            
+          elseif((atm_fre(ia).eq.2).or.(atm_fre(ib).eq.2))then
+            
+c     set hamiltonian mixing parameter
+            
+            bnd_fre=bnd_fre+omega
+            bnd_vir=bnd_vir+gamma*rab*rab
+            omega=lambda2*omega
+            gamma=lambda2*gamma
+            
+          endif
+          
+        endif
+        
+        if(lselect)then
+          
+c     calculate bond energy and virial
+        
+          engbnd=engbnd+omega
+          virbnd=virbnd+gamma*rab*rab
+          
+c     calculate solvation energy
+        
+          if(lsolva)then
+            bnd_sol(atmolt(ia))=bnd_sol(atmolt(ia))+omega
+          endif
+          
+c     calculate forces
+          
+          fx=-gamma*xdab(ii)
+          fy=-gamma*ydab(ii)
+          fz=-gamma*zdab(ii)
+          
+          fxx(ia)=fxx(ia)+fx
+          fyy(ia)=fyy(ia)+fy
+          fzz(ia)=fzz(ia)+fz
+          
+          fxx(ib)=fxx(ib)-fx
+          fyy(ib)=fyy(ib)-fy
+          fzz(ib)=fzz(ib)-fz
+          
+c     calculate stress tensor
+        
+          strs(1)=strs(1)+xdab(ii)*fx
+          strs(2)=strs(2)+xdab(ii)*fy
+          strs(3)=strs(3)+xdab(ii)*fz
+          strs(4)=strs(4)+ydab(ii)*fy
+          strs(5)=strs(5)+ydab(ii)*fz
+          strs(6)=strs(6)+zdab(ii)*fz
+          
+        endif
+        
+c     metadynamics local parameters
+        
+        if(lmetadyn.and.(idrive.or.jdrive))then
+          
+c     local energy and virial
+          
+          eng_loc=eng_loc+omega
+          vir_loc=vir_loc+gamma*rab*rab
+          
+c     local forces
+          
+          fxx_loc(ia)=fxx_loc(ia)+fx
+          fyy_loc(ia)=fyy_loc(ia)+fy
+          fzz_loc(ia)=fzz_loc(ia)+fz
+          
+          fxx_loc(ib)=fxx_loc(ib)-fx
+          fyy_loc(ib)=fyy_loc(ib)-fy
+          fzz_loc(ib)=fzz_loc(ib)-fz
+          
+c     local stress tensor
+          
+          strs_loc(1)=strs_loc(1)+xdab(ii)*fx
+          strs_loc(2)=strs_loc(2)+xdab(ii)*fy
+          strs_loc(3)=strs_loc(3)+xdab(ii)*fz
+          strs_loc(4)=strs_loc(4)+ydab(ii)*fy
+          strs_loc(5)=strs_loc(5)+ydab(ii)*fz
+          strs_loc(6)=strs_loc(6)+zdab(ii)*fz
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+      
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+      
+      endif
+      
+c     check for undefined potentials
+      
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)call error(idnode,444)
+      
+c     sum contributions to potential and virial
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engbnd
+        buffer(2)=virbnd
+        buffer(3)=bnd_fre
+        buffer(4)=bnd_vir
+        call gdsum(buffer(1),4,buffer(5))        
+        engbnd=buffer(1)
+        virbnd=buffer(2)
+        bnd_fre=buffer(3)
+        bnd_vir=buffer(4)
+        
+        if(lsolva)then
+          
+          call gdsum(bnd_sol(1),mxtmls,buffer(1))
+          if(lexcite)call gdsum(bnd_exc(1),mxtmls,buffer(1))
+          
+        endif
+        
+      endif
+      
+      deallocate (xdab,ydab,zdab,stat=fail)
+      
+      return
+      end subroutine bndfrc
+      
+      end module bonds_module
diff -urN dl_class_1.9.orig/srcmod/comms.inc dl_class_1.9/srcmod/comms.inc
--- dl_class_1.9.orig/srcmod/comms.inc	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/comms.inc	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,42 @@
+c*********************************************************************
+c
+c     dl_poly include file for MPI, PVM and SHMEM
+c     copyright - daresbury laboratory
+c
+c*********************************************************************
+
+CMPIU define mpipriv mpipriv_
+
+      include "mpif.h"
+
+c     parameters for message tags
+
+      integer Xgcopy_tag, Merge1_tag
+      integer Dgsum_tag1, Dgsum_tag2
+      integer Igmax_tag1, Igmax_tag2
+      integer Igsum_tag1, Igsum_tag2
+      integer Shmove_tag, Merge_tag
+      integer Merge4_tag, Shell_tag
+      integer Gstate_tag1, Gstate_tag2
+      integer Passcon_tag, Msgtag
+
+c     MPI tagsizes
+
+      parameter(
+     $     Xgcopy_tag = 105,
+     $     Dgsum_tag1  = 6001,
+     $     Dgsum_tag2  = 9001,
+     $     Igsum_tag1  = 12001,
+     $     Igsum_tag2  = 15001,
+     $     Shmove_tag  = 18001,
+     $     Merge_tag   = 6001,
+     $     Merge1_tag  = 9001,
+     $     Merge4_tag  = 12001,
+     $     Gstate_tag1 = 15001,
+     $     Gstate_tag2 = 18001,
+     $     Shell_tag   = 21001,
+     $     Passcon_tag =  3001,
+     $     Igmax_tag1  = 24001,
+     $     Igmax_tag2  = 27001,
+     $     Msgtag      = 30000)
+
diff -urN dl_class_1.9.orig/srcmod/config_module.f dl_class_1.9/srcmod/config_module.f
--- dl_class_1.9.orig/srcmod/config_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/config_module.f	2015-11-07 16:58:03.486054734 +0100
@@ -0,0 +1,105 @@
+      module config_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining simulation configuration data
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use setup_module
+      use error_module
+      
+      implicit none
+
+      character*1 cfgname(80)
+      character*1 sysname(80)
+      real(8) cell(9),rcell(9),celprp(10)
+      real(8) eta(9),stress(9),stresl(9),strcns(9),strbod(9)
+      
+      character*8, allocatable :: atmnam(:)
+      real(8), allocatable :: xxx(:),yyy(:),zzz(:)
+      real(8), allocatable :: vxx(:),vyy(:),vzz(:)
+      real(8), allocatable :: fxx(:),fyy(:),fzz(:)
+      real(8), allocatable :: flx(:),fly(:),flz(:)
+      real(8), allocatable :: chge(:),weight(:),rmass(:)
+      integer, allocatable :: ltype(:),lstfrz(:)
+      integer, allocatable :: neulst(:),lstneu(:)
+      integer, allocatable :: lentry(:),list(:,:)
+      integer, allocatable :: lstout(:),link(:)
+      integer, allocatable :: lct(:),lst(:)
+
+      real(8), allocatable :: buffer(:)
+
+c PluMeD variables
+      logical, save :: lplumed  
+      character(len=20) :: plumedfile
+      character(len=80) :: parse_file
+c end PluMeD variables
+
+      save atmnam,neulst,lstneu,cfgname,sysname
+      save cell,xxx,yyy,zzz,vxx,vyy,vzz,fxx,fyy,fzz
+      save buffer,weight,chge,ltype,lstfrz,flx,fly,flz
+      save lentry,list,lstout,link,lct,lst,celprp,rmass
+      save eta,stress,stresl,strcns,rcell
+      
+      contains
+      
+      subroutine alloc_config_arrays(idnode)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining simulation configuration arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+      
+      integer, parameter :: nnn=27
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate (xxx(mxatms),stat=fail(1))
+      allocate (yyy(mxatms),stat=fail(2))
+      allocate (zzz(mxatms),stat=fail(3))
+      allocate (vxx(mxatms),stat=fail(4))
+      allocate (vyy(mxatms),stat=fail(5))
+      allocate (vzz(mxatms),stat=fail(6))
+      allocate (fxx(mxatms),stat=fail(7))
+      allocate (fyy(mxatms),stat=fail(8))
+      allocate (fzz(mxatms),stat=fail(9))
+      allocate (weight(mxatms),stat=fail(11))
+      allocate (chge(mxatms),stat=fail(12))
+      allocate (ltype(mxatms),stat=fail(13))
+      allocate (lstfrz(mxatms),stat=fail(14))
+      allocate (flx(mxatms),stat=fail(15))
+      allocate (fly(mxatms),stat=fail(16))
+      allocate (flz(mxatms),stat=fail(17))
+      allocate (atmnam(mxatms),stat=fail(18))
+      allocate (neulst(mxneut),stat=fail(19))
+      allocate (lstneu(mxatms),stat=fail(20))
+      allocate (lstout(mxatms),stat=fail(21))
+      allocate (lentry(msatms),stat=fail(22))
+      allocate (list(msatms,mxlist),stat=fail(23))
+      allocate (link(mxatms),stat=fail(24))
+      allocate (lct(mxcell),stat=fail(25))
+      allocate (lst(mxcell),stat=fail(26))
+      allocate (rmass(mxatms),stat=fail(27))
+      allocate (buffer(mxbuff),stat=fail(10))
+
+      do i=1,nnn
+        if(fail(i).gt.0)then
+          if(idnode.eq.0)write(nrite,'(10i5)')fail
+          call error(idnode,1000)
+        endif
+      enddo
+
+      end subroutine alloc_config_arrays
+
+      end module config_module
diff -urN dl_class_1.9.orig/srcmod/config_module.f.preplumed dl_class_1.9/srcmod/config_module.f.preplumed
--- dl_class_1.9.orig/srcmod/config_module.f.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/config_module.f.preplumed	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,99 @@
+      module config_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining simulation configuration data
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use setup_module
+      use error_module
+      
+      implicit none
+
+      character*1 cfgname(80)
+      character*1 sysname(80)
+      real(8) cell(9),rcell(9),celprp(10)
+      real(8) eta(9),stress(9),stresl(9),strcns(9),strbod(9)
+      
+      character*8, allocatable :: atmnam(:)
+      real(8), allocatable :: xxx(:),yyy(:),zzz(:)
+      real(8), allocatable :: vxx(:),vyy(:),vzz(:)
+      real(8), allocatable :: fxx(:),fyy(:),fzz(:)
+      real(8), allocatable :: flx(:),fly(:),flz(:)
+      real(8), allocatable :: chge(:),weight(:),rmass(:)
+      integer, allocatable :: ltype(:),lstfrz(:)
+      integer, allocatable :: neulst(:),lstneu(:)
+      integer, allocatable :: lentry(:),list(:,:)
+      integer, allocatable :: lstout(:),link(:)
+      integer, allocatable :: lct(:),lst(:)
+
+      real(8), allocatable :: buffer(:)
+
+      save atmnam,neulst,lstneu,cfgname,sysname
+      save cell,xxx,yyy,zzz,vxx,vyy,vzz,fxx,fyy,fzz
+      save buffer,weight,chge,ltype,lstfrz,flx,fly,flz
+      save lentry,list,lstout,link,lct,lst,celprp,rmass
+      save eta,stress,stresl,strcns,rcell
+      
+      contains
+      
+      subroutine alloc_config_arrays(idnode)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining simulation configuration arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+      
+      integer, parameter :: nnn=27
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate (xxx(mxatms),stat=fail(1))
+      allocate (yyy(mxatms),stat=fail(2))
+      allocate (zzz(mxatms),stat=fail(3))
+      allocate (vxx(mxatms),stat=fail(4))
+      allocate (vyy(mxatms),stat=fail(5))
+      allocate (vzz(mxatms),stat=fail(6))
+      allocate (fxx(mxatms),stat=fail(7))
+      allocate (fyy(mxatms),stat=fail(8))
+      allocate (fzz(mxatms),stat=fail(9))
+      allocate (weight(mxatms),stat=fail(11))
+      allocate (chge(mxatms),stat=fail(12))
+      allocate (ltype(mxatms),stat=fail(13))
+      allocate (lstfrz(mxatms),stat=fail(14))
+      allocate (flx(mxatms),stat=fail(15))
+      allocate (fly(mxatms),stat=fail(16))
+      allocate (flz(mxatms),stat=fail(17))
+      allocate (atmnam(mxatms),stat=fail(18))
+      allocate (neulst(mxneut),stat=fail(19))
+      allocate (lstneu(mxatms),stat=fail(20))
+      allocate (lstout(mxatms),stat=fail(21))
+      allocate (lentry(msatms),stat=fail(22))
+      allocate (list(msatms,mxlist),stat=fail(23))
+      allocate (link(mxatms),stat=fail(24))
+      allocate (lct(mxcell),stat=fail(25))
+      allocate (lst(mxcell),stat=fail(26))
+      allocate (rmass(mxatms),stat=fail(27))
+      allocate (buffer(mxbuff),stat=fail(10))
+
+      do i=1,nnn
+        if(fail(i).gt.0)then
+          if(idnode.eq.0)write(nrite,'(10i5)')fail
+          call error(idnode,1000)
+        endif
+      enddo
+
+      end subroutine alloc_config_arrays
+
+      end module config_module
diff -urN dl_class_1.9.orig/srcmod/core_shell_module.f dl_class_1.9/srcmod/core_shell_module.f
--- dl_class_1.9.orig/srcmod/core_shell_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/core_shell_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,826 @@
+      module core_shell_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining core_shell arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use pair_module
+      use parse_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use site_module
+      use solvation_module
+
+      implicit none
+
+      real(8), allocatable :: prmshl(:,:)
+      integer, allocatable :: listshl(:,:)
+      integer, allocatable :: numshl(:),lstshl(:,:)
+
+      save prmshl,listshl,numshl,lstshl
+
+      contains
+      
+      subroutine alloc_csh_arrays(idnode)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining core_shell arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer i,fail,idnode
+      dimension fail(4)
+
+      do i=1,4
+        fail(i)=0
+      enddo
+
+      allocate (prmshl(mxtshl,2),stat=fail(1))
+      allocate (numshl(mxtmls),stat=fail(2))
+      allocate (lstshl(mxtshl,2),stat=fail(3))
+      allocate (listshl(mxshl,3),stat=fail(4))
+
+      do i=1,4
+        if(fail(i).gt.0)call error(idnode,1100)
+      enddo
+
+      do i=1,mxtmls
+         numshl(i)=0
+      enddo
+
+      end subroutine alloc_csh_arrays
+
+      subroutine define_core_shell
+     x  (safe,idnode,itmols,nshels,nsite,keyshl,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining core-shell units
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      logical safe
+      integer idnode,itmols,nshels,nsite,ntmp,ishls
+      integer iatm1,iatm2,isite1,isite2,keyshl,kshl,idum
+      real(8) engunit
+
+      ntmp=intstr(record,lenrec,idum)
+      numshl(itmols)=numshl(itmols)+ntmp
+      kshl=intstr(record,lenrec,idum)
+      if(keyshl.eq.0)then
+        keyshl=kshl
+      elseif(kshl.ne.keyshl)then
+        call error(idnode,1960)
+      endif
+      if(idnode.eq.0) then
+        
+        write(nrite,
+     x    "(/,1x,'number of core-shell units',5x,i10)")
+     x    ntmp
+        if(keyshl.eq.1)then
+
+          write(nrite,
+     x       "(/,/,1x,'core-shell details:',/,/,21x,
+     x       5x,'index',5x,'index',6x,'parameter')")
+
+        else
+
+          write(nrite,
+     x       "(/,/,1x,'core-shell details:',/,/,21x,
+     x       6x,'core',5x,'shell',6x,'parameter')")
+        
+        endif
+
+      endif
+      
+      do ishls=1,numshl(itmols)
+        
+        nshels=nshels+1
+        if(nshels.gt.mxtshl) call error(idnode,57)
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        iatm1=intstr(record,lenrec,idum)
+        iatm2=intstr(record,lenrec,idum)
+        lstshl(nshels,1)=iatm1
+        lstshl(nshels,2)=iatm2
+        prmshl(nshels,1)=dblstr(record,lenrec,idum)
+        prmshl(nshels,2)=dblstr(record,lenrec,idum)
+        if(idnode.eq.0) write(nrite,
+     x    "(21x,2i10,2f15.4)")
+     x    lstshl(nshels,1),lstshl(nshels,2),
+     x    prmshl(nshels,1),prmshl(nshels,2)
+
+c     test for frozen cores or shells
+        
+        isite1=nsite-numsit(itmols)+iatm1
+        isite2=nsite-numsit(itmols)+iatm2
+        if(lfzsit(isite1)*lfzsit(isite2).ne.0)
+     x    call error(idnode,49)
+        
+c     convert energy units to internal units
+        
+        prmshl(nshels,1)=prmshl(nshels,1)*engunit
+        prmshl(nshels,2)=prmshl(nshels,2)*engunit
+        
+      enddo
+
+      return
+      end subroutine define_core_shell
+
+      subroutine corshl(idnode,mxnode,ntshl,shlke)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating the internal kinetic
+c     energy of core-shell units in the shell polarisation model
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith july 1994
+c
+c***********************************************************************
+      
+      implicit none
+
+      integer  idnode,mxnode,ntshl,ishl1,ishl2,i,j,k,m
+      real(8) shlke,ppp,ccc,sss
+      
+      shlke=0.d0
+
+c     block indices
+
+      ishl1=(idnode*ntshl)/mxnode+1
+      ishl2=((idnode+1)*ntshl)/mxnode
+
+c     loop over all specified core-shell pairs
+      
+      m=0
+
+      do k=ishl1,ishl2
+        
+        m=m+1
+        
+c     indices of atoms involved
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+
+c     calculate atom translational kinetic energy
+        
+        ppp=((weight(i)*vxx(i)+weight(j)*vxx(j))**2
+     x      +(weight(i)*vyy(i)+weight(j)*vyy(j))**2
+     x      +(weight(i)*vzz(i)+weight(j)*vzz(j))**2)
+     x      /(weight(i)+weight(j))
+
+c     calculate individual core and shell kinetic energies
+        
+        ccc=weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+        sss=weight(j)*(vxx(j)**2+vyy(j)**2+vzz(j)**2)
+        
+c     calculate core-shell internal kinetic energy
+        
+        shlke=shlke+0.5d0*(ccc+sss-ppp)
+        
+      enddo
+
+c     global average of core-shell internal kinetic energy
+        
+      if(mxnode.gt.1)then
+        buffer(1)=shlke
+        call gdsum(buffer(1),1,buffer(2))
+        shlke=buffer(1)
+      endif
+      
+      return
+      end subroutine corshl
+
+      subroutine put_shells_on_cores(idnode,mxnode,ntshl)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for placing shells on top of cores in the
+c     shell model at the start of a simulation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith feb 2006
+c     
+c***********************************************************************
+            
+      implicit none
+      
+      integer, allocatable :: ltop(:)
+      integer  idnode,mxnode,ntshl,ishl1,ishl2,i,j,k,m,fail
+      
+c     allocate ltop array
+
+      allocate(ltop(ntshl),stat=fail)
+
+c     block indices
+      
+      ishl1=(idnode*ntshl)/mxnode+1
+      ishl2=((idnode+1)*ntshl)/mxnode
+      
+c     zero ltop array
+      
+      do i=1,ntshl
+        ltop(i)=0
+      enddo
+
+c     loop over all specified core-shell pairs
+      
+      m=0
+      
+      do k=ishl1,ishl2
+        
+        m=m+1
+        
+c     indices of atoms involved
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+        
+c     set shell and core positions equal
+        
+        ltop(m)=j
+        xxx(j)=xxx(i)
+        yyy(j)=yyy(i)
+        zzz(j)=zzz(i)
+        
+      enddo
+      
+c     merge data on different processors
+      
+      if(mxnode.gt.1)call merge1
+     x  (idnode,mxnode,ntshl,ltop,xxx,yyy,zzz,buffer)
+      
+c     deallocate ltop array
+      
+      deallocate(ltop,stat=fail)
+      
+      return
+      end subroutine put_shells_on_cores
+
+      subroutine shlfrc
+     x  (lsolva,lfree,lexcite,idnode,imcon,mxnode,ntshl,engshl,virshl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating shell model spring energy and 
+c     force terms in molecular dynamics.
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith        july 1994
+c
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lexcite,lselect
+      integer idnode,imcon,mxnode,ntshl,ishl1,ishl2,i,j,k,m,kk
+      real(8) engshl,virshl,rij2,omega,gamma,ffx,ffy,ffz,strs
+
+      dimension strs(6)
+      
+c     check adequate workspace is available
+
+      if(mxxdf.lt.mxshl)call error(idnode,423)
+
+c     block indices
+
+      ishl1=(idnode*ntshl)/mxnode+1
+      ishl2=((idnode+1)*ntshl)/mxnode
+
+c     initialise accumulators
+      
+      engshl=0.d0
+      virshl=0.d0
+      shl_fre=0.d0
+      shl_vir=0.d0
+      
+      do i=1,6
+        strs(i)=0.d0
+      enddo
+
+      if(lsolva)then
+        
+        lcomp(5)=.true.
+        shl_sol(:)=0.d0
+        if(lexcite)shl_exc(:)=0.d0
+        
+      endif
+      
+c     calculate core-shell separation vectors
+      
+      m=0
+      do k=ishl1,ishl2
+        
+        m=m+1
+
+c     indices of core and shell
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+        
+c     components of bond vector
+        
+        xdf(m)=xxx(i)-xxx(j)
+        ydf(m)=yyy(i)-yyy(j)
+        zdf(m)=zzz(i)-zzz(j)
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,0,1,m,cell,xdf,ydf,zdf)
+
+c     loop over all specified core-shell units
+      
+      m=0
+      do k=ishl1,ishl2
+        
+        m=m+1
+
+c     index of potential parameters
+
+        kk=listshl(m,1)
+
+c     core-shell separation
+        
+        rij2=xdf(m)**2+ydf(m)**2+zdf(m)**2
+        
+c     calculate scalar constant terms
+        
+        omega=(0.5d0*prmshl(kk,1)+0.25d0*prmshl(kk,2)*rij2)*rij2
+        gamma=prmshl(kk,1)+prmshl(kk,2)*rij2
+
+c     indices of core and shell
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+        
+c     set selection control
+        
+        lselect=.true.
+        
+        if(lexcite)then
+          
+c     selected excitation option
+        
+          if((atm_fre(i).ne.1).and.(atm_fre(j).ne.1))then
+            
+c     reset selection control
+            
+            lselect=(atm_fre(i)+atm_fre(i).eq.0)
+            
+            if(lsolva)then
+              shl_exc(atmolt(i))=shl_exc(atmolt(i))+omega
+            endif
+            
+          endif
+          
+        elseif(lfree)then
+          
+c     selected free energy option
+          
+          if((atm_fre(i).eq.1).or.(atm_fre(j).eq.1))then
+            
+c     set hamiltonian mixing parameter
+
+            shl_fre=shl_fre-omega
+            shl_vir=shl_vir-gamma*rij2
+            omega=lambda1*omega
+            gamma=lambda1*gamma
+            
+          elseif((atm_fre(i).eq.2).or.(atm_fre(j).eq.2))then
+            
+c     set hamiltonian mixing parameter
+
+            shl_fre=shl_fre+omega
+            shl_vir=shl_vir+gamma*rij2
+            omega=lambda2*omega
+            gamma=lambda2*gamma
+                        
+          endif
+          
+        endif
+        
+        if(lselect)then
+          
+c     calculate spring energy and virial
+          
+          engshl=engshl+omega
+          virshl=virshl+gamma*rij2
+          
+          if(lsolva)then
+            shl_sol(atmolt(i))=shl_sol(atmolt(i))+omega
+          endif
+          
+c     calculate spring forces
+          
+          ffx=-gamma*xdf(m)
+          ffy=-gamma*ydf(m) 
+          ffz=-gamma*zdf(m)
+          
+          fxx(i)=fxx(i)+ffx
+          fyy(i)=fyy(i)+ffy
+          fzz(i)=fzz(i)+ffz
+          
+          fxx(j)=fxx(j)-ffx
+          fyy(j)=fyy(j)-ffy
+          fzz(j)=fzz(j)-ffz
+          
+c     calculate stress tensor
+          
+          strs(1)=strs(1)+xdf(m)*ffx
+          strs(2)=strs(2)+xdf(m)*ffy
+          strs(3)=strs(3)+xdf(m)*ffz
+          strs(4)=strs(4)+ydf(m)*ffy
+          strs(5)=strs(5)+ydf(m)*ffz
+          strs(6)=strs(6)+zdf(m)*ffz
+          
+        endif
+        
+      enddo
+        
+c     complete stress tensor
+
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+c     sum contributions to potential and virial
+      
+      if(mxnode.gt.1) then
+        
+        buffer(1)=engshl
+        buffer(2)=virshl
+        buffer(3)=shl_fre
+        buffer(4)=shl_vir
+        call gdsum(buffer(1),4,buffer(5))
+        engshl=buffer(1)
+        virshl=buffer(2)
+        shl_fre=buffer(3)
+        shl_vir=buffer(4)
+        
+c     sum up solvation energies
+        
+        if(lsolva)then
+
+          call gdsum(shl_sol(1),mxtmls,buffer(1))
+          if(lexcite)call gdsum(shl_exc(1),mxtmls,buffer(1))
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine shlfrc
+
+      subroutine check_shells(idnode,itmols,nshels,ngrp)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine to check no core-shell units are in 
+c     rigid bodies
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,itmols,nshels,ngrp,k1,ia,ib,kk
+      integer id,jj,ia1,jk,ib1
+
+      nshels=nshels-numshl(itmols)
+      do k1=1,numshl(itmols)
+
+        nshels=nshels+1
+        ia=lstshl(nshels,1)
+        ib=lstshl(nshels,2)
+
+        ngrp=ngrp-numgrp(itmols)
+
+        do kk=1,numgrp(itmols)
+          
+          ngrp=ngrp+1
+          id=listyp(ngrp)
+          
+          do jj=1,numgsit(id)-1
+            
+            ia1=lstgst(ngrp,jj)
+            if(ia1.eq.ia) then
+
+              do jk=jj,numgsit(id)
+                
+                ib1=lstgst(ngrp,jk)
+                if(ib1.eq.ib) then 
+                  
+                  if(idnode.eq.0)write(nrite,'(/,13x,a,2i10)')
+     x              'error: sites ',ia,ib
+                  call error(idnode,456)
+
+                endif
+
+              enddo
+
+            elseif(ia1.eq.ib) then
+
+              do jk=jj,numgsit(id)
+                
+                ib1=lstgst(ngrp,jk)
+                if(ib1.eq.ia) then 
+                  
+                  if(idnode.eq.0)write(nrite,'(/,13x,a,2i10)')
+     x              'error: sites ',ia,ib
+                  call error(idnode,456)
+
+                endif
+
+              enddo
+
+            endif
+
+          enddo
+        enddo
+      enddo
+
+      return
+      end subroutine check_shells
+
+      subroutine relax_shells
+     x   (relaxed,keyrlx,idnode,mxnode,natms,ntpmls,tstep,rlxtol)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for relaxing shells to zero force
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2004
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical relaxed,newjob
+      integer keyrlx,idnode,mxnode,natms,i,j,itmols,imols
+      integer iatm1,iatm2,fail,numopt,isite,ishls,jshls,lshls,ntpmls
+      integer nbuff
+      real(8) hnorm,grad0,grad1,grad2,stride,tstep,step
+      real(8) ggg,gam2,sgn,rlxtol
+
+      dimension fail(4)
+
+      integer, allocatable :: lstopt(:)
+      real(8), allocatable :: ggx(:),ggy(:),ggz(:)
+      real(8), allocatable :: hhx(:),hhy(:),hhz(:)
+      real(8), allocatable :: oxx(:),oyy(:),ozz(:)
+
+      save hnorm,grad0,grad1,grad2,stride,lstopt
+      save ggx,ggy,ggz,hhx,hhy,hhz,oxx,oyy,ozz,numopt,nbuff,sgn
+
+      data newjob/.true./,fail/0,0,0,0/
+
+c     define initial data
+
+      if(newjob)then
+
+        newjob=.false.
+        allocate(lstopt(mxatms),stat=fail(1))
+        allocate(ggx(mxatms),ggy(mxatms),ggz(mxatms),stat=fail(2))
+        allocate(hhx(mxatms),hhy(mxatms),hhz(mxatms),stat=fail(3))
+        allocate(oxx(mxatms),oyy(mxatms),ozz(mxatms),stat=fail(4))
+        do i=1,4
+          if(fail(i).ne.0)call error(idnode,1970)
+        enddo
+
+c     identify the shells
+
+        isite=0
+        ishls=0
+        jshls=0
+        do i=1,natms
+
+          lstopt(i)=0
+
+        enddo
+        do itmols=1,ntpmls
+
+          do imols=1,nummols(itmols)
+
+            do lshls=1,numshl(itmols)
+              
+              ishls=ishls+1
+              lstopt(lstshl(lshls+jshls,2)+isite)=1
+              
+            enddo
+            
+            isite=isite+numsit(itmols)
+
+          enddo
+
+          jshls=jshls+numshl(itmols)
+
+        enddo
+
+        numopt=ishls
+
+      endif
+
+c     load coordinates of shells
+
+      j=0
+      do i=1,natms
+
+        if(lstopt(i).gt.0)then
+
+          j=j+1
+          oxx(j)=xxx(i)
+          oyy(j)=yyy(i)
+          ozz(j)=zzz(i)
+          ggx(j)=fxx(i)
+          ggy(j)=fyy(i)
+          ggz(j)=fzz(i)
+
+        endif
+
+      enddo
+
+c     step length for relaxation
+
+      step=tstep**2
+
+c     define atoms for this nodes
+
+      iatm1=(idnode*numopt)/mxnode+1
+      iatm2=((idnode+1)*numopt)/mxnode
+
+      ggg=0.d0
+      do i=iatm1,iatm2
+        ggg=ggg+ggx(i)**2+ggy(i)**2+ggz(i)**2
+      enddo
+      if(mxnode.gt.1)then
+        buffer(1)=ggg
+        call gdsum(buffer(1),1,buffer(2))
+        ggg=buffer(1)
+      endif
+      ggg=sqrt(ggg)
+
+c     check convergence
+
+      if(abs(ggg)/dble(numopt).lt.rlxtol)then
+
+        relaxed=.true.
+        return
+        
+      endif
+
+      if(keyrlx.eq.0) then
+
+c     set original search direction
+
+        hnorm=ggg
+        grad0=ggg
+        grad2=ggg
+        do i=iatm1,iatm2
+
+          hhx(i)=ggx(i)
+          hhy(i)=ggy(i)
+          hhz(i)=ggz(i)
+          oxx(i)=oxx(i)+step*hhx(i)
+          oyy(i)=oyy(i)+step*hhy(i)
+          ozz(i)=ozz(i)+step*hhz(i)
+
+        enddo
+        keyrlx=1
+        sgn=1.d0
+
+      elseif(keyrlx.eq.1)then
+
+c     line search along chosen direction
+
+        grad1=grad2
+        grad2=0.d0
+        do i=iatm1,iatm2
+          grad2=grad2+hhx(i)*ggx(i)+hhy(i)*ggy(i)+hhz(i)*ggz(i)
+        enddo
+        if(mxnode.gt.1)then
+          buffer(1)=grad2
+          call gdsum(buffer(1),1,buffer(2))
+          grad2=buffer(1)
+        endif
+        grad2=sgn*grad2/hnorm
+
+c     linear extrapolation to minimum
+
+        stride=sgn*step
+        if(grad2.lt.0.d0)then
+
+          keyrlx=2
+          stride=sgn*step*grad2/(grad1-grad2)
+
+        endif
+        
+        do i=iatm1,iatm2
+          
+          oxx(i)=oxx(i)+stride*hhx(i)
+          oyy(i)=oyy(i)+stride*hhy(i)
+          ozz(i)=ozz(i)+stride*hhz(i)
+          
+        enddo
+
+      elseif(keyrlx.eq.2)then
+
+c     construct conjugate search vector
+
+        gam2=(ggg/grad0)**2
+        hnorm=0.d0
+        grad0=ggg
+        grad2=0.d0
+        do i=iatm1,iatm2
+          
+          hhx(i)=ggx(i)+gam2*hhx(i)
+          hhy(i)=ggy(i)+gam2*hhy(i)
+          hhz(i)=ggz(i)+gam2*hhz(i)
+          hnorm=hnorm+hhx(i)**2+hhy(i)**2+hhz(i)**2
+          grad2=grad2+hhx(i)*ggx(i)+hhy(i)*ggy(i)+hhz(i)*ggz(i)
+          
+        enddo
+        if(mxnode.gt.1)then
+          
+          buffer(1)=hnorm
+          buffer(2)=grad2
+          call gdsum(buffer(1),2,buffer(3))
+          hnorm=buffer(1)
+          grad2=buffer(2)
+          
+        endif
+        hnorm=sqrt(hnorm)
+        grad2=grad2/hnorm
+        sgn=sign(1.d0,grad2)
+        grad2=sgn*grad2
+
+        do i=iatm1,iatm2
+          
+          oxx(i)=oxx(i)+sgn*step*hhx(i)
+          oyy(i)=oyy(i)+sgn*step*hhy(i)
+          ozz(i)=ozz(i)+sgn*step*hhz(i)
+          
+        enddo
+        
+        keyrlx=1
+
+      endif 
+      
+c     merge coordinate arrays
+      
+      if(mxnode.gt.1)then
+        
+        nbuff=6*(numopt+mxnode-1)/mxnode
+        call merge(idnode,mxnode,numopt,nbuff,oxx,oyy,ozz,buffer)
+        
+      endif
+
+c     unload coordinates of shells
+
+      j=0
+      do i=1,natms
+
+        if(lstopt(i).gt.0)then
+
+          j=j+1
+          xxx(i)=oxx(j)
+          yyy(i)=oyy(j)
+          zzz(i)=ozz(j)
+
+        endif
+
+      enddo
+      
+      return
+      end subroutine relax_shells
+      
+      end module core_shell_module
diff -urN dl_class_1.9.orig/srcmod/coulomb_module.f dl_class_1.9/srcmod/coulomb_module.f
--- dl_class_1.9.orig/srcmod/coulomb_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/coulomb_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1542 @@
+      module coulomb_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining coulomb terms
+c     copyright - daresbury laboratory
+c     
+c     author    - w. smith    sep 2003
+c     adapted for solvation, free energy and excitation
+c               - p.-a. cazade oct 2007
+c     
+c***********************************************************************
+
+      use config_module
+      use ewald_module
+      use metafreeze_module
+      use pair_module
+      use property_module
+      use setup_module
+      use solvation_module
+
+      implicit none
+
+      contains
+      
+      subroutine coul0
+     x  (lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic force.
+c     1/r potential, no truncation or damping
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - t. forester february 1993
+c     stress tensor - t.forester may 1994
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,ik,m,jatm,kkk
+      real(8) rcsq,chgea,rsq,chgprd,rrr,coul,fcoul,fi,fx,fy,fz
+      real(8) engcpe,vircpe,rcut,epsq,strs(6),strs_loc(6)
+
+      dimension fi(3)
+
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0     
+      
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      
+      if(abs(chgea).gt.1.d-10)then
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+        do m=1,ik
+
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          if(lmetadyn)jdrive=driven(ltype(jatm))
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+
+          chgprd=chgea*chge(jatm)
+          if(abs(chgprd).gt.1.d-10)then
+            
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+
+c     apply truncation of potential
+            
+            if(rcsq.gt.rsq)then
+              
+              rrr=sqrt(rsq)
+              
+c     coulomb potential and force
+              
+              coul=chgprd/rrr
+              fcoul=coul/rsq
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-coul
+                  cou_vir=cou_vir+coul
+                  coul=lambda1*coul
+                  fcoul=lambda1*fcoul
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+
+                  cou_fre=cou_fre+coul
+                  cou_vir=cou_vir-coul
+                  coul=lambda2*coul
+                  fcoul=lambda2*fcoul
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+                
+c     calculate potential energy and virial
+              
+                engcpe=engcpe+coul
+                vircpe=vircpe-coul
+                
+c     calculate solvation energy
+              
+                if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+                
+c     calculate forces
+                
+                fx=fcoul*xdf(m)
+                fy=fcoul*ydf(m)
+                fz=fcoul*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+                
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+                
+c     calculate stress tensor
+              
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+              
+c     metadynamics local parameters
+              
+              if(lmetadyn.and.(idrive.or.jdrive))then
+                
+c     local energy and virial
+          
+                eng_loc=eng_loc+coul
+                vir_loc=vir_loc-coul
+                
+c     local forces          
+                
+                fxx_loc(iatm)=fxx_loc(iatm)+fx
+                fyy_loc(iatm)=fyy_loc(iatm)+fy
+                fzz_loc(iatm)=fzz_loc(iatm)+fz
+
+                fxx_loc(jatm)=fxx_loc(jatm)-fx
+                fyy_loc(jatm)=fyy_loc(jatm)-fy
+                fzz_loc(jatm)=fzz_loc(jatm)-fz
+                
+c     calculate stress tensor
+              
+                strs_loc(1)=strs_loc(1)+xdf(m)*fx
+                strs_loc(2)=strs_loc(2)+xdf(m)*fy
+                strs_loc(3)=strs_loc(3)+xdf(m)*fz
+                strs_loc(4)=strs_loc(4)+ydf(m)*fy
+                strs_loc(5)=strs_loc(5)+ydf(m)*fz
+                strs_loc(6)=strs_loc(6)+zdf(m)*fz
+                
+              endif
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+c     load temps back to fxx(iatm) etc
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+        
+c     complete stress tensor
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+
+        if(lmetadyn)then
+          
+          stress_loc(1)=stress_loc(1)+strs_loc(1)
+          stress_loc(2)=stress_loc(2)+strs_loc(2)
+          stress_loc(3)=stress_loc(3)+strs_loc(3)
+          stress_loc(4)=stress_loc(4)+strs_loc(2)
+          stress_loc(5)=stress_loc(5)+strs_loc(4)
+          stress_loc(6)=stress_loc(6)+strs_loc(5)
+          stress_loc(7)=stress_loc(7)+strs_loc(3)
+          stress_loc(8)=stress_loc(8)+strs_loc(5)
+          stress_loc(9)=stress_loc(9)+strs_loc(6)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine coul0
+      
+      subroutine coul1
+     x  (lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces 
+c     assuming a standard coulomb potential truncated at rcut
+c     and shifted to zero at rcut.
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith december 1992.
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c     stress tensor t.forester may 1994
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,ik,m,jatm,kkk
+      real(8) engcpe,vircpe,rcut,epsq,rcsq,chgea,rsq
+      real(8) fi,chgprd,omega,egamma,fx,fy,fz,rrr
+      real(8) strs(6),strs_loc(6)
+
+      dimension fi(3)
+
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+      chgea=chge(iatm)*r4pie0/epsq
+
+      if(abs(chgea).gt.1.d-10)then
+
+c     start of primary loop for forces evaluation
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+        do m=1,ik
+          
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          if(lmetadyn)jdrive=driven(ltype(jatm))
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+          
+          chgprd=chgea*chge(jatm)
+          if(abs(chgprd).gt.1.d-10) then
+
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+
+c     apply truncation of potential
+            
+            if(rcsq.gt.rsq)then
+              
+              rrr=sqrt(rsq)
+
+c     calculate potential energy and virial
+
+              omega=chgprd*(rcut-rrr)/(rrr*rcut)
+              egamma=chgprd/(rrr*rsq)
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc(kkk)=cou_exc(kkk)+omega
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-omega
+                  cou_vir=cou_vir+egamma*rsq
+                  omega=lambda1*omega
+                  egamma=lambda1*egamma
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+
+                  cou_fre=cou_fre+omega
+                  cou_vir=cou_vir-egamma*rsq
+                  omega=lambda2*omega
+                  egamma=lambda2*egamma
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+
+c     calculate potential energy and virial
+              
+                engcpe=engcpe+omega
+                vircpe=vircpe-egamma*rsq
+                
+c     calculate solvation energy
+              
+                if(lsolva)cou_sol(kkk)=cou_sol(kkk)+omega
+              
+c     calculate forces
+                
+                fx=egamma*xdf(m)
+                fy=egamma*ydf(m)
+                fz=egamma*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+                
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+                
+c     calculate stress tensor
+              
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+
+c     metadynamics local parameters
+        
+              if(lmetadyn.and.(idrive.or.jdrive))then
+
+c     local energy and virial
+
+                eng_loc=eng_loc+omega
+                vir_loc=vir_loc-egamma*rsq                
+              
+c     local forces
+          
+                fxx_loc(iatm)=fxx_loc(iatm)+fx
+                fyy_loc(iatm)=fyy_loc(iatm)+fy
+                fzz_loc(iatm)=fzz_loc(iatm)+fz
+                
+                fxx_loc(jatm)=fxx_loc(jatm)-fx
+                fyy_loc(jatm)=fyy_loc(jatm)-fy
+                fzz_loc(jatm)=fzz_loc(jatm)-fz
+                
+c     local  stress tensor
+              
+                strs_loc(1)=strs_loc(1)+xdf(m)*fx
+                strs_loc(2)=strs_loc(2)+xdf(m)*fy
+                strs_loc(3)=strs_loc(3)+xdf(m)*fz
+                strs_loc(4)=strs_loc(4)+ydf(m)*fy
+                strs_loc(5)=strs_loc(5)+ydf(m)*fz
+                strs_loc(6)=strs_loc(6)+zdf(m)*fz
+                
+              endif
+
+            endif
+            
+          endif
+
+        enddo
+
+c     load temps back to fxx(iatm) etc
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+
+c     complete stress tensor
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+
+        if(lmetadyn)then
+          
+          stress_loc(1)=stress_loc(1)+strs_loc(1)
+          stress_loc(2)=stress_loc(2)+strs_loc(2)
+          stress_loc(3)=stress_loc(3)+strs_loc(3)
+          stress_loc(4)=stress_loc(4)+strs_loc(2)
+          stress_loc(5)=stress_loc(5)+strs_loc(4)
+          stress_loc(6)=stress_loc(6)+strs_loc(5)
+          stress_loc(7)=stress_loc(7)+strs_loc(3)
+          stress_loc(8)=stress_loc(8)+strs_loc(5)
+          stress_loc(9)=stress_loc(9)+strs_loc(6)
+          
+        endif
+
+      endif
+      
+      return
+      end subroutine coul1
+
+      subroutine coul2
+     x  (lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces 
+c     assuming a distance dependant dielectric `constant'.
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - t. forester    april 1993
+c     stress tensor added - t.forester may 1994
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,ik,m,jatm,kkk
+      real(8) engcpe,vircpe,rcut,epsq
+      real(8) fi,rcsq,chgea,chgprd,rsq,rrsq,coul,egamma,fx,fy,fz
+      real(8) strs(6),strs_loc(6)
+      
+      dimension fi(3)
+      
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+      
+c     initialise stress tensor accumulators
+      
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      if(abs(chgea).gt.1.d-10)then
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+c     start of primary loop for forces evaluation
+        
+        do m=1,ik
+          
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          if(lmetadyn)jdrive=driven(ltype(jatm))
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+          
+          chgprd=chgea*chge(jatm)
+          if(abs(chgprd).gt.1.d-10)then
+            
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+            
+c     apply truncation of potential
+            
+            if(rcsq.gt.rsq)then
+              
+c     calculate potential energy and Virial
+              
+              rrsq=1.d0/rsq
+              coul=chgprd*rrsq
+              egamma=2.d0*coul*rrsq
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-coul
+                  cou_vir=cou_vir+2.d0*coul
+                  coul=lambda1*coul
+                  egamma=lambda1*egamma
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre+coul
+                  cou_vir=cou_vir-2.d0*coul
+                  coul=lambda2*coul
+                  egamma=lambda2*egamma
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+
+c     calculate potential energy and Virial
+                
+                engcpe=engcpe+coul
+                vircpe=vircpe-2.d0*coul
+                
+c     calculate solvation energy
+              
+                if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+              
+c     calculate forces
+                
+                fx=egamma*xdf(m)
+                fy=egamma*ydf(m)
+                fz=egamma*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+              
+c     calculate stress tensor
+                
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+              
+c     metadynamics local parameters
+        
+              if(lmetadyn.and.(idrive.or.jdrive))then
+
+c     local energy and virial
+        
+                eng_loc=eng_loc+coul
+                vir_loc=vir_loc-2.d0*coul
+              
+c     local forces
+          
+                fxx_loc(iatm)=fxx_loc(iatm)+fx
+                fyy_loc(iatm)=fyy_loc(iatm)+fy
+                fzz_loc(iatm)=fzz_loc(iatm)+fz
+                
+                fxx_loc(jatm)=fxx_loc(jatm)-fx
+                fyy_loc(jatm)=fyy_loc(jatm)-fy
+                fzz_loc(jatm)=fzz_loc(jatm)-fz
+                
+c     local stress tensor
+              
+                strs_loc(1)=strs_loc(1)+xdf(m)*fx
+                strs_loc(2)=strs_loc(2)+xdf(m)*fy
+                strs_loc(3)=strs_loc(3)+xdf(m)*fz
+                strs_loc(4)=strs_loc(4)+ydf(m)*fy
+                strs_loc(5)=strs_loc(5)+ydf(m)*fz
+                strs_loc(6)=strs_loc(6)+zdf(m)*fz
+                
+              endif
+
+            endif
+            
+          endif
+          
+        enddo
+        
+c     load temps back to fxx(iatm) etc
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+        
+c     complete stress tensor
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+
+        if(lmetadyn)then
+          
+          stress_loc(1)=stress_loc(1)+strs_loc(1)
+          stress_loc(2)=stress_loc(2)+strs_loc(2)
+          stress_loc(3)=stress_loc(3)+strs_loc(3)
+          stress_loc(4)=stress_loc(4)+strs_loc(2)
+          stress_loc(5)=stress_loc(5)+strs_loc(4)
+          stress_loc(6)=stress_loc(6)+strs_loc(5)
+          stress_loc(7)=stress_loc(7)+strs_loc(3)
+          stress_loc(8)=stress_loc(8)+strs_loc(5)
+          stress_loc(9)=stress_loc(9)+strs_loc(6)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine coul2
+
+      subroutine coul3
+     x  (lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic force.
+c     reaction field  potential
+c     Ref: M Neumann, J Chem Phys, 82, 5633, (1985)
+c     adapted for fennell-gezelter coulombic model
+c     by w.smith june 2007
+c     Ref: CJ Fennell and JD Gezelter, J Chem Phys, 
+c     124, 234104, (2006)
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - t. forester february 1995
+c     stress tensor - t.forester   feb 1995
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,ik,m,jatm,l,kkk
+      real(8) engcpe,vircpe,rcut,epsq,vcon,fcon,rdr,ppp,fi,rcsq
+      real(8) b0,rfld0,rfld1,rfld2,chgea,chgprd,rsq,coul,omega
+      real(8) fx,fy,fz,fcoul,rrr,vk0,vk1,vk2,gk0,gk1,gk2,t1,t2
+      real(8) strs(6),strs_loc(6)
+      dimension fi(3)
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+        
+c     reaction field terms
+      
+      b0=2.d0*(epsq-1.d0)/(2.d0*epsq+1.d0)
+      rfld0=b0/rcut**3
+      rfld1=(1.d0+b0*0.5d0)/rcut
+      rfld2=rfld0*0.5d0
+      
+c     screened coulomb terms
+        
+      vcon=erc(mxegrd-4)+rfld2*rcut**2-rfld1
+      fcon=rcut*fer(mxegrd-4)-rfld0*rcut
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+      rdr=dble(mxegrd-4)/rcut
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)*r4pie0
+      
+      if(abs(chgea).gt.1.d-10)then
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+        do m=1,ik
+
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          if(lmetadyn)jdrive=driven(ltype(jatm))
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+          
+          chgprd=chgea*chge(jatm)
+          if(abs(chgprd).gt.1.d-10)then
+
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+
+c     apply truncation of potential
+            
+            if(rcsq.gt.rsq)then
+              
+              rrr=sqrt(rsq)
+              l=int(rrr*rdr)
+              ppp=rrr*rdr-dble(l)
+              
+c     calculate potential energy using 3-point interpolation
+              
+              vk0=erc(l)
+              vk1=erc(l+1)
+              vk2=erc(l+2)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              omega=t1+(t2-t1)*ppp*0.5d0-vcon+fcon*(rrr-rcut)
+              coul=chgprd*(omega+rfld2*rsq-rfld1)
+
+c     calculate forces using 3-point interpolation
+              
+              gk0=fer(l)
+              gk1=fer(l+1)
+              gk2=fer(l+2)
+              t1=gk0+(gk1-gk0)*ppp
+              t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+              fcoul=chgprd*((t1+(t2-t1)*ppp*0.5d0)-fcon/rrr-rfld0)
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-coul
+                  cou_vir=cou_vir+fcoul*rsq
+                  coul=lambda1*coul
+                  fcoul=lambda1*fcoul
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+
+                  cou_fre=cou_fre+coul
+                  cou_vir=cou_vir-fcoul*rsq
+                  coul=lambda2*coul
+                  fcoul=lambda2*fcoul
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+
+c     calculate coulombic energy and virial
+              
+                engcpe=engcpe+coul
+                vircpe=vircpe-fcoul*rsq
+              
+c     calculate solvation energy
+              
+                if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+                
+c     calculate coulombic force
+                
+                fx=fcoul*xdf(m)
+                fy=fcoul*ydf(m)
+                fz=fcoul*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+                
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+                
+c     calculate stress tensor
+              
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+
+c     metadynamics local parameters
+        
+              if(lmetadyn.and.(idrive.or.jdrive))then
+
+c     local energy and virial
+              
+                eng_loc=eng_loc+coul
+                vir_loc=vir_loc-fcoul*rsq
+              
+c     local forces
+                
+                fxx_loc(iatm)=fxx_loc(iatm)+fx
+                fyy_loc(iatm)=fyy_loc(iatm)+fy
+                fzz_loc(iatm)=fzz_loc(iatm)+fz
+
+                fxx_loc(jatm)=fxx_loc(jatm)-fx
+                fyy_loc(jatm)=fyy_loc(jatm)-fy
+                fzz_loc(jatm)=fzz_loc(jatm)-fz
+                
+c     local stress tensor
+              
+                strs_loc(1)=strs_loc(1)+xdf(m)*fx
+                strs_loc(2)=strs_loc(2)+xdf(m)*fy
+                strs_loc(3)=strs_loc(3)+xdf(m)*fz
+                strs_loc(4)=strs_loc(4)+ydf(m)*fy
+                strs_loc(5)=strs_loc(5)+ydf(m)*fz
+                strs_loc(6)=strs_loc(6)+zdf(m)*fz
+                
+              endif
+              
+            endif
+
+          endif
+          
+        enddo
+        
+c     load temps back to fxx(iatm) etc
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+
+c     complete stress tensor
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+
+        if(lmetadyn)then
+
+          stress_loc(1)=stress_loc(1)+strs_loc(1)
+          stress_loc(2)=stress_loc(2)+strs_loc(2)
+          stress_loc(3)=stress_loc(3)+strs_loc(3)
+          stress_loc(4)=stress_loc(4)+strs_loc(2)
+          stress_loc(5)=stress_loc(5)+strs_loc(4)
+          stress_loc(6)=stress_loc(6)+strs_loc(5)
+          stress_loc(7)=stress_loc(7)+strs_loc(3)
+          stress_loc(8)=stress_loc(8)+strs_loc(5)
+          stress_loc(9)=stress_loc(9)+strs_loc(6)
+
+      endif
+
+      endif
+      
+      return
+      end subroutine coul3
+
+      subroutine coul4
+     X  (lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces 
+c     assuming a force shifted coulomb potential.
+c     adapted for fennell-gezelter coulombic model
+c     by w.smith may 2007
+c     Ref: CJ Fennell and JD Gezelter, J Chem Phys, 
+c     124, 234104, (2006)
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1995
+c     author    -  t.forester october  1995
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,ik,m,jatm,l,kkk
+      real(8) engcpe,vircpe,rcut,epsq,vcon,fcon,rdr,ppp,fi,rcsq,coul
+      real(8) strs9,chgea,chgprd,rsq,rrr,omega,fcoul,fx,fy,fz
+      real(8) vk0,vk1,vk2,gk0,gk1,gk2,t1,t2
+      real(8) strs(6),strs_loc(6)
+
+      dimension fi(3)
+
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+
+c     screened coulomb terms
+        
+      vcon=erc(mxegrd-4)
+      fcon=rcut*fer(mxegrd-4)
+      rdr=dble(mxegrd-4)/rcut
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+      chgea=chge(iatm)*r4pie0/epsq
+
+      if(abs(chgea).gt.1.d-10)then
+
+c     start of primary loop for forces evaluation
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+        do m=1,ik
+          
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          if(lmetadyn)jdrive=driven(ltype(jatm))
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+          
+          chgprd=chgea*chge(jatm)
+          if(abs(chgprd).gt.1.d-10)then
+
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+
+c     apply truncation of potential
+            
+            if(rcsq.gt.rsq)then
+              
+              rrr=sqrt(rsq)
+              l=int(rrr*rdr)
+              ppp=rrr*rdr-dble(l)
+              
+c     calculate potential energy using 3-point interpolation
+              
+              vk0=erc(l)
+              vk1=erc(l+1)
+              vk2=erc(l+2)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              omega=t1+(t2-t1)*ppp*0.5d0
+              coul=chgprd*(omega-vcon+fcon*(rrr-rcut))
+              
+c     calculate forces using 3-point interpolation
+              
+              gk0=fer(l)
+              gk1=fer(l+1)
+              gk2=fer(l+2)
+              t1=gk0+(gk1-gk0)*ppp
+              t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+              fcoul=chgprd*((t1+(t2-t1)*ppp*0.5d0)-fcon/rrr)
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-coul
+                  cou_vir=cou_vir+fcoul*rsq
+                  coul=lambda1*coul
+                  fcoul=lambda1*fcoul
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre+coul
+                  cou_vir=cou_vir-fcoul*rsq
+                  coul=lambda2*coul
+                  fcoul=lambda2*fcoul
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+
+c     calculate the coulombic energy and virial
+              
+                engcpe=engcpe+coul
+                vircpe=vircpe-fcoul*rsq
+                
+c     calculate solvation energy
+                
+                if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+                
+c     calculate coulombic forces
+                
+                fx=fcoul*xdf(m)
+                fy=fcoul*ydf(m)
+                fz=fcoul*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+                
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+                
+c     calculate stress tensor
+                
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+
+c     metadynamics local parameters
+        
+              if(lmetadyn.and.(idrive.or.jdrive))then
+
+c     local energy and virial
+          
+                eng_loc=eng_loc+coul
+                vir_loc=vir_loc-fcoul*rsq
+                
+c     local forces
+                                
+                fxx_loc(iatm)=fxx_loc(iatm)+fx
+                fyy_loc(iatm)=fyy_loc(iatm)+fy
+                fzz_loc(iatm)=fzz_loc(iatm)+fz
+                
+                fxx_loc(jatm)=fxx_loc(jatm)-fx
+                fyy_loc(jatm)=fyy_loc(jatm)-fy
+                fzz_loc(jatm)=fzz_loc(jatm)-fz
+                
+c     local stress tensor
+                
+                strs_loc(1)=strs_loc(1)+xdf(m)*fx
+                strs_loc(2)=strs_loc(2)+xdf(m)*fy
+                strs_loc(3)=strs_loc(3)+xdf(m)*fz
+                strs_loc(4)=strs_loc(4)+ydf(m)*fy
+                strs_loc(5)=strs_loc(5)+ydf(m)*fz
+                strs_loc(6)=strs_loc(6)+zdf(m)*fz
+                
+              endif
+              
+            endif
+            
+          endif
+
+        enddo
+
+c     load temps back to fxx(iatm) etc
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+
+c     complete stress tensor
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+
+        if(lmetadyn)then
+
+          stress_loc(1)=stress_loc(1)+strs_loc(1)
+          stress_loc(2)=stress_loc(2)+strs_loc(2)
+          stress_loc(3)=stress_loc(3)+strs_loc(3)
+          stress_loc(4)=stress_loc(4)+strs_loc(2)
+          stress_loc(5)=stress_loc(5)+strs_loc(4)
+          stress_loc(6)=stress_loc(6)+strs_loc(5)
+          stress_loc(7)=stress_loc(7)+strs_loc(3)
+          stress_loc(8)=stress_loc(8)+strs_loc(5)
+          stress_loc(9)=stress_loc(9)+strs_loc(6)
+          
+        endif
+      
+      endif
+      
+      return
+      end subroutine coul4
+      
+      subroutine coul_nsq
+     x  (lsolva,lfree,lghost,idnode,mxnode,natms,imcon,epsq,rcut,
+     x  engcpe,vircpe)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic potential and forces
+c     for the all-pairs algorithm beyond the range of the normal cutoff
+c     i.e. the 'tertiary' forces.  frozen atom option included
+c     
+c     to be used with multiple_nsq
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith  august 2008
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lghost,lselect,lskip
+      integer natms,idnode,mxnode,imcon,ibig,i,last,mpm2
+      integer npm2,m,ii,j,idum,kkk
+      real(8) engcpe,epsq,rcut,vircpe,rsq,rrr,chgprd,fcoul,coul,rct2
+
+      lskip=(lfree.or.lghost)
+      
+c     zero energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     zero force arrays
+      
+      do i=1,natms
+        
+        flx(i)=0.d0
+        fly(i)=0.d0
+        flz(i)=0.d0
+        
+      enddo
+      
+c     zero stress tensor
+      
+      do i=1,9
+        stresl(i)=0.d0
+      enddo
+      
+c     zero solvation and excitation accumulators
+      
+      if(lsolva)then
+        
+        cou_sol_lng(:)=0.d0
+        
+        if(lghost)then
+          
+          cou_exc_lng(:)=0.d0
+          
+        endif
+        
+      endif
+      
+c     set control variables
+      
+      last=natms
+      mpm2=natms/2
+      npm2=(natms-1)/2
+      
+c     set cutoff radius
+      
+      rct2=rcut**2
+      
+c     outer loop over atoms
+      
+      do m=1,mpm2
+        
+        if(m.gt.npm2)last=mpm2
+        
+c     inner loop over atoms
+        
+        ii=0
+        do i=idnode+1,last,mxnode
+          
+c     calculate atom indices
+          
+          j=i+m
+          if(j.gt.natms)j=j-natms
+          
+          if(lskip)then
+            if(atm_fre(i)*atm_fre(j).eq.2)cycle
+          endif
+          
+c     calculate interatomic displacements
+          
+          ii=ii+1
+          xdf(ii)=xxx(i)-xxx(j)
+          ydf(ii)=yyy(i)-yyy(j)
+          zdf(ii)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     apply minimum image convention
+        
+        call images(imcon,0,1,ii,cell,xdf,ydf,zdf)
+
+c     calculate coulomb terms
+        
+        ii=0
+        
+        do i=idnode+1,last,mxnode
+          
+c     calculate atom indices
+          
+          j=i+m
+          if(j.gt.natms)j=j-natms
+          
+          if(lskip)then
+            if(atm_fre(i)*atm_fre(j).eq.2)cycle
+          endif
+          
+          ii=ii+1
+          if(lstfrz(i).eq.0.or.lstfrz(j).eq.0)then
+            
+c     reject frozen atoms and calculate interatomic distance
+            
+            rsq=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+            
+c     running check of neighbour list array capacity
+            
+            if(rsq.ge.rct2)then
+              
+              chgprd=chge(i)*chge(j)*r4pie0/epsq
+              rrr=sqrt(rsq)
+              
+c     calculate potential energy and force
+              
+              coul=chgprd/rrr
+              fcoul=coul/rsq
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(i),atmolt(j))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(i).ne.1).and.(atm_fre(j).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(i)+atm_fre(j).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc_lng(kkk)=cou_exc_lng(kkk)+coul
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(i).eq.1).or.(atm_fre(j).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-coul
+                  cou_vir=cou_vir+coul
+                  coul=lambda1*coul
+                  fcoul=lambda1*fcoul
+                  
+                elseif((atm_fre(i).eq.2).or.(atm_fre(j).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+
+                  cou_fre=cou_fre+coul
+                  cou_vir=cou_vir-coul
+                  coul=lambda2*coul
+                  fcoul=lambda2*fcoul
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+                
+c     calculate potential energy and virial
+              
+                engcpe=engcpe+coul
+                vircpe=vircpe-coul
+
+c     calculate solvation energy
+              
+                if(lsolva)cou_sol_lng(kkk)=cou_sol_lng(kkk)+coul
+                
+c     calculate forces
+                
+                flx(i)=flx(i)+fcoul*xdf(ii)
+                fly(i)=fly(i)+fcoul*ydf(ii)
+                flz(i)=flz(i)+fcoul*zdf(ii)             
+                
+                flx(j)=flx(j)-fcoul*xdf(ii)
+                fly(j)=fly(j)-fcoul*ydf(ii)
+                flz(j)=flz(j)-fcoul*zdf(ii)  
+                
+c     stress tensor
+                
+                stresl(1)=stresl(1)+xdf(ii)*fcoul*xdf(ii)
+                stresl(2)=stresl(2)+xdf(ii)*fcoul*ydf(ii)
+                stresl(3)=stresl(3)+xdf(ii)*fcoul*zdf(ii)
+                stresl(5)=stresl(5)+ydf(ii)*fcoul*ydf(ii)
+                stresl(6)=stresl(6)+ydf(ii)*fcoul*zdf(ii)
+                stresl(9)=stresl(9)+zdf(ii)*fcoul*zdf(ii)
+                
+              endif
+              
+            endif
+            
+          endif
+          
+        enddo
+          
+      enddo
+
+c     complete stress tensor
+
+      stresl(4)=stresl(2)
+      stresl(7)=stresl(3)
+      stresl(8)=stresl(6)
+      
+      return
+      end subroutine coul_nsq
+      
+      end module coulomb_module
diff -urN dl_class_1.9.orig/srcmod/define_system_module.f dl_class_1.9/srcmod/define_system_module.f
--- dl_class_1.9.orig/srcmod/define_system_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/define_system_module.f	2015-11-07 16:58:03.495054998 +0100
@@ -0,0 +1,6013 @@
+      module define_system_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for utility subroutines and functions
+c     copyright - daresbury laboratory
+c     author    - w. smith     aug 2006
+c     adapted   - p.-a. cazade oct 2007, solvation, free energy
+c     and excitation
+c     adapted   - d. quigley nov 2010, metadynamics
+c     
+c***********************************************************************
+      
+      use angles_module
+      use bonds_module
+      use config_module
+      use core_shell_module
+      use dihedral_module
+      use ensemble_tools_module
+      use error_module
+      use ewald_module
+      use exclude_module
+      use external_field_module
+      use four_body_module
+      use hkewald_module
+      use hyper_dynamics_module
+      use inversion_module
+      use metafreeze_module
+      use metal_module
+      use parse_module
+      use pmf_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use solvation_module
+      use spme_module
+      use temp_scalers_module
+      use tersoff_module
+      use tether_module
+      use three_body_module
+      use vdw_module
+      
+      contains
+      
+      subroutine simdef
+     x  (seek,lfcap,lgofr,lnsq,loptim,lzero,lminim,lpgr,ltraj,ltscal,
+     x  lzeql,lzden,nolink,newgau,lhit,lbpd,ltad,lneb,prechk,tadall,
+     x  lsolva,lfree,lfrmas,lexcite,lswitch,lghost,lnfic,nebgo,lpsoc,
+     x  idnode,minstp,intsta,istraj,keybpd,keyens,keyfce,keyres,keyver,
+     x  keytrj,kmax1,kmax2,kmax3,multt,nstack,nstbgr,nsbzdn,nstbpo,
+     x  nhko,nlatt,nstbts,nsteql,nstraj,nstrun,nospl,keytol,numgau,
+     x  khit,nhit,nblock,ntrack,blkout,numneb,mode,nsolva,isolva,nofic,
+     x  alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup,taut,
+     x  temp,timcls,timjob,tolnce,tstep,rlxtol,opttol,zlen,ehit,xhit,
+     x  yhit,zhit,ebias,vmin,catchrad,sprneb,deltad,tlow,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading in the simulation control 
+c     parameters
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith july 1992.
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c     modified
+c     author   - t.forester       may  1993
+c     amended  - t.forester       sept 1994 - dl_poly_1.1
+c     amended  - t.forester       nov  1994 - macro version
+c     amended  - w.smith          dec  1994 - t3d adaptation
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit,seek
+      character*1 hms
+      character*1 directive(lenrec)
+      logical lsolva,lfree,lfrmas,lexcite,lswitch,lghost,lnfic,lpsoc
+      logical ltscal,lzeql,loptim,ltraj,lfcap,lgofr,lpgr,lpres,safe
+      logical lstep,ltemp,lcut,ldelr,lprim,lforc,lens,lvdw,lrvdw,kill
+      logical lnsq,lzden,lewald,lspme,lhke,loop,lzero,nolink,newgau
+      logical lminim,lminopt,ltad,lneb,lhit,lbpd,prechk,tadall,nebgo
+      integer idnode,intsta,istraj,keyens,keyfce,keyres,nstbpo,nsbzdn
+      integer keytrj,kmax1,kmax2,kmax3,multt,nstack,nstbgr,khit,nhit
+      integer nhko,nlatt,nstbts,nsteql,nstraj,nstrun,nospl,ntrack
+      integer idum,imcon,keyver,keytol,nblock,blkout,numgau
+      integer minstp,numneb,i,keybpd,mode,nsolva,isolva,nofic
+      real(8) alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup
+      real(8) taut,temp,timcls,timjob,tolnce,tstep,rlxtol,opttol
+      real(8) eps,tol,fm,densvar,delrdf,delzdn,zlen,ehit,hyp_units
+      real(8) catchrad,sprneb,deltad,tlow,xhit,yhit,zhit,ebias,vmin
+      real(8) prntim
+      
+CSGIC      real(8) dummy
+CCRAY      real(8) dummy
+CFFTWc     FFTW instruction codes
+CFFTW
+CFFTW      integer FFTW_FORWARD,FFTW_BACKWARD
+CFFTW      parameter (FFTW_FORWARD=-1,FFTW_BACKWARD=1)
+CFFTW
+CFFTW      integer FFTW_REAL_TO_COMPLEX,FFTW_COMPLEX_TO_REAL
+CFFTW      parameter (FFTW_REAL_TO_COMPLEX=-1,FFTW_COMPLEX_TO_REAL=1)
+CFFTW
+CFFTW      integer FFTW_ESTIMATE,FFTW_MEASURE
+CFFTW      parameter (FFTW_ESTIMATE=0,FFTW_MEASURE=1)
+CFFTW
+CFFTW      integer FFTW_OUT_OF_PLACE,FFTW_IN_PLACE,FFTW_USE_WISDOM
+CFFTW      parameter (FFTW_OUT_OF_PLACE=0)
+CFFTW      parameter (FFTW_IN_PLACE=8,FFTW_USE_WISDOM=16)
+CFFTW
+CFFTW      integer FFTW_THREADSAFE
+CFFTW      parameter (FFTW_THREADSAFE=128)
+CFFTW
+      
+c     intitialize system variables: temperature,pressure,ensemble key
+c     force key, cutoff, primary cutoff, verlet shell width, relative
+c     dielectric constant,timestep,temperature scaling flag, 
+c     temp scaling interval
+      
+      mode=0
+      nhko=0
+      nlatt=0
+      nsteql=0
+      nstrun=0
+      minstp=0
+      keybpd=0
+      keyres=0
+      keyens=0
+      keyver=0
+      taut=0.d0
+      nstbts=0
+      nstbgr=0
+      nsbzdn=0
+      nstbpo=100
+      nstack=mxstak
+      intsta=0
+      nstraj=0
+      istraj=1
+      keytrj=0
+      numgau=1
+      alpha=0.d0
+      kmax1=0
+      kmax2=0
+      kmax3=0
+      nospl=min(8,mxspl)
+      isolva=1
+      nsolva=0
+      niswitch=0
+      nswitch=0
+      nofic=1000
+      
+      fmax=1000.d0
+      keyfce=0
+      multt=1
+      keytol=0
+      tstep=0.d0
+      temp=0.d0
+      press=0.d0
+      rcut=0.d0
+      rprim=0.d0
+      rvdw=0.d0
+      delr=0.d0
+      epsq=1.d0
+      rlxtol=1.d0
+      opttol=1.d0
+      tolnce=1.d-8
+      quattol=1.d-8
+      timjob=0.d0
+      timcls=0.d0
+      delrdf=0.d0
+      delzdn=0.d0
+      zlen=0.d0
+      ehit=0.d0
+      xhit=0.d0
+      yhit=0.d0
+      zhit=0.d0
+      vmin=0.d0
+      ebias=0.d0
+      catchrad=0.d0
+      pfree=0.d0
+      
+      lhit=.false.
+      lbpd=.false.
+      ltad=.false.
+      lneb=.false.
+      loop=.true.
+      lnfic=.false.
+      lpsoc=.false.
+      lzero=.false.
+      ltscal=.false.
+      lewald=.false.
+      lspme=.false.
+      lhke=.false.
+      lgofr=.false.
+      lpgr=.false.
+      lzeql=.true.
+      loptim=.false.
+      lminim=.false.
+      lminopt=.false.
+      ltraj=.false.
+      lfcap=.false.
+      ltemp=.false.
+      lstep=.false.
+      lcut=.false.
+      ldelr=.false.
+      lprim=.false.
+      lforc=.false.
+      lens=.false.
+      lvdw=.false.
+      lrvdw=.false.
+      lpres=.false.
+      kill=.false.
+      lnsq=.false.
+      lzden=.false.
+      nolink=.false.
+      newgau=.false.
+      prechk=.false.
+      tadall=.false.
+      lsolva=.false.
+      lfree=.false.
+      lfrmas=.false.
+      lexcite=.false.
+      lswitch=.false.
+      lghost=.false.
+      nebgo=.true.
+      seek='all     '
+      
+c PluMeD defaults
+      lplumed   = .false.
+      plumedfile="plumed.dat"
+c end PluMeD defaults
+
+c     open the simulation input file
+      
+      if(idnode.eq.0)open(nread,file='CONTROL',status='old')
+      
+c     read job title
+      
+      call getrec(safe,idnode,nread)
+      if(.not.safe)call abort_control_read(1,idnode,nread)
+      
+      call copystring(record,sysname,80)
+      if(idnode.eq.0)then 
+        
+        write(nrite,"(3(1x,120('*'),/),1x,15('*'),5x,80a1,5x,15('*'),/,
+     x    3(1x,120('*'),/),/,/,1x,'SIMULATION CONTROL PARAMETERS',/)")
+     x    sysname
+        
+      endif
+      
+c     read and process directives from CONTROL file
+      
+      do while(loop)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        
+c     convert to lowercase and strip out leading blanks
+        
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.' ')then
+          
+c PluMeD modifications
+
+        elseif(findstring('plumed ',directive,idum)) then
+             if(findstring('on',directive,idum) ) lplumed=.true.
+             if(findstring('off',directive,idum)) lplumed=.false.
+
+        elseif(findstring('plumedfile',directive,idum)) then
+             do i=1,80
+               parse_file(i:i)=record(i)
+             enddo
+             read(parse_file,*)plumedfile,plumedfile
+
+c end PluMeD modifications
+
+c     record is commented out
+          cycle
+          
+        elseif(findstring('redirect',directive,idum))then
+          
+c     ignore this option in this context
+          cycle
+          
+        elseif(findstring('steps',directive,idum))then
+          
+c     number of timesteps
+          
+          nstrun=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'selected number of timesteps',3x,i10)")nstrun
+          
+        elseif(findstring('integ',directive,idum))then
+          
+c     choice of integration algorithm
+          
+          if(findstring('leapfrog',directive,idum))then
+            
+            keyver=0
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'leapfrog verlet integration selected')")
+            
+          elseif(findstring('velocity',directive,idum))then
+            
+            keyver=1
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'velocity verlet integration selected')")
+            
+          endif
+          
+        elseif(findstring('no fic',directive,idum))then
+          
+c     cancel possible "flying ice cube" in Berendsen thermostats
+          
+          lnfic=.true.
+          nofic=intstr(directive,lenrec,idum)
+          
+        elseif(findstring('shells',directive,idum).and.
+     x      findstring('on',directive,idum).and.
+     x      findstring('cores',directive,idum))then
+          
+c     put shells on cores at start - shell model only (else null)
+          
+          lpsoc=.true.
+          
+        elseif(findstring('densvar',directive,idum))then
+          
+c     specify allowed density variation
+          
+          densvar=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'allowed density variation   ',3x,1p,e12.4)")
+     x      densvar
+          
+        elseif(findstring('no link',directive,idum))then
+          
+c     switch off link cell option
+          
+          nolink=.true.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'link cells option deactivated')")
+          
+        elseif(findstring('equil',directive,idum))then
+          
+c     number of equilibration timesteps
+          
+          nsteql=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'equilibration period        ',3x,i10)")nsteql
+          
+        elseif(findstring('restart',directive,idum))then
+          
+c     restart control
+          
+          if(findstring('noscale',directive,idum))then
+            
+            keyres=3
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'noscale restart requested')")
+            
+          elseif(findstring('scale',directive,idum))then
+            
+            keyres=2
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'scaled restart requested')")
+            
+          else
+            
+            keyres=1
+            if(idnode.eq.0)write(nrite,"(/,1x,'restart requested')")
+            
+          endif
+          
+        elseif(findstring('ensemble',directive,idum))then
+          
+c     ensemble selection
+          
+          call ensemble_selection(directive,lens,kill,idnode,keyens,
+     x      mode,taut,taup)
+          
+        elseif(findstring('regauss',directive,idum))then
+          
+c     re-initialise velocities option (regaussing)
+          
+          newgau=.true.
+          numgau=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'regaussing option activated',
+     x      /,1x,'regaussing interval set to  ',3x,i10)")
+     x      numgau
+          
+        elseif(findstring('scale',directive,idum))then
+          
+          nstbts=intstr(directive,lenrec,idum)
+          if(nstbts.gt.0)then
+            ltscal=.true.
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'temperature scaling on' 
+     x        /,1x,'temperature scaling interval',3x,i10)")
+     x        nstbts
+            
+          endif
+          
+        elseif(findstring('rdf',directive,idum))then
+          
+          if(findstring('print',directive,idum))then
+            
+            lpgr=.true.
+            lpgr=(lgofr.and.lpgr)
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'g(r) printing option on      ')")
+          
+          else
+            
+            lgofr=.true.
+            nstbgr=intstr(directive,lenrec,idum)
+            delrdf=dblstr(directive,lenrec,idum)
+            if(nstbgr.eq.0)nstbgr=10
+            if(delrdf.lt.1.d-8)delrdf=0.05d0
+            
+            if(idnode.eq.0)then
+              
+              write(nrite,
+     x          "(/,/,1x,'radial distribution functions on ',
+     x          /,1x,'g(r) collection interval    ',3x,i10)")nstbgr
+              write(nrite,
+     x          "(1x,'g(r) bin width              ',3x,1p,e12.4)")
+     x          delrdf
+              
+            endif
+            
+          endif
+          
+        elseif(findstring('zden',directive,idum))then
+          
+          lzden=.true.
+          nsbzdn=intstr(directive,lenrec,idum)
+          delzdn=dblstr(directive,lenrec,idum)
+          zlen=dblstr(directive,lenrec,idum)
+          if(nsbzdn.eq.0)nsbzdn=10
+          if(delzdn.lt.1.d-8)then
+            zlen=0.1d0*dble(mxzdn)
+            delzdn=0.1d0
+          elseif(zlen.lt.1.d-8)then
+            zlen=delzdn*dble(mxzdn)
+          endif
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,/,1x,'Z density profile requested',
+     x        /,1x,'zdensity collection interval',3x,i10)")nsbzdn
+            write(nrite,
+     x        "(1x,'zdensity bin width          ',3x,1p,e12.4)")
+     x        delzdn
+            write(nrite,
+     x        "(1x,'zdensity range              ',3x,1p,e12.4)")
+     x        zlen
+            
+          endif
+          
+        elseif(findstring('collect',directive,idum))then
+          
+          lzeql=.false.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'equilibration included in overall averages')")
+          
+        elseif(findstring('neb',directive,idum))then
+          
+c     activate nudged elastic band option
+          
+          call neb_option(directive,lneb,lminopt,idnode,
+     x      numneb,keytol,sprneb,opttol,hyp_units)
+          
+        elseif(findstring('impact',directive,idum))then
+          
+c     activate the impact option
+          
+          if(lhit)call error(idnode,516)
+          lhit=.true.
+          khit=intstr(directive,lenrec,idum)
+          nhit=intstr(directive,lenrec,idum)
+          ehit=dblstr(directive,lenrec,idum)
+          xhit=dblstr(directive,lenrec,idum)
+          yhit=dblstr(directive,lenrec,idum)
+          zhit=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)then
+            
+            write(nrite,"(/,1x,'impact option selected')")
+            write(nrite,"(
+     x        /,1x,'identity of impact atom        ',i10,
+     x        /,1x,'time step of impact            ',i10,
+     x        /,1x,'impact recoil energy (keV)     ',1p,e12.4,
+     x        /,1x,'impact direction (x component) ',1p,e12.4,
+     x        /,1x,'impact direction (y component) ',1p,e12.4,
+     x        /,1x,'impact direction (z component) ',1p,e12.4)")
+     x        khit,nhit,ehit,xhit,yhit,zhit
+            
+          endif
+          
+c     convert impact energy from keV to internal units
+          
+          ehit=ehit*9648530.821d0
+          
+        elseif(findstring('bpd',directive,idum))then
+          
+c     activate the BPD option
+          
+          call bpd_option(directive,seek,lbpd,ltad,lminopt,prechk,
+     x      nebgo,keybpd,idnode,nblock,ntrack,keytol,ebias,vmin,
+     x      catchrad,sprneb,opttol,hyp_units)
+          
+        elseif(findstring('tad',directive,idum))then
+          
+c     activate temperature accelerated dynamics option
+          
+          call tad_option(directive,ltad,lbpd,lminopt,prechk,tadall,
+     x      idnode,nblock,ntrack,blkout,keytol,catchrad,sprneb,tlow,
+     x      deltad,opttol,hyp_units)
+          
+        elseif(findstring('minim',directive,idum))then
+          
+          if(lminopt)call error(idnode,225)
+          if(findstring('forc',directive,idum))keytol=0
+          if(findstring('ener',directive,idum))keytol=1
+          if(findstring('posi',directive,idum))keytol=2
+          hyp_units=energy_unit()
+          minstp=intstr(directive,lenrec,idum)
+          opttol=dblstr(directive,lenrec,idum)
+          call getword(cunit,directive,8,lenrec)
+          lminim=.true.
+          loptim=.false.
+          lzero=.false.
+          ltscal=.false.
+          lminopt=.true.
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,1x,'minimisation programme requested')")
+            write(nrite,
+     x        "(1x,'structure minimisation interval ',
+     x        3x,i10)")minstp
+            call print_optim(keytol)
+            write(nrite,
+     x        "(1x,'structure minimisation tolerance',
+     x        3x,1p,e12.4,1x,a8)")opttol,cunit
+            
+          endif
+          if(keytol.lt.2)opttol=opttol*hyp_units
+          
+        elseif(findstring('optim',directive,idum))then
+          
+          if(lminopt)call error(idnode,225)
+          if(findstring('forc',directive,idum))keytol=0
+          if(findstring('ener',directive,idum))keytol=1
+          if(findstring('posi',directive,idum))keytol=2
+          hyp_units=energy_unit()
+          opttol=dblstr(directive,lenrec,idum)
+          call getword(cunit,directive,8,lenrec)
+          loptim=.true.
+          lminim=.false.
+          lzero=.false.
+          ltscal=.false.
+          lminopt=.true.
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,1x,'structure optimisation requested')")
+            call print_optim(keytol)
+            write(nrite,
+     x        "(1x,'tolerance for structure optimisation ',
+     x        3x,1p,e12.4,1x,a8)")opttol,cunit
+            
+          endif
+          if(keytol.lt.2)opttol=opttol*hyp_units
+          
+        elseif(findstring('zero',directive,idum))then
+          
+          if(lminopt)call error(idnode,225)
+          temp=1.d0
+          lzero=.true.
+          loptim=.false.
+          lminim=.false.
+          ltemp=.true.
+          ltscal=.false.
+          lminopt=.true.
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,1x,'zero K optimisation requested')")
+            write(nrite,
+     x        "(' temperature reset to',1p,e12.4)")1.d0
+            
+          endif
+          
+        else if(findstring('solva',directive,idum))then
+          
+          call solvation_option
+     x      (directive,lsolva,idnode,nsolva,isolva)
+          
+        else if(findstring('decomp',directive,idum))then
+          
+          call solvation_option
+     x      (directive,lsolva,idnode,nsolva,isolva)
+          
+        elseif(findstring('metafreeze',directive,idum).or.
+     x      findstring('metadyn',directive,idum))then
+          
+c     activate metadynamics option - d. quigley
+          
+          call metadyn_option
+     x      (directive,lmetadyn,lstein,ltet,lglobpe,llocpe,idnode,
+     x      ncolvar,nq4,nq6,ntet,hkey,meta_step_int,globpe_scale,
+     x      locpe_scale,ref_W_aug,h_aug,wt_Dt)
+          
+        else if(findstring('free',directive,idum))then
+          
+          call free_energy_option(directive,lfree,lfrmas,idnode)
+          
+        else if(findstring('excite',directive,idum))then
+          
+          call excitation_option
+     x      (directive,lsolva,lexcite,lghost,idnode,nsolva,isolva)
+          
+        else if(findstring('switch',directive,idum))then
+          
+          call switching_option
+     x      (directive,lsolva,lswitch,lghost,idnode,nsolva,isolva)
+          
+        elseif(findstring('print',directive,idum))then
+          
+          nstbpo=intstr(directive,lenrec,idum)
+          nstbpo=max(nstbpo,1)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'data printing interval      ',3x,i10)")nstbpo
+          
+        elseif(findstring('stack',directive,idum))then
+          
+          nstack=intstr(directive,lenrec,idum)
+          
+c     reset stack limit if too large
+          
+          nstack=min(nstack,mxstak)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'data stacking interval      ',3x,i10)")nstack
+          
+        elseif(findstring('stats',directive,idum))then
+          
+          intsta=intstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'statistics file interval    ',3x,i10)")intsta
+          
+        elseif(findstring('traj',directive,idum))then
+          
+          ltraj=.true.
+          nstraj=intstr(directive,lenrec,idum)
+          istraj=max(intstr(directive,lenrec,idum),1)
+          keytrj=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'trajectory file option on  ',
+     x      /,1x,'trajectory file start       ',3x,i10,
+     x      /,1x,'trajectory file interval    ',3x,i10
+     x      /,1x,'trajectory file info key    ',3x,i10)")
+     x      nstraj,istraj,keytrj
+          
+        elseif(findstring('ewald',directive,idum).or.
+     x      findstring('spme',directive,idum).or.
+     x      findstring('hke',directive,idum))then
+          
+c     read Ewald or HK-Ewald or SPM-Ewald sum parameters
+          
+          call ewald_selection(directive,lhke,lspme,lewald,lcut,
+     x      lforc,kill,idnode,keyfce,imcon,nhko,nlatt,kmax1,kmax2,
+     x      kmax3,alpha,rcut)
+          
+        elseif(findstring('distan',directive,idum))then
+          
+          keyfce=4
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : Distance dependent dielectric')")
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('coul',directive,idum))then
+          
+          keyfce=6
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : Coulombic potential')")
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('shift',directive,idum))then
+          
+          keyfce=8
+          alpha=0.d0
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : Shifted Coulombic potential')")
+          
+          if(findstring('precision',directive,idum))then
+            
+            eps=dblstr(directive,lenrec,idum)
+            if(.not.lcut)then
+              call error(idnode,-435)
+              kill=.true.
+            else
+              
+              eps=min(abs(eps),0.5d0)
+              tol=sqrt(abs(log(eps*rcut)))
+              alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+              if(idnode.eq.0)then
+                
+                write(nrite,
+     x            "(1x,'Specified precision parameter : ',1p,
+     x            e12.4)")eps
+                write(nrite,
+     x            "(1x,'Calculated damping parameter: ',1p,
+     x            e12.4)")alpha
+                
+              endif
+              
+            endif
+            
+          elseif(findstring('damp',directive,idum))then
+            
+            alpha=dblstr(directive,lenrec,idum)
+            if(idnode.eq.0)write(nrite,
+     x        "(1x,'Specified damping parameter : ',1p,e12.4)")
+     x        alpha
+            
+          endif
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('reaction',directive,idum))then
+          
+          keyfce=10
+          alpha=0.d0
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : reaction field')")
+          
+          if(findstring('precision',directive,idum))then
+            
+            eps=dblstr(directive,lenrec,idum)
+            if(.not.lcut)then
+              call error(idnode,-435)
+              kill=.true.
+            else
+              
+              eps=min(abs(eps),0.5d0)
+              tol=sqrt(abs(log(eps*rcut)))
+              alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+              if(idnode.eq.0)then
+                
+                write(nrite,
+     x            "(1x,'Specified precision parameter : ',1p,
+     x            e12.4)")eps
+                write(nrite,
+     x            "(1x,'Calculated damping parameter: ',1p,
+     x            e12.4)")alpha
+                
+              endif
+              
+            endif
+            
+          elseif(findstring('damp',directive,idum))then
+            
+            alpha=dblstr(directive,lenrec,idum)
+            if(idnode.eq.0)write(nrite,
+     x        "(1x,'Specified damping parameter : ',1p,e12.4)")
+     x        alpha
+            
+          endif
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('cap',directive,idum))then
+          
+          lfcap=.true.
+          fm=dblstr(directive,lenrec,idum)
+          if(fm.gt.0.d0)fmax=fm
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'force capping :',16x,1p,e12.4,' kT/A')")fmax
+          
+        elseif(findstring('no vdw',directive,idum))then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'short-range potential terms off')")
+          lvdw=.true.
+          
+        elseif(findstring('no elec',directive,idum))then
+          
+          keyfce=0
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'electrostatic potential terms off')")
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('mult',directive,idum))then
+          
+          multt=max(intstr(directive,lenrec,idum),1)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'multiple timestep interval  ',3x,i10)")multt
+          
+        elseif(findstring('timestep',directive,idum))then
+          
+          lstep=.true.
+          tstep=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'simulation timestep         ',3x,1p,e12.4)")tstep
+          
+        elseif(findstring('temp',directive,idum))then
+          
+          ltemp=.true.
+          temp=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'simulation temperature      ',3x,1p,e12.4)")temp
+          
+        elseif(findstring('pres',directive,idum))then
+          
+          press=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'simulation pressure (katm)  ',3x,1p,e12.4)")press
+          
+c     convert from katm to internal units of pressure
+          
+          press=press/prsunt
+          lpres=.true.
+          
+        elseif(findstring('prim',directive,idum))then
+          
+c     primary cutoff
+          
+          lprim=.true.
+          rprim=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'primary neighbour cut off   ',3x,1p,e12.4)")rprim
+          
+        elseif(findstring('rvdw',directive,idum))then
+          
+c     cutoff for short range potentials
+          
+          rvdw=dblstr(directive,lenrec,idum)
+          lrvdw=.true.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'real space cut off (vdw)    ',3x,1p,e12.4)")rvdw
+          
+        elseif(findstring('delr',directive,idum))then
+          
+c     Verlet shell width
+          
+          ldelr=.true.
+          delr=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'border width of Verlet shell',3x,1p,e12.4)")delr
+          
+        elseif(findstring('cut',directive,idum))then
+          
+c     cutoff
+          
+          lcut=.true.
+          rcut=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'real space cut off          ',3x,1p,e12.4)")rcut
+          
+        elseif(findstring('eps',directive,idum))then
+          
+c     relative dielectric constant
+          
+          epsq=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'relative dielectric constant',3x,1p,e12.4)")epsq
+          
+        elseif(findstring('rlxtol',directive,idum))then
+          
+c     force tolerance for shell relaxation
+          
+          rlxtol=max(rlxtol,dblstr(directive,lenrec,idum))
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'tolerance for shell relaxn. ',3x,1p,e12.4)")rlxtol
+          
+        elseif(findstring('shake',directive,idum))then
+          
+c     tolerance for shake
+          
+          tolnce=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'tolerance for SHAKE         ',3x,1p,e12.4)")tolnce
+          
+        elseif(findstring('quaternion',directive,idum))then
+          
+c     tolerance for quaternion integration
+          
+          quattol=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'tolerance for Quaternions   ',3x,1p,e12.4)")quattol
+          
+        elseif(findstring('job time',directive,idum))then
+          
+c     time for simulation (in seconds/minutes/hours/days or indefinite)
+          
+          if(findstring('indef',directive,idum))then
+             timjob=1.0d6*365.25d0*24.d0*60.d0*60.d0
+          else
+             timjob=dblstr(directive,lenrec,idum)
+             if(findstring('m',directive,idum))then
+               timjob=6.0d1*timjob
+             elseif(findstring('h',directive,idum))then
+               timjob=3.6d3*timjob
+             elseif(findstring('d',directive,idum))then
+               timjob=8.64d4*timjob
+             endif
+          endif
+          
+          call get_prntime(hms,timjob,prntim)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'user allocated job time (',a1,') ',3x,f8.4)")
+     x      hms,prntim
+          
+        elseif(findstring('close time',directive,idum))then
+          
+c     time for winding up a job (in seconds)
+          
+          timcls=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'job closure time        (s) ',3x,f8.3)")timcls
+          
+        elseif(findstring('all pairs',directive,idum))then
+          
+c     full minimum image - N^2 interactions each timestep
+          
+          lnsq=.true.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'All-pairs requested for electrostatics')")
+          
+        elseif(findstring('nospl',directive,idum))then
+          
+c     set ewald_spme interpolation order
+          
+          nospl=intstr(directive,lenrec,idum)
+          
+        elseif(findstring('finish',directive,idum))then
+          
+c     safe termination of reading CONTROL file
+          
+          loop=.false.
+          
+        else
+          
+c     unrecognised directive in control file
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+      enddo
+      
+c     check on steps before temperature scaling
+      
+      if(nstbts.eq.0)nstbts=nstrun+1
+      
+c     conduct consistency checks on directives
+      
+      if(lminim)then
+        
+c     ensure final configuration follows minimisation
+        
+        if(minstp.eq.0)minstp=nstrun
+        nstrun=minstp*(nstrun/minstp)
+        
+      endif
+      
+c     check force activation options
+      
+      if(.not.lforc)then
+        
+c     check if any forces are in operation
+        
+        if(.not.lvdw)then
+          
+          kill=.true.
+          call error(idnode,-383)
+          
+        endif
+        
+      else
+        
+c     turn on short range forces
+        
+        if(lvdw)then
+          
+          if(keyfce.eq.0)then
+            
+            lcut=.true.
+            ldelr=.true.
+            
+          endif
+          
+        else
+          
+          keyfce=keyfce+1
+          
+        endif
+        
+      endif
+      
+c     if tad selected use only leap frog
+      
+      if(ltad.and.keyver.eq.1)then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'switching to leapfrog for TAD dynamics')")
+        keyver=0
+        
+      endif
+      
+c     error checking 
+      
+      if(lmetadyn.and.keyens.ne.3.and.keyens.ne.5.and.keyens.ne.7)then
+        
+        kill=.true.
+        call error(idnode,-2360)
+        
+      endif
+      
+      if(lsolva.or.lfree.or.lexcite.or.lswitch)then
+        
+        if(lspme)then
+          
+          kill=.true.
+          call error(idnode,-601)
+          
+        endif
+        
+        if(lhke)then
+          
+          kill=.true.
+          call error(idnode,-602)
+          
+        endif
+        
+      endif
+      
+      if(lghost.and.nstbgr.ne.isolva)then
+        
+        call warning(idnode,130,dble(isolva),0.d0,0.d0)
+        nstbgr=isolva
+        
+      endif
+      if(lfree.and.lgofr)then
+        
+        call warning(idnode,140,0.d0,0.d0,0.d0)
+        lgofr=.false.
+        lpgr=.false.
+        
+      endif
+      if(loptim)then
+        
+        temp=0.d0
+        
+      elseif(.not.ltemp)then
+        
+        kill=.true.
+        call error(idnode,-380)
+        
+      endif
+      
+      if(.not.lstep)then
+        
+        kill=.true.
+        call error(idnode,-381)
+        
+      endif
+      
+      if(.not.lcut)then
+        
+        kill=.true.
+        call error(idnode,-382)
+        
+      endif
+      
+c     check if van der Waals cutoff set
+      
+      if(.not.lrvdw.and.mod(keyfce,2).eq.1)then
+        
+        if(rcut.gt.0.d0)then
+          
+          rvdw=rcut
+          
+        else
+          
+          kill=.true.
+          call error(idnode,-402)
+          
+        endif      
+        
+      endif
+      
+      if(.not.ldelr)then
+        
+        kill=.true.
+        call error(idnode,-384)
+        
+      endif
+      
+      if(multt.gt.1)then
+        
+        if(.not.lprim)then
+          
+          kill=.true.
+          call error(idnode,-385)
+          
+        elseif(rprim.gt.rcut)then
+          
+          kill=.true.
+          call error(idnode,-386)
+          
+        endif
+        
+      endif
+      
+c     check settings in nvt ensemble
+      
+      if(keyens.ge.2.and.keyens.le.3)then
+        
+        if(taut.le.0.d0)then
+          
+          kill=.true.
+          call error(idnode,-464)
+          
+        endif
+        
+      endif
+      
+c     check settings in npt ensemble
+      
+      if(keyens.ge.4.and.keyens.le.7)then
+        
+        if(.not.lpres)then
+          
+          kill=.true.
+          call error(idnode,-387)
+          
+        endif
+        
+c     check barostat and thermostat rates non zero
+        
+        if(taut.le.0.d0)then
+          
+          kill=.true.
+          call error(idnode,-464)
+          
+        endif
+        if(taup.le.0.d0)then
+          
+          kill=.true.
+          call error(idnode,-466)
+          
+        endif
+        
+      endif
+      
+c     check multiple timestep cutoffs are sensible
+      
+      if(multt.gt.1)then
+        if(rcut-rprim.lt.delr)then
+          
+          kill=.true.
+          call error(idnode,-398)
+          
+        endif
+      endif
+      
+c     check rcut > rvdw (for verlet list constructor)
+      
+      if(rcut.lt.rvdw)then 
+        
+        kill=.true.
+        call error(idnode,-400)
+        
+      endif
+      
+c     check spme is not being used with incorrect pbc
+      
+      if(lspme)then
+        
+        if(imcon.eq.0.or.imcon.eq.6)then
+          
+          kill=.true.
+          call error(idnode,-513)
+          
+        endif
+        
+      endif
+      
+c     check on all-pairs calculation request
+      
+      if(lnsq)then
+        
+        if(multt.eq.1)then
+          
+          kill=.true.
+          call error(idnode,-422)
+          
+        endif
+        
+        if(keyfce/2.lt.2.or.keyfce/2.gt.3)then
+          
+          kill=.true.
+          call error(idnode,-424)
+          
+        endif
+        
+      endif
+      
+c     cancel rdf option if no vdw or coulombic forces
+      
+      if(lgofr.and.keyfce.eq.0)then
+        
+        lgofr=.false.
+        call warning(idnode,120,0.d0,0.d0,0.d0)
+        
+      endif
+      
+      if(kill)call abort_control_read(2,idnode,nread)
+      
+c     close CONTROL file
+      
+      if(idnode.eq.0)close(nread)
+      
+      return
+      end subroutine simdef
+      
+      subroutine sysdef
+     x  (lneut,lnsq,lsolva,lfree,lexcite,lswitch,lghost,idnode,keyfce,
+     x  keyfld,natms,ngrp,ntpatm,ntpmls,ntpvdw,ntptbp,ntpmet,ntpfbp,
+     x  ntpter,nshels,keyshl,ntghost,keyver,dlrpot,engunit,rvdw,rcuttb,
+     x  rctter,rcutfb)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading in the molecular specifications
+c     of the system to be simulated
+c     version for rigid unit data and neutral groups
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith may 1992.
+c     amended   - w.smith march 1994 
+c     amended   - t.forester april 1994
+c     amended   - w.smith  dec 1994 - getrec etc
+c     amended   - a.smondyrev may 2000 - keydih=5 for 
+c     ryckaert-bellemans potential in dihedrals
+c     amended   - a.smondyrev may 2000 - keydih=6 for 
+c     fluorinated ryckaert-bellemans potential in dihedrals
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lunits,lmols,lneut,ltable,lnsq,lshl,safe,lpmf
+      logical loop1,loop2,lsolva,lfree,lexcite,lswitch,lghost
+      
+      integer idnode,keyfce,keyfld,natms,ngrp,ntpatm,ntpmls
+      integer ntpvdw,ntptbp,ntpmet,ntpfbp,nshels,ksite
+      integer nsite,nconst,nangle,ndihed,ninver,nbonds
+      integer nteth,nspmf,itmols,i,idum,keyver
+      integer ntpter,keyshl,iatm,natmsr,ntghost
+      
+      real(8) dlrpot,engunit,rvdw,rcuttb,rctter,rcutfb
+      real(8) sumchg
+      
+      data loop1/.true./,loop2/.true./
+      
+c     initialise system counters: atomic site index, number of 
+c     constraints, bond angles, dihedrals, inversions, chemical bonds,
+c     unique atom types, total number of atoms,
+c     total number of rigid groups, number of tethered atoms,
+c     number of three body potentials
+      
+      nsite=0
+      nconst=0
+      nangle=0
+      ndihed=0
+      ninver=0
+      nbonds=0
+      ntpatm=0
+      natms=0
+      ngrp=0
+      nteth=0
+      ntptbp=0
+      ntpter=0
+      ntpmet=0
+      ntpvdw=0
+      ntpfbp=0
+      nshels=0
+      nspmf=0
+      keyfld=0
+      keyshl=0
+      ntghost=0
+      natmsr=0
+      ntcons_ghost=0
+      
+      lunits=.false.
+      lmols=.false.
+      lneut=.false.
+      ltable=.false.
+      lmetab=.false.
+      lshl=.false.
+      lpmf=.false.
+      engunit=1.d0
+      
+      numbonds(:)=0
+      numpmf(:)=0
+      numcon(:)=0
+      numdih(:)=0
+      numinv(:)=0
+      numgrp(:)=0
+      numsit(:)=0
+      numteth(:)=0
+      numshl(:)=0
+      npmf(:)=0
+      indpmf(:)=0
+      
+c     open force field data file
+      
+      if(idnode.eq.0)open (nfield,file='FIELD',status='old')
+      
+      if(idnode.eq.0)
+     x  write(nrite,"(/,/,'SYSTEM SPECIFICATION')")
+      
+      call getrec(safe,idnode,nfield)
+      if(.not.safe)call abort_field_read(1,idnode,nfield)
+      
+c     read and process directives from field file
+      
+      do while(loop1)
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)call abort_field_read(1,idnode,nfield)
+        
+c     convert to lowercase and remove leading blanks
+        
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.' ')then
+          
+c     record is commented out
+          cycle
+          
+        elseif(findstring('units',record,idum))then
+          
+c     identify energy unit for input/output
+          
+          lunits=.true.
+          call define_units(idnode,engunit)
+          
+c     neutral group control option
+          
+        elseif(findstring('neut',record,idum))then
+          
+          lneut=.true.
+          if(idnode.eq.0)
+     x      write(nrite,"(/,' neutral group implementation in use')")
+          
+c     can't have neutral groups with all-pairs
+          
+          if(lnsq)call error(idnode,426)
+          
+c     specify molecular species
+          
+        elseif(findstring('molecu',record,idum))then
+          
+c     number of molecular types
+          
+          if(lmols)call error(idnode,11)
+          lmols=.true.
+          ntpmls=intstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(/,/,1x,'number of molecular types',6x,i10)")
+     x      ntpmls
+          
+          if(ntpmls.gt.mxtmls)call error(idnode,10)
+          
+c     initialise total system charge
+          
+          sumchg=0.d0
+          
+c     read in molecular characteristics
+          
+          do itmols=1,ntpmls
+            
+            if(idnode.eq.0)
+     x        write(nrite,"(/,1x,'molecular species type',9x,i10)")
+     x        itmols
+            
+c     name of molecular species
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abort_field_read(1,idnode,nfield)
+            
+            call copystring(record,molnam(1,itmols),40)
+            if(idnode.eq.0)
+     x        write(nrite,"(/,/,1x,'name of species:',13x,40a1)")
+     x        (molnam(i,itmols),i=1,40)
+            
+c     stop processing if energy unit has not been specified
+            
+            if(.not.lunits)call error(idnode,6)
+            
+c     read molecular data
+            
+            loop2=.true.
+            
+            do while(loop2)
+              
+              call getrec(safe,idnode,nfield)
+              if(.not.safe)call abort_field_read(1,idnode,nfield)
+              
+              call lowcase(record,lenrec)
+              call strip(record,lenrec)
+              
+              ksite=0
+              
+              if(findstring('nummol',record,idum))then
+                
+                nummols(itmols)=intstr(record,lenrec,idum)
+                if(idnode.eq.0)
+     x            write(nrite,"(/,1x,'number of molecules  ',
+     x            10x,i10)")nummols(itmols)
+                
+              elseif(findstring('atoms',record,idum))then
+                
+c     read in atomic details
+                
+                call define_atoms
+     x            (safe,lneut,idnode,itmols,nsite,ksite,ntpatm)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read core - shell spring parameters
+                
+              elseif(findstring('shell',record,idum))then
+                
+                lshl=.true.
+                call define_core_shell
+     x            (safe,idnode,itmols,nshels,nsite,keyshl,
+     x            engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read chemical bond force constant and bondlength
+                
+              elseif(findstring('bonds',record,idum))then
+                
+                call define_bonds
+     x            (safe,idnode,itmols,nbonds,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read bond atom indices and constraint bondlength
+                
+              elseif(findstring('constr',record,idum))then
+                
+                call define_constraints
+     x            (safe,lghost,idnode,itmols,nconst,nsite,natmsr)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read pmf bond atom indices, weights and constraint bondlength
+                
+              elseif(findstring('pmf',record,idum))then
+                
+                if(lpmf)call error(idnode,484)
+                lpmf=.true.
+                call define_pmf(safe,idnode,itmols,nspmf)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read intramolecular angular potential parameters
+                
+              elseif(findstring('angles',record,idum))then
+                
+                call define_angles
+     x            (safe,idnode,itmols,nangle,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read intramolecular dihedral potential parameters
+                
+              elseif(findstring('dihedr',record,idum))then
+                
+                call define_dihedrals
+     x            (safe,idnode,itmols,ndihed,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read intramolecular inversion potential parameters
+                
+              elseif(findstring('invers',record,idum))then
+                
+                call define_inversions
+     x            (safe,idnode,itmols,ninver,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read rigid body data
+                
+              elseif(findstring('rigid',record,idum))then
+                
+                call define_rigid_body
+     x            (safe,lghost,idnode,itmols,ngrp,natmsr)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read tethered atom indices and tethering parameters
+                
+              elseif(findstring('teth',record,idum))then
+                
+                call define_tethers
+     x            (safe,idnode,itmols,nteth,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     finish of data for one molecular type
+                
+              elseif(findstring('finish',record,idum))then
+                
+c     running total of number of atoms in system
+                
+                natms=natms+nummols(itmols)*numsit(itmols)
+                if(natms.gt.mxatms)call error(idnode,75)
+                
+c     check core-shell units are not both in same rigid body unit
+                
+                call check_shells(idnode,itmols,nshels,ngrp)
+                
+                loop2=.false.
+                
+              else
+                
+c     error exit for unidentified directive in molecular data
+                
+                if(idnode.eq.0)write(nrite,'(12x,a)')record
+                call error(idnode,12)
+                
+              endif
+              
+            enddo
+            
+c     construction of atmolt table for solvation calculation
+            
+            if(lsolva)then
+              
+              do iatm=natmsr+1,natms
+                atmolt(iatm)=itmols
+              enddo
+              natmsr=natms
+              
+            endif
+            
+          enddo
+          
+c     construction of atm_fre table for free energy or excitation
+          
+          if(lfree.or.lexcite.or.lswitch)then
+            
+            atm_fre(:)=0
+            if((ind_fre(1).ne.0).and.(ind_fre(2).ne.0))then
+              
+              do iatm=ind_fre(1),ind_fre(2)
+                atm_fre(iatm)=1
+              enddo
+              
+            endif
+            
+            if((ind_fre(3).ne.0).and.(ind_fre(4).ne.0))then
+              
+              do iatm=ind_fre(3),ind_fre(4)
+                
+                atm_fre(iatm)=2
+                if(lghost)ntghost=ntghost+1
+                
+              enddo
+              
+            endif
+            
+          endif
+          
+c     calculate system charge
+          
+          call check_syschg(idnode,ntpmls,sumchg)
+          
+c     read in the nonbonded potential energy parameters
+          
+        elseif(findstring('vdw',record,idum))then
+          
+          call define_van_der_waals
+     x      (safe,ltable,lunits,lmols,idnode,ntpvdw,
+     x      ntpatm,keyfce,dlrpot,rvdw,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read in the metal potential energy parameters
+          
+        elseif(findstring('met',record,idum))then
+          
+          call define_metals
+     x      (safe,lunits,lmols,idnode,ntpmet,ntpatm,rvdw,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read the three body potential energy parameters
+          
+        elseif(findstring('tbp',record,idum))then
+          
+          call define_three_body
+     x      (safe,lunits,lmols,idnode,ntptbp,ntpatm,rcuttb,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read the tersoff potential energy parameters
+          
+        elseif(findstring('tersoff',record,idum))then
+          
+          call define_tersoff
+     x      (safe,lunits,lmols,idnode,ntpter,ntpatm,rctter,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read in the four body potential energy parameters
+          
+        elseif(findstring('fbp',record,idum))then
+          
+          call define_four_body
+     x      (safe,lunits,lmols,idnode,ntpfbp,ntpatm,
+     x      rcutfb,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read external field data
+          
+        elseif(findstring('extern',record,idum))then
+          
+          call define_external_field
+     x      (safe,lunits,idnode,keyfld,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     normal end of FIELD file
+          
+        elseif(findstring('close',record,idum))then
+          
+          loop1=.false.
+          if(ntpvdw.eq.0.and.ntpmet.eq.0.and.
+     x      mod(keyfce,2).eq.1)call error(idnode,145)
+          
+c     error exit for unidentified directive
+          
+        else
+          
+          if(idnode.eq.0)write(nrite,'(100a)')record
+          call abort_field_read(2,idnode,nfield)
+          
+        endif
+        
+      enddo
+      
+c     close force field file
+      
+      if(idnode.eq.0)close (nfield)
+      
+      
+      if(lshl.and.idnode.eq.0)then
+        
+        if(keyshl.eq.1)write(nrite,
+     x    "(/,/,'adiabatic shell model in operation')")
+        
+        if(keyshl.eq.2)write(nrite,
+     x    "(/,/,'relaxed shell model in operation')")
+        
+      endif
+      
+      if(lshl.and.keyshl.eq.0)call error(idnode,1951)
+      
+c     if metadynamics and shell selected use only velocity verlet
+      
+      if(lshl.and.lmetadyn.and.keyver.eq.0)then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'switching to velocity verlet for metadynamics')")
+        keyver=1
+        
+      endif
+
+      return
+      end subroutine sysdef
+      
+      subroutine sysgen
+     x  (loglnk,lneut,nolink,lfree,lfrmas,idnode,imcon,keyens,
+     x  keyfce,keyres,levcfg,multt,mxnode,ntpmls,delr,rcut,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading the configuration data file
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 atname(8)
+      
+      logical loglnk,safe,lneut,nolink,lfree,lfrmas
+      integer idnode,imcon,keyens,keyfce,keyres,levcfg,multt
+      integer ntpmls,i,indatm,indnam,indneu,k,ilx,ily,ilz
+      integer m,l,ncells,idum,mxnode
+      real(8) delr,rcut,volm,xcoord,ycoord,zcoord,totmas,xveloc
+      real(8) yveloc,zveloc,xforce,yforce,zforce,axx,rt3,xhi,yhi,zhi
+      real(8) width,dum1,dum2,test,com(3)
+      
+c     open the system input file
+      
+      if(idnode.eq.0)open (nconf,file='CONFIG')
+      
+c     read the CONFIG file header
+      
+      call getrec(safe,idnode,nconf)
+      if(.not.safe)call abort_config_read(1,idnode,nconf)
+      
+      call copystring(record,cfgname,80)
+      if(idnode.eq.0)write(nrite,
+     x  "(/,1x,'configuration file name: ',/,/,10x,80a1)")cfgname
+      
+      call getrec(safe,idnode,nconf)
+      if(.not.safe)call abort_config_read(1,idnode,nconf)
+      
+      levcfg=intstr(record,lenrec,idum)
+      imcon=intstr(record,lenrec,idum)
+      if(idnode.eq.0)write(nrite,
+     x  "(/,/,1x,'selected image convention',6x,i10)")imcon
+      
+c     check config file contents for consistent data
+      
+      if((imcon.eq.0.or.imcon.eq.6).and.
+     x  (keyfce/2.eq.1.or.keyfce/2.eq.6))
+     x  call error(idnode,180)
+      
+      if(imcon.eq.0.and.(.not.lneut).and.(keyfce.gt.1)
+     x  .and.(multt.eq.1))call warning(idnode,30,0.d0,0.d0,0.d0)
+      
+      if(imcon.eq.0.and.(keyens.ge.4.and.keyens.le.7))
+     x  call error(idnode,390)
+      if(imcon.le.2.and.(keyens.eq.6.or.keyens.eq.7))imcon=3
+      if(keyres.gt.0.and.levcfg.lt.1)call error(idnode,85)
+      
+c     specify molecular dynamics simulation cell
+      
+      if(imcon.eq.0)then
+        
+c     if no periodic boundaries - set zero values for cell 
+c     vectors and cell volume
+        
+        cell(:)=0.d0
+        volm=0.d0
+        
+      else
+        
+c     read cell vectors
+        
+        call getrec(safe,idnode,nconf)
+        if(.not.safe)call abort_config_read(1,idnode,nconf)
+        cell(1)=dblstr(record,lenrec,idum)
+        cell(2)=dblstr(record,lenrec,idum)
+        cell(3)=dblstr(record,lenrec,idum)
+        call getrec(safe,idnode,nconf)
+        if(.not.safe)call abort_config_read(1,idnode,nconf)
+        cell(4)=dblstr(record,lenrec,idum)
+        cell(5)=dblstr(record,lenrec,idum)
+        cell(6)=dblstr(record,lenrec,idum)
+        call getrec(safe,idnode,nconf)
+        if(.not.safe)call abort_config_read(1,idnode,nconf)
+        cell(7)=dblstr(record,lenrec,idum)
+        cell(8)=dblstr(record,lenrec,idum)
+        cell(9)=dblstr(record,lenrec,idum)
+        
+      endif
+      
+c     read the atomic coordinates
+      
+      indatm=0
+      indnam=0
+      indneu=0
+      safe=.true.
+      
+      do k=1,ntpmls
+        
+        do l=1,nummols(k)
+          
+          do m=1,numsit(k)
+            
+            indatm=indatm+1
+            
+            if(indatm.gt.mxatms)call error(idnode,45)
+            
+            xxx(indatm)=0.d0
+            yyy(indatm)=0.d0
+            zzz(indatm)=0.d0
+            vxx(indatm)=0.d0
+            vyy(indatm)=0.d0
+            vzz(indatm)=0.d0
+            fxx(indatm)=0.d0
+            fyy(indatm)=0.d0
+            fzz(indatm)=0.d0
+            
+            if(idnode.eq.0)then
+              
+              if(levcfg.eq.0)then
+                
+                read(nconf,'(8a1)',end=100)atname
+                read(nconf,'(3f20.0)',end=100)xcoord,ycoord,zcoord
+                
+              elseif(levcfg.eq.1)then
+                
+                read(nconf,'(8a1)',end=100)atname
+                read(nconf,'(3f20.0)',end=100)xcoord,ycoord,zcoord
+                read(nconf,'(3f20.0)',end=100)xveloc,yveloc,zveloc
+                
+              else
+                
+                read(nconf,'(8a1)',end=100)atname
+                read(nconf,'(3f20.0)',end=100)xcoord,ycoord,zcoord
+                read(nconf,'(3f20.0)',end=100)xveloc,yveloc,zveloc
+                read(nconf,'(3f20.0)',end=100)xforce,yforce,zforce
+                
+              endif
+              
+c     strip blanks off atom name
+              
+              call strip(atname,8)
+              
+              if(sitnam(indnam+m).eq.mkwd8(atname))then
+                
+                xxx(indatm)=xcoord
+                yyy(indatm)=ycoord
+                zzz(indatm)=zcoord
+                
+                if(levcfg.gt.0)then
+                  
+                  vxx(indatm)=xveloc
+                  vyy(indatm)=yveloc
+                  vzz(indatm)=zveloc
+                  
+                endif
+                
+                if(levcfg.gt.1)then
+                  
+                  fxx(indatm)=xforce
+                  fyy(indatm)=yforce
+                  fzz(indatm)=zforce
+                  
+                endif
+                
+              else
+                
+                write(nrite,"(/,/,'unidentified atom label :',8a1,
+     x            ': atom number ',i5)")atname,indatm
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+            call gstate(safe)
+            if(.not.safe)call error(idnode,25)
+            
+            ltype(indatm)=ltpsit(indnam+m)
+            weight(indatm)=wgtsit(indnam+m)
+            chge(indatm)=chgsit(indnam+m)
+            atmnam(indatm)=sitnam(indnam+m)
+            lstfrz(indatm)=lfzsit(indnam+m)
+            if(lneut)lstneu(indatm)=nugrp(indnam+m)+indneu
+            
+c     reset atomic masses according to free energy definitions
+            
+            if(lfree)then
+
+              weight_sav(indatm)=weight(indatm)
+              
+              if(lfrmas)then
+                
+                if(indatm.ge.ind_fre(1).and.indatm.le.ind_fre(2))then
+                  weight(indatm)=lambda1*weight(indatm)
+                elseif(indatm.ge.ind_fre(3).and.indatm.le.ind_fre(4))
+     x              then
+                  weight(indatm)=lambda2*weight(indatm)
+                endif
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          indneu=indneu+nugrp(indnam+numsit(k))
+          
+        enddo
+        
+        indnam=indnam+numsit(k)
+        
+      enddo
+      
+      if(mxnode.gt.1)then
+        
+        call gdsum(xxx,indatm,buffer)
+        call gdsum(yyy,indatm,buffer)
+        call gdsum(zzz,indatm,buffer)
+        
+        if(levcfg.gt.0)then
+          
+          call gdsum(vxx,indatm,buffer)
+          call gdsum(vyy,indatm,buffer)
+          call gdsum(vzz,indatm,buffer)
+          
+        endif
+        
+        if(levcfg.gt.1)then
+          
+          call gdsum(fxx,indatm,buffer)
+          call gdsum(fyy,indatm,buffer)
+          call gdsum(fzz,indatm,buffer)
+          
+        endif
+        
+      endif
+      
+c     check integrity of cell vectors : for cubic, TO and RD cases
+c     ie. cell(1)=cell(5)=cell(9) (or cell(9)/sqrt(2) for RD)
+      
+      if((imcon.eq.1).or.(imcon.eq.4).or.(imcon.eq.5))then
+        
+        axx=(abs(cell(1))+abs(cell(5)))/2.d0
+        test=1.d-8*axx
+        if(abs(cell(1)-axx).gt.test)call error(idnode,410)
+        if(abs(cell(5)-axx).gt.test)call error(idnode,410)
+        if(imcon.eq.5)then
+          if(abs(cell(9)-axx*sqrt(2.d0)).gt.test)
+     x      call error(idnode,410)
+        else
+          if(abs(cell(9)-axx).gt.test)call error(idnode,410)
+        endif
+        
+      endif
+      
+c     check integrity of hexagonal prism cell vectors
+      
+      if(imcon.eq.7)then
+        
+        rt3=sqrt(3.d0)
+        if(abs(cell(1)-rt3*cell(5)).ge.1.d-6)
+     x    call error(idnode,410)
+        
+      endif
+      
+c     check 2D PBC for imcon=6
+      
+      if(imcon.eq.6)then
+        
+        if(abs(cell(3)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(6)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(7)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(8)).gt.1.d-10)call error(idnode,410)
+        
+      endif
+      
+c     check for diagonal cell matrix if appropriate
+      
+      if((imcon.eq.1).or.(imcon.eq.2).or.(imcon.eq.4).or.
+     x  (imcon.eq.5).or.(imcon.eq.7))then
+        
+        if(abs(cell(2)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(3)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(4)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(6)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(7)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(8)).gt.1.d-10)call error(idnode,410)
+        
+      endif
+      
+c     put centre of mass at centre of coordinates if imcon=0
+      
+      if(imcon.eq.0)then
+        
+        totmas=getmass(indatm,idnode,mxnode)
+        call getcom(indatm,idnode,mxnode,totmas,com)
+        
+        do i=1,indatm
+          
+          xxx(i)=xxx(i)-com(1)
+          yyy(i)=yyy(i)-com(2)
+          zzz(i)=zzz(i)-com(3)
+          
+        enddo
+        
+      endif
+      
+c     set widths if unset - needed for check on link cells below
+      
+      if(imcon.eq.0.or.imcon.eq.6)then
+        
+        xhi=abs(xxx(1))
+        yhi=abs(yyy(1))
+        zhi=abs(zzz(1))
+        do i=2,indatm
+          
+          xhi=max(xhi,abs(xxx(i)))
+          yhi=max(yhi,abs(yyy(i)))
+          zhi=max(zhi,abs(zzz(i)))
+          
+        enddo
+        if(imcon.eq.0)then
+          
+          cell(1)=max(2.d0*xhi+rcut+delr,3.d0*(rcut+delr))
+          cell(5)=max(2.d0*yhi+rcut+delr,3.d0*(rcut+delr))
+          cell(9)=max(2.d0*zhi+rcut+delr,3.d0*(rcut+delr))
+          
+        endif
+        
+        if(imcon.eq.6.and.cell(9).lt.1.d-6)then
+          
+          cell(9)=max(2.d0*zhi+rcut+delr,3.d0*(rcut+delr))
+          
+        endif
+        
+      endif
+      
+c     calculate dimensional properties of simulation cell
+      
+      call dcell(cell,celprp)
+      
+      if(imcon.eq.0)then
+        
+        volm=0.d0
+        
+      elseif(imcon.eq.4)then
+        
+        volm=0.5d0*celprp(10)
+        
+      elseif(imcon.eq.5)then
+        
+        volm=0.5d0*celprp(10)
+        
+      elseif(imcon.eq.7)then
+        
+        volm=0.5d0*celprp(10)
+        
+      else
+        
+        volm=celprp(10)
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,"(/,/,1x,'simulation cell vectors'/,/)")
+        write(nrite,"(21x,3f12.6)")cell
+        
+        write(nrite,
+     x    "(/,/,1x,'system volume     ',2x,1p,g22.12)")volm
+        
+      endif
+      
+c     check value of cutoff and reset if necessary
+      
+      if(imcon.gt.0)then
+        
+        width=min(celprp(7),celprp(8),celprp(9))/2.d0
+        if(imcon.eq.4)width=sqrt(3.d0)*cell(1)/4.d0
+        if(imcon.eq.5)width=cell(1)/2.d0
+        if(imcon.eq.6)width=min(celprp(7),celprp(8))/2.d0
+        
+c     halt program if potential cutoff exceeds cell width
+        
+        if(rcut.gt.width)call error(idnode,95)
+        
+      endif
+      
+c     decide on whether to use link cells for verlet list constructor
+      
+      if(nolink)then
+        
+        loglnk=.false.
+        
+      else
+        
+        loglnk=.true.
+        
+        ilx=int(celprp(7)/(rcut+delr))
+        ily=int(celprp(8)/(rcut+delr))
+        ilz=int(celprp(9)/(rcut+delr))
+        if(ilx.lt.3.or.ily.lt.3.or.ilz.lt.3)loglnk=.false.
+        ncells=ilx*ily*ilz
+        if(lneut.and.ncells.le.36)loglnk=.false.
+        if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)loglnk=.false.
+        if(loglnk.and.ncells.gt.mxcell)then
+          
+          dum1=dble(ncells)
+          dum2=dble(mxcell)
+          call warning(idnode,90,dum1,dum2,dum2)
+          loglnk=.false.
+          
+        endif
+        
+      endif
+      
+      if(loglnk.and.idnode.eq.0)
+     x  write(nrite,"(/,/,' link cell algorithm in use')")
+      
+      if(idnode.eq.0)close (nconf)
+      
+c     ensure PBC compliance of starting structure
+      
+      if(keyres.eq.0.and.imcon.gt.0)then
+        
+        call images(imcon,idnode,mxnode,indatm,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,indatm,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+      return
+      
+c     error exit for config file read
+      
+  100 call abort_config_read(2,idnode,nconf)
+      
+      end subroutine sysgen
+      
+      subroutine sysinit
+     x  (lgofr,lzden,lsolva,lfree,lghost,lpsoc,idnode,imcon,keyfce,
+     x  keyres,mxnode,natms,ntshl,nstep,numacc,numrdf,ntpatm,
+     x  ntpmet,ntpvdw,nzden,chip,chit,conint,elrc,engunit,virlrc,
+     x  rvdw,volm,virtot,vircom,tboost,chit_shl)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading the REVIVE file data and 
+c     defining the initial thermodynamic and structural accumulators.
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     adapted   - d. quigley nov 2010, metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lgofr,lzden,lfree,lsolva,lghost,lpsoc
+      integer idnode,imcon,keyfce,keyres,mxnode,natms,nstep,numacc
+      integer numrdf,ntpatm,nzden,i,j,k,ntpmet,ntshl,ntpvdw
+      real(8) chip,chit,conint,elrc,engunit,virlrc,rvdw,volm
+      real(8) dnumrd,dnstep,dnumac,dnzden,virtot,vircom,tboost
+      real(8) chit_shl
+      
+c     read or initialise accumulator arrays
+      
+      if(keyres.eq.1.and.idnode.eq.0)then
+        
+c     read accumulator data from dump file
+        
+        open(nrest,file='REVOLD',form='unformatted')
+        
+        read(nrest) dnstep,dnumac,dnumrd,chit,chip,conint,dnzden,
+     x    tboost,chit_shl
+        read(nrest) virtot,vircom,eta,strcns,strbod
+        read(nrest) stpval
+        read(nrest) sumval
+        read(nrest) ssqval
+        read(nrest) zumval
+        read(nrest) ravval
+        read(nrest) stkval
+        read(nrest) xx0,yy0,zz0
+        read(nrest) xxs,yys,zzs
+        
+        if(lgofr) read(nrest)rdf
+        if(lzden) read(nrest)zdens
+        
+        nstep=nint(dnstep)
+        numacc=nint(dnumac)
+        numrdf=nint(dnumrd)
+        nzden=nint(dnzden)
+        close (nrest)
+        
+      else
+         
+c     initialise step counters
+        
+        nstep=0
+        numacc=0
+        numrdf=0
+        nzden=0
+        
+c     initialise temperature and pressure coupling parameters
+c     and integral for conserved quantity
+        
+        chit=0.d0
+        chip=0.d0
+        conint=0.d0
+        virtot=0.d0
+        vircom=0.d0
+        chit_shl=0.d0
+        do i=1,9
+          
+          eta(i)=0.d0
+          strcns(i)=0.d0
+          strbod(i)=0.d0
+          
+        enddo
+        
+c     initialise accumulator arrays
+        
+        do i=1,mxnstk
+          
+          stpval(i)=0.d0
+          sumval(i)=0.d0
+          ssqval(i)=0.d0
+          zumval(i)=0.d0
+          ravval(i)=0.d0
+          
+        enddo
+        
+        do i=1,mxatms
+          
+          xx0(i)=0.d0
+          yy0(i)=0.d0
+          zz0(i)=0.d0
+          xxs(i)=0.d0
+          yys(i)=0.d0
+          zzs(i)=0.d0
+          
+        enddo
+        
+        do j=1,mxnstk
+          
+          do i=1,mxstak
+            
+            stkval(i,j)=0.d0
+            
+          enddo
+          
+        enddo
+        
+        if(lgofr)then
+          
+          do i=1,mxxtyp
+            
+            do j=1,mxrdf
+              
+              rdf(j,i)=0.d0
+              
+            enddo
+            
+          enddo
+          
+        endif
+        
+        if(lzden)then
+          
+          do i=1,mxatyp
+            
+            do j=1,mxzdn
+              zdens(j,i)=0.d0
+            enddo
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     put shells on cores at start
+      
+      if(lpsoc.and.keyres.ne.1.and.ntshl.gt.0)
+     x  call put_shells_on_cores(idnode,mxnode,ntshl)
+      
+c     if restart then broadcast stored variables via a global sum
+      
+      if(keyres.eq.1.and.mxnode.gt.1)then
+        
+        if(mxbuff.lt.natms.or.mxbuff.lt.mxnstk*mxstak)
+     x    call error(idnode,186)
+        
+        buffer(1)=chit
+        buffer(2)=chip
+        buffer(3)=conint
+        buffer(4)=dble(nstep)
+        buffer(5)=dble(numacc)
+        buffer(6)=dble(numrdf)
+        buffer(7)=dble(nzden)
+        buffer(8)=tboost
+        buffer(9)=virtot
+        buffer(10)=vircom
+        buffer(11)=chit_shl
+        call gdsum(buffer(1),11,buffer(12))
+        chit=buffer(1)
+        chip=buffer(2)
+        conint=buffer(3)
+        nstep=nint(buffer(4))
+        numacc=nint(buffer(5))
+        numrdf=nint(buffer(6))
+        nzden=nint(buffer(7))
+        tboost=buffer(8)
+        virtot=buffer(9)
+        vircom=buffer(10)
+        chit_shl=buffer(11)
+        
+        call gdsum(eta,9,buffer)
+        call gdsum(strcns,9,buffer)
+        call gdsum(strbod,9,buffer)
+        call gdsum(stpval,mxnstk,buffer)
+        call gdsum(sumval,mxnstk,buffer)
+        call gdsum(ssqval,mxnstk,buffer)
+        call gdsum(zumval,mxnstk,buffer)
+        call gdsum(ravval,mxnstk,buffer)    
+        call gdsum(stkval,mxnstk*mxstak,buffer)
+        call gdsum(xx0,natms,buffer)
+        call gdsum(yy0,natms,buffer)
+        call gdsum(zz0,natms,buffer)
+        call gdsum(xxs,natms,buffer)
+        call gdsum(yys,natms,buffer)
+        call gdsum(zzs,natms,buffer)
+        
+c     for rdf table - broadcast and normalise
+        
+        if(lgofr)then
+          
+          do k=1,mxxtyp
+            
+            call gdsum(rdf(1,k),mxrdf,buffer)
+            
+            do j=1,mxrdf
+              rdf(j,k)=rdf(j,k)/dble(mxnode)
+            enddo
+            
+          enddo
+          
+        endif
+        
+        if(lzden)then
+          
+          do k=1,mxatyp
+            
+            call gdsum(zdens(1,k),mxzdn,buffer)
+            
+            do j=1,mxzdn
+              zdens(j,k)=zdens(j,k)/dble(mxnode)
+            enddo
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     number densities and long-range corrections
+      
+      elrc=0.d0       
+      virlrc=0.d0
+      
+      if(imcon.eq.0.or.imcon.eq.6)volm=4.d0*pi/3.d0*rvdw**3
+      
+      call lrcorrect
+     x  (lsolva,lfree,lghost,idnode,imcon,keyfce,natms,
+     x  ntpatm,ntpvdw,elrc,engunit,virlrc,rvdw,volm)
+      
+      if(lmetab.or.ntpmet.eq.0)then
+        
+        elrcm(0)=0.d0
+        vlrcm(0)=0.d0
+        
+      else 
+        
+        call lrcmetal
+     x    (idnode,imcon,natms,ntpatm,engunit,rvdw,volm)
+        
+      endif
+      
+      if(imcon.eq.0.or.imcon.eq.6)volm=0.d0
+      
+      return
+      end subroutine sysinit
+      
+      subroutine systemp
+     x  (idnode,imcon,keyres,mxnode,natms,ngrp,nscons,ntcons,
+     x  ntfree,ntshl,levcfg,keyshl,degfre,degshl,degrot,temp,
+     x  tolnce)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for setting the initial system temperature
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idnode,imcon,keyres,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,ntshl,levcfg,i,io,k,keyshl
+      real(8) degfre,degshl,degrot,temp,tolnce,sigma,rsq
+      
+c     number of degrees of freedom 
+c     3 for com translation
+c     3 for angular momentum about origin (non-periodic systems only)
+      
+      degfre=dble(3*(ntfree-ntshl)-3-ntcons)+degfre
+      if(imcon.eq.0.or.imcon.eq.6)degfre=degfre-3.0d0
+      if(imcon.eq.0.or.imcon.eq.6)degrot=max(0.d0,degrot-3.0d0)
+      degshl=dble(3*ntshl)
+      
+c     lose one degree of freedom if temperature constrained
+c     gaussian constraints
+      
+c     if(keyens.eq.1)degfre=degfre-1.d0
+      
+      if(idnode.eq.0)
+     x  write(nrite,"(/,/,' total degrees of freedom       ',f20.0,/,
+     x  ' rotational degrees of freedom  ',f20.0,/,
+     x  ' shell pseudo degrees of freedom',f20.0)")
+     x  degfre,degrot,degshl
+      if(degfre.lt.1.d0)call error(idnode,350)
+      
+c     define reciprocal masses of atoms
+      
+      do i=1,natms
+        
+        if(lstfrz(i).ne.0.or.weight(i).lt.1.d-6)then
+          
+          rmass(i)=0.d0
+          weight(i)=0.d0
+          
+        else
+          
+          rmass(i)=1.d0/weight(i)
+          
+        endif
+        
+      enddo
+      
+c     generate starting velocities
+      
+      sigma=temp*boltz*degfre*0.5d0
+      
+      if(keyres.eq.0)then
+        
+        call gauss(natms,vxx,vyy,vzz)
+        
+        do i=1,natms
+          
+          rsq=sqrt(rmass(i))
+          vxx(i)=vxx(i)*rsq
+          vyy(i)=vyy(i)*rsq
+          vzz(i)=vzz(i)*rsq
+          
+        enddo
+        
+        if(ntcons.gt.0)call quench
+     x    (imcon,idnode,mxnode,natms,nscons,tolnce)
+        
+        if(ngrp.gt.0)call quatqnch(idnode,imcon,mxnode,natms,ngrp)
+        
+        if(keyshl.eq.1)then
+          
+          do k=1,4
+            
+            call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+            call shlqnch(idnode,mxnode,ntshl,temp)
+            
+          enddo
+          
+        else
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        endif
+        
+      elseif(keyres.eq.1.or.keyres.eq.3)then 
+        
+        if(ngrp.gt.0)call quatqnch(idnode,imcon,mxnode,natms,ngrp)
+        
+      elseif(keyres.eq.2)then
+        
+        if(ngrp.gt.0)then 
+          
+          call vscaleg
+     x      (idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        elseif(keyshl.eq.1)then
+          
+          do k=1,4
+            
+            call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+            call shlqnch(idnode,mxnode,ntshl,temp)
+            
+          enddo
+          
+        else
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        endif
+        
+      endif
+      
+c     print out sample of initial configuration 
+      
+      if(idnode.eq.0)write(nrite,
+     x  "(/,/,1x,'sample of starting configuration',/)")
+      
+      io=(natms+19)/20
+      if((levcfg.le.1).and.(idnode.eq.0))
+     x  write(nrite,"(6x,'i',7x,'x(i)',8x,'y(i)',8x,'z(i)',
+     x  7x,'vx(i)',7x,'vy(i)',7x,'vz(i)',/,/)")
+      if((levcfg.eq.2).and.(idnode.eq.0))
+     x  write(nrite,"(6x,'i',7x,'x(i)',8x,'y(i)',8x,'z(i)',
+     x  7x,'vx(i)',7x,'vy(i)',7x,'vz(i)',
+     x  7x,'fx(i)',7x,'fy(i)',7x,'fz(i)',/,/)")
+      
+      do i=1,natms,io
+        
+        if(levcfg.le.1)then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(1x,i6,1p,3e12.4,3e12.4,3e12.4)")
+     x      i,xxx(i),yyy(i),zzz(i),vxx(i),vyy(i),vzz(i)
+          
+        elseif(levcfg.eq.2)then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(1x,i6,1p,3e12.4,3e12.4,3e12.4)")
+     x      i,xxx(i),yyy(i),zzz(i),
+     x      vxx(i),vyy(i),vzz(i),fxx(i),fyy(i),fzz(i)
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine systemp
+      
+      subroutine sysbook
+     x  (loglnk,lneut,lshmov,lcnb,lsolva,lghost,idnode,imcon,
+     x  mxnode,natms,nneut,ngrp,nscons,ntangl,ntbond,ntcons,
+     x  ntdihd,ntinv,ntpmls,ntpmf,nspmf,ntfree,ntteth,ntshl,
+     x  ntghost,degfre,degrot)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine  defining global bookkeeping
+c     arrays
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical loglnk,lneut,lshmov,lcnb,lsolva,lghost
+      integer idnode,imcon,mxnode,natms,nneut,ngrp,nscons,ntangl,i
+      integer ntbond,ntcons,ntdihd,ntinv,ntpmls,ntpmf,nspmf,ntfree
+      integer ntteth,ntshl,ii,isol,itmols,igsol,iggsol,natmsf,natmsl
+      integer ntghost,natms2
+      real(8) degfre,degrot
+      
+c     if excitation calculation, allow for ghost species
+      
+      if(lghost)then
+        natms2=natms-ntghost
+      else
+        natms2=natms
+      endif
+      
+c     neutral group bookkeeping
+      
+      call neutbook(lneut,idnode,natms,nneut)
+      
+c     rigid body bookkeeping 
+      
+      call quatbook
+     x  (lsolva,idnode,imcon,mxnode,natms2,ngrp,ntpmls,
+     x  ntfree,degfre,degrot)
+      
+c     if excitation calculation, allow for ghost species
+      
+      if(lghost)then
+        
+        numcon(mxtmls)=numcon(mxtmls)+ntcons_ghost
+        numgrp(mxtmls)=numgrp(mxtmls)+ngrp_ghost
+        
+      endif
+      
+c     construct list of excluded pair interactions
+      
+      if(lneut)then
+ 
+        call exclude(idnode,mxnode,natms,ntpmls)
+        call excludeneu(idnode,mxnode,nneut)
+        
+      elseif(.not.lneut)then
+        
+        call exclude(idnode,mxnode,natms,ntpmls)
+        
+        if(loglnk)then
+          
+          call exclude_link(idnode,mxnode,ntpmls)
+          
+        else
+          
+          call exclude_atom(idnode,mxnode,natms,ntpmls)
+          
+        endif
+        
+      endif
+      
+c     if excitation calculation, allow for ghost species
+      
+      if(lghost)then
+        
+        numcon(mxtmls)=numcon(mxtmls)-ntcons_ghost
+        numgrp(mxtmls)=numgrp(mxtmls)-ngrp_ghost
+        
+      endif
+      
+c     construct interaction lists for bonded forces
+      
+      call intlist
+     x  (lshmov,lcnb,idnode,mxnode,natms2,nscons,ntangl,ntbond,
+     x  ntcons,ntdihd,ntinv,ntpmls,ntteth,ntshl,ntpmf,nspmf,ngrp)
+      
+c     adaptations for solvation and excitation simulations
+      
+      if(lsolva.or.lghost)then
+                
+        natmsf=0
+        natmsl=0
+        natm_sol(:)=0
+        const_sol(:)=numcon(:)*nummols(:)
+        rigid_sol(:)=numgrp(:)*nummols(:)
+        
+        if(ngrp.eq.0)then
+          
+          do itmols=1,mxtmls
+            
+            natmsl=natmsl+numsit(itmols)*nummols(itmols)
+            
+            do isol=natmsf+1,natmsl
+              
+              if(lstfrz(isol).eq.0)then
+                natm_sol(itmols)=natm_sol(itmols)+1
+              endif
+              
+            enddo
+            
+            natmsf=natmsl
+            
+          enddo
+
+        else
+          
+          ii=1
+          
+          do itmols=1,mxtmls
+            
+            natmsl=natmsl+numsit(itmols)*nummols(itmols)
+            
+            do isol=natmsf+1,natmsl
+              
+              if(lstgot_sol(ii).eq.isol)then
+                ii=ii+1
+              else
+                
+                if(lstfrz(isol).eq.0)then
+                  natm_sol(itmols)=natm_sol(itmols)+1
+                endif
+                
+              endif
+              
+            enddo
+            
+            natmsf=natmsl
+            
+          enddo
+          
+          degrot_sol(:)=degrot_sol(:)+dble(rigid_sol(:))*3.d0
+          degfre_sol(:)=degrot_sol(:)+dble(rigid_sol(:))*3.d0
+          
+        endif
+        
+        if(lghost)natm_sol(mxtmls)=natm_sol(mxtmls)-ntghost
+        degfre_sol(:)=dble(3*(natm_sol(:))-const_sol(:))+degfre_sol(:)
+        
+      endif
+      
+      return
+      end subroutine sysbook
+      
+      subroutine define_units(idnode,engunit)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting energy units
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith august 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idnode,idum,i
+      real(8) engunit
+      logical blank
+      
+      blank=.true.
+      
+      do i=6,lenrec
+        if(record(i).ne.' ')blank=.false.
+      enddo
+      
+      if(blank)then
+        
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=dl_poly internal ',
+     x    'units ')")
+        
+      elseif(findstring('ev',record,idum))then
+        
+        engunit=9648.530821d0
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=electron volts ')")
+        
+      elseif(findstring('kev',record,idum))then
+        
+        engunit=9648530.821d0
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kilo electron volts ')")
+        
+      elseif(findstring('kcal',record,idum))then
+        
+        engunit=418.4d0
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kcal/ mol ')")
+        
+      elseif(findstring('kj',record,idum))then
+        
+        engunit=1.d2
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kjoule/mol ')")
+        
+      elseif(findstring('k',record,idum))then
+        
+        engunit=boltz
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kelvin ')")
+        
+      elseif(findstring('internal',record,idum))then
+        
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=dl_poly internal',
+     x    ' units ')")
+        
+      else
+        
+        if(idnode.eq.0)write(nrite,'(a)')record
+        call error(idnode,5)
+        
+      endif
+      
+      return
+      end subroutine define_units
+      
+      subroutine quatbook
+     x  (lsolva,idnode,imcon,mxnode,natms,ngrp,ntpmls,ntfree,
+     x  degfre,degrot)
+      
+c**************************************************************************
+c     
+c     dl_poly subroutine for setting up bookkeeping for rigid bodies
+c     
+c     parallel replicated data version : block data
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c*************************************************************************
+      
+      implicit none
+      
+      logical safe,pass1,pass2,linear,lsolva
+      integer fail,idnode,imcon,mxnode,natms,ngrp,ntpmls,ntfree
+      integer i,igrp,jgrp,kgrp,jr,jt,igrp1,igrp2,itmols,imols,lgrp,id
+      integer ii,jj,isite,k,kk,ill,i1,i2,i3,j,ngp,ifre1,ifre2,ig,ij
+      integer fngrp,lngrp
+      real(8) degfre,degrot,dnorm,a1,rtall,rotall,rot,aa,rotinr,bb,rot1
+      real(8) rsq,det,dettest,aq,bq,cq,dq,eq,fq,gq,hq,rnorm,tol,rotxyz
+      real(8) rotlim,rrr
+      
+      integer, allocatable :: ind(:,:),lstgot(:)
+      real(8), allocatable :: gaxs(:,:),rotmin(:),accum(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      
+      dimension rot(9),aa(9),rotinr(3,3),bb(9),rot1(3,3),fail(5)
+      
+      data fail/0,0,0,0,0/
+      
+c     allocate working arrays
+      
+      allocate (ind(mxgrp,3),lstgot(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(3))
+      allocate (gaxs(mxungp,9),rotmin(mxungp),stat=fail(4))
+      allocate (accum(mxungp),stat=fail(5))
+      do i=1,5
+        if(fail(i).ne.0)call error(idnode,1790)
+      enddo
+      
+c     initialise bookkeeping indices
+      
+      igrp=0
+      jgrp=0
+      kgrp=0
+      isite=0
+      jr=0
+      jt=0
+      safe=.true.
+      degfre=0.d0
+      degrot=0.d0
+      
+c     rigid body identifier
+      
+      do i=1,natms
+        lstbod(i)=0
+      enddo
+      
+c     number of rigid groups in system
+      
+      ngrp=0
+      do itmols=1,ntpmls
+        ngrp=ngrp+nummols(itmols)*numgrp(itmols)
+      enddo
+      
+c     block indices for groups
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+      
+c     loop over molecule types
+      
+      do itmols=1,ntpmls
+        
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+          
+c     construct rigid body site list: each processor has a different copy
+          
+          do lgrp=1,numgrp(itmols)
+            
+            igrp=igrp+1
+            
+            if(igrp.le.mxgrp)then
+              
+              lstgtp(igrp)=listyp(lgrp+kgrp)
+              id=listyp(lgrp+kgrp)
+              
+              if((igrp.ge.igrp1).and.(igrp.le.igrp2))then
+                
+                jgrp=jgrp+1
+                
+                do jj=1,numgsit(id)
+                  
+                  jr=jr+1
+                  jt=jt+1
+                  
+                  if(jr.le.mxatms.and.jt.le.mxatms)then
+                    
+                    lstrgd(jr)=lstgst(id,jj)+isite
+                    lstgot(jt)=lstgst(id,jj)+isite
+                    lstbod(lstgst(id,jj)+isite)=igrp
+                    
+                  else
+                    
+                    safe=.false.
+                    
+                  endif
+                  
+                enddo
+                
+              else
+                
+                do jj=1,numgsit(id)
+                  
+                  jt=jt+1
+                  if(jt.le.mxatms)then
+                    
+                    lstgot(jt)=lstgst(id,jj)+isite
+                    lstbod(lstgst(id,jj)+isite)=igrp
+                    
+                  else
+                    
+                    safe=.false.
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            else
+              
+              safe=.false.
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,304)
+          isite=isite+numsit(itmols)
+          
+        enddo
+        
+        kgrp=kgrp+numgrp(itmols)
+        
+      enddo
+      
+      if(ngrp.eq.0)then
+        
+        j=0
+        do i=1,natms
+          
+          if(lstfrz(i).eq.0)then
+            
+            j=j+1
+            lstfre(j)=i
+            
+          endif
+          
+        enddo
+        ntfree=j
+        
+      else
+        
+c     centre of mass of groups
+c     assumes group dimensions are smaller than half box width
+        
+        do i=1,natms
+          lstme(i)=0
+        enddo
+        
+        do id=1,mxungp
+          gmass(id)=0.d0
+        enddo
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     working com is first site in group
+          
+          i=lstrgd(jr+1)
+          txx(ig)=xxx(i)
+          tyy(ig)=yyy(i)
+          tzz(ig)=zzz(i)
+          
+          id=lstgtp(ig)
+          safe=.false.
+          if(abs(gmass(id)).lt.1.d-10)safe=.true.
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            xxt(jr)=xxx(i)-txx(ig)
+            yyt(jr)=yyy(i)-tyy(ig)
+            zzt(jr)=zzz(i)-tzz(ig)
+            if(safe)gmass(id)=gmass(id)+weight(i)
+            
+          enddo
+          
+        enddo
+        
+c     minimum image from working com
+        
+        call images(imcon,0,1,jr,cell,xxt,yyt,zzt)
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          gcmx(ig)=0.d0
+          gcmy(ig)=0.d0
+          gcmz(ig)=0.d0
+          
+          id=lstgtp(ig)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            gcmx(ig)=gcmx(ig)+weight(i)*xxt(jr)
+            gcmy(ig)=gcmy(ig)+weight(i)*yyt(jr)
+            gcmz(ig)=gcmz(ig)+weight(i)*zzt(jr)
+            
+          enddo
+          
+          gcmx(ig)=gcmx(ig)/gmass(id)+txx(ig)
+          gcmy(ig)=gcmy(ig)/gmass(id)+tyy(ig)
+          gcmz(ig)=gcmz(ig)/gmass(id)+tzz(ig)
+          
+        enddo
+        
+c     global communications
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+c     make sure all nodes have same copy of gmass
+        
+        if(mxnode.gt.1)then
+          
+          do id=1,mxungp
+            
+            accum(id)=0.d0
+            if(gmass(id).gt.0.d0)accum(id)=1.d0
+            
+          enddo
+          
+          call gdsum(gmass(1),mxungp,buffer(1))
+          call gdsum(accum(1),mxungp,buffer(1))
+          
+          do id=1,mxungp
+            
+            dnorm=max(1.d0,accum(id))
+            gmass(id)=gmass(id)/dnorm
+            
+          enddo
+          
+        endif
+        
+c     find a group of each type on this node to 
+c     find principal axis system of the group type
+        
+        do id=1,mxungp
+          
+          jr=0
+          ij=0
+          safe=.false.
+          
+          do while(.not.safe.and.ij.lt.ngrp)
+            
+            ij=ij+1
+            jr=jr+numgsit(lstgtp(ij))
+            if(lstgtp(ij).eq.id)safe=.true.
+            
+          enddo
+          
+          if(safe)then
+
+c     rotational inertia accumulator
+            
+            do k=1,3
+              
+              do kk=1,3
+                
+                rotinr(k,kk)=0.d0
+                
+              enddo
+              
+            enddo
+            
+            jr=jr-numgsit(id)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstgot(jr)
+              
+              xxt(jr)=xxx(i)-gcmx(ij)
+              yyt(jr)=yyy(i)-gcmy(ij)
+              zzt(jr)=zzz(i)-gcmz(ij)
+              
+              call images(imcon,0,1,1,cell,xxt(jr),yyt(jr),zzt(jr))
+              
+              rotinr(1,1)=rotinr(1,1)+weight(i)*(xxt(jr)**2)
+              rotinr(1,2)=rotinr(1,2)+weight(i)*xxt(jr)*yyt(jr)
+              rotinr(1,3)=rotinr(1,3)+weight(i)*xxt(jr)*zzt(jr)
+              rotinr(2,2)=rotinr(2,2)+weight(i)*(yyt(jr)**2)
+              rotinr(2,3)=rotinr(2,3)+weight(i)*yyt(jr)*zzt(jr)
+              rotinr(3,3)=rotinr(3,3)+weight(i)*(zzt(jr)**2)
+              
+            enddo
+            
+            rotinr(2,1)=rotinr(1,2)
+            rotinr(3,1)=rotinr(1,3)
+            rotinr(3,2)=rotinr(2,3)
+            
+            call jacobi(rotinr,rot1,3)
+            
+            rot(1)=rot1(1,1)
+            rot(4)=rot1(2,1)
+            rot(7)=rot1(3,1)
+            rot(2)=rot1(1,2)
+            rot(5)=rot1(2,2)
+            rot(8)=rot1(3,2)
+            rot(3)=rot1(1,3)
+            rot(6)=rot1(2,3)
+            rot(9)=rot1(3,3)
+            
+c     rotational inertia accumulators
+            
+            rotinx(id,1)=0.d0
+            rotiny(id,1)=0.d0
+            rotinz(id,1)=0.d0
+            
+            jr=jr-numgsit(id)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstgot(jr)
+              
+c     site positions in principal axis system
+              
+              gxx(id,j)=rot(1)*xxt(jr)+rot(4)*yyt(jr)+rot(7)*zzt(jr)
+              gyy(id,j)=rot(2)*xxt(jr)+rot(5)*yyt(jr)+rot(8)*zzt(jr)
+              gzz(id,j)=rot(3)*xxt(jr)+rot(6)*yyt(jr)+rot(9)*zzt(jr)
+              
+c     impose rounding 
+              
+              if(abs(gxx(id,j)).lt.1.d-8)gxx(id,j)=0.d0
+              if(abs(gyy(id,j)).lt.1.d-8)gyy(id,j)=0.d0
+              if(abs(gzz(id,j)).lt.1.d-8)gzz(id,j)=0.d0
+              
+c     rotational inertia tensor of group type
+              
+              rotinx(id,1)=rotinx(id,1)+
+     x          weight(i)*(gyy(id,j)**2+gzz(id,j)**2)
+              rotiny(id,1)=rotiny(id,1)+
+     x          weight(i)*(gzz(id,j)**2+gxx(id,j)**2)
+              rotinz(id,1)=rotinz(id,1)+
+     x          weight(i)*(gxx(id,j)**2+gyy(id,j)**2)
+              
+            enddo
+            
+c     set axis system such that: Ixx >=Iyy >=Izz
+            
+            rotxyz=max(rotinx(id,1),rotiny(id,1),rotinz(id,1))
+            
+            if(rotxyz.ge.rotinx(id,1))then
+              
+              if(rotiny(id,1).ge.rotxyz)then
+                
+                do j=1,numgsit(id)
+                  
+                  a1=gxx(id,j)
+                  gxx(id,j)=gyy(id,j)
+                  gyy(id,j)=-a1
+                  
+                enddo
+                
+                rotiny(id,1)=rotinx(id,1)
+                rotinx(id,1)=rotxyz
+                
+              elseif(rotinz(id,1).ge.rotxyz)then
+                
+                do j=1,numgsit(id)
+                  
+                  a1=gxx(id,j)
+                  gxx(id,j)=gzz(id,j)
+                  gzz(id,j)=-a1
+                  
+                enddo
+                
+                rotinz(id,1)=rotinx(id,1)
+                rotinx(id,1)=rotxyz
+                
+              endif
+              
+            endif
+            
+            if(rotinz(id,1).gt.rotiny(id,1))then
+              
+              do j=1,numgsit(id)
+                
+                a1=gyy(id,j)
+                gyy(id,j)=gzz(id,j)
+                gzz(id,j)=-a1
+                
+              enddo
+              
+              a1=rotinz(id,1)
+              rotinz(id,1)=rotiny(id,1)
+              rotiny(id,1)=a1
+              
+            endif
+            
+c     set up principal axis system in terms of site positions
+            
+c     test for (near) linear unit
+            
+            ill=0
+            rtall=(rotinx(id,1)+rotiny(id,1)+rotinz(id,1))
+            
+            if(rtall.gt.1.d-5)then
+              rotall=rtall
+            else
+              rotall=1.d0
+            endif
+            
+            rotmin(id)=min(rotinx(id,1),rotiny(id,1))
+            rotmin(id)=min(rotmin(id),rotinz(id,1))/rotall
+            
+            if((rotinx(id,1)/rotall).lt.1.d-5)ill=ill+1
+            if((rotiny(id,1)/rotall).lt.1.d-5)ill=ill+1
+            if((rotinz(id,1)/rotall).lt.1.d-5)ill=ill+1
+            
+            if(ill.ge.2)then
+
+c     point particle only
+              
+              ind(id,1)=1
+              ind(id,2)=1
+              ind(id,3)=1
+              
+              do jj=1,9
+                gaxs(id,jj)=0.d0
+              enddo
+              
+            elseif(ill.eq.1)then
+              
+c     linear molecule
+              
+              ind(id,1)=1
+              ind(id,2)=2
+              ind(id,3)=1
+              
+              aa(1)=gxx(id,1)-gxx(id,2)
+              aa(4)=gyy(id,1)-gyy(id,2)
+              aa(7)=gzz(id,1)-gzz(id,2)
+              rsq=sqrt(aa(1)**2+aa(4)**2+aa(7)**2)
+              
+              if(abs(aa(7)/rsq).gt.0.5d0)then
+                
+                rsq=sqrt(aa(4)**2+aa(7)**2)
+                aa(2)=0.d0
+                aa(5)=aa(7)/rsq
+                aa(8)=-aa(4)/rsq
+                
+              elseif(abs(aa(4)/rsq).gt.0.5d0)then
+                
+                rsq=sqrt(aa(4)**2+aa(1)**2)
+                aa(2)=-aa(4)/rsq
+                aa(5)=aa(1)/rsq
+                aa(8)=0.d0
+                
+              elseif(abs(aa(1)/rsq).gt.0.5d0)then
+                
+                rsq=sqrt(aa(1)**2+aa(7)**2)
+                aa(2)=-aa(7)/rsq
+                aa(5)=0.d0
+                aa(8)=aa(1)/rsq
+                
+              endif
+              
+              aa(3)=aa(4)*aa(8)-aa(7)*aa(5)
+              aa(6)=aa(7)*aa(2)-aa(1)*aa(8)
+              aa(9)=aa(1)*aa(5)-aa(4)*aa(2)
+              
+              call invert(aa,bb,det)
+              
+              if(abs(det).lt.1.d-5)call error(idnode,306)
+              
+              do j=1,9
+                gaxs(id,j)=bb(j)
+              enddo
+              
+            elseif(ill.eq.0)then
+              
+c     non-linear molecule
+              
+              i1=1
+              i2=1
+              i3=1
+              pass1=.true.
+              dettest=1.d-1
+              
+              do while(pass1.and.i2.lt.numgsit(id)-1)
+                
+                i2=i2+1
+                i3=i2
+                pass2=.true.
+                
+                do while(pass2.and.i3.lt.numgsit(id))
+                  
+                  i3=i3+1
+                  
+                  aa(1)=gxx(id,i1)-gxx(id,i2)
+                  aa(4)=gyy(id,i1)-gyy(id,i2)
+                  aa(7)=gzz(id,i1)-gzz(id,i2)
+                  aa(2)=gxx(id,i1)-gxx(id,i3)
+                  aa(5)=gyy(id,i1)-gyy(id,i3)
+                  aa(8)=gzz(id,i1)-gzz(id,i3)
+                  aa(3)=aa(4)*aa(8)-aa(7)*aa(5)
+                  aa(6)=aa(7)*aa(2)-aa(1)*aa(8)
+                  aa(9)=aa(1)*aa(5)-aa(4)*aa(2)
+                  
+c     invert matrix
+                  
+                  call invert(aa,bb,det)
+                  
+c     check on size of determinant - to see if the 3 sites are
+c     too close to being linear for safety.
+                  
+                  pass2=abs(det).lt.dettest
+                  
+                enddo
+                
+                pass1=abs(det).lt.dettest
+                
+              enddo
+              
+              if(abs(det).lt.dettest)call error(idnode,306)
+              
+c     store indices used
+              
+              ind(id,1)=i1
+              ind(id,2)=i2
+              ind(id,3)=i3
+              
+c     store coefficients 
+              
+              do j=1,9
+                
+                gaxs(id,j)=bb(j)
+                
+              enddo
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+c     check that rigid unit does not contain frozen atoms
+        
+        safe=.true.
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            if(lstfrz(i).ne.0)safe=.false.
+            
+          enddo
+          
+        enddo
+        
+c     global check on error condition
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)call error(idnode,360)
+        
+c     quaternions for all rigid groups in system
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          i1=lstrgd(jr+ind(id,1))
+          i2=lstrgd(jr+ind(id,2))
+          i3=lstrgd(jr+ind(id,3))
+          
+          jr=jr+numgsit(id)
+          
+c     group basis vectors
+          
+          aa(1)=xxx(i1)-xxx(i2)
+          aa(4)=yyy(i1)-yyy(i2)
+          aa(7)=zzz(i1)-zzz(i2)
+          
+          call images(imcon,0,1,1,cell,aa(1),aa(4),aa(7))
+          
+          if(rotmin(id).gt.1.d-5)then
+            
+            aa(2)=xxx(i1)-xxx(i3)
+            aa(5)=yyy(i1)-yyy(i3)
+            aa(8)=zzz(i1)-zzz(i3)
+            
+          else
+            
+            rsq=sqrt(aa(1)**2+aa(4)**2+aa(7)**2)
+            
+            if(abs(aa(7)/rsq).gt.0.5d0)then
+              
+              rsq=sqrt(aa(4)**2+aa(7)**2)
+              aa(2)=0.d0
+              aa(5)=aa(7)/rsq
+              aa(8)=-aa(4)/rsq
+              
+            elseif(abs(aa(4)/rsq).gt.0.5d0)then
+              
+              rsq=sqrt(aa(4)**2+aa(1)**2)
+              aa(2)=-aa(4)/rsq
+              aa(5)=aa(1)/rsq
+              aa(8)=0.d0
+              
+            elseif(abs(aa(1)/rsq).gt.0.5d0)then
+              
+              rsq=sqrt(aa(1)**2+aa(7)**2)
+              aa(2)=-aa(7)/rsq
+              aa(5)=0.d0
+              aa(8)=aa(1)/rsq
+              
+            endif
+            
+          endif
+          
+          call images(imcon,0,1,1,cell,aa(2),aa(5),aa(8))
+          
+          aa(3)=aa(4)*aa(8)-aa(7)*aa(5)
+          aa(6)=aa(7)*aa(2)-aa(1)*aa(8)
+          aa(9)=aa(1)*aa(5)-aa(4)*aa(2)
+          
+c     group rotational matrix
+          
+          rot(1)=gaxs(id,1)*aa(1)+gaxs(id,4)*aa(2)+gaxs(id,7)*aa(3)
+          rot(2)=gaxs(id,2)*aa(1)+gaxs(id,5)*aa(2)+gaxs(id,8)*aa(3)
+          rot(3)=gaxs(id,3)*aa(1)+gaxs(id,6)*aa(2)+gaxs(id,9)*aa(3)
+          rot(4)=gaxs(id,1)*aa(4)+gaxs(id,4)*aa(5)+gaxs(id,7)*aa(6)
+          rot(5)=gaxs(id,2)*aa(4)+gaxs(id,5)*aa(5)+gaxs(id,8)*aa(6)
+          rot(6)=gaxs(id,3)*aa(4)+gaxs(id,6)*aa(5)+gaxs(id,9)*aa(6)
+          rot(7)=gaxs(id,1)*aa(7)+gaxs(id,4)*aa(8)+gaxs(id,7)*aa(9)
+          rot(8)=gaxs(id,2)*aa(7)+gaxs(id,5)*aa(8)+gaxs(id,8)*aa(9)
+          rot(9)=gaxs(id,3)*aa(7)+gaxs(id,6)*aa(8)+gaxs(id,9)*aa(9)
+          
+c     determine quaternions from rotational matrix
+          
+          aq=rot(1)+rot(5)
+          bq=rot(2)-rot(4)
+          cq=rot(6)-rot(8)
+          dq=rot(2)+rot(4)
+          eq=rot(3)+rot(7)
+          fq=rot(6)+rot(8)
+          gq=rot(3)-rot(7)
+          hq=rot(1)-rot(5)
+          
+          q0(ig)=0.5d0*sqrt(aq+sqrt(aq*aq+bq*bq))
+          
+          if(q0(ig).gt.1.d-4)then
+            
+            q1(ig)=-0.25d0*cq/q0(ig)
+            q2(ig)=0.25d0*gq/q0(ig)
+            q3(ig)=-0.25d0*bq/q0(ig)
+            
+          else
+            
+            q1(ig)=0.5d0*sqrt(hq+sqrt(hq*hq+dq*dq))
+            
+            if(q1(ig).gt.1.d-4)then
+              
+              q2(ig)=0.25d0*dq/q1(ig)
+              q3(ig)=0.25d0*eq/q1(ig)
+              
+            else
+              
+              q2(ig)=0.5d0*sqrt(-hq+sqrt(hq*hq+dq*dq))
+              
+              if(q2(ig).gt.1.d-4)then
+                
+                q3(ig)=0.25d0*fq/q2(ig)
+                
+              else
+                
+                q3(ig)=1.d0
+                
+              endif
+              
+            endif
+            
+          endif
+          
+c     normalise quaternions
+          
+          rnorm=1.d0/sqrt(q0(ig)**2+q1(ig)**2+q2(ig)**2+q3(ig)**2)
+          q0(ig)=rnorm*q0(ig)
+          q1(ig)=rnorm*q1(ig)
+          q2(ig)=rnorm*q2(ig)
+          q3(ig)=rnorm*q3(ig)
+          
+        enddo
+        
+c     test for redundant degrees of freedom
+c     and ensure rotational inertias are non-zero
+        
+        degrot=0.d0
+        
+        if(lsolva)then
+          degrot_sol(:)=0.d0
+        endif
+        
+        do ig=1,ngrp
+          
+          id=lstgtp(ig)
+          rotall=1.d0/max(1.d-5,rotinx(id,1)+rotiny(id,1)+
+     x      rotinz(id,1))
+          
+          if(rotall*rotinx(id,1).lt.1.d-5)then
+            degrot=degrot-1.d0
+          endif
+          
+          if(rotall*rotiny(id,1).lt.1.d-5)then
+            degrot=degrot-1.d0
+          endif
+          
+          if(rotall*rotinz(id,1).lt.1d-5)then
+            degrot=degrot-1.d0
+          endif
+          
+        enddo
+        
+c     rotational degrees of freedom and rigid body contribution
+c     to total degrees of freedom
+        
+        degrot=degrot+dble(ngrp)*3.d0
+        degfre=degrot+dble(ngrp)*3.d0
+        
+        if(lsolva)then
+          
+          fngrp=1
+          lngrp=0
+          
+          do itmols=1,mxtmls
+            
+            lngrp=lngrp+nummols(itmols)*numgrp(itmols)
+            
+            do ig=fngrp,lngrp
+              
+              id=lstgtp(ig)
+              rotall=1.d0/max(1.d-5,rotinx(id,1)+rotiny(id,1)+
+     x          rotinz(id,1))
+              
+              if(rotall*rotinx(id,1).lt.1.d-5)then
+                degrot_sol(itmols)=degrot_sol(itmols)-1.d0
+              endif
+              
+              if(rotall*rotiny(id,1).lt.1.d-5)then
+                degrot_sol(itmols)=degrot_sol(itmols)-1.d0
+              endif
+              
+              if(rotall*rotinz(id,1).lt.1d-5)then
+                degrot_sol(itmols)=degrot_sol(itmols)-1.d0
+              endif
+              
+            enddo
+            
+            fngrp=lngrp+1
+            
+          enddo
+          
+        endif
+        
+c     summarise results
+        
+        if(idnode.eq.0)then
+          
+          if(gmass(1).gt.0.d0)then
+            
+            write(nrite,'(/,/,12x,a)')' summary of rigid body set up'
+            
+            do id=1,mxungp
+              
+              if(gmass(id).gt.0.d0)then
+                
+                write(nrite,'(/,a,i10)')' group of type ',id
+                write(nrite,'(12x,a,f20.10)')' total mass    ',
+     x            gmass(id)
+                write(nrite,'(12x,a,3f20.10)')' rot. inertia  ',
+     x            rotinx(id,1),rotiny(id,1),rotinz(id,1)
+                write(nrite,'(/,12x,a,3(8x,a7))')' site','a coord',
+     x            'b coord','c coord'
+                do j=1,numgsit(id)
+                  write(nrite,'(12x,i5,1p,3e15.5)')j,gxx(id,j),
+     x              gyy(id,j),gzz(id,j)
+                enddo
+                
+              endif
+              
+            enddo
+            
+          endif
+          
+        endif
+        
+c     find number of unique groups 
+        
+        ngp=0
+        do ig=1,ngrp
+          ngp=max(ngp,lstgtp(ig))
+        enddo
+        
+c     calculate reciprocal of rotational inertias 
+        
+        do id=1,ngp
+          
+          rotlim=max(1.d-2,rotinx(id,1)+rotiny(id,1)+
+     x      rotinz(id,1))*1.d-5
+          
+          if(rotinx(id,1).lt.rotlim)then
+            rotinx(id,2)=0.d0
+          else
+            rotinx(id,2)=1.d0/rotinx(id,1)
+          endif
+          
+          if(rotiny(id,1).lt.rotlim)then
+            rotiny(id,2)=0.d0
+          else
+            rotiny(id,2)=1.d0/rotiny(id,1)
+          endif
+          
+          if(rotinz(id,1).lt.rotlim)then
+            rotinz(id,2)=0.d0
+          else
+            rotinz(id,2)=1.d0/rotinz(id,1)
+          endif
+          
+        enddo
+        
+c     Check of quaternion set up with atomic positions
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     group type
+          
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          rot(1)=q0(ig)**2+q1(ig)**2-q2(ig)**2-q3(ig)**2
+          rot(2)=2.d0*(q1(ig)*q2(ig)-q0(ig)*q3(ig))
+          rot(3)=2.d0*(q1(ig)*q3(ig)+q0(ig)*q2(ig))
+          rot(4)=2.d0*(q1(ig)*q2(ig)+q0(ig)*q3(ig))
+          rot(5)=q0(ig)**2-q1(ig)**2+q2(ig)**2-q3(ig)**2
+          rot(6)=2.d0*(q2(ig)*q3(ig)-q0(ig)*q1(ig))
+          rot(7)=2.d0*(q1(ig)*q3(ig)-q0(ig)*q2(ig))
+          rot(8)=2.d0*(q2(ig)*q3(ig)+q0(ig)*q1(ig))
+          rot(9)=q0(ig)**2-q1(ig)**2-q2(ig)**2+q3(ig)**2
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxt(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x        rot(3)*gzz(id,j)+gcmx(ig)
+            yyt(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x        rot(6)*gzz(id,j)+gcmy(ig)
+            zzt(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x        rot(9)*gzz(id,j)+gcmz(ig)
+            
+            
+            txx(jr)=xxx(i)-xxt(i)
+            tyy(jr)=yyy(i)-yyt(i)
+            tzz(jr)=zzz(i)-zzt(i)
+            
+          enddo
+          
+        enddo
+        
+        call images(imcon,0,1,jr,cell,txx,tyy,tzz)
+        
+c     set tolerance for testing quaternion setup.
+        
+        rsq=0.d0
+        tol=1.d-2
+        
+        do i=1,jr
+          
+          rrr=txx(i)**2+tyy(i)**2+tzz(i)**2
+          if(rrr.gt.tol)then 
+            
+            rsq=rrr
+            
+          endif
+          
+        enddo
+        
+c     exit if error in set up
+        
+        safe=.true.
+        if(rsq.gt.tol)safe=.false.
+        if(mxnode.gt.1)call gstate(safe)
+        
+        if(.not.safe)call  error(idnode,310)
+        
+c     sort lstgot into ascending order
+        
+        call shellsort(jt,lstgot)
+        
+c     check that no site is in more than 1 rigid group
+        
+        i=1
+        safe=.true.
+        do while(i.lt.jt)
+          
+          i=i+1
+          linear=.true.
+          do while(linear)
+            
+            linear=.false.
+            
+            if(lstgot(i).eq.lstgot(i-1))then
+              
+              linear=.true.
+              safe=.false.
+              jt=jt-1
+              
+              do j=i,jt
+                lstgot(j)=lstgot(j+1)
+              enddo
+              
+            endif
+            
+            if(i.ge.jt)linear=.false.
+            
+          enddo
+          
+        enddo
+        
+        if(.not.safe)call error(idnode,320)
+        
+c     list of 'free' sites
+        
+        ii=1
+        jj=0
+        do i=1,natms
+          
+          if(lstgot(ii).eq.i)then
+            
+            ii=ii+1
+            
+          else
+            
+            if(lstfrz(i).eq.0)then
+              jj=jj+1
+              lstfre(jj)=i
+            endif
+            
+          endif
+          
+        enddo
+        
+c     number of free sites
+        
+        ntfree=jj
+        
+c     list of atoms integrated on this node
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          jr=jr+numgsit(id)
+          
+        enddo
+        
+        do i=1,jr
+          lstme(i)=lstrgd(i)
+        enddo
+        
+c     block parameters for free atoms
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+        do i=ifre1,ifre2
+          
+          jr=jr+1
+          lstme(jr)=lstfre(i)
+          
+        enddo
+        
+c     exchange quaternion data with other nodes
+        
+        if(mxnode.gt.1)call merge4
+     x    (idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+      if(lsolva)lstgot_sol(:)=lstgot(:)
+      
+c     deallocate work arrays
+      
+      deallocate (ind,lstgot,stat=fail(1))
+      deallocate (txx,tyy,tzz,stat=fail(2))
+      deallocate (xxt,yyt,zzt,stat=fail(3))
+      deallocate (gaxs,rotmin,stat=fail(4))
+      deallocate (accum,stat=fail(5))
+      
+      return
+      end subroutine quatbook
+      
+      subroutine abort_field_read(kode,idnode,nfield)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for aborting FIELD file read
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer kode,idnode,nfield
+      
+      if(idnode.eq.0)close (nfield)
+      
+      if(kode.eq.1)then
+        
+c     end of field file error exit
+        
+        call error(idnode,52)
+        
+      elseif(kode.eq.2)then
+        
+c     unrecognised directive in field file
+        
+        call error(idnode,4)
+        
+      endif
+      
+      return
+      end subroutine abort_field_read
+      
+      subroutine abort_control_read(kode,idnode,nread)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for aborting CONTROL file read
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer kode,idnode,nread
+      
+      if(idnode.eq.0)close (nread)
+      
+      if(kode.eq.1)then
+        
+c     end of control file error exit
+        
+        call error(idnode,53)
+        
+      elseif(kode.eq.2)then
+        
+c     general error exit from field file processing
+        
+        call error(idnode,0)
+        
+      endif
+      
+      return
+      end subroutine abort_control_read
+      
+      subroutine abort_config_read(kode,idnode,nconf)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for aborting CONTROL file read
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer kode,idnode,nconf
+      
+      if(idnode.eq.0)close (nconf)
+      
+      if(kode.eq.1)then
+        
+c     general error exit from field file processing
+        
+        call error(idnode,54)
+        
+      elseif(kode.eq.2)then
+        
+c     end of config file error exit
+        
+        call error(idnode,55)
+        
+      endif
+      
+      return
+      end subroutine abort_config_read
+      
+      subroutine neutbook(lneut,idnode,natms,nneut)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for neutral group bookkeeping
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    nov 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lneut,safe
+      integer idnode,natms,nneut,i
+      
+      safe=.true.
+      
+c     neutral group bookkeeping: sites must be listed consecutively
+      
+      if(lneut)then
+        
+        if(lstneu(1).ne.1)call error(idnode,230)
+        
+        neulst(1)=1
+        nneut=1
+        
+        do i=2,natms
+          
+          safe=.false.
+          if(lstneu(i).eq.lstneu(i-1))safe=.true.
+          if(lstneu(i).eq.lstneu(i-1)+1)then
+            
+            safe=.true.
+            nneut=nneut+1
+            if(nneut.gt.mxneut)call error(idnode,220)
+            neulst(nneut)=i
+            
+          endif
+          
+          if(.not.safe)call error(idnode,230)
+          
+        enddo
+        
+        neulst(nneut+1)=natms+1
+        
+      endif
+      
+      return
+      
+      end subroutine neutbook
+      
+      subroutine intlist
+     x  (lshmov,lcnb,idnode,mxnode,natms,nscons,ntangl,ntbond,
+     x  ntcons,ntdihd,ntinv,ntpmls,ntteth,ntshl,ntpmf,nspmf,ngrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the interaction lists
+c     for the entire simulated system
+c     
+c     parallel replicated dat version : block data
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith        july 1992
+c     amended   - t.forester      oct 1993
+c     amended   - t.forester      dec 1994 : block data
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lshmov,safe1,lcnb,lchk,lfail
+      integer idnode,mxnode,natms,nscons,ntangl,ntbond,ntcons
+      integer ntdihd,ntinv,ntpmls,ntteth,ntshl,ntpmf,nspmf
+      integer ibonds,jbonds,kbonds,ipmf,jpmf,iangle,jangle,kangle
+      integer idihed,jdihed,kdihed,iinver,jinver,kinver,iteths
+      integer jteths,kteths,ishels,jshels,kshels,ntbon0,ntpmf0
+      integer ntang0,ntdih0,ntinv0,nttet0,ntshl0,ntcon0,idum
+      integer itmols,isite,iconst,jconst,kconst,ibnd1,ibnd2,ipmf1
+      integer ipmf2,iang1,iang2,idih1,idih2,iinv1,iinv2,itet1
+      integer itet2,ishl1,ishl2,imols,lbonds,lpmf,jj,nnn,langle
+      integer ldihed,linver,lteths,lshels,i,ii,ntmp,klo,khi,ngrp
+      integer klo0,ifail,iloop,nnode,nscons0,nscons1,icon,fail
+      integer kcons,id,jdnode,lconst,itry,iatom,jatom,j,nfail
+      real(8) tol
+      
+      integer, allocatable :: itest(:),index(:),kscons(:)
+      integer, allocatable :: msite(:),mconst(:),listin(:)
+      
+      dimension fail(4)
+      
+      data fail/0,0,0,0/
+      
+c     allocate work arrays
+      
+      allocate (itest(mxtmls),index(mxtmls),stat=fail(1))
+      allocate (msite(mxtmls),mconst(mxtmls),stat=fail(2))
+      allocate (listin(mxatms),stat=fail(3))
+      allocate (kscons(0:mxproc-1),stat=fail(4))
+      do i=1,4
+        if(fail(i).ne.0)call error(idnode,1800)
+      enddo
+      
+c     initialise bookkeeping indices
+      
+      ibonds=0
+      jbonds=0
+      kbonds=0
+      ipmf=0
+      jpmf=0
+      iangle=0
+      jangle=0
+      kangle=0
+      idihed=0
+      jdihed=0
+      kdihed=0
+      iinver=0
+      jinver=0
+      kinver=0
+      iteths=0
+      jteths=0
+      kteths=0
+      ishels=0
+      jshels=0
+      kshels=0
+      safe=.true.
+      safe1=.true.
+      
+c     find total number of bonds,pmf constraints,bond constraints,
+c     angles,dihedrals,inversions, tethers,core-shells, in system 
+c     - ignoring frozen atoms
+      
+      ntbon0=0
+      ntpmf0=0
+      ntcon0=0
+      ntang0=0
+      ntdih0=0
+      ntinv0=0
+      nttet0=0
+      ntshl0=0
+      nscons=0
+      ntcons=0
+      
+      do itmols=1,ntpmls
+        
+        ntbon0=ntbon0+nummols(itmols)*numbonds(itmols)
+        ntpmf0=ntpmf0+nummols(itmols)*numpmf(itmols)
+        ntcon0=ntcon0+nummols(itmols)*numcon(itmols)
+        ntang0=ntang0+nummols(itmols)*numang(itmols)
+        ntdih0=ntdih0+nummols(itmols)*numdih(itmols)
+        ntinv0=ntinv0+nummols(itmols)*numinv(itmols)
+        nttet0=nttet0+nummols(itmols)*numteth(itmols)
+        ntshl0=ntshl0+nummols(itmols)*numshl(itmols)
+        
+      enddo
+      
+      isite=0
+      iconst=0
+      jconst=0
+      kconst=0
+      
+c     first and last index of bonds, angles etc for this node
+      
+      ibnd1=(idnode*ntbon0)/mxnode+1
+      ibnd2=((idnode+1)*ntbon0)/mxnode
+      
+      ipmf1=(idnode*ntpmf0)/mxnode+1
+      ipmf2=((idnode+1)*ntpmf0)/mxnode
+      ntpmf=ntpmf0
+      nspmf=ipmf2+1-ipmf1
+      
+      iang1=(idnode*ntang0)/mxnode+1
+      iang2=((idnode+1)*ntang0)/mxnode
+      
+      idih1=(idnode*ntdih0)/mxnode+1
+      idih2=((idnode+1)*ntdih0)/mxnode
+      
+      iinv1=(idnode*ntinv0)/mxnode+1
+      iinv2=((idnode+1)*ntinv0)/mxnode
+      
+      itet1=(idnode*nttet0)/mxnode+1
+      itet2=((idnode+1)*nttet0)/mxnode
+      
+      ishl1=(idnode*ntshl0)/mxnode+1
+      ishl2=((idnode+1)*ntshl0)/mxnode
+      
+c     loop over molecule types
+      
+      do itmols=1,ntpmls
+        
+        
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+          
+c     construct bond constraint list later
+c     construct chemical bond interaction list
+          
+          do lbonds=1,numbonds(itmols)
+            
+            ibonds=ibonds+1
+            
+            if(ibonds.ge.ibnd1.and.ibonds.le.ibnd2)then
+              
+              jbonds=jbonds+1
+              if(jbonds.le.mxbond)then
+                
+                listbnd(jbonds,1)=lbonds+kbonds
+                listbnd(jbonds,2)=lstbnd(lbonds+kbonds,1)
+     x            +isite
+                listbnd(jbonds,3)=lstbnd(lbonds+kbonds,2)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,31)
+          
+c     construct pmf site lists - no exclusions
+          
+          do lpmf=1,numpmf(itmols)
+            
+            ipmf=ipmf+1
+            
+            if(ipmf.ge.ipmf1.and.ipmf.le.ipmf2)then
+              
+              jpmf=jpmf+1
+              if(jpmf.le.mspmf)then
+                
+                nnn=npmf(1)+npmf(2)
+                if(nnn.le.mxspmf)then
+                  
+                  do jj=1,npmf(1)+npmf(2)
+                    lstpmf(jj,jpmf)=indpmf(jj)+isite
+                  enddo
+                  
+                else
+                  
+                  safe=.false.
+                  
+                endif
+                
+              else
+                
+                safe1=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe1)
+          if(.not.safe1)call error(idnode,458)
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,460)
+          
+c     construct valence angle interaction list
+          
+          do langle=1,numang(itmols)
+            
+            iangle=iangle+1
+            
+            if(iangle.ge.iang1.and.iangle.le.iang2)then
+              
+              jangle=jangle+1
+              if(jangle.le.mxangl)then
+                
+                listang(jangle,1)=langle+kangle
+                listang(jangle,2)=lstang(langle+kangle,1)
+     x            +isite
+                listang(jangle,3)=lstang(langle+kangle,2)
+     x            +isite
+                listang(jangle,4)=lstang(langle+kangle,3)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,51)
+          
+c     construct dihedral angle interaction list
+          
+          do ldihed=1,numdih(itmols)
+            
+            idihed=idihed+1
+            
+            if(idihed.ge.idih1.and.idihed.le.idih2)then
+              
+              jdihed=jdihed+1
+              if(jdihed.le.mxdihd)then
+                
+                listdih(jdihed,1)=ldihed+kdihed
+                listdih(jdihed,2)=lstdih(ldihed+kdihed,1)
+     x            +isite
+                listdih(jdihed,3)=lstdih(ldihed+kdihed,2)
+     x            +isite
+                listdih(jdihed,4)=lstdih(ldihed+kdihed,3)
+     x            +isite
+                listdih(jdihed,5)=lstdih(ldihed+kdihed,4)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,61)
+          
+c     construct inversion potential list
+          
+          do linver=1,numinv(itmols)
+            
+            iinver=iinver+1
+            
+            if(iinver.ge.iinv1.and.iinver.le.iinv2)then
+              
+              jinver=jinver+1
+              if(jinver.le.mxinv)then
+                
+                listinv(jinver,1)=linver+kinver
+                listinv(jinver,2)=lstinv(linver+kinver,1)
+     x            +isite
+                listinv(jinver,3)=lstinv(linver+kinver,2)
+     x            +isite
+                listinv(jinver,4)=lstinv(linver+kinver,3)
+     x            +isite
+                listinv(jinver,5)=lstinv(linver+kinver,4)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,77)
+          
+c     construct tethered atoms interaction list
+          
+          do lteths=1,numteth(itmols)
+            
+            iteths=iteths+1
+            
+            if(iteths.ge.itet1.and.iteths.le.itet2)then
+              
+              jteths=jteths+1
+              if(jteths.le.msteth)then
+                
+                listtet(jteths,1)=lteths+kteths
+                listtet(jteths,2)=lsttet(lteths+kteths)+isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,63)
+          
+c     construct core-shell list
+          
+          do lshels=1,numshl(itmols)
+            
+            ishels=ishels+1
+            
+            if(ishels.ge.ishl1.and.ishels.le.ishl2)then
+              
+              jshels=jshels+1
+              if(jshels.le.mxshl)then
+                
+                listshl(jshels,1)=lshels+kshels
+                listshl(jshels,2)=lstshl(lshels+kshels,1)
+     x            +isite
+                listshl(jshels,3)=lstshl(lshels+kshels,2)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,59)
+          
+          isite=isite+numsit(itmols)
+          
+        enddo
+        
+        kbonds=kbonds+numbonds(itmols)
+        kangle=kangle+numang(itmols)
+        kdihed=kdihed+numdih(itmols)
+        kinver=kinver+numinv(itmols)
+        kteths=kteths+numteth(itmols)
+        kshels=kshels+numshl(itmols)
+        
+      enddo
+      
+c     store array counters for bookkeeping
+      
+      ntbond=ibonds
+      ntangl=iangle
+      ntdihd=idihed
+      ntinv=iinver
+      ntteth=iteths
+      ntshl=ishels
+      
+c     pass bond constraint information to other nodes
+      
+      if(ntcon0.gt.0)then
+        
+        ntcons=ntcon0
+        
+c     find starting site no. and constraint no. for each molec. type
+        
+        msite(1)=0
+        mconst(1)=0
+        
+        do itmols=2,ntpmls
+          
+          msite(itmols)=msite(itmols-1)+numsit(itmols-1)*
+     x      nummols(itmols-1)
+          mconst(itmols)=mconst(itmols-1)+numcon(itmols-1)
+          
+        enddo
+        
+c     sort molecules into ascending order of number of constraints
+        
+        do i=1,ntpmls
+          
+          itest(i)=numcon(i)
+          index(i)=0
+          
+        enddo
+        
+        call shellsort(ntpmls,itest)
+        
+        do i=1,ntpmls
+          
+          lchk=.true.
+          do j=1,ntpmls
+            
+            if(itest(i).eq.numcon(j))then
+              
+              if(lchk)then 
+                index(i)=j
+                lchk=.false.
+                
+              endif
+              
+              do ii=1,i-1
+                if(index(ii).eq.j)lchk=.true.
+              enddo
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+c     load balance to within 10%
+        
+        tol=1.0d0+(0.10d0)/2.d0
+        kcons=(ntcons)/mxnode
+        ntmp=0
+        
+c     find smallest constrained molecule to allocate to a node
+        
+        do i=1,ntpmls
+          
+          if(ntmp.le.mxnode)then
+            
+            if(numcon(index(i)).gt.0)then
+              ntmp=ntmp+nummols(index(i))
+              klo=max(0,kcons-numcon(index(i))/2)
+              khi=klo+numcon(index(i))+1
+            endif
+            
+          endif
+          
+        enddo
+        
+c     reset hi/lo limits if molecules contain too many constraints
+        
+        if(dble(khi)/dble(max(1,klo)).gt.tol)then
+          klo=nint(dble(kcons)/tol)
+          khi=nint(dble(kcons)*tol)+1
+        endif
+        
+c     store lo value for later
+        
+        klo0=klo
+        
+c     begin assignment of constraints ----------------------------------
+        
+        ifail=-1
+        lfail=.true.
+        do while(lfail)
+          
+          ifail=ifail+1
+          
+          if(ifail.gt.ntpmls)then
+            call error(idnode,432)
+          endif
+          
+          iconst=0
+          jconst=0
+          kconst=0
+          lconst=0
+          
+c     zero running totals of constraints on each processor
+          
+          do id=0,mxnode-1
+            kscons(id)=0
+          enddo
+          
+          iloop=0
+          lfail=.false.
+          iconst=0
+          jconst=0
+          nnode=0
+          
+c     assign difficult molecules in blocks
+          
+          if(ifail.gt.0)then
+            
+            nfail=0
+            do i=1,ifail
+              
+              ii=ntpmls+1-i
+              nfail=nfail+nummols(index(ii))*numcon(index(ii))
+              
+            enddo
+            
+c     decide on number of processors to split over
+            
+            nnode=int(dble(nfail)/dble(max(kcons,1))+1.d0/tol)
+            nnode=max(2,nnode)
+            nnode=min(nnode,mxnode)
+            
+c     assign to processors 0..nnode-1
+            
+            do id=0,nnode-1
+              
+              nscons0=(id*nfail)/nnode+1
+              nscons1=((id+1)*nfail)/nnode
+              
+              kscons(id)=nscons1+1-nscons0
+              
+            enddo
+            
+c     this processors block
+            
+            nscons0=(idnode*nfail)/nnode+1
+            nscons1=((idnode+1)*nfail)/nnode
+            
+c     assign in blocks
+            
+            do itmols=ntpmls,ntpmls-ifail+1,-1
+              
+              ii=index(itmols)
+              icon=numcon(ii)
+              kconst=mconst(ii)
+              
+              do imols=1,nummols(ii)
+                
+                isite=msite(ii)+(imols-1)*numsit(ii)
+                
+c     construct bond constraint list
+                
+                do lconst=1,numcon(ii)
+                  
+                  iconst=iconst+1
+                  
+                  if(iconst.ge.nscons0.and.iconst.le.nscons1)then
+                    
+                    jconst=jconst+1
+                    
+                    if(jconst.le.mxcons)then
+                      
+                      listcon(jconst,1)=lconst+kconst
+                      iatom=lstcon(lconst+kconst,1)+isite
+                      jatom=lstcon(lconst+kconst,2)+isite
+                      
+                      listcon(jconst,2)=iatom
+                      listcon(jconst,3)=jatom
+                      
+                    else
+                      
+                      safe=.false.
+                      
+                    endif
+                    
+                  endif
+                  
+                enddo
+                
+              enddo
+              
+            enddo
+            
+          endif
+          
+c     assign non-problematic molecules
+          
+          jdnode=mod(nnode+1,mxnode)
+          
+          do itmols=ntpmls-ifail,1,-1
+            
+            ii=index(itmols)
+            icon=numcon(ii)
+            kconst=mconst(ii)
+            
+            do imols=1,nummols(ii)
+              
+              itry=0
+              lchk=.true.
+              do while(lchk)
+                
+                if(kscons(jdnode)+icon.le.klo)then
+                  
+                  if(jdnode.ne.idnode)then
+                    kscons(jdnode)=kscons(jdnode)+icon
+                    jdnode=mod(jdnode+1,mxnode)
+                    lchk=.false.
+                  else
+                    
+c     construct bond constraint list
+                    
+                    isite=msite(ii)+(imols-1)*numsit(ii)
+                    do lconst=1,numcon(ii)
+                      
+                      jconst=jconst+1
+                      
+                      if(jconst.le.mxcons)then
+                        
+                        listcon(jconst,1)=lconst+kconst
+                        iatom=lstcon(lconst+kconst,1)+isite
+                        jatom=lstcon(lconst+kconst,2)+isite
+                        listcon(jconst,2)=iatom
+                        listcon(jconst,3)=jatom
+                        
+                      else
+                        
+                        safe=.false.
+                        
+                      endif
+                      
+                    enddo
+                    
+                    kscons(jdnode)=kscons(jdnode)+icon
+                    jdnode=mod(jdnode+1,mxnode)
+                    lchk=.false.
+                    
+                  endif
+                  
+                else
+                  
+                  jdnode=mod(jdnode+1,mxnode)
+                  lchk=.true.
+                  itry=itry+1
+                  
+                endif
+                
+                if(lchk.and.itry.gt.mxnode)then
+                  
+                  klo=kcons
+                  kcons=khi
+                  itry=0
+                  iloop=iloop+1
+                  
+                endif
+                
+c     split molecule across nodes if have to
+                
+                if(iloop.gt.3)then
+                  lfail=.true.
+                  kcons=ntcons/mxnode
+                  klo=klo0
+                  lchk=.false.
+                endif
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+c     check no node has less than minimum number
+          
+          do id=0,mxnode-1
+            if(kscons(id).lt.klo0)then 
+              lfail=.true.
+            endif
+          enddo
+          
+        enddo
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)then
+          
+          if(mxnode.gt.1)call gimax(jconst,1,idum)
+          if(idnode.eq.0)write(nrite,'(a,i10,a,i10)')
+     x      'Number of constraints found ',jconst,'Max allowed ',mxcons
+          
+          call error(idnode,41)
+          
+        endif
+        
+        nscons=kscons(idnode)
+        
+        call passcon
+     x    (lshmov,idnode,mxnode,natms,nscons,lashap,lishap,listme,
+     x    listin,listot,listcon,lstfrz)
+        
+      endif
+      
+      if(npmf(1).gt.0)then
+        
+        call passpmf
+     x    (idnode,mxnode,natms,nspmf,listpm,listin,lstpmt,lstpmf,npmf)
+        
+      endif
+      
+c     pass rigid body data
+      
+      lcnb=.false.
+      if(ntcons.gt.0.and.ngrp.gt.0)then
+        
+        call passquat
+     x    (lcnb,idnode,mxnode,natms,ngrp,nscons,ntpmls,listin,
+     x    listcon,lstrgd,lstout,lstcsit,lstgtp,nummols,numgrp,
+     x    numgsit)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate(itest,index,msite,stat=fail(1))
+      deallocate(mconst,kscons,listin,stat=fail(2))
+      
+      return
+      end subroutine intlist
+      
+      subroutine ensemble_selection
+     x  (directive,lens,kill,idnode,keyens,mode,taut,taup)
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting the ensemble and reading 
+c     the required parameters
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical kill,lens
+      integer keyens,idnode,idum,mode
+      real(8) taut,taup
+      
+      if(findstring('nve',directive,idum))then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'microcanonical ensemble')")
+        if(lens)then
+          call error(idnode,-414)
+          kill=.true.
+        endif
+        lens=.true.
+        
+      elseif(findstring('nvt',directive,idum))then
+        
+        if(findstring('evans',directive,idum))then
+          
+          keyens=1
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Evans Gaussian temperature constraints',
+     x      ' in use')")
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('ber',directive,idum))then
+          
+          keyens=2
+          taut=dblstr(directive,69,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Berendsen thermostat',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4)")
+     x      taut
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('hoover',directive,idum))then
+          
+          keyens=3
+          taut=dblstr(directive,69,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Nose-Hoover ',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4)")
+     x      taut
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        else
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+      elseif(findstring('npt',directive,idum))then
+        
+        if(findstring('ber',directive,idum))then
+          
+          keyens=4
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Berendsen isotropic N-P-T',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('hoover',directive,idum))then
+          
+          keyens=5
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Nose-Hoover  (Melchionna) isotropic N-P-T ',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        else
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+      elseif(findstring('nst',directive,idum))then
+        
+        mode=0
+        if(findstring('block',directive,idum))mode=1
+        if(findstring('surf',directive,idum))mode=2
+        if(findstring('slab',directive,idum))mode=3
+        
+        if(findstring('ber',directive,idum))then
+          
+          keyens=6
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Berendsen anisotropic N-P-T',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('hoover',directive,idum))then
+          
+          keyens=7
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Nose-Hoover (Melchionna) anisotropic N-P-T ',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        else
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+        if(idnode.eq.0)then
+          
+          if(mode.eq.0)then
+            write(nrite,"(/,1x,'NST mode 0 X<>Y<>Z')")
+          elseif(mode.eq.1)then
+            write(nrite,
+     x        "(/,1x,'NST mode 1 X<>Y<>Z (rectangular block)')")
+          elseif(mode.eq.2)then
+            write(nrite,
+     x        "(/,1x,'NST mode 2 X=Y<>Z (liquid surface)')")
+          elseif(mode.eq.3)then
+            write(nrite,
+     x        "(/,1x,'NST mode 3 X<>Y<>Z (solid slab)')")
+          endif
+          
+        endif
+        
+      elseif(findstring('pmf',directive,idum))then
+        
+        keyens=8
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'potential of mean force calculation (NVE)')")
+        if(lens)then
+          call error(idnode,-414)
+          kill=.true.
+        endif
+        lens=.true.
+        
+      else
+        
+        call error(idnode,-436)
+        kill=.true.
+        
+      endif
+      
+      return
+      end subroutine ensemble_selection
+      
+      subroutine neb_option
+     x  (directive,lneb,lminopt,idnode,numneb,keytol,sprneb,
+     x  opttol,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for NEB option
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit
+      character*1 directive(lenrec)
+      logical lneb,lminopt,endneb,safe
+      integer numneb,idnode,keytol,i,idum
+      real(8) sprneb,opttol,hyp_units
+      
+      if(lminopt)call error(idnode,225)
+      lminopt=.true.
+      lneb=.true.
+      endneb=.false.
+      numneb=intstr(directive,lenrec,idum)
+      if(numneb.eq.0)numneb=1
+      numneb=min(maxneb,numneb)
+      
+      hyp_units=1.d0
+      do while(.not.endneb)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+          cycle
+        elseif(findstring('endneb',directive,idum))then
+          endneb=.true.
+        elseif(findstring('units',directive,idum))then
+          hyp_units=energy_unit()
+          call getword(cunit,directive,8,lenrec)
+          call getword(cunit,directive,8,lenrec)
+        elseif(findstring('basin_1',directive,idum))then
+          call striptext(directive,lenrec,1)
+          do i=1,numneb
+            bsn_1(i)=intstr(directive,lenrec,idum)
+          enddo
+        elseif(findstring('basin_2',directive,idum))then
+          call striptext(directive,lenrec,1)
+          do i=1,numneb
+            bsn_2(i)=intstr(directive,lenrec,idum)
+          enddo
+        elseif(findstring('neb_spring',directive,idum))then
+          sprneb=dblstr(directive,lenrec,idum)
+        elseif(findstring('forc',directive,idum))then
+          keytol=0
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('ener',directive,idum))then
+          keytol=1
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('posi',directive,idum))then
+          keytol=2
+          opttol=dblstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,"(/,1x,'NEB calculation controls')")
+        write(nrite,"(/,1x,'identity of basin 1            ',
+     x    10i10)")(bsn_1(i),i=1,numneb)
+        write(nrite,"(1x,'identity of basin 2            ',
+     x    10i10)")(bsn_2(i),i=1,numneb)
+        write(nrite,
+     x    "(1x,'NEB spring constant            ',e12.4,
+     x    /,1x,'minimisation tolerance         ',e12.4,
+     x    /,1x,'energy units                   ',2x,a8)")
+     x    sprneb,opttol,cunit
+        
+        call print_optim(keytol)
+        
+      endif
+      
+c     units conversion
+      
+      sprneb=sprneb*hyp_units
+      if(keytol.lt.2)opttol=opttol*hyp_units
+      
+      return
+      end subroutine  neb_option
+      
+      subroutine bpd_option
+     x  (directive,seek,lbpd,ltad,lminopt,prechk,nebgo,keybpd,idnode,
+     x  nblock,ntrack,keytol,ebias,vmin,catchrad,sprneb,opttol,
+     x  hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for bias potential
+c     dynamics option
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit,seek
+      character*1 directive(lenrec)
+      logical lbpd,ltad,lminopt,prechk,endbpd,safe,nebgo
+      integer keybpd,idnode,nblock,ntrack,keytol,idum
+      real(8) ebias,vmin,catchrad,sprneb,opttol,hyp_units
+      
+      if(lminopt)call error(idnode,225)
+      if(ltad)call error(idnode,2355)
+      lminopt=.true.
+      lbpd=.true.
+      endbpd=.false.
+      cunit=" dl_poly"
+      if(idnode.eq.0)
+     x  write(nrite,"(/,1x,'bias potential dynamics controls')")
+      
+      if(findstring('dyn',directive,idum))then
+        
+        keybpd=1
+        hyp_units=energy_unit()
+        ebias=dblstr(directive,lenrec,idum)
+        vmin=dblstr(directive,lenrec,idum)
+        call getword(cunit,directive,8,lenrec)
+        if(idnode.eq.0)write(nrite,"(
+     x    1x,'dynamics option selected       ',
+     x    /,1x,'bias potential E_bias  (kelvin)',f10.4,
+     x    /,1x,'bias potential V_min   (kelvin)',f10.4
+     x    /,1x,'energy units                   ',2x,a8)")
+     x    ebias,vmin,cunit
+        
+      elseif(findstring('path',directive,idum))then
+        
+        keybpd=2
+        nebgo=.true.
+        hyp_units=1.d0
+        do while(.not.endbpd)
+          
+          call getrec(safe,idnode,nread)
+          if(.not.safe)call abort_control_read(1,idnode,nread)
+          call lowcase(record,lenrec)
+          call strip(record,lenrec)
+          call copystring(record,directive,lenrec)
+          
+          if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+            cycle
+          elseif(findstring('endbpd',directive,idum))then
+            endbpd=.true.
+          elseif(findstring('pre',directive,idum))then
+            prechk=.true.
+            if(findstring('false',directive,idum))prechk=.false.
+          elseif(findstring('noneb',directive,idum))then
+            nebgo=.false.
+          elseif(findstring('target',directive,idum))then
+            call getword(seek,directive,8,lenrec)
+            call getword(seek,directive,8,lenrec)
+          elseif(findstring('units',directive,idum))then
+            hyp_units=energy_unit()
+            call getword(cunit,directive,8,lenrec)
+            call getword(cunit,directive,8,lenrec)
+          elseif(findstring('ebias',directive,idum))then
+            ebias=dblstr(directive,lenrec,idum)
+          elseif(findstring('vmin',directive,idum))then
+            vmin=dblstr(directive,lenrec,idum)
+          elseif(findstring('num_block',directive,idum))then
+            nblock=intstr(directive,lenrec,idum)
+          elseif(findstring('num_track',directive,idum))then
+            ntrack=intstr(directive,lenrec,idum)
+          elseif(findstring('catch_radius',directive,idum))then
+            catchrad=dblstr(directive,lenrec,idum)
+          elseif(findstring('neb_spring',directive,idum))then
+            sprneb=dblstr(directive,lenrec,idum)
+          elseif(findstring('forc',directive,idum))then
+            keytol=0
+            opttol=dblstr(directive,lenrec,idum)
+          elseif(findstring('ener',directive,idum))then
+            keytol=1
+            opttol=dblstr(directive,lenrec,idum)
+          elseif(findstring('posi',directive,idum))then
+            keytol=2
+            opttol=dblstr(directive,lenrec,idum)
+          endif
+          
+        enddo
+        
+        if(idnode.eq.0)then
+          
+          write(nrite,"(
+     x      1x,'dynamics with path analysis selected',
+     x      /,1x,'bias potential E_bias  (kelvin)',f10.4,
+     x      /,1x,'bias potential V_min   (kelvin)',f10.4,
+     x      /,1x,'steps per time block           ',i10,
+     x      /,1x,'steps per tracking block       ',i10,
+     x      /,1x,'configuration catch radius  (A)',f10.4,
+     x      /,1x,'minimisation tolerance         ',e12.4,
+     x      /,1x,'atom type to be tracked        ',2x,a8,
+     x      /,1x,'energy units                   ',2x,a8)")
+     x      ebias,vmin,nblock,ntrack,catchrad,opttol,seek,cunit
+          if(nebgo)write(nrite,
+     x      "(1x,'NEB spring constant            ',e12.4)")sprneb
+          if(prechk)write(nrite,
+     x      "(1x,'transition prechecking option selected')")
+          call print_optim(keytol)
+          
+        endif
+        
+c     energy unit conversions
+        
+        sprneb=sprneb*hyp_units
+        if(keytol.lt.2)opttol=opttol*hyp_units
+        
+      endif
+      
+      return
+      end subroutine bpd_option
+      
+      subroutine tad_option
+     x  (directive,ltad,lbpd,lminopt,prechk,tadall,idnode,nblock,
+     x  ntrack,blkout,keytol,catchrad,sprneb,tlow,deltad,opttol,
+     x  hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for TAD option
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit
+      character*1 directive(lenrec)
+      logical ltad,lbpd,lminopt,prechk,tadall,endtad,safe
+      integer idnode,nblock,ntrack,blkout,keytol,idum
+      real(8) catchrad,sprneb,deltad,tlow,opttol,hyp_units
+      
+      if(lminopt)call error(idnode,225)
+      if(lbpd)call error(idnode,2355)
+      lminopt=.true.
+      ltad=.true.
+      endtad=.false.
+      hyp_units=1.d0
+      
+      do while(.not.endtad)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+          cycle
+        elseif(findstring('endtad',directive,idum))then
+          endtad=.true.
+        elseif(findstring('pre',directive,idum))then
+          prechk=.true.
+          if(findstring('false',directive,idum))prechk=.false.
+        elseif(findstring('all',directive,idum))then
+          tadall=.true.
+          if(findstring('false',directive,idum))tadall=.false.
+        elseif(findstring('units',directive,idum))then
+          hyp_units=energy_unit()
+          call getword(cunit,directive,8,lenrec)
+          call getword(cunit,directive,8,lenrec)
+        elseif(findstring('num_block',directive,idum))then
+          nblock=intstr(directive,lenrec,idum)
+        elseif(findstring('num_track',directive,idum))then
+          ntrack=intstr(directive,lenrec,idum)
+        elseif(findstring('blackout',directive,idum))then
+          blkout=intstr(directive,lenrec,idum)
+        elseif(findstring('catch_radius',directive,idum))then
+          catchrad=dblstr(directive,lenrec,idum)
+        elseif(findstring('neb_spring',directive,idum))then
+          sprneb=dblstr(directive,lenrec,idum)
+        elseif(findstring('deltad',directive,idum))then
+          deltad=dblstr(directive,lenrec,idum)
+        elseif(findstring('low_temp',directive,idum))then
+          tlow=dblstr(directive,lenrec,idum)
+        elseif(findstring('forc',directive,idum))then
+          keytol=0
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('ener',directive,idum))then
+          keytol=1
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('posi',directive,idum))then
+          keytol=2
+          opttol=dblstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'TAD dynamics controls'
+     x    /,1x,'steps per time block           ',i10,
+     x    /,1x,'steps per tracking block       ',i10,
+     x    /,1x,'steps in blackout periods      ',i10,
+     x    /,1x,'configuration catch radius     ',1p,e12.4,
+     x    /,1x,'NEB spring constant            ',e12.4,
+     x    /,1x,'stopping parameter             ',e12.4,
+     x    /,1x,'target low temperature         ',e12.4,
+     x    /,1x,'minimisation tolerance         ',e12.4,
+     x    /,1x,'energy units                   ',2x,a8)")
+     x    nblock,ntrack,blkout,catchrad,sprneb,deltad,
+     x    tlow,opttol,cunit
+        if(prechk)write(nrite,
+     x    "(1x,'transition prechecking option selected')")
+        if(tadall)write(nrite,
+     x    "(1x,'option for all basins analysis selected')")
+        call print_optim(keytol)
+        
+      endif
+      
+c     energy unit conversions
+      
+      sprneb=sprneb*hyp_units
+      if(keytol.lt.2)opttol=opttol*hyp_units
+      
+      return
+      end subroutine tad_option
+
+      subroutine metadyn_option
+     x  (directive,lmetadyn,lstein,ltet,lglobpe,llocpe,idnode,
+     x  ncolvar,nq4,nq6,ntet,hkey,meta_step_int,globpe_scale,
+     x  locpe_scale,ref_W_aug,h_aug,wt_Dt)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for metadynamics option
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2011
+c     
+c     note: default values are set in metafreeze_module
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lmetadyn,endmet,lstein,ltet,lglobpe,llocpe,safe
+      integer idnode,idum,ncolvar,nq4,nq6,ntet,hkey,meta_step_int
+      real(8) globpe_scale,locpe_scale,ref_W_aug,h_aug,wt_Dt
+      
+      lmetadyn=.true.
+      endmet=.false.          
+      
+      do while(.not.endmet)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+          cycle
+        elseif(findstring('endmet',directive,idum))then
+          endmet=.true.
+        elseif(findstring('ncolvar',directive,idum))then
+          ncolvar=intstr(directive,lenrec,idum)
+        elseif(findstring('lstein',directive,idum))then
+          lstein=.true.
+          if(findstring('false',directive,idum))lstein=.false.
+        elseif(findstring('ltet',directive,idum))then
+          ltet=.true.
+          if(findstring('false',directive,idum))ltet=.false.
+        elseif(findstring('lglobpe',directive,idum))then
+          lglobpe=.true.
+          if(findstring('false',directive,idum))lglobpe=.false.
+        elseif(findstring('llocpe',directive,idum))then
+          llocpe=.true.
+          if(findstring('false',directive,idum))llocpe=.false.
+        elseif(findstring('globpe_scale',directive,idum))then
+          globpe_scale=dblstr(directive,lenrec,idum)
+        elseif(findstring('locpe_scale',directive,idum))then
+          locpe_scale=dblstr(directive,lenrec,idum)
+        elseif(findstring('nq4',directive,idum))then
+          nq4=intstr(directive,lenrec,idum)
+          nq4=intstr(directive,lenrec,idum) ! do twice - number in name!
+        elseif(findstring('nq6',directive,idum))then
+          nq6=intstr(directive,lenrec,idum)
+          nq6=intstr(directive,lenrec,idum) ! do twice - number in name!
+        elseif(findstring('ntet',directive,idum))then
+          ntet=intstr(directive,lenrec,idum)
+        elseif(findstring('meta_step_int',directive,idum))then
+          meta_step_int=intstr(directive,lenrec,idum)
+        elseif(findstring('ref_w_aug',directive,idum))then
+          ref_W_aug=dblstr(directive,lenrec,idum)
+        elseif(findstring('h_aug',directive,idum))then
+          h_aug=dblstr(directive,lenrec,idum)
+        elseif(findstring('hkey',directive,idum))then
+          hkey=intstr(directive,lenrec,idum)
+        elseif(findstring('wt_dt',directive,idum))then
+          wt_dt=dblstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'metadynamics controls'
+     x    /,1x,'total number of collective variables',i10,
+     x    /,1x,'steinhardt parameters option (Q4/Q6)',l10,
+     x    /,1x,'tetrahedral parameters option (zeta)',l10,
+     x    /,1x,'global potential parameter option   ',l10,
+     x    /,1x,'local potential parameter option    ',l10,
+     x    /,1x,'global potential param. scale factor',e12.4,
+     x    /,1x,'local potential param. scale factor ',e12.4)")
+     x    ncolvar,lstein,ltet,lglobpe,llocpe,globpe_scale,locpe_scale
+        
+        write(nrite,
+     x    "(  1x,'number of Q4 atom pair types        ',i10,
+     x      /,1x,'number of Q6 atom pair types        ',i10,
+     x      /,1x,'number of zeta atom triplet types   ',i10)")
+     x    nq4,nq6,ntet
+        
+        write(nrite,
+     x    "(  1x,'gaussian deposition interval        ',i10,
+     x      /,1x,'reference gaussian height           ',e12.4,
+     x      /,1x,'gaussian width parameter            ',e12.4,
+     x      /,1x,'height control key                  ',i10,
+     x      /,1x,'well-tempered control parameter     ',e12.4)")
+     x    meta_step_int,ref_W_aug,h_aug,hkey,wt_Dt
+        
+      endif
+            
+      return
+      end subroutine metadyn_option
+      
+      subroutine ewald_selection
+     x  (directive,lhke,lspme,lewald,lcut,lforc,kill,idnode,keyfce,
+     x  imcon,nhko,nlatt,kmax1,kmax2,kmax3,alpha,rcut)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting the ewald method and reading 
+c     the required parameters
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lhke,lspme,lewald,lcut,lforc,kill,safe
+      integer idnode,keyfce,imcon,nhko,nlatt,kmax1,kmax2,kmax3,idum
+      integer kmaxpow2
+      real(8) alpha,rcut,eps,tol,fac,tol1
+      
+      lhke=findstring('hke',directive,idum)
+      lspme=findstring('spme',directive,idum)
+      lewald=findstring('ewald',directive,idum)
+      if(lewald)keyfce=2
+      if(lspme)keyfce=12
+      if(lhke)keyfce=14
+      if(idnode.eq.0)open(nconf,file='CONFIG')
+      call getrec(safe,idnode,nconf)
+      call getrec(safe,idnode,nconf)
+      imcon=intstr(record,lenrec,idum)
+      imcon=intstr(record,lenrec,idum)
+      if(.not.lhke.and.(imcon.eq.0.or.imcon.eq.6))then
+        
+        call error(idnode,-180)
+        kill=.true.
+        
+      endif
+      
+      if(findstring('precision',directive,idum))then
+        
+        eps=dblstr(directive,lenrec,idum)
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'Ewald sum  precision    ',7x,1p,e12.4)")eps
+        
+        if(lhke)then
+          
+          nhko=min(intstr(directive,lenrec,idum),3)
+          nlatt=min(intstr(directive,lenrec,idum),2)
+          if(nlatt.eq.0)nlatt=1
+          if(nhko.eq.0)nhko=1
+          
+        endif
+        
+        if(.not.lcut)then
+          call error(idnode,-433)
+          kill=.true.
+        else
+          
+c     retreive cell vectors
+          
+          call getrec(safe,idnode,nconf)
+          cell(1)=dblstr(record,lenrec,idum)
+          cell(2)=dblstr(record,lenrec,idum)
+          cell(3)=dblstr(record,lenrec,idum)
+          call getrec(safe,idnode,nconf)
+          cell(4)=dblstr(record,lenrec,idum)
+          cell(5)=dblstr(record,lenrec,idum)
+          cell(6)=dblstr(record,lenrec,idum)
+          call getrec(safe,idnode,nconf)
+          cell(7)=dblstr(record,lenrec,idum)
+          cell(8)=dblstr(record,lenrec,idum)
+          cell(9)=dblstr(record,lenrec,idum)
+          
+c     compute alpha and the kmax
+          
+          if(lewald.or.lspme)then
+            
+            call dcell(cell,celprp)
+            eps=min(abs(eps),0.5d0)
+            tol=sqrt(abs(log(eps*rcut)))
+            alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+            tol1=sqrt(-log(eps*rcut*(2.d0*tol*alpha)**2))
+            fac=1.d0
+            if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)
+     x        fac=2.d0**(1.d0/3.d0)
+            kmax1=nint(0.25d0+fac*celprp(1)*alpha*tol1/pi)
+            kmax2=nint(0.25d0+fac*celprp(2)*alpha*tol1/pi)
+            kmax3=nint(0.25d0+fac*celprp(3)*alpha*tol1/pi)
+            
+          elseif(lhke)then
+            
+            if(nhko.eq.0)then
+              if(eps.le.1.d-6)then
+                alpha=3.46d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=3.14d0/rcut
+              else
+                alpha=2.76d0/rcut
+              endif
+            elseif(nhko.eq.1)then
+              if(eps.le.1.d-6)then
+                alpha=4.37d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=4.08d0/rcut
+              else
+                alpha=3.75d0/rcut
+              endif                
+            elseif(nhko.eq.2)then
+              if(eps.le.1.d-6)then
+                alpha=5.01d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=4.74d0/rcut
+              else
+                alpha=4.44d0/rcut
+              endif
+            elseif(nhko.eq.3)then
+              if(eps.le.1.d-6)then
+                alpha=5.55d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=5.28d0/rcut
+              else
+                alpha=5.00d0/rcut
+              endif
+            endif
+            alpha=alpha/dble(2*nlatt+1)
+            if(abs(cell(9)).lt.1.d-8)cell(9)=1.d0
+            call dcell(cell,celprp)
+            tol=2.d0*alpha*sqrt(abs(log(eps*alpha)))
+            tol1=2.d0*alpha*sqrt(abs(log(eps*alpha*tol)))
+            kmax1=nint(0.25d0+0.5d0*celprp(1)*tol1/pi)
+            kmax2=nint(0.25d0+0.5d0*celprp(2)*tol1/pi)
+            kmax3=1
+            
+          endif
+          
+        endif
+        
+      else
+        
+        alpha=dblstr(directive,lenrec,idum)
+        kmax1=intstr(directive,lenrec,idum)
+        kmax2=intstr(directive,lenrec,idum)
+        
+        if(lhke)then
+          
+          kmax3=1
+          nhko=min(intstr(directive,lenrec,idum),3)
+          nlatt=min(intstr(directive,lenrec,idum),2)
+          
+        else
+          
+          kmax3=intstr(directive,lenrec,idum)
+          
+        endif
+        
+      endif
+      
+c     if spme double kmax and set to next power of 2, with current upper
+c     limit of 512.
+      
+      if(lspme)then
+        
+        kmaxpow2=1
+        do while (kmax1.gt.kmaxpow2.and.kmaxpow2.lt.256)
+          kmaxpow2=kmaxpow2 * 2
+        enddo
+        kmax1=2 * kmaxpow2
+        
+        kmaxpow2=1
+        do while (kmax2.gt.kmaxpow2.and.kmaxpow2.lt.256)
+          kmaxpow2=kmaxpow2 * 2
+        enddo
+        kmax2=2 * kmaxpow2
+        
+        kmaxpow2=1
+        do while (kmax3.gt.kmaxpow2.and.kmaxpow2.lt.256)
+          kmaxpow2=kmaxpow2 * 2
+        enddo
+        kmax3=2 * kmaxpow2
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        close(nconf)
+        
+        if(lspme)then
+          
+          write(nrite,
+     x      "(/,1x,'Electrostatics : SPME  ')")
+          
+          write(nrite,
+     x      "(/,1x,'Ewald convergence parameter    ',1p,e12.4,
+     x      /,1x,'Ewald kmax1 kmax2 kmax3     ',3i5)")
+     x      alpha,kmax1/2,kmax2/2,kmax3/2
+          
+        elseif(lhke)then
+          
+          write(nrite,
+     x      "(/,1x,'Electrostatics : Hautman-Klein-Ewald sum  ')")
+          
+          write(nrite,
+     x      "(/,1x,'Ewald convergence parameter    ',1p,e12.4,
+     x      /,1x,'Ewald kmax1 kmax2              ',2i5)")
+     x      alpha,kmax1,kmax2
+          
+          write(nrite,
+     x      "(1x,'HKE expansion order     ',7x,i10,
+     x      /,1x,'HKE lattice control     ',7x,i10)")nhko,nlatt
+          
+        else
+          
+          write(nrite,
+     x      "(/,1x,'Electrostatics : Ewald sum  ')")
+          
+          write(nrite,
+     x      "(/,1x,'Ewald convergence parameter    ',1p,e12.4,
+     x      /,1x,'Ewald kmax1 kmax2 kmax3     ',3i5)")
+     x      alpha,kmax1,kmax2,kmax3
+          
+        endif
+        
+      endif
+      
+      if(lspme)then
+        
+c     Initialize fft tables
+        
+CFFTW             call fftw3d_f77_create_plan
+CFFTW     x           (fplan,kmaxd,kmaxe,kmaxf,
+CFFTW     x            FFTW_FORWARD,FFTW_ESTIMATE+FFTW_IN_PLACE)
+CFFTW
+CFFTW             call fftw3d_f77_create_plan
+CFFTW     x           (bplan,kmaxd,kmaxe,kmaxf,
+CFFTW     x            FFTW_BACKWARD,FFTW_ESTIMATE+FFTW_IN_PLACE)
+        
+CSGIC             call zzfft3d( 0,kmaxd,kmaxe,kmaxf,1.d0,dummy,1,1,
+CSGIC     x                     dummy,1,1,ffttable,dummy,dummy )
+        
+CCRAY             call ccfft3d( 0,kmaxd,kmaxe,kmaxf,1.d0,dummy,1,1,
+CCRAY     x                     dummy,1,1,ffttable,dummy,dummy )
+        
+      endif
+      
+      if(lspme)then
+        
+        if(kmax1.gt.kmaxd.or.kmax2.gt.kmaxe.or.kmax3.gt.kmaxf)then
+          
+          kill=.true.
+          call error(idnode,-185)
+          
+        endif
+        
+      elseif(lhke)then
+        
+        if(kmax2.gt.kmaxb)then
+          
+          kill=.true.
+          call error(idnode,-185)
+          
+        endif
+        
+      else
+        
+        if(kmax2.gt.kmaxb.or.kmax3.gt.kmaxc)then
+          
+          kill=.true.
+          call error(idnode,-185)
+          
+        endif
+        
+      endif
+      
+      if(lforc)then
+        call  error(idnode,-416)
+        kill=.true.
+      endif
+      lforc=.true.
+      
+      return
+      end subroutine ewald_selection
+      
+      subroutine print_optim(keytol)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for printing the optimisation option
+c     the required parameters
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer keytol
+      
+      if(keytol.eq.0)then
+        write(nrite,
+     x    "(1x,'convergence to minimum force selected')")
+      elseif(keytol.eq.1)then
+        write(nrite,
+     x    "(1x,'convergence to minimum energy selected')")
+      else
+        write(nrite,
+     x    "(1x,'convergence to minimum position selected')")
+      endif
+      
+      return
+      end subroutine print_optim
+      
+      function energy_unit()
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for assigning energy conversion factors
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idum
+      real(8) energy_unit
+      
+      energy_unit=1.d0
+      if(findstring('ev',record,idum))then
+        energy_unit=9648.530821d0
+      elseif(findstring('kev',record,idum))then
+        energy_unit=9648530.821d0
+      elseif(findstring('kcal',record,idum))then
+        energy_unit=418.4d0
+      elseif(findstring('kj',record,idum))then
+        energy_unit=1.d2
+      elseif(findstring('k',record,idum))then
+        energy_unit=boltz
+      endif
+      
+      return
+      end function energy_unit
+      
+      subroutine solvation_option
+     x  (directive,lsolva,idnode,nsolva,isolva)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for solvation option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lsolva,endsol,safe
+      integer idnode,nsolva,isolva,idum
+      
+      lsolva=.true.
+      endsol=.false.
+      
+      nsolva=intstr(directive,lenrec,idum)
+      isolva=intstr(directive,lenrec,idum)
+      
+      if(nsolva.eq.0.and.isolva.eq.0)then
+        
+        do while(.not.endsol)
+          
+          call getrec(safe,idnode,nread)
+          if(.not.safe)call abort_control_read(1,idnode,nread)
+          call lowcase(record,lenrec)
+          call strip(record,lenrec)
+          call copystring(record,directive,lenrec)
+          
+          if(findstring('endsol',directive,idum))then
+            endsol=.true.
+          elseif(findstring('enddec',directive,idum))then
+            endsol=.true.
+          elseif(findstring('start',directive,idum))then
+            nsolva=intstr(directive,lenrec,idum)
+          elseif(findstring('inter',directive,idum))then
+            isolva=max(intstr(directive,lenrec,idum),1)
+          endif
+          
+        enddo
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'solvation calculation selected',
+     x    /,1x,'start of solvation calculation ',i10,
+     x    /,1x,'solvation calculation interval ',i10)")
+     x    nsolva,isolva
+        
+      endif
+      
+      return
+      end subroutine solvation_option
+      
+      subroutine free_energy_option(directive,lfree,lfrmas,idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for free energy option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lfree,lfrmas,endfre,safe
+      integer idnode,idum
+      
+      mfree=1
+      kfree=1
+      lfree=.true.
+      lfrmas=.false.
+      endfre=.false.
+      
+      do while(.not.endfre)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(findstring('endfre',directive,idum))then
+          endfre=.true.
+        elseif(findstring('start',directive,idum))then
+          nfrn=intstr(directive,lenrec,idum)
+        elseif(findstring('interval',directive,idum))then
+          ifrn=intstr(directive,lenrec,idum)
+        elseif(findstring('lambda',directive,idum))then
+          pfree=dblstr(directive,lenrec,idum)
+        elseif(findstring('mix',directive,idum))then
+          mfree=intstr(directive,lenrec,idum)
+        elseif(findstring('expo',directive,idum))then
+          kfree=intstr(directive,lenrec,idum)
+        elseif(findstring('reset_mass',directive,idum))then
+          lfrmas=.true.
+          if(findstring('false',directive,idum))lfrmas=.false.
+        elseif(findstring('system_a',directive,idum))then
+          ind_fre(1)=intstr(directive,lenrec,idum)
+          ind_fre(2)=intstr(directive,lenrec,idum)
+        elseif(findstring('system_b',directive,idum))then
+          ind_fre(3)=intstr(directive,lenrec,idum)
+          ind_fre(4)=intstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(mfree.eq.1)kfree=1
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'free energy option selected',
+     x    /,1x,'start of free energy calculation ',i10,
+     x    /,1x,'sampling interval                ',i10,
+     x    /,1x,'free energy parameter (lambda)   ',f10.3,
+     x    /,1x,'mixing rule selected             ',i10,
+     x    /,1x,'mixing rule exponent             ',i10,
+     x    /,1x,'system A first atom              ',i10,
+     x    /,1x,'system A last atom               ',i10,
+     x    /,1x,'system B first atom              ',i10,
+     x    /,1x,'system B last atom               ',i10,
+     x    /,1x,'mass scaling option              ',l10)")
+     x    nfrn,ifrn,pfree,mfree,kfree,ind_fre,lfrmas
+        
+      endif
+      
+c     define free energy scaling parameters
+
+      call freegen()
+      
+      return
+      end subroutine free_energy_option
+      
+      subroutine excitation_option
+     x  (directive,lsolva,lexcite,lghost,idnode,nsolva,isolva)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for excitation option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lsolva,lexcite,lghost,endexc,safe
+      integer idnode,nsolva,isolva,idum
+      
+      lsolva=.true.
+      lghost=.true.
+      lexcite=.true.
+      endexc=.false.
+      
+      do while(.not.endexc)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(findstring('endexc',directive,idum))then
+          endexc=.true.
+        elseif(findstring('start',directive,idum))then
+          nsolva=intstr(directive,lenrec,idum)
+        elseif(findstring('inter',directive,idum))then
+          isolva=intstr(directive,lenrec,idum)
+        elseif(findstring('system_a',directive,idum))then
+          ind_fre(1)=intstr(directive,lenrec,idum)
+          ind_fre(2)=intstr(directive,lenrec,idum)
+        elseif(findstring('system_b',directive,idum))then
+          ind_fre(3)=intstr(directive,lenrec,idum)
+          ind_fre(4)=intstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'excitation option selected',
+     x    /,1x,'energy decomposition start       ',i10,
+     x    /,1x,'energy decomposition interval    ',i10,
+     x    /,1x,'system A first atom              ',i10,
+     x    /,1x,'system A last atom               ',i10,
+     x    /,1x,'system B first atom              ',i10,
+     x    /,1x,'system B last atom               ',i10)")
+     x   nsolva,isolva,ind_fre
+        
+      endif
+      
+      return
+      end subroutine excitation_option
+      
+      subroutine switching_option
+     x  (directive,lsolva,lswitch,lghost,idnode,nsolva,isolva)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for switching option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lsolva,lswitch,lghost,endswi,safe
+      integer idnode,nsolva,isolva,idum
+      
+      lsolva=.true.
+      lghost=.true.
+      lswitch=.true.
+      endswi=.false.
+      niswitch=0
+      
+      do while(.not.endswi)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(findstring('endswi',directive,idum))then
+          endswi=.true.
+        elseif(findstring('start',directive,idum))then
+          nsolva=intstr(directive,lenrec,idum)
+        elseif(findstring('inter',directive,idum))then
+          isolva=intstr(directive,lenrec,idum)
+        elseif(findstring('period',directive,idum))then
+          niswitch=max(intstr(directive,lenrec,idum),2)
+        elseif(findstring('system_a',directive,idum))then
+          ind_fre(1)=intstr(directive,lenrec,idum)
+          ind_fre(2)=intstr(directive,lenrec,idum)
+        elseif(findstring('system_b',directive,idum))then
+          ind_fre(3)=intstr(directive,lenrec,idum)
+          ind_fre(4)=intstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(niswitch.eq.0)niswitch=nsolva
+      nswitch=nsolva
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'switching option selected',
+     x    /,1x,'energy decomposition start       ',i10,
+     x    /,1x,'energy decomposition interval    ',i10,
+     x    /,1x,'switching period                 ',i10,
+     x    /,1x,'system A first atom              ',i10,
+     x    /,1x,'system A last atom               ',i10,
+     x    /,1x,'system B first atom              ',i10,
+     x    /,1x,'system B last atom               ',i10)")
+     x   nsolva,isolva,niswitch,ind_fre
+        
+      endif
+      
+      return
+      end subroutine switching_option
+      
+      end module define_system_module
+      
diff -urN dl_class_1.9.orig/srcmod/define_system_module.f.preplumed dl_class_1.9/srcmod/define_system_module.f.preplumed
--- dl_class_1.9.orig/srcmod/define_system_module.f.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/define_system_module.f.preplumed	2011-10-17 17:32:15.000000000 +0200
@@ -0,0 +1,5994 @@
+      module define_system_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for utility subroutines and functions
+c     copyright - daresbury laboratory
+c     author    - w. smith     aug 2006
+c     adapted   - p.-a. cazade oct 2007, solvation, free energy
+c     and excitation
+c     adapted   - d. quigley nov 2010, metadynamics
+c     
+c***********************************************************************
+      
+      use angles_module
+      use bonds_module
+      use config_module
+      use core_shell_module
+      use dihedral_module
+      use ensemble_tools_module
+      use error_module
+      use ewald_module
+      use exclude_module
+      use external_field_module
+      use four_body_module
+      use hkewald_module
+      use hyper_dynamics_module
+      use inversion_module
+      use metafreeze_module
+      use metal_module
+      use parse_module
+      use pmf_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use solvation_module
+      use spme_module
+      use temp_scalers_module
+      use tersoff_module
+      use tether_module
+      use three_body_module
+      use vdw_module
+      
+      contains
+      
+      subroutine simdef
+     x  (seek,lfcap,lgofr,lnsq,loptim,lzero,lminim,lpgr,ltraj,ltscal,
+     x  lzeql,lzden,nolink,newgau,lhit,lbpd,ltad,lneb,prechk,tadall,
+     x  lsolva,lfree,lfrmas,lexcite,lswitch,lghost,lnfic,nebgo,lpsoc,
+     x  idnode,minstp,intsta,istraj,keybpd,keyens,keyfce,keyres,keyver,
+     x  keytrj,kmax1,kmax2,kmax3,multt,nstack,nstbgr,nsbzdn,nstbpo,
+     x  nhko,nlatt,nstbts,nsteql,nstraj,nstrun,nospl,keytol,numgau,
+     x  khit,nhit,nblock,ntrack,blkout,numneb,mode,nsolva,isolva,nofic,
+     x  alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup,taut,
+     x  temp,timcls,timjob,tolnce,tstep,rlxtol,opttol,zlen,ehit,xhit,
+     x  yhit,zhit,ebias,vmin,catchrad,sprneb,deltad,tlow,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading in the simulation control 
+c     parameters
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith july 1992.
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c     modified
+c     author   - t.forester       may  1993
+c     amended  - t.forester       sept 1994 - dl_poly_1.1
+c     amended  - t.forester       nov  1994 - macro version
+c     amended  - w.smith          dec  1994 - t3d adaptation
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit,seek
+      character*1 hms
+      character*1 directive(lenrec)
+      logical lsolva,lfree,lfrmas,lexcite,lswitch,lghost,lnfic,lpsoc
+      logical ltscal,lzeql,loptim,ltraj,lfcap,lgofr,lpgr,lpres,safe
+      logical lstep,ltemp,lcut,ldelr,lprim,lforc,lens,lvdw,lrvdw,kill
+      logical lnsq,lzden,lewald,lspme,lhke,loop,lzero,nolink,newgau
+      logical lminim,lminopt,ltad,lneb,lhit,lbpd,prechk,tadall,nebgo
+      integer idnode,intsta,istraj,keyens,keyfce,keyres,nstbpo,nsbzdn
+      integer keytrj,kmax1,kmax2,kmax3,multt,nstack,nstbgr,khit,nhit
+      integer nhko,nlatt,nstbts,nsteql,nstraj,nstrun,nospl,ntrack
+      integer idum,imcon,keyver,keytol,nblock,blkout,numgau
+      integer minstp,numneb,i,keybpd,mode,nsolva,isolva,nofic
+      real(8) alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup
+      real(8) taut,temp,timcls,timjob,tolnce,tstep,rlxtol,opttol
+      real(8) eps,tol,fm,densvar,delrdf,delzdn,zlen,ehit,hyp_units
+      real(8) catchrad,sprneb,deltad,tlow,xhit,yhit,zhit,ebias,vmin
+      real(8) prntim
+      
+CSGIC      real(8) dummy
+CCRAY      real(8) dummy
+CFFTWc     FFTW instruction codes
+CFFTW
+CFFTW      integer FFTW_FORWARD,FFTW_BACKWARD
+CFFTW      parameter (FFTW_FORWARD=-1,FFTW_BACKWARD=1)
+CFFTW
+CFFTW      integer FFTW_REAL_TO_COMPLEX,FFTW_COMPLEX_TO_REAL
+CFFTW      parameter (FFTW_REAL_TO_COMPLEX=-1,FFTW_COMPLEX_TO_REAL=1)
+CFFTW
+CFFTW      integer FFTW_ESTIMATE,FFTW_MEASURE
+CFFTW      parameter (FFTW_ESTIMATE=0,FFTW_MEASURE=1)
+CFFTW
+CFFTW      integer FFTW_OUT_OF_PLACE,FFTW_IN_PLACE,FFTW_USE_WISDOM
+CFFTW      parameter (FFTW_OUT_OF_PLACE=0)
+CFFTW      parameter (FFTW_IN_PLACE=8,FFTW_USE_WISDOM=16)
+CFFTW
+CFFTW      integer FFTW_THREADSAFE
+CFFTW      parameter (FFTW_THREADSAFE=128)
+CFFTW
+      
+c     intitialize system variables: temperature,pressure,ensemble key
+c     force key, cutoff, primary cutoff, verlet shell width, relative
+c     dielectric constant,timestep,temperature scaling flag, 
+c     temp scaling interval
+      
+      mode=0
+      nhko=0
+      nlatt=0
+      nsteql=0
+      nstrun=0
+      minstp=0
+      keybpd=0
+      keyres=0
+      keyens=0
+      keyver=0
+      taut=0.d0
+      nstbts=0
+      nstbgr=0
+      nsbzdn=0
+      nstbpo=100
+      nstack=mxstak
+      intsta=0
+      nstraj=0
+      istraj=1
+      keytrj=0
+      numgau=1
+      alpha=0.d0
+      kmax1=0
+      kmax2=0
+      kmax3=0
+      nospl=min(8,mxspl)
+      isolva=1
+      nsolva=0
+      niswitch=0
+      nswitch=0
+      nofic=1000
+      
+      fmax=1000.d0
+      keyfce=0
+      multt=1
+      keytol=0
+      tstep=0.d0
+      temp=0.d0
+      press=0.d0
+      rcut=0.d0
+      rprim=0.d0
+      rvdw=0.d0
+      delr=0.d0
+      epsq=1.d0
+      rlxtol=1.d0
+      opttol=1.d0
+      tolnce=1.d-8
+      quattol=1.d-8
+      timjob=0.d0
+      timcls=0.d0
+      delrdf=0.d0
+      delzdn=0.d0
+      zlen=0.d0
+      ehit=0.d0
+      xhit=0.d0
+      yhit=0.d0
+      zhit=0.d0
+      vmin=0.d0
+      ebias=0.d0
+      catchrad=0.d0
+      pfree=0.d0
+      
+      lhit=.false.
+      lbpd=.false.
+      ltad=.false.
+      lneb=.false.
+      loop=.true.
+      lnfic=.false.
+      lpsoc=.false.
+      lzero=.false.
+      ltscal=.false.
+      lewald=.false.
+      lspme=.false.
+      lhke=.false.
+      lgofr=.false.
+      lpgr=.false.
+      lzeql=.true.
+      loptim=.false.
+      lminim=.false.
+      lminopt=.false.
+      ltraj=.false.
+      lfcap=.false.
+      ltemp=.false.
+      lstep=.false.
+      lcut=.false.
+      ldelr=.false.
+      lprim=.false.
+      lforc=.false.
+      lens=.false.
+      lvdw=.false.
+      lrvdw=.false.
+      lpres=.false.
+      kill=.false.
+      lnsq=.false.
+      lzden=.false.
+      nolink=.false.
+      newgau=.false.
+      prechk=.false.
+      tadall=.false.
+      lsolva=.false.
+      lfree=.false.
+      lfrmas=.false.
+      lexcite=.false.
+      lswitch=.false.
+      lghost=.false.
+      nebgo=.true.
+      seek='all     '
+      
+c     open the simulation input file
+      
+      if(idnode.eq.0)open(nread,file='CONTROL',status='old')
+      
+c     read job title
+      
+      call getrec(safe,idnode,nread)
+      if(.not.safe)call abort_control_read(1,idnode,nread)
+      
+      call copystring(record,sysname,80)
+      if(idnode.eq.0)then 
+        
+        write(nrite,"(3(1x,120('*'),/),1x,15('*'),5x,80a1,5x,15('*'),/,
+     x    3(1x,120('*'),/),/,/,1x,'SIMULATION CONTROL PARAMETERS',/)")
+     x    sysname
+        
+      endif
+      
+c     read and process directives from CONTROL file
+      
+      do while(loop)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        
+c     convert to lowercase and strip out leading blanks
+        
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.' ')then
+          
+c     record is commented out
+          cycle
+          
+        elseif(findstring('redirect',directive,idum))then
+          
+c     ignore this option in this context
+          cycle
+          
+        elseif(findstring('steps',directive,idum))then
+          
+c     number of timesteps
+          
+          nstrun=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'selected number of timesteps',3x,i10)")nstrun
+          
+        elseif(findstring('integ',directive,idum))then
+          
+c     choice of integration algorithm
+          
+          if(findstring('leapfrog',directive,idum))then
+            
+            keyver=0
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'leapfrog verlet integration selected')")
+            
+          elseif(findstring('velocity',directive,idum))then
+            
+            keyver=1
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'velocity verlet integration selected')")
+            
+          endif
+          
+        elseif(findstring('no fic',directive,idum))then
+          
+c     cancel possible "flying ice cube" in Berendsen thermostats
+          
+          lnfic=.true.
+          nofic=intstr(directive,lenrec,idum)
+          
+        elseif(findstring('shells',directive,idum).and.
+     x      findstring('on',directive,idum).and.
+     x      findstring('cores',directive,idum))then
+          
+c     put shells on cores at start - shell model only (else null)
+          
+          lpsoc=.true.
+          
+        elseif(findstring('densvar',directive,idum))then
+          
+c     specify allowed density variation
+          
+          densvar=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'allowed density variation   ',3x,1p,e12.4)")
+     x      densvar
+          
+        elseif(findstring('no link',directive,idum))then
+          
+c     switch off link cell option
+          
+          nolink=.true.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'link cells option deactivated')")
+          
+        elseif(findstring('equil',directive,idum))then
+          
+c     number of equilibration timesteps
+          
+          nsteql=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'equilibration period        ',3x,i10)")nsteql
+          
+        elseif(findstring('restart',directive,idum))then
+          
+c     restart control
+          
+          if(findstring('noscale',directive,idum))then
+            
+            keyres=3
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'noscale restart requested')")
+            
+          elseif(findstring('scale',directive,idum))then
+            
+            keyres=2
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'scaled restart requested')")
+            
+          else
+            
+            keyres=1
+            if(idnode.eq.0)write(nrite,"(/,1x,'restart requested')")
+            
+          endif
+          
+        elseif(findstring('ensemble',directive,idum))then
+          
+c     ensemble selection
+          
+          call ensemble_selection(directive,lens,kill,idnode,keyens,
+     x      mode,taut,taup)
+          
+        elseif(findstring('regauss',directive,idum))then
+          
+c     re-initialise velocities option (regaussing)
+          
+          newgau=.true.
+          numgau=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'regaussing option activated',
+     x      /,1x,'regaussing interval set to  ',3x,i10)")
+     x      numgau
+          
+        elseif(findstring('scale',directive,idum))then
+          
+          nstbts=intstr(directive,lenrec,idum)
+          if(nstbts.gt.0)then
+            ltscal=.true.
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'temperature scaling on' 
+     x        /,1x,'temperature scaling interval',3x,i10)")
+     x        nstbts
+            
+          endif
+          
+        elseif(findstring('rdf',directive,idum))then
+          
+          if(findstring('print',directive,idum))then
+            
+            lpgr=.true.
+            lpgr=(lgofr.and.lpgr)
+            if(idnode.eq.0)write(nrite,
+     x        "(/,1x,'g(r) printing option on      ')")
+          
+          else
+            
+            lgofr=.true.
+            nstbgr=intstr(directive,lenrec,idum)
+            delrdf=dblstr(directive,lenrec,idum)
+            if(nstbgr.eq.0)nstbgr=10
+            if(delrdf.lt.1.d-8)delrdf=0.05d0
+            
+            if(idnode.eq.0)then
+              
+              write(nrite,
+     x          "(/,/,1x,'radial distribution functions on ',
+     x          /,1x,'g(r) collection interval    ',3x,i10)")nstbgr
+              write(nrite,
+     x          "(1x,'g(r) bin width              ',3x,1p,e12.4)")
+     x          delrdf
+              
+            endif
+            
+          endif
+          
+        elseif(findstring('zden',directive,idum))then
+          
+          lzden=.true.
+          nsbzdn=intstr(directive,lenrec,idum)
+          delzdn=dblstr(directive,lenrec,idum)
+          zlen=dblstr(directive,lenrec,idum)
+          if(nsbzdn.eq.0)nsbzdn=10
+          if(delzdn.lt.1.d-8)then
+            zlen=0.1d0*dble(mxzdn)
+            delzdn=0.1d0
+          elseif(zlen.lt.1.d-8)then
+            zlen=delzdn*dble(mxzdn)
+          endif
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,/,1x,'Z density profile requested',
+     x        /,1x,'zdensity collection interval',3x,i10)")nsbzdn
+            write(nrite,
+     x        "(1x,'zdensity bin width          ',3x,1p,e12.4)")
+     x        delzdn
+            write(nrite,
+     x        "(1x,'zdensity range              ',3x,1p,e12.4)")
+     x        zlen
+            
+          endif
+          
+        elseif(findstring('collect',directive,idum))then
+          
+          lzeql=.false.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'equilibration included in overall averages')")
+          
+        elseif(findstring('neb',directive,idum))then
+          
+c     activate nudged elastic band option
+          
+          call neb_option(directive,lneb,lminopt,idnode,
+     x      numneb,keytol,sprneb,opttol,hyp_units)
+          
+        elseif(findstring('impact',directive,idum))then
+          
+c     activate the impact option
+          
+          if(lhit)call error(idnode,516)
+          lhit=.true.
+          khit=intstr(directive,lenrec,idum)
+          nhit=intstr(directive,lenrec,idum)
+          ehit=dblstr(directive,lenrec,idum)
+          xhit=dblstr(directive,lenrec,idum)
+          yhit=dblstr(directive,lenrec,idum)
+          zhit=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)then
+            
+            write(nrite,"(/,1x,'impact option selected')")
+            write(nrite,"(
+     x        /,1x,'identity of impact atom        ',i10,
+     x        /,1x,'time step of impact            ',i10,
+     x        /,1x,'impact recoil energy (keV)     ',1p,e12.4,
+     x        /,1x,'impact direction (x component) ',1p,e12.4,
+     x        /,1x,'impact direction (y component) ',1p,e12.4,
+     x        /,1x,'impact direction (z component) ',1p,e12.4)")
+     x        khit,nhit,ehit,xhit,yhit,zhit
+            
+          endif
+          
+c     convert impact energy from keV to internal units
+          
+          ehit=ehit*9648530.821d0
+          
+        elseif(findstring('bpd',directive,idum))then
+          
+c     activate the BPD option
+          
+          call bpd_option(directive,seek,lbpd,ltad,lminopt,prechk,
+     x      nebgo,keybpd,idnode,nblock,ntrack,keytol,ebias,vmin,
+     x      catchrad,sprneb,opttol,hyp_units)
+          
+        elseif(findstring('tad',directive,idum))then
+          
+c     activate temperature accelerated dynamics option
+          
+          call tad_option(directive,ltad,lbpd,lminopt,prechk,tadall,
+     x      idnode,nblock,ntrack,blkout,keytol,catchrad,sprneb,tlow,
+     x      deltad,opttol,hyp_units)
+          
+        elseif(findstring('minim',directive,idum))then
+          
+          if(lminopt)call error(idnode,225)
+          if(findstring('forc',directive,idum))keytol=0
+          if(findstring('ener',directive,idum))keytol=1
+          if(findstring('posi',directive,idum))keytol=2
+          hyp_units=energy_unit()
+          minstp=intstr(directive,lenrec,idum)
+          opttol=dblstr(directive,lenrec,idum)
+          call getword(cunit,directive,8,lenrec)
+          lminim=.true.
+          loptim=.false.
+          lzero=.false.
+          ltscal=.false.
+          lminopt=.true.
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,1x,'minimisation programme requested')")
+            write(nrite,
+     x        "(1x,'structure minimisation interval ',
+     x        3x,i10)")minstp
+            call print_optim(keytol)
+            write(nrite,
+     x        "(1x,'structure minimisation tolerance',
+     x        3x,1p,e12.4,1x,a8)")opttol,cunit
+            
+          endif
+          if(keytol.lt.2)opttol=opttol*hyp_units
+          
+        elseif(findstring('optim',directive,idum))then
+          
+          if(lminopt)call error(idnode,225)
+          if(findstring('forc',directive,idum))keytol=0
+          if(findstring('ener',directive,idum))keytol=1
+          if(findstring('posi',directive,idum))keytol=2
+          hyp_units=energy_unit()
+          opttol=dblstr(directive,lenrec,idum)
+          call getword(cunit,directive,8,lenrec)
+          loptim=.true.
+          lminim=.false.
+          lzero=.false.
+          ltscal=.false.
+          lminopt=.true.
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,1x,'structure optimisation requested')")
+            call print_optim(keytol)
+            write(nrite,
+     x        "(1x,'tolerance for structure optimisation ',
+     x        3x,1p,e12.4,1x,a8)")opttol,cunit
+            
+          endif
+          if(keytol.lt.2)opttol=opttol*hyp_units
+          
+        elseif(findstring('zero',directive,idum))then
+          
+          if(lminopt)call error(idnode,225)
+          temp=1.d0
+          lzero=.true.
+          loptim=.false.
+          lminim=.false.
+          ltemp=.true.
+          ltscal=.false.
+          lminopt=.true.
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,
+     x        "(/,1x,'zero K optimisation requested')")
+            write(nrite,
+     x        "(' temperature reset to',1p,e12.4)")1.d0
+            
+          endif
+          
+        else if(findstring('solva',directive,idum))then
+          
+          call solvation_option
+     x      (directive,lsolva,idnode,nsolva,isolva)
+          
+        else if(findstring('decomp',directive,idum))then
+          
+          call solvation_option
+     x      (directive,lsolva,idnode,nsolva,isolva)
+          
+        elseif(findstring('metafreeze',directive,idum).or.
+     x      findstring('metadyn',directive,idum))then
+          
+c     activate metadynamics option - d. quigley
+          
+          call metadyn_option
+     x      (directive,lmetadyn,lstein,ltet,lglobpe,llocpe,idnode,
+     x      ncolvar,nq4,nq6,ntet,hkey,meta_step_int,globpe_scale,
+     x      locpe_scale,ref_W_aug,h_aug,wt_Dt)
+          
+        else if(findstring('free',directive,idum))then
+          
+          call free_energy_option(directive,lfree,lfrmas,idnode)
+          
+        else if(findstring('excite',directive,idum))then
+          
+          call excitation_option
+     x      (directive,lsolva,lexcite,lghost,idnode,nsolva,isolva)
+          
+        else if(findstring('switch',directive,idum))then
+          
+          call switching_option
+     x      (directive,lsolva,lswitch,lghost,idnode,nsolva,isolva)
+          
+        elseif(findstring('print',directive,idum))then
+          
+          nstbpo=intstr(directive,lenrec,idum)
+          nstbpo=max(nstbpo,1)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'data printing interval      ',3x,i10)")nstbpo
+          
+        elseif(findstring('stack',directive,idum))then
+          
+          nstack=intstr(directive,lenrec,idum)
+          
+c     reset stack limit if too large
+          
+          nstack=min(nstack,mxstak)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'data stacking interval      ',3x,i10)")nstack
+          
+        elseif(findstring('stats',directive,idum))then
+          
+          intsta=intstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'statistics file interval    ',3x,i10)")intsta
+          
+        elseif(findstring('traj',directive,idum))then
+          
+          ltraj=.true.
+          nstraj=intstr(directive,lenrec,idum)
+          istraj=max(intstr(directive,lenrec,idum),1)
+          keytrj=intstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'trajectory file option on  ',
+     x      /,1x,'trajectory file start       ',3x,i10,
+     x      /,1x,'trajectory file interval    ',3x,i10
+     x      /,1x,'trajectory file info key    ',3x,i10)")
+     x      nstraj,istraj,keytrj
+          
+        elseif(findstring('ewald',directive,idum).or.
+     x      findstring('spme',directive,idum).or.
+     x      findstring('hke',directive,idum))then
+          
+c     read Ewald or HK-Ewald or SPM-Ewald sum parameters
+          
+          call ewald_selection(directive,lhke,lspme,lewald,lcut,
+     x      lforc,kill,idnode,keyfce,imcon,nhko,nlatt,kmax1,kmax2,
+     x      kmax3,alpha,rcut)
+          
+        elseif(findstring('distan',directive,idum))then
+          
+          keyfce=4
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : Distance dependent dielectric')")
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('coul',directive,idum))then
+          
+          keyfce=6
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : Coulombic potential')")
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('shift',directive,idum))then
+          
+          keyfce=8
+          alpha=0.d0
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : Shifted Coulombic potential')")
+          
+          if(findstring('precision',directive,idum))then
+            
+            eps=dblstr(directive,lenrec,idum)
+            if(.not.lcut)then
+              call error(idnode,-435)
+              kill=.true.
+            else
+              
+              eps=min(abs(eps),0.5d0)
+              tol=sqrt(abs(log(eps*rcut)))
+              alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+              if(idnode.eq.0)then
+                
+                write(nrite,
+     x            "(1x,'Specified precision parameter : ',1p,
+     x            e12.4)")eps
+                write(nrite,
+     x            "(1x,'Calculated damping parameter: ',1p,
+     x            e12.4)")alpha
+                
+              endif
+              
+            endif
+            
+          elseif(findstring('damp',directive,idum))then
+            
+            alpha=dblstr(directive,lenrec,idum)
+            if(idnode.eq.0)write(nrite,
+     x        "(1x,'Specified damping parameter : ',1p,e12.4)")
+     x        alpha
+            
+          endif
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('reaction',directive,idum))then
+          
+          keyfce=10
+          alpha=0.d0
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'Electrostatics : reaction field')")
+          
+          if(findstring('precision',directive,idum))then
+            
+            eps=dblstr(directive,lenrec,idum)
+            if(.not.lcut)then
+              call error(idnode,-435)
+              kill=.true.
+            else
+              
+              eps=min(abs(eps),0.5d0)
+              tol=sqrt(abs(log(eps*rcut)))
+              alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+              if(idnode.eq.0)then
+                
+                write(nrite,
+     x            "(1x,'Specified precision parameter : ',1p,
+     x            e12.4)")eps
+                write(nrite,
+     x            "(1x,'Calculated damping parameter: ',1p,
+     x            e12.4)")alpha
+                
+              endif
+              
+            endif
+            
+          elseif(findstring('damp',directive,idum))then
+            
+            alpha=dblstr(directive,lenrec,idum)
+            if(idnode.eq.0)write(nrite,
+     x        "(1x,'Specified damping parameter : ',1p,e12.4)")
+     x        alpha
+            
+          endif
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('cap',directive,idum))then
+          
+          lfcap=.true.
+          fm=dblstr(directive,lenrec,idum)
+          if(fm.gt.0.d0)fmax=fm
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'force capping :',16x,1p,e12.4,' kT/A')")fmax
+          
+        elseif(findstring('no vdw',directive,idum))then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'short-range potential terms off')")
+          lvdw=.true.
+          
+        elseif(findstring('no elec',directive,idum))then
+          
+          keyfce=0
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'electrostatic potential terms off')")
+          
+          if(lforc)then
+            call  error(idnode,-416)
+            kill=.true.
+          endif
+          
+          lforc=.true.
+          
+        elseif(findstring('mult',directive,idum))then
+          
+          multt=max(intstr(directive,lenrec,idum),1)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'multiple timestep interval  ',3x,i10)")multt
+          
+        elseif(findstring('timestep',directive,idum))then
+          
+          lstep=.true.
+          tstep=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'simulation timestep         ',3x,1p,e12.4)")tstep
+          
+        elseif(findstring('temp',directive,idum))then
+          
+          ltemp=.true.
+          temp=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'simulation temperature      ',3x,1p,e12.4)")temp
+          
+        elseif(findstring('pres',directive,idum))then
+          
+          press=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'simulation pressure (katm)  ',3x,1p,e12.4)")press
+          
+c     convert from katm to internal units of pressure
+          
+          press=press/prsunt
+          lpres=.true.
+          
+        elseif(findstring('prim',directive,idum))then
+          
+c     primary cutoff
+          
+          lprim=.true.
+          rprim=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'primary neighbour cut off   ',3x,1p,e12.4)")rprim
+          
+        elseif(findstring('rvdw',directive,idum))then
+          
+c     cutoff for short range potentials
+          
+          rvdw=dblstr(directive,lenrec,idum)
+          lrvdw=.true.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'real space cut off (vdw)    ',3x,1p,e12.4)")rvdw
+          
+        elseif(findstring('delr',directive,idum))then
+          
+c     Verlet shell width
+          
+          ldelr=.true.
+          delr=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'border width of Verlet shell',3x,1p,e12.4)")delr
+          
+        elseif(findstring('cut',directive,idum))then
+          
+c     cutoff
+          
+          lcut=.true.
+          rcut=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'real space cut off          ',3x,1p,e12.4)")rcut
+          
+        elseif(findstring('eps',directive,idum))then
+          
+c     relative dielectric constant
+          
+          epsq=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,/,1x,'relative dielectric constant',3x,1p,e12.4)")epsq
+          
+        elseif(findstring('rlxtol',directive,idum))then
+          
+c     force tolerance for shell relaxation
+          
+          rlxtol=max(rlxtol,dblstr(directive,lenrec,idum))
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'tolerance for shell relaxn. ',3x,1p,e12.4)")rlxtol
+          
+        elseif(findstring('shake',directive,idum))then
+          
+c     tolerance for shake
+          
+          tolnce=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'tolerance for SHAKE         ',3x,1p,e12.4)")tolnce
+          
+        elseif(findstring('quaternion',directive,idum))then
+          
+c     tolerance for quaternion integration
+          
+          quattol=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'tolerance for Quaternions   ',3x,1p,e12.4)")quattol
+          
+        elseif(findstring('job time',directive,idum))then
+          
+c     time for simulation (in seconds/minutes/hours/days or indefinite)
+          
+          if(findstring('indef',directive,idum))then
+             timjob=1.0d6*365.25d0*24.d0*60.d0*60.d0
+          else
+             timjob=dblstr(directive,lenrec,idum)
+             if(findstring('m',directive,idum))then
+               timjob=6.0d1*timjob
+             elseif(findstring('h',directive,idum))then
+               timjob=3.6d3*timjob
+             elseif(findstring('d',directive,idum))then
+               timjob=8.64d4*timjob
+             endif
+          endif
+          
+          call get_prntime(hms,timjob,prntim)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'user allocated job time (',a1,') ',3x,f8.4)")
+     x      hms,prntim
+          
+        elseif(findstring('close time',directive,idum))then
+          
+c     time for winding up a job (in seconds)
+          
+          timcls=dblstr(directive,lenrec,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'job closure time        (s) ',3x,f8.3)")timcls
+          
+        elseif(findstring('all pairs',directive,idum))then
+          
+c     full minimum image - N^2 interactions each timestep
+          
+          lnsq=.true.
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'All-pairs requested for electrostatics')")
+          
+        elseif(findstring('nospl',directive,idum))then
+          
+c     set ewald_spme interpolation order
+          
+          nospl=intstr(directive,lenrec,idum)
+          
+        elseif(findstring('finish',directive,idum))then
+          
+c     safe termination of reading CONTROL file
+          
+          loop=.false.
+          
+        else
+          
+c     unrecognised directive in control file
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+      enddo
+      
+c     check on steps before temperature scaling
+      
+      if(nstbts.eq.0)nstbts=nstrun+1
+      
+c     conduct consistency checks on directives
+      
+      if(lminim)then
+        
+c     ensure final configuration follows minimisation
+        
+        if(minstp.eq.0)minstp=nstrun
+        nstrun=minstp*(nstrun/minstp)
+        
+      endif
+      
+c     check force activation options
+      
+      if(.not.lforc)then
+        
+c     check if any forces are in operation
+        
+        if(.not.lvdw)then
+          
+          kill=.true.
+          call error(idnode,-383)
+          
+        endif
+        
+      else
+        
+c     turn on short range forces
+        
+        if(lvdw)then
+          
+          if(keyfce.eq.0)then
+            
+            lcut=.true.
+            ldelr=.true.
+            
+          endif
+          
+        else
+          
+          keyfce=keyfce+1
+          
+        endif
+        
+      endif
+      
+c     if tad selected use only leap frog
+      
+      if(ltad.and.keyver.eq.1)then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'switching to leapfrog for TAD dynamics')")
+        keyver=0
+        
+      endif
+      
+c     error checking 
+      
+      if(lmetadyn.and.keyens.ne.3.and.keyens.ne.5.and.keyens.ne.7)then
+        
+        kill=.true.
+        call error(idnode,-2360)
+        
+      endif
+      
+      if(lsolva.or.lfree.or.lexcite.or.lswitch)then
+        
+        if(lspme)then
+          
+          kill=.true.
+          call error(idnode,-601)
+          
+        endif
+        
+        if(lhke)then
+          
+          kill=.true.
+          call error(idnode,-602)
+          
+        endif
+        
+      endif
+      
+      if(lghost.and.nstbgr.ne.isolva)then
+        
+        call warning(idnode,130,dble(isolva),0.d0,0.d0)
+        nstbgr=isolva
+        
+      endif
+      if(lfree.and.lgofr)then
+        
+        call warning(idnode,140,0.d0,0.d0,0.d0)
+        lgofr=.false.
+        lpgr=.false.
+        
+      endif
+      if(loptim)then
+        
+        temp=0.d0
+        
+      elseif(.not.ltemp)then
+        
+        kill=.true.
+        call error(idnode,-380)
+        
+      endif
+      
+      if(.not.lstep)then
+        
+        kill=.true.
+        call error(idnode,-381)
+        
+      endif
+      
+      if(.not.lcut)then
+        
+        kill=.true.
+        call error(idnode,-382)
+        
+      endif
+      
+c     check if van der Waals cutoff set
+      
+      if(.not.lrvdw.and.mod(keyfce,2).eq.1)then
+        
+        if(rcut.gt.0.d0)then
+          
+          rvdw=rcut
+          
+        else
+          
+          kill=.true.
+          call error(idnode,-402)
+          
+        endif      
+        
+      endif
+      
+      if(.not.ldelr)then
+        
+        kill=.true.
+        call error(idnode,-384)
+        
+      endif
+      
+      if(multt.gt.1)then
+        
+        if(.not.lprim)then
+          
+          kill=.true.
+          call error(idnode,-385)
+          
+        elseif(rprim.gt.rcut)then
+          
+          kill=.true.
+          call error(idnode,-386)
+          
+        endif
+        
+      endif
+      
+c     check settings in nvt ensemble
+      
+      if(keyens.ge.2.and.keyens.le.3)then
+        
+        if(taut.le.0.d0)then
+          
+          kill=.true.
+          call error(idnode,-464)
+          
+        endif
+        
+      endif
+      
+c     check settings in npt ensemble
+      
+      if(keyens.ge.4.and.keyens.le.7)then
+        
+        if(.not.lpres)then
+          
+          kill=.true.
+          call error(idnode,-387)
+          
+        endif
+        
+c     check barostat and thermostat rates non zero
+        
+        if(taut.le.0.d0)then
+          
+          kill=.true.
+          call error(idnode,-464)
+          
+        endif
+        if(taup.le.0.d0)then
+          
+          kill=.true.
+          call error(idnode,-466)
+          
+        endif
+        
+      endif
+      
+c     check multiple timestep cutoffs are sensible
+      
+      if(multt.gt.1)then
+        if(rcut-rprim.lt.delr)then
+          
+          kill=.true.
+          call error(idnode,-398)
+          
+        endif
+      endif
+      
+c     check rcut > rvdw (for verlet list constructor)
+      
+      if(rcut.lt.rvdw)then 
+        
+        kill=.true.
+        call error(idnode,-400)
+        
+      endif
+      
+c     check spme is not being used with incorrect pbc
+      
+      if(lspme)then
+        
+        if(imcon.eq.0.or.imcon.eq.6)then
+          
+          kill=.true.
+          call error(idnode,-513)
+          
+        endif
+        
+      endif
+      
+c     check on all-pairs calculation request
+      
+      if(lnsq)then
+        
+        if(multt.eq.1)then
+          
+          kill=.true.
+          call error(idnode,-422)
+          
+        endif
+        
+        if(keyfce/2.lt.2.or.keyfce/2.gt.3)then
+          
+          kill=.true.
+          call error(idnode,-424)
+          
+        endif
+        
+      endif
+      
+c     cancel rdf option if no vdw or coulombic forces
+      
+      if(lgofr.and.keyfce.eq.0)then
+        
+        lgofr=.false.
+        call warning(idnode,120,0.d0,0.d0,0.d0)
+        
+      endif
+      
+      if(kill)call abort_control_read(2,idnode,nread)
+      
+c     close CONTROL file
+      
+      if(idnode.eq.0)close(nread)
+      
+      return
+      end subroutine simdef
+      
+      subroutine sysdef
+     x  (lneut,lnsq,lsolva,lfree,lexcite,lswitch,lghost,idnode,keyfce,
+     x  keyfld,natms,ngrp,ntpatm,ntpmls,ntpvdw,ntptbp,ntpmet,ntpfbp,
+     x  ntpter,nshels,keyshl,ntghost,keyver,dlrpot,engunit,rvdw,rcuttb,
+     x  rctter,rcutfb)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading in the molecular specifications
+c     of the system to be simulated
+c     version for rigid unit data and neutral groups
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith may 1992.
+c     amended   - w.smith march 1994 
+c     amended   - t.forester april 1994
+c     amended   - w.smith  dec 1994 - getrec etc
+c     amended   - a.smondyrev may 2000 - keydih=5 for 
+c     ryckaert-bellemans potential in dihedrals
+c     amended   - a.smondyrev may 2000 - keydih=6 for 
+c     fluorinated ryckaert-bellemans potential in dihedrals
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lunits,lmols,lneut,ltable,lnsq,lshl,safe,lpmf
+      logical loop1,loop2,lsolva,lfree,lexcite,lswitch,lghost
+      
+      integer idnode,keyfce,keyfld,natms,ngrp,ntpatm,ntpmls
+      integer ntpvdw,ntptbp,ntpmet,ntpfbp,nshels,ksite
+      integer nsite,nconst,nangle,ndihed,ninver,nbonds
+      integer nteth,nspmf,itmols,i,idum,keyver
+      integer ntpter,keyshl,iatm,natmsr,ntghost
+      
+      real(8) dlrpot,engunit,rvdw,rcuttb,rctter,rcutfb
+      real(8) sumchg
+      
+      data loop1/.true./,loop2/.true./
+      
+c     initialise system counters: atomic site index, number of 
+c     constraints, bond angles, dihedrals, inversions, chemical bonds,
+c     unique atom types, total number of atoms,
+c     total number of rigid groups, number of tethered atoms,
+c     number of three body potentials
+      
+      nsite=0
+      nconst=0
+      nangle=0
+      ndihed=0
+      ninver=0
+      nbonds=0
+      ntpatm=0
+      natms=0
+      ngrp=0
+      nteth=0
+      ntptbp=0
+      ntpter=0
+      ntpmet=0
+      ntpvdw=0
+      ntpfbp=0
+      nshels=0
+      nspmf=0
+      keyfld=0
+      keyshl=0
+      ntghost=0
+      natmsr=0
+      ntcons_ghost=0
+      
+      lunits=.false.
+      lmols=.false.
+      lneut=.false.
+      ltable=.false.
+      lmetab=.false.
+      lshl=.false.
+      lpmf=.false.
+      engunit=1.d0
+      
+      numbonds(:)=0
+      numpmf(:)=0
+      numcon(:)=0
+      numdih(:)=0
+      numinv(:)=0
+      numgrp(:)=0
+      numsit(:)=0
+      numteth(:)=0
+      numshl(:)=0
+      npmf(:)=0
+      indpmf(:)=0
+      
+c     open force field data file
+      
+      if(idnode.eq.0)open (nfield,file='FIELD',status='old')
+      
+      if(idnode.eq.0)
+     x  write(nrite,"(/,/,'SYSTEM SPECIFICATION')")
+      
+      call getrec(safe,idnode,nfield)
+      if(.not.safe)call abort_field_read(1,idnode,nfield)
+      
+c     read and process directives from field file
+      
+      do while(loop1)
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)call abort_field_read(1,idnode,nfield)
+        
+c     convert to lowercase and remove leading blanks
+        
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.' ')then
+          
+c     record is commented out
+          cycle
+          
+        elseif(findstring('units',record,idum))then
+          
+c     identify energy unit for input/output
+          
+          lunits=.true.
+          call define_units(idnode,engunit)
+          
+c     neutral group control option
+          
+        elseif(findstring('neut',record,idum))then
+          
+          lneut=.true.
+          if(idnode.eq.0)
+     x      write(nrite,"(/,' neutral group implementation in use')")
+          
+c     can't have neutral groups with all-pairs
+          
+          if(lnsq)call error(idnode,426)
+          
+c     specify molecular species
+          
+        elseif(findstring('molecu',record,idum))then
+          
+c     number of molecular types
+          
+          if(lmols)call error(idnode,11)
+          lmols=.true.
+          ntpmls=intstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(/,/,1x,'number of molecular types',6x,i10)")
+     x      ntpmls
+          
+          if(ntpmls.gt.mxtmls)call error(idnode,10)
+          
+c     initialise total system charge
+          
+          sumchg=0.d0
+          
+c     read in molecular characteristics
+          
+          do itmols=1,ntpmls
+            
+            if(idnode.eq.0)
+     x        write(nrite,"(/,1x,'molecular species type',9x,i10)")
+     x        itmols
+            
+c     name of molecular species
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abort_field_read(1,idnode,nfield)
+            
+            call copystring(record,molnam(1,itmols),40)
+            if(idnode.eq.0)
+     x        write(nrite,"(/,/,1x,'name of species:',13x,40a1)")
+     x        (molnam(i,itmols),i=1,40)
+            
+c     stop processing if energy unit has not been specified
+            
+            if(.not.lunits)call error(idnode,6)
+            
+c     read molecular data
+            
+            loop2=.true.
+            
+            do while(loop2)
+              
+              call getrec(safe,idnode,nfield)
+              if(.not.safe)call abort_field_read(1,idnode,nfield)
+              
+              call lowcase(record,lenrec)
+              call strip(record,lenrec)
+              
+              ksite=0
+              
+              if(findstring('nummol',record,idum))then
+                
+                nummols(itmols)=intstr(record,lenrec,idum)
+                if(idnode.eq.0)
+     x            write(nrite,"(/,1x,'number of molecules  ',
+     x            10x,i10)")nummols(itmols)
+                
+              elseif(findstring('atoms',record,idum))then
+                
+c     read in atomic details
+                
+                call define_atoms
+     x            (safe,lneut,idnode,itmols,nsite,ksite,ntpatm)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read core - shell spring parameters
+                
+              elseif(findstring('shell',record,idum))then
+                
+                lshl=.true.
+                call define_core_shell
+     x            (safe,idnode,itmols,nshels,nsite,keyshl,
+     x            engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read chemical bond force constant and bondlength
+                
+              elseif(findstring('bonds',record,idum))then
+                
+                call define_bonds
+     x            (safe,idnode,itmols,nbonds,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read bond atom indices and constraint bondlength
+                
+              elseif(findstring('constr',record,idum))then
+                
+                call define_constraints
+     x            (safe,lghost,idnode,itmols,nconst,nsite,natmsr)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read pmf bond atom indices, weights and constraint bondlength
+                
+              elseif(findstring('pmf',record,idum))then
+                
+                if(lpmf)call error(idnode,484)
+                lpmf=.true.
+                call define_pmf(safe,idnode,itmols,nspmf)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read intramolecular angular potential parameters
+                
+              elseif(findstring('angles',record,idum))then
+                
+                call define_angles
+     x            (safe,idnode,itmols,nangle,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read intramolecular dihedral potential parameters
+                
+              elseif(findstring('dihedr',record,idum))then
+                
+                call define_dihedrals
+     x            (safe,idnode,itmols,ndihed,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read intramolecular inversion potential parameters
+                
+              elseif(findstring('invers',record,idum))then
+                
+                call define_inversions
+     x            (safe,idnode,itmols,ninver,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read rigid body data
+                
+              elseif(findstring('rigid',record,idum))then
+                
+                call define_rigid_body
+     x            (safe,lghost,idnode,itmols,ngrp,natmsr)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     read tethered atom indices and tethering parameters
+                
+              elseif(findstring('teth',record,idum))then
+                
+                call define_tethers
+     x            (safe,idnode,itmols,nteth,nsite,engunit)
+                if(.not.safe)call abort_field_read(1,idnode,nfield)
+                
+c     finish of data for one molecular type
+                
+              elseif(findstring('finish',record,idum))then
+                
+c     running total of number of atoms in system
+                
+                natms=natms+nummols(itmols)*numsit(itmols)
+                if(natms.gt.mxatms)call error(idnode,75)
+                
+c     check core-shell units are not both in same rigid body unit
+                
+                call check_shells(idnode,itmols,nshels,ngrp)
+                
+                loop2=.false.
+                
+              else
+                
+c     error exit for unidentified directive in molecular data
+                
+                if(idnode.eq.0)write(nrite,'(12x,a)')record
+                call error(idnode,12)
+                
+              endif
+              
+            enddo
+            
+c     construction of atmolt table for solvation calculation
+            
+            if(lsolva)then
+              
+              do iatm=natmsr+1,natms
+                atmolt(iatm)=itmols
+              enddo
+              natmsr=natms
+              
+            endif
+            
+          enddo
+          
+c     construction of atm_fre table for free energy or excitation
+          
+          if(lfree.or.lexcite.or.lswitch)then
+            
+            atm_fre(:)=0
+            if((ind_fre(1).ne.0).and.(ind_fre(2).ne.0))then
+              
+              do iatm=ind_fre(1),ind_fre(2)
+                atm_fre(iatm)=1
+              enddo
+              
+            endif
+            
+            if((ind_fre(3).ne.0).and.(ind_fre(4).ne.0))then
+              
+              do iatm=ind_fre(3),ind_fre(4)
+                
+                atm_fre(iatm)=2
+                if(lghost)ntghost=ntghost+1
+                
+              enddo
+              
+            endif
+            
+          endif
+          
+c     calculate system charge
+          
+          call check_syschg(idnode,ntpmls,sumchg)
+          
+c     read in the nonbonded potential energy parameters
+          
+        elseif(findstring('vdw',record,idum))then
+          
+          call define_van_der_waals
+     x      (safe,ltable,lunits,lmols,idnode,ntpvdw,
+     x      ntpatm,keyfce,dlrpot,rvdw,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read in the metal potential energy parameters
+          
+        elseif(findstring('met',record,idum))then
+          
+          call define_metals
+     x      (safe,lunits,lmols,idnode,ntpmet,ntpatm,rvdw,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read the three body potential energy parameters
+          
+        elseif(findstring('tbp',record,idum))then
+          
+          call define_three_body
+     x      (safe,lunits,lmols,idnode,ntptbp,ntpatm,rcuttb,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read the tersoff potential energy parameters
+          
+        elseif(findstring('tersoff',record,idum))then
+          
+          call define_tersoff
+     x      (safe,lunits,lmols,idnode,ntpter,ntpatm,rctter,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read in the four body potential energy parameters
+          
+        elseif(findstring('fbp',record,idum))then
+          
+          call define_four_body
+     x      (safe,lunits,lmols,idnode,ntpfbp,ntpatm,
+     x      rcutfb,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     read external field data
+          
+        elseif(findstring('extern',record,idum))then
+          
+          call define_external_field
+     x      (safe,lunits,idnode,keyfld,engunit)
+          if(.not.safe)call abort_field_read(1,idnode,nfield)
+          
+c     normal end of FIELD file
+          
+        elseif(findstring('close',record,idum))then
+          
+          loop1=.false.
+          if(ntpvdw.eq.0.and.ntpmet.eq.0.and.
+     x      mod(keyfce,2).eq.1)call error(idnode,145)
+          
+c     error exit for unidentified directive
+          
+        else
+          
+          if(idnode.eq.0)write(nrite,'(100a)')record
+          call abort_field_read(2,idnode,nfield)
+          
+        endif
+        
+      enddo
+      
+c     close force field file
+      
+      if(idnode.eq.0)close (nfield)
+      
+      
+      if(lshl.and.idnode.eq.0)then
+        
+        if(keyshl.eq.1)write(nrite,
+     x    "(/,/,'adiabatic shell model in operation')")
+        
+        if(keyshl.eq.2)write(nrite,
+     x    "(/,/,'relaxed shell model in operation')")
+        
+      endif
+      
+      if(lshl.and.keyshl.eq.0)call error(idnode,1951)
+      
+c     if metadynamics and shell selected use only velocity verlet
+      
+      if(lshl.and.lmetadyn.and.keyver.eq.0)then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'switching to velocity verlet for metadynamics')")
+        keyver=1
+        
+      endif
+
+      return
+      end subroutine sysdef
+      
+      subroutine sysgen
+     x  (loglnk,lneut,nolink,lfree,lfrmas,idnode,imcon,keyens,
+     x  keyfce,keyres,levcfg,multt,mxnode,ntpmls,delr,rcut,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading the configuration data file
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 atname(8)
+      
+      logical loglnk,safe,lneut,nolink,lfree,lfrmas
+      integer idnode,imcon,keyens,keyfce,keyres,levcfg,multt
+      integer ntpmls,i,indatm,indnam,indneu,k,ilx,ily,ilz
+      integer m,l,ncells,idum,mxnode
+      real(8) delr,rcut,volm,xcoord,ycoord,zcoord,totmas,xveloc
+      real(8) yveloc,zveloc,xforce,yforce,zforce,axx,rt3,xhi,yhi,zhi
+      real(8) width,dum1,dum2,test,com(3)
+      
+c     open the system input file
+      
+      if(idnode.eq.0)open (nconf,file='CONFIG')
+      
+c     read the CONFIG file header
+      
+      call getrec(safe,idnode,nconf)
+      if(.not.safe)call abort_config_read(1,idnode,nconf)
+      
+      call copystring(record,cfgname,80)
+      if(idnode.eq.0)write(nrite,
+     x  "(/,1x,'configuration file name: ',/,/,10x,80a1)")cfgname
+      
+      call getrec(safe,idnode,nconf)
+      if(.not.safe)call abort_config_read(1,idnode,nconf)
+      
+      levcfg=intstr(record,lenrec,idum)
+      imcon=intstr(record,lenrec,idum)
+      if(idnode.eq.0)write(nrite,
+     x  "(/,/,1x,'selected image convention',6x,i10)")imcon
+      
+c     check config file contents for consistent data
+      
+      if((imcon.eq.0.or.imcon.eq.6).and.
+     x  (keyfce/2.eq.1.or.keyfce/2.eq.6))
+     x  call error(idnode,180)
+      
+      if(imcon.eq.0.and.(.not.lneut).and.(keyfce.gt.1)
+     x  .and.(multt.eq.1))call warning(idnode,30,0.d0,0.d0,0.d0)
+      
+      if(imcon.eq.0.and.(keyens.ge.4.and.keyens.le.7))
+     x  call error(idnode,390)
+      if(imcon.le.2.and.(keyens.eq.6.or.keyens.eq.7))imcon=3
+      if(keyres.gt.0.and.levcfg.lt.1)call error(idnode,85)
+      
+c     specify molecular dynamics simulation cell
+      
+      if(imcon.eq.0)then
+        
+c     if no periodic boundaries - set zero values for cell 
+c     vectors and cell volume
+        
+        cell(:)=0.d0
+        volm=0.d0
+        
+      else
+        
+c     read cell vectors
+        
+        call getrec(safe,idnode,nconf)
+        if(.not.safe)call abort_config_read(1,idnode,nconf)
+        cell(1)=dblstr(record,lenrec,idum)
+        cell(2)=dblstr(record,lenrec,idum)
+        cell(3)=dblstr(record,lenrec,idum)
+        call getrec(safe,idnode,nconf)
+        if(.not.safe)call abort_config_read(1,idnode,nconf)
+        cell(4)=dblstr(record,lenrec,idum)
+        cell(5)=dblstr(record,lenrec,idum)
+        cell(6)=dblstr(record,lenrec,idum)
+        call getrec(safe,idnode,nconf)
+        if(.not.safe)call abort_config_read(1,idnode,nconf)
+        cell(7)=dblstr(record,lenrec,idum)
+        cell(8)=dblstr(record,lenrec,idum)
+        cell(9)=dblstr(record,lenrec,idum)
+        
+      endif
+      
+c     read the atomic coordinates
+      
+      indatm=0
+      indnam=0
+      indneu=0
+      safe=.true.
+      
+      do k=1,ntpmls
+        
+        do l=1,nummols(k)
+          
+          do m=1,numsit(k)
+            
+            indatm=indatm+1
+            
+            if(indatm.gt.mxatms)call error(idnode,45)
+            
+            xxx(indatm)=0.d0
+            yyy(indatm)=0.d0
+            zzz(indatm)=0.d0
+            vxx(indatm)=0.d0
+            vyy(indatm)=0.d0
+            vzz(indatm)=0.d0
+            fxx(indatm)=0.d0
+            fyy(indatm)=0.d0
+            fzz(indatm)=0.d0
+            
+            if(idnode.eq.0)then
+              
+              if(levcfg.eq.0)then
+                
+                read(nconf,'(8a1)',end=100)atname
+                read(nconf,'(3f20.0)',end=100)xcoord,ycoord,zcoord
+                
+              elseif(levcfg.eq.1)then
+                
+                read(nconf,'(8a1)',end=100)atname
+                read(nconf,'(3f20.0)',end=100)xcoord,ycoord,zcoord
+                read(nconf,'(3f20.0)',end=100)xveloc,yveloc,zveloc
+                
+              else
+                
+                read(nconf,'(8a1)',end=100)atname
+                read(nconf,'(3f20.0)',end=100)xcoord,ycoord,zcoord
+                read(nconf,'(3f20.0)',end=100)xveloc,yveloc,zveloc
+                read(nconf,'(3f20.0)',end=100)xforce,yforce,zforce
+                
+              endif
+              
+c     strip blanks off atom name
+              
+              call strip(atname,8)
+              
+              if(sitnam(indnam+m).eq.mkwd8(atname))then
+                
+                xxx(indatm)=xcoord
+                yyy(indatm)=ycoord
+                zzz(indatm)=zcoord
+                
+                if(levcfg.gt.0)then
+                  
+                  vxx(indatm)=xveloc
+                  vyy(indatm)=yveloc
+                  vzz(indatm)=zveloc
+                  
+                endif
+                
+                if(levcfg.gt.1)then
+                  
+                  fxx(indatm)=xforce
+                  fyy(indatm)=yforce
+                  fzz(indatm)=zforce
+                  
+                endif
+                
+              else
+                
+                write(nrite,"(/,/,'unidentified atom label :',8a1,
+     x            ': atom number ',i5)")atname,indatm
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+            call gstate(safe)
+            if(.not.safe)call error(idnode,25)
+            
+            ltype(indatm)=ltpsit(indnam+m)
+            weight(indatm)=wgtsit(indnam+m)
+            chge(indatm)=chgsit(indnam+m)
+            atmnam(indatm)=sitnam(indnam+m)
+            lstfrz(indatm)=lfzsit(indnam+m)
+            if(lneut)lstneu(indatm)=nugrp(indnam+m)+indneu
+            
+c     reset atomic masses according to free energy definitions
+            
+            if(lfree)then
+
+              weight_sav(indatm)=weight(indatm)
+              
+              if(lfrmas)then
+                
+                if(indatm.ge.ind_fre(1).and.indatm.le.ind_fre(2))then
+                  weight(indatm)=lambda1*weight(indatm)
+                elseif(indatm.ge.ind_fre(3).and.indatm.le.ind_fre(4))
+     x              then
+                  weight(indatm)=lambda2*weight(indatm)
+                endif
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          indneu=indneu+nugrp(indnam+numsit(k))
+          
+        enddo
+        
+        indnam=indnam+numsit(k)
+        
+      enddo
+      
+      if(mxnode.gt.1)then
+        
+        call gdsum(xxx,indatm,buffer)
+        call gdsum(yyy,indatm,buffer)
+        call gdsum(zzz,indatm,buffer)
+        
+        if(levcfg.gt.0)then
+          
+          call gdsum(vxx,indatm,buffer)
+          call gdsum(vyy,indatm,buffer)
+          call gdsum(vzz,indatm,buffer)
+          
+        endif
+        
+        if(levcfg.gt.1)then
+          
+          call gdsum(fxx,indatm,buffer)
+          call gdsum(fyy,indatm,buffer)
+          call gdsum(fzz,indatm,buffer)
+          
+        endif
+        
+      endif
+      
+c     check integrity of cell vectors : for cubic, TO and RD cases
+c     ie. cell(1)=cell(5)=cell(9) (or cell(9)/sqrt(2) for RD)
+      
+      if((imcon.eq.1).or.(imcon.eq.4).or.(imcon.eq.5))then
+        
+        axx=(abs(cell(1))+abs(cell(5)))/2.d0
+        test=1.d-8*axx
+        if(abs(cell(1)-axx).gt.test)call error(idnode,410)
+        if(abs(cell(5)-axx).gt.test)call error(idnode,410)
+        if(imcon.eq.5)then
+          if(abs(cell(9)-axx*sqrt(2.d0)).gt.test)
+     x      call error(idnode,410)
+        else
+          if(abs(cell(9)-axx).gt.test)call error(idnode,410)
+        endif
+        
+      endif
+      
+c     check integrity of hexagonal prism cell vectors
+      
+      if(imcon.eq.7)then
+        
+        rt3=sqrt(3.d0)
+        if(abs(cell(1)-rt3*cell(5)).ge.1.d-6)
+     x    call error(idnode,410)
+        
+      endif
+      
+c     check 2D PBC for imcon=6
+      
+      if(imcon.eq.6)then
+        
+        if(abs(cell(3)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(6)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(7)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(8)).gt.1.d-10)call error(idnode,410)
+        
+      endif
+      
+c     check for diagonal cell matrix if appropriate
+      
+      if((imcon.eq.1).or.(imcon.eq.2).or.(imcon.eq.4).or.
+     x  (imcon.eq.5).or.(imcon.eq.7))then
+        
+        if(abs(cell(2)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(3)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(4)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(6)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(7)).gt.1.d-10)call error(idnode,410)
+        if(abs(cell(8)).gt.1.d-10)call error(idnode,410)
+        
+      endif
+      
+c     put centre of mass at centre of coordinates if imcon=0
+      
+      if(imcon.eq.0)then
+        
+        totmas=getmass(indatm,idnode,mxnode)
+        call getcom(indatm,idnode,mxnode,totmas,com)
+        
+        do i=1,indatm
+          
+          xxx(i)=xxx(i)-com(1)
+          yyy(i)=yyy(i)-com(2)
+          zzz(i)=zzz(i)-com(3)
+          
+        enddo
+        
+      endif
+      
+c     set widths if unset - needed for check on link cells below
+      
+      if(imcon.eq.0.or.imcon.eq.6)then
+        
+        xhi=abs(xxx(1))
+        yhi=abs(yyy(1))
+        zhi=abs(zzz(1))
+        do i=2,indatm
+          
+          xhi=max(xhi,abs(xxx(i)))
+          yhi=max(yhi,abs(yyy(i)))
+          zhi=max(zhi,abs(zzz(i)))
+          
+        enddo
+        if(imcon.eq.0)then
+          
+          cell(1)=max(2.d0*xhi+rcut+delr,3.d0*(rcut+delr))
+          cell(5)=max(2.d0*yhi+rcut+delr,3.d0*(rcut+delr))
+          cell(9)=max(2.d0*zhi+rcut+delr,3.d0*(rcut+delr))
+          
+        endif
+        
+        if(imcon.eq.6.and.cell(9).lt.1.d-6)then
+          
+          cell(9)=max(2.d0*zhi+rcut+delr,3.d0*(rcut+delr))
+          
+        endif
+        
+      endif
+      
+c     calculate dimensional properties of simulation cell
+      
+      call dcell(cell,celprp)
+      
+      if(imcon.eq.0)then
+        
+        volm=0.d0
+        
+      elseif(imcon.eq.4)then
+        
+        volm=0.5d0*celprp(10)
+        
+      elseif(imcon.eq.5)then
+        
+        volm=0.5d0*celprp(10)
+        
+      elseif(imcon.eq.7)then
+        
+        volm=0.5d0*celprp(10)
+        
+      else
+        
+        volm=celprp(10)
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,"(/,/,1x,'simulation cell vectors'/,/)")
+        write(nrite,"(21x,3f12.6)")cell
+        
+        write(nrite,
+     x    "(/,/,1x,'system volume     ',2x,1p,g22.12)")volm
+        
+      endif
+      
+c     check value of cutoff and reset if necessary
+      
+      if(imcon.gt.0)then
+        
+        width=min(celprp(7),celprp(8),celprp(9))/2.d0
+        if(imcon.eq.4)width=sqrt(3.d0)*cell(1)/4.d0
+        if(imcon.eq.5)width=cell(1)/2.d0
+        if(imcon.eq.6)width=min(celprp(7),celprp(8))/2.d0
+        
+c     halt program if potential cutoff exceeds cell width
+        
+        if(rcut.gt.width)call error(idnode,95)
+        
+      endif
+      
+c     decide on whether to use link cells for verlet list constructor
+      
+      if(nolink)then
+        
+        loglnk=.false.
+        
+      else
+        
+        loglnk=.true.
+        
+        ilx=int(celprp(7)/(rcut+delr))
+        ily=int(celprp(8)/(rcut+delr))
+        ilz=int(celprp(9)/(rcut+delr))
+        if(ilx.lt.3.or.ily.lt.3.or.ilz.lt.3)loglnk=.false.
+        ncells=ilx*ily*ilz
+        if(lneut.and.ncells.le.36)loglnk=.false.
+        if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)loglnk=.false.
+        if(loglnk.and.ncells.gt.mxcell)then
+          
+          dum1=dble(ncells)
+          dum2=dble(mxcell)
+          call warning(idnode,90,dum1,dum2,dum2)
+          loglnk=.false.
+          
+        endif
+        
+      endif
+      
+      if(loglnk.and.idnode.eq.0)
+     x  write(nrite,"(/,/,' link cell algorithm in use')")
+      
+      if(idnode.eq.0)close (nconf)
+      
+c     ensure PBC compliance of starting structure
+      
+      if(keyres.eq.0.and.imcon.gt.0)then
+        
+        call images(imcon,idnode,mxnode,indatm,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,indatm,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+      return
+      
+c     error exit for config file read
+      
+  100 call abort_config_read(2,idnode,nconf)
+      
+      end subroutine sysgen
+      
+      subroutine sysinit
+     x  (lgofr,lzden,lsolva,lfree,lghost,lpsoc,idnode,imcon,keyfce,
+     x  keyres,mxnode,natms,ntshl,nstep,numacc,numrdf,ntpatm,
+     x  ntpmet,ntpvdw,nzden,chip,chit,conint,elrc,engunit,virlrc,
+     x  rvdw,volm,virtot,vircom,tboost,chit_shl)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading the REVIVE file data and 
+c     defining the initial thermodynamic and structural accumulators.
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     adapted   - d. quigley nov 2010, metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lgofr,lzden,lfree,lsolva,lghost,lpsoc
+      integer idnode,imcon,keyfce,keyres,mxnode,natms,nstep,numacc
+      integer numrdf,ntpatm,nzden,i,j,k,ntpmet,ntshl,ntpvdw
+      real(8) chip,chit,conint,elrc,engunit,virlrc,rvdw,volm
+      real(8) dnumrd,dnstep,dnumac,dnzden,virtot,vircom,tboost
+      real(8) chit_shl
+      
+c     read or initialise accumulator arrays
+      
+      if(keyres.eq.1.and.idnode.eq.0)then
+        
+c     read accumulator data from dump file
+        
+        open(nrest,file='REVOLD',form='unformatted')
+        
+        read(nrest) dnstep,dnumac,dnumrd,chit,chip,conint,dnzden,
+     x    tboost,chit_shl
+        read(nrest) virtot,vircom,eta,strcns,strbod
+        read(nrest) stpval
+        read(nrest) sumval
+        read(nrest) ssqval
+        read(nrest) zumval
+        read(nrest) ravval
+        read(nrest) stkval
+        read(nrest) xx0,yy0,zz0
+        read(nrest) xxs,yys,zzs
+        
+        if(lgofr) read(nrest)rdf
+        if(lzden) read(nrest)zdens
+        
+        nstep=nint(dnstep)
+        numacc=nint(dnumac)
+        numrdf=nint(dnumrd)
+        nzden=nint(dnzden)
+        close (nrest)
+        
+      else
+         
+c     initialise step counters
+        
+        nstep=0
+        numacc=0
+        numrdf=0
+        nzden=0
+        
+c     initialise temperature and pressure coupling parameters
+c     and integral for conserved quantity
+        
+        chit=0.d0
+        chip=0.d0
+        conint=0.d0
+        virtot=0.d0
+        vircom=0.d0
+        chit_shl=0.d0
+        do i=1,9
+          
+          eta(i)=0.d0
+          strcns(i)=0.d0
+          strbod(i)=0.d0
+          
+        enddo
+        
+c     initialise accumulator arrays
+        
+        do i=1,mxnstk
+          
+          stpval(i)=0.d0
+          sumval(i)=0.d0
+          ssqval(i)=0.d0
+          zumval(i)=0.d0
+          ravval(i)=0.d0
+          
+        enddo
+        
+        do i=1,mxatms
+          
+          xx0(i)=0.d0
+          yy0(i)=0.d0
+          zz0(i)=0.d0
+          xxs(i)=0.d0
+          yys(i)=0.d0
+          zzs(i)=0.d0
+          
+        enddo
+        
+        do j=1,mxnstk
+          
+          do i=1,mxstak
+            
+            stkval(i,j)=0.d0
+            
+          enddo
+          
+        enddo
+        
+        if(lgofr)then
+          
+          do i=1,mxxtyp
+            
+            do j=1,mxrdf
+              
+              rdf(j,i)=0.d0
+              
+            enddo
+            
+          enddo
+          
+        endif
+        
+        if(lzden)then
+          
+          do i=1,mxatyp
+            
+            do j=1,mxzdn
+              zdens(j,i)=0.d0
+            enddo
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     put shells on cores at start
+      
+      if(lpsoc.and.keyres.ne.1.and.ntshl.gt.0)
+     x  call put_shells_on_cores(idnode,mxnode,ntshl)
+      
+c     if restart then broadcast stored variables via a global sum
+      
+      if(keyres.eq.1.and.mxnode.gt.1)then
+        
+        if(mxbuff.lt.natms.or.mxbuff.lt.mxnstk*mxstak)
+     x    call error(idnode,186)
+        
+        buffer(1)=chit
+        buffer(2)=chip
+        buffer(3)=conint
+        buffer(4)=dble(nstep)
+        buffer(5)=dble(numacc)
+        buffer(6)=dble(numrdf)
+        buffer(7)=dble(nzden)
+        buffer(8)=tboost
+        buffer(9)=virtot
+        buffer(10)=vircom
+        buffer(11)=chit_shl
+        call gdsum(buffer(1),11,buffer(12))
+        chit=buffer(1)
+        chip=buffer(2)
+        conint=buffer(3)
+        nstep=nint(buffer(4))
+        numacc=nint(buffer(5))
+        numrdf=nint(buffer(6))
+        nzden=nint(buffer(7))
+        tboost=buffer(8)
+        virtot=buffer(9)
+        vircom=buffer(10)
+        chit_shl=buffer(11)
+        
+        call gdsum(eta,9,buffer)
+        call gdsum(strcns,9,buffer)
+        call gdsum(strbod,9,buffer)
+        call gdsum(stpval,mxnstk,buffer)
+        call gdsum(sumval,mxnstk,buffer)
+        call gdsum(ssqval,mxnstk,buffer)
+        call gdsum(zumval,mxnstk,buffer)
+        call gdsum(ravval,mxnstk,buffer)    
+        call gdsum(stkval,mxnstk*mxstak,buffer)
+        call gdsum(xx0,natms,buffer)
+        call gdsum(yy0,natms,buffer)
+        call gdsum(zz0,natms,buffer)
+        call gdsum(xxs,natms,buffer)
+        call gdsum(yys,natms,buffer)
+        call gdsum(zzs,natms,buffer)
+        
+c     for rdf table - broadcast and normalise
+        
+        if(lgofr)then
+          
+          do k=1,mxxtyp
+            
+            call gdsum(rdf(1,k),mxrdf,buffer)
+            
+            do j=1,mxrdf
+              rdf(j,k)=rdf(j,k)/dble(mxnode)
+            enddo
+            
+          enddo
+          
+        endif
+        
+        if(lzden)then
+          
+          do k=1,mxatyp
+            
+            call gdsum(zdens(1,k),mxzdn,buffer)
+            
+            do j=1,mxzdn
+              zdens(j,k)=zdens(j,k)/dble(mxnode)
+            enddo
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     number densities and long-range corrections
+      
+      elrc=0.d0       
+      virlrc=0.d0
+      
+      if(imcon.eq.0.or.imcon.eq.6)volm=4.d0*pi/3.d0*rvdw**3
+      
+      call lrcorrect
+     x  (lsolva,lfree,lghost,idnode,imcon,keyfce,natms,
+     x  ntpatm,ntpvdw,elrc,engunit,virlrc,rvdw,volm)
+      
+      if(lmetab.or.ntpmet.eq.0)then
+        
+        elrcm(0)=0.d0
+        vlrcm(0)=0.d0
+        
+      else 
+        
+        call lrcmetal
+     x    (idnode,imcon,natms,ntpatm,engunit,rvdw,volm)
+        
+      endif
+      
+      if(imcon.eq.0.or.imcon.eq.6)volm=0.d0
+      
+      return
+      end subroutine sysinit
+      
+      subroutine systemp
+     x  (idnode,imcon,keyres,mxnode,natms,ngrp,nscons,ntcons,
+     x  ntfree,ntshl,levcfg,keyshl,degfre,degshl,degrot,temp,
+     x  tolnce)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for setting the initial system temperature
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idnode,imcon,keyres,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,ntshl,levcfg,i,io,k,keyshl
+      real(8) degfre,degshl,degrot,temp,tolnce,sigma,rsq
+      
+c     number of degrees of freedom 
+c     3 for com translation
+c     3 for angular momentum about origin (non-periodic systems only)
+      
+      degfre=dble(3*(ntfree-ntshl)-3-ntcons)+degfre
+      if(imcon.eq.0.or.imcon.eq.6)degfre=degfre-3.0d0
+      if(imcon.eq.0.or.imcon.eq.6)degrot=max(0.d0,degrot-3.0d0)
+      degshl=dble(3*ntshl)
+      
+c     lose one degree of freedom if temperature constrained
+c     gaussian constraints
+      
+c     if(keyens.eq.1)degfre=degfre-1.d0
+      
+      if(idnode.eq.0)
+     x  write(nrite,"(/,/,' total degrees of freedom       ',f20.0,/,
+     x  ' rotational degrees of freedom  ',f20.0,/,
+     x  ' shell pseudo degrees of freedom',f20.0)")
+     x  degfre,degrot,degshl
+      if(degfre.lt.1.d0)call error(idnode,350)
+      
+c     define reciprocal masses of atoms
+      
+      do i=1,natms
+        
+        if(lstfrz(i).ne.0.or.weight(i).lt.1.d-6)then
+          
+          rmass(i)=0.d0
+          weight(i)=0.d0
+          
+        else
+          
+          rmass(i)=1.d0/weight(i)
+          
+        endif
+        
+      enddo
+      
+c     generate starting velocities
+      
+      sigma=temp*boltz*degfre*0.5d0
+      
+      if(keyres.eq.0)then
+        
+        call gauss(natms,vxx,vyy,vzz)
+        
+        do i=1,natms
+          
+          rsq=sqrt(rmass(i))
+          vxx(i)=vxx(i)*rsq
+          vyy(i)=vyy(i)*rsq
+          vzz(i)=vzz(i)*rsq
+          
+        enddo
+        
+        if(ntcons.gt.0)call quench
+     x    (imcon,idnode,mxnode,natms,nscons,tolnce)
+        
+        if(ngrp.gt.0)call quatqnch(idnode,imcon,mxnode,natms,ngrp)
+        
+        if(keyshl.eq.1)then
+          
+          do k=1,4
+            
+            call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+            call shlqnch(idnode,mxnode,ntshl,temp)
+            
+          enddo
+          
+        else
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        endif
+        
+      elseif(keyres.eq.1.or.keyres.eq.3)then 
+        
+        if(ngrp.gt.0)call quatqnch(idnode,imcon,mxnode,natms,ngrp)
+        
+      elseif(keyres.eq.2)then
+        
+        if(ngrp.gt.0)then 
+          
+          call vscaleg
+     x      (idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        elseif(keyshl.eq.1)then
+          
+          do k=1,4
+            
+            call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+            call shlqnch(idnode,mxnode,ntshl,temp)
+            
+          enddo
+          
+        else
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        endif
+        
+      endif
+      
+c     print out sample of initial configuration 
+      
+      if(idnode.eq.0)write(nrite,
+     x  "(/,/,1x,'sample of starting configuration',/)")
+      
+      io=(natms+19)/20
+      if((levcfg.le.1).and.(idnode.eq.0))
+     x  write(nrite,"(6x,'i',7x,'x(i)',8x,'y(i)',8x,'z(i)',
+     x  7x,'vx(i)',7x,'vy(i)',7x,'vz(i)',/,/)")
+      if((levcfg.eq.2).and.(idnode.eq.0))
+     x  write(nrite,"(6x,'i',7x,'x(i)',8x,'y(i)',8x,'z(i)',
+     x  7x,'vx(i)',7x,'vy(i)',7x,'vz(i)',
+     x  7x,'fx(i)',7x,'fy(i)',7x,'fz(i)',/,/)")
+      
+      do i=1,natms,io
+        
+        if(levcfg.le.1)then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(1x,i6,1p,3e12.4,3e12.4,3e12.4)")
+     x      i,xxx(i),yyy(i),zzz(i),vxx(i),vyy(i),vzz(i)
+          
+        elseif(levcfg.eq.2)then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(1x,i6,1p,3e12.4,3e12.4,3e12.4)")
+     x      i,xxx(i),yyy(i),zzz(i),
+     x      vxx(i),vyy(i),vzz(i),fxx(i),fyy(i),fzz(i)
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine systemp
+      
+      subroutine sysbook
+     x  (loglnk,lneut,lshmov,lcnb,lsolva,lghost,idnode,imcon,
+     x  mxnode,natms,nneut,ngrp,nscons,ntangl,ntbond,ntcons,
+     x  ntdihd,ntinv,ntpmls,ntpmf,nspmf,ntfree,ntteth,ntshl,
+     x  ntghost,degfre,degrot)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine  defining global bookkeeping
+c     arrays
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith         july 1997
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical loglnk,lneut,lshmov,lcnb,lsolva,lghost
+      integer idnode,imcon,mxnode,natms,nneut,ngrp,nscons,ntangl,i
+      integer ntbond,ntcons,ntdihd,ntinv,ntpmls,ntpmf,nspmf,ntfree
+      integer ntteth,ntshl,ii,isol,itmols,igsol,iggsol,natmsf,natmsl
+      integer ntghost,natms2
+      real(8) degfre,degrot
+      
+c     if excitation calculation, allow for ghost species
+      
+      if(lghost)then
+        natms2=natms-ntghost
+      else
+        natms2=natms
+      endif
+      
+c     neutral group bookkeeping
+      
+      call neutbook(lneut,idnode,natms,nneut)
+      
+c     rigid body bookkeeping 
+      
+      call quatbook
+     x  (lsolva,idnode,imcon,mxnode,natms2,ngrp,ntpmls,
+     x  ntfree,degfre,degrot)
+      
+c     if excitation calculation, allow for ghost species
+      
+      if(lghost)then
+        
+        numcon(mxtmls)=numcon(mxtmls)+ntcons_ghost
+        numgrp(mxtmls)=numgrp(mxtmls)+ngrp_ghost
+        
+      endif
+      
+c     construct list of excluded pair interactions
+      
+      if(lneut)then
+ 
+        call exclude(idnode,mxnode,natms,ntpmls)
+        call excludeneu(idnode,mxnode,nneut)
+        
+      elseif(.not.lneut)then
+        
+        call exclude(idnode,mxnode,natms,ntpmls)
+        
+        if(loglnk)then
+          
+          call exclude_link(idnode,mxnode,ntpmls)
+          
+        else
+          
+          call exclude_atom(idnode,mxnode,natms,ntpmls)
+          
+        endif
+        
+      endif
+      
+c     if excitation calculation, allow for ghost species
+      
+      if(lghost)then
+        
+        numcon(mxtmls)=numcon(mxtmls)-ntcons_ghost
+        numgrp(mxtmls)=numgrp(mxtmls)-ngrp_ghost
+        
+      endif
+      
+c     construct interaction lists for bonded forces
+      
+      call intlist
+     x  (lshmov,lcnb,idnode,mxnode,natms2,nscons,ntangl,ntbond,
+     x  ntcons,ntdihd,ntinv,ntpmls,ntteth,ntshl,ntpmf,nspmf,ngrp)
+      
+c     adaptations for solvation and excitation simulations
+      
+      if(lsolva.or.lghost)then
+                
+        natmsf=0
+        natmsl=0
+        natm_sol(:)=0
+        const_sol(:)=numcon(:)*nummols(:)
+        rigid_sol(:)=numgrp(:)*nummols(:)
+        
+        if(ngrp.eq.0)then
+          
+          do itmols=1,mxtmls
+            
+            natmsl=natmsl+numsit(itmols)*nummols(itmols)
+            
+            do isol=natmsf+1,natmsl
+              
+              if(lstfrz(isol).eq.0)then
+                natm_sol(itmols)=natm_sol(itmols)+1
+              endif
+              
+            enddo
+            
+            natmsf=natmsl
+            
+          enddo
+
+        else
+          
+          ii=1
+          
+          do itmols=1,mxtmls
+            
+            natmsl=natmsl+numsit(itmols)*nummols(itmols)
+            
+            do isol=natmsf+1,natmsl
+              
+              if(lstgot_sol(ii).eq.isol)then
+                ii=ii+1
+              else
+                
+                if(lstfrz(isol).eq.0)then
+                  natm_sol(itmols)=natm_sol(itmols)+1
+                endif
+                
+              endif
+              
+            enddo
+            
+            natmsf=natmsl
+            
+          enddo
+          
+          degrot_sol(:)=degrot_sol(:)+dble(rigid_sol(:))*3.d0
+          degfre_sol(:)=degrot_sol(:)+dble(rigid_sol(:))*3.d0
+          
+        endif
+        
+        if(lghost)natm_sol(mxtmls)=natm_sol(mxtmls)-ntghost
+        degfre_sol(:)=dble(3*(natm_sol(:))-const_sol(:))+degfre_sol(:)
+        
+      endif
+      
+      return
+      end subroutine sysbook
+      
+      subroutine define_units(idnode,engunit)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting energy units
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith august 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idnode,idum,i
+      real(8) engunit
+      logical blank
+      
+      blank=.true.
+      
+      do i=6,lenrec
+        if(record(i).ne.' ')blank=.false.
+      enddo
+      
+      if(blank)then
+        
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=dl_poly internal ',
+     x    'units ')")
+        
+      elseif(findstring('ev',record,idum))then
+        
+        engunit=9648.530821d0
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=electron volts ')")
+        
+      elseif(findstring('kev',record,idum))then
+        
+        engunit=9648530.821d0
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kilo electron volts ')")
+        
+      elseif(findstring('kcal',record,idum))then
+        
+        engunit=418.4d0
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kcal/ mol ')")
+        
+      elseif(findstring('kj',record,idum))then
+        
+        engunit=1.d2
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kjoule/mol ')")
+        
+      elseif(findstring('k',record,idum))then
+        
+        engunit=boltz
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=kelvin ')")
+        
+      elseif(findstring('internal',record,idum))then
+        
+        if(idnode.eq.0)
+     x    write(nrite,"(/,' energy units=dl_poly internal',
+     x    ' units ')")
+        
+      else
+        
+        if(idnode.eq.0)write(nrite,'(a)')record
+        call error(idnode,5)
+        
+      endif
+      
+      return
+      end subroutine define_units
+      
+      subroutine quatbook
+     x  (lsolva,idnode,imcon,mxnode,natms,ngrp,ntpmls,ntfree,
+     x  degfre,degrot)
+      
+c**************************************************************************
+c     
+c     dl_poly subroutine for setting up bookkeeping for rigid bodies
+c     
+c     parallel replicated data version : block data
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     adapted   - p.-a. cazade oct 2007, solvation etc
+c     
+c*************************************************************************
+      
+      implicit none
+      
+      logical safe,pass1,pass2,linear,lsolva
+      integer fail,idnode,imcon,mxnode,natms,ngrp,ntpmls,ntfree
+      integer i,igrp,jgrp,kgrp,jr,jt,igrp1,igrp2,itmols,imols,lgrp,id
+      integer ii,jj,isite,k,kk,ill,i1,i2,i3,j,ngp,ifre1,ifre2,ig,ij
+      integer fngrp,lngrp
+      real(8) degfre,degrot,dnorm,a1,rtall,rotall,rot,aa,rotinr,bb,rot1
+      real(8) rsq,det,dettest,aq,bq,cq,dq,eq,fq,gq,hq,rnorm,tol,rotxyz
+      real(8) rotlim,rrr
+      
+      integer, allocatable :: ind(:,:),lstgot(:)
+      real(8), allocatable :: gaxs(:,:),rotmin(:),accum(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      
+      dimension rot(9),aa(9),rotinr(3,3),bb(9),rot1(3,3),fail(5)
+      
+      data fail/0,0,0,0,0/
+      
+c     allocate working arrays
+      
+      allocate (ind(mxgrp,3),lstgot(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(3))
+      allocate (gaxs(mxungp,9),rotmin(mxungp),stat=fail(4))
+      allocate (accum(mxungp),stat=fail(5))
+      do i=1,5
+        if(fail(i).ne.0)call error(idnode,1790)
+      enddo
+      
+c     initialise bookkeeping indices
+      
+      igrp=0
+      jgrp=0
+      kgrp=0
+      isite=0
+      jr=0
+      jt=0
+      safe=.true.
+      degfre=0.d0
+      degrot=0.d0
+      
+c     rigid body identifier
+      
+      do i=1,natms
+        lstbod(i)=0
+      enddo
+      
+c     number of rigid groups in system
+      
+      ngrp=0
+      do itmols=1,ntpmls
+        ngrp=ngrp+nummols(itmols)*numgrp(itmols)
+      enddo
+      
+c     block indices for groups
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+      
+c     loop over molecule types
+      
+      do itmols=1,ntpmls
+        
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+          
+c     construct rigid body site list: each processor has a different copy
+          
+          do lgrp=1,numgrp(itmols)
+            
+            igrp=igrp+1
+            
+            if(igrp.le.mxgrp)then
+              
+              lstgtp(igrp)=listyp(lgrp+kgrp)
+              id=listyp(lgrp+kgrp)
+              
+              if((igrp.ge.igrp1).and.(igrp.le.igrp2))then
+                
+                jgrp=jgrp+1
+                
+                do jj=1,numgsit(id)
+                  
+                  jr=jr+1
+                  jt=jt+1
+                  
+                  if(jr.le.mxatms.and.jt.le.mxatms)then
+                    
+                    lstrgd(jr)=lstgst(id,jj)+isite
+                    lstgot(jt)=lstgst(id,jj)+isite
+                    lstbod(lstgst(id,jj)+isite)=igrp
+                    
+                  else
+                    
+                    safe=.false.
+                    
+                  endif
+                  
+                enddo
+                
+              else
+                
+                do jj=1,numgsit(id)
+                  
+                  jt=jt+1
+                  if(jt.le.mxatms)then
+                    
+                    lstgot(jt)=lstgst(id,jj)+isite
+                    lstbod(lstgst(id,jj)+isite)=igrp
+                    
+                  else
+                    
+                    safe=.false.
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            else
+              
+              safe=.false.
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,304)
+          isite=isite+numsit(itmols)
+          
+        enddo
+        
+        kgrp=kgrp+numgrp(itmols)
+        
+      enddo
+      
+      if(ngrp.eq.0)then
+        
+        j=0
+        do i=1,natms
+          
+          if(lstfrz(i).eq.0)then
+            
+            j=j+1
+            lstfre(j)=i
+            
+          endif
+          
+        enddo
+        ntfree=j
+        
+      else
+        
+c     centre of mass of groups
+c     assumes group dimensions are smaller than half box width
+        
+        do i=1,natms
+          lstme(i)=0
+        enddo
+        
+        do id=1,mxungp
+          gmass(id)=0.d0
+        enddo
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     working com is first site in group
+          
+          i=lstrgd(jr+1)
+          txx(ig)=xxx(i)
+          tyy(ig)=yyy(i)
+          tzz(ig)=zzz(i)
+          
+          id=lstgtp(ig)
+          safe=.false.
+          if(abs(gmass(id)).lt.1.d-10)safe=.true.
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            xxt(jr)=xxx(i)-txx(ig)
+            yyt(jr)=yyy(i)-tyy(ig)
+            zzt(jr)=zzz(i)-tzz(ig)
+            if(safe)gmass(id)=gmass(id)+weight(i)
+            
+          enddo
+          
+        enddo
+        
+c     minimum image from working com
+        
+        call images(imcon,0,1,jr,cell,xxt,yyt,zzt)
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          gcmx(ig)=0.d0
+          gcmy(ig)=0.d0
+          gcmz(ig)=0.d0
+          
+          id=lstgtp(ig)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            gcmx(ig)=gcmx(ig)+weight(i)*xxt(jr)
+            gcmy(ig)=gcmy(ig)+weight(i)*yyt(jr)
+            gcmz(ig)=gcmz(ig)+weight(i)*zzt(jr)
+            
+          enddo
+          
+          gcmx(ig)=gcmx(ig)/gmass(id)+txx(ig)
+          gcmy(ig)=gcmy(ig)/gmass(id)+tyy(ig)
+          gcmz(ig)=gcmz(ig)/gmass(id)+tzz(ig)
+          
+        enddo
+        
+c     global communications
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+c     make sure all nodes have same copy of gmass
+        
+        if(mxnode.gt.1)then
+          
+          do id=1,mxungp
+            
+            accum(id)=0.d0
+            if(gmass(id).gt.0.d0)accum(id)=1.d0
+            
+          enddo
+          
+          call gdsum(gmass(1),mxungp,buffer(1))
+          call gdsum(accum(1),mxungp,buffer(1))
+          
+          do id=1,mxungp
+            
+            dnorm=max(1.d0,accum(id))
+            gmass(id)=gmass(id)/dnorm
+            
+          enddo
+          
+        endif
+        
+c     find a group of each type on this node to 
+c     find principal axis system of the group type
+        
+        do id=1,mxungp
+          
+          jr=0
+          ij=0
+          safe=.false.
+          
+          do while(.not.safe.and.ij.lt.ngrp)
+            
+            ij=ij+1
+            jr=jr+numgsit(lstgtp(ij))
+            if(lstgtp(ij).eq.id)safe=.true.
+            
+          enddo
+          
+          if(safe)then
+
+c     rotational inertia accumulator
+            
+            do k=1,3
+              
+              do kk=1,3
+                
+                rotinr(k,kk)=0.d0
+                
+              enddo
+              
+            enddo
+            
+            jr=jr-numgsit(id)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstgot(jr)
+              
+              xxt(jr)=xxx(i)-gcmx(ij)
+              yyt(jr)=yyy(i)-gcmy(ij)
+              zzt(jr)=zzz(i)-gcmz(ij)
+              
+              call images(imcon,0,1,1,cell,xxt(jr),yyt(jr),zzt(jr))
+              
+              rotinr(1,1)=rotinr(1,1)+weight(i)*(xxt(jr)**2)
+              rotinr(1,2)=rotinr(1,2)+weight(i)*xxt(jr)*yyt(jr)
+              rotinr(1,3)=rotinr(1,3)+weight(i)*xxt(jr)*zzt(jr)
+              rotinr(2,2)=rotinr(2,2)+weight(i)*(yyt(jr)**2)
+              rotinr(2,3)=rotinr(2,3)+weight(i)*yyt(jr)*zzt(jr)
+              rotinr(3,3)=rotinr(3,3)+weight(i)*(zzt(jr)**2)
+              
+            enddo
+            
+            rotinr(2,1)=rotinr(1,2)
+            rotinr(3,1)=rotinr(1,3)
+            rotinr(3,2)=rotinr(2,3)
+            
+            call jacobi(rotinr,rot1,3)
+            
+            rot(1)=rot1(1,1)
+            rot(4)=rot1(2,1)
+            rot(7)=rot1(3,1)
+            rot(2)=rot1(1,2)
+            rot(5)=rot1(2,2)
+            rot(8)=rot1(3,2)
+            rot(3)=rot1(1,3)
+            rot(6)=rot1(2,3)
+            rot(9)=rot1(3,3)
+            
+c     rotational inertia accumulators
+            
+            rotinx(id,1)=0.d0
+            rotiny(id,1)=0.d0
+            rotinz(id,1)=0.d0
+            
+            jr=jr-numgsit(id)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstgot(jr)
+              
+c     site positions in principal axis system
+              
+              gxx(id,j)=rot(1)*xxt(jr)+rot(4)*yyt(jr)+rot(7)*zzt(jr)
+              gyy(id,j)=rot(2)*xxt(jr)+rot(5)*yyt(jr)+rot(8)*zzt(jr)
+              gzz(id,j)=rot(3)*xxt(jr)+rot(6)*yyt(jr)+rot(9)*zzt(jr)
+              
+c     impose rounding 
+              
+              if(abs(gxx(id,j)).lt.1.d-8)gxx(id,j)=0.d0
+              if(abs(gyy(id,j)).lt.1.d-8)gyy(id,j)=0.d0
+              if(abs(gzz(id,j)).lt.1.d-8)gzz(id,j)=0.d0
+              
+c     rotational inertia tensor of group type
+              
+              rotinx(id,1)=rotinx(id,1)+
+     x          weight(i)*(gyy(id,j)**2+gzz(id,j)**2)
+              rotiny(id,1)=rotiny(id,1)+
+     x          weight(i)*(gzz(id,j)**2+gxx(id,j)**2)
+              rotinz(id,1)=rotinz(id,1)+
+     x          weight(i)*(gxx(id,j)**2+gyy(id,j)**2)
+              
+            enddo
+            
+c     set axis system such that: Ixx >=Iyy >=Izz
+            
+            rotxyz=max(rotinx(id,1),rotiny(id,1),rotinz(id,1))
+            
+            if(rotxyz.ge.rotinx(id,1))then
+              
+              if(rotiny(id,1).ge.rotxyz)then
+                
+                do j=1,numgsit(id)
+                  
+                  a1=gxx(id,j)
+                  gxx(id,j)=gyy(id,j)
+                  gyy(id,j)=-a1
+                  
+                enddo
+                
+                rotiny(id,1)=rotinx(id,1)
+                rotinx(id,1)=rotxyz
+                
+              elseif(rotinz(id,1).ge.rotxyz)then
+                
+                do j=1,numgsit(id)
+                  
+                  a1=gxx(id,j)
+                  gxx(id,j)=gzz(id,j)
+                  gzz(id,j)=-a1
+                  
+                enddo
+                
+                rotinz(id,1)=rotinx(id,1)
+                rotinx(id,1)=rotxyz
+                
+              endif
+              
+            endif
+            
+            if(rotinz(id,1).gt.rotiny(id,1))then
+              
+              do j=1,numgsit(id)
+                
+                a1=gyy(id,j)
+                gyy(id,j)=gzz(id,j)
+                gzz(id,j)=-a1
+                
+              enddo
+              
+              a1=rotinz(id,1)
+              rotinz(id,1)=rotiny(id,1)
+              rotiny(id,1)=a1
+              
+            endif
+            
+c     set up principal axis system in terms of site positions
+            
+c     test for (near) linear unit
+            
+            ill=0
+            rtall=(rotinx(id,1)+rotiny(id,1)+rotinz(id,1))
+            
+            if(rtall.gt.1.d-5)then
+              rotall=rtall
+            else
+              rotall=1.d0
+            endif
+            
+            rotmin(id)=min(rotinx(id,1),rotiny(id,1))
+            rotmin(id)=min(rotmin(id),rotinz(id,1))/rotall
+            
+            if((rotinx(id,1)/rotall).lt.1.d-5)ill=ill+1
+            if((rotiny(id,1)/rotall).lt.1.d-5)ill=ill+1
+            if((rotinz(id,1)/rotall).lt.1.d-5)ill=ill+1
+            
+            if(ill.ge.2)then
+
+c     point particle only
+              
+              ind(id,1)=1
+              ind(id,2)=1
+              ind(id,3)=1
+              
+              do jj=1,9
+                gaxs(id,jj)=0.d0
+              enddo
+              
+            elseif(ill.eq.1)then
+              
+c     linear molecule
+              
+              ind(id,1)=1
+              ind(id,2)=2
+              ind(id,3)=1
+              
+              aa(1)=gxx(id,1)-gxx(id,2)
+              aa(4)=gyy(id,1)-gyy(id,2)
+              aa(7)=gzz(id,1)-gzz(id,2)
+              rsq=sqrt(aa(1)**2+aa(4)**2+aa(7)**2)
+              
+              if(abs(aa(7)/rsq).gt.0.5d0)then
+                
+                rsq=sqrt(aa(4)**2+aa(7)**2)
+                aa(2)=0.d0
+                aa(5)=aa(7)/rsq
+                aa(8)=-aa(4)/rsq
+                
+              elseif(abs(aa(4)/rsq).gt.0.5d0)then
+                
+                rsq=sqrt(aa(4)**2+aa(1)**2)
+                aa(2)=-aa(4)/rsq
+                aa(5)=aa(1)/rsq
+                aa(8)=0.d0
+                
+              elseif(abs(aa(1)/rsq).gt.0.5d0)then
+                
+                rsq=sqrt(aa(1)**2+aa(7)**2)
+                aa(2)=-aa(7)/rsq
+                aa(5)=0.d0
+                aa(8)=aa(1)/rsq
+                
+              endif
+              
+              aa(3)=aa(4)*aa(8)-aa(7)*aa(5)
+              aa(6)=aa(7)*aa(2)-aa(1)*aa(8)
+              aa(9)=aa(1)*aa(5)-aa(4)*aa(2)
+              
+              call invert(aa,bb,det)
+              
+              if(abs(det).lt.1.d-5)call error(idnode,306)
+              
+              do j=1,9
+                gaxs(id,j)=bb(j)
+              enddo
+              
+            elseif(ill.eq.0)then
+              
+c     non-linear molecule
+              
+              i1=1
+              i2=1
+              i3=1
+              pass1=.true.
+              dettest=1.d-1
+              
+              do while(pass1.and.i2.lt.numgsit(id)-1)
+                
+                i2=i2+1
+                i3=i2
+                pass2=.true.
+                
+                do while(pass2.and.i3.lt.numgsit(id))
+                  
+                  i3=i3+1
+                  
+                  aa(1)=gxx(id,i1)-gxx(id,i2)
+                  aa(4)=gyy(id,i1)-gyy(id,i2)
+                  aa(7)=gzz(id,i1)-gzz(id,i2)
+                  aa(2)=gxx(id,i1)-gxx(id,i3)
+                  aa(5)=gyy(id,i1)-gyy(id,i3)
+                  aa(8)=gzz(id,i1)-gzz(id,i3)
+                  aa(3)=aa(4)*aa(8)-aa(7)*aa(5)
+                  aa(6)=aa(7)*aa(2)-aa(1)*aa(8)
+                  aa(9)=aa(1)*aa(5)-aa(4)*aa(2)
+                  
+c     invert matrix
+                  
+                  call invert(aa,bb,det)
+                  
+c     check on size of determinant - to see if the 3 sites are
+c     too close to being linear for safety.
+                  
+                  pass2=abs(det).lt.dettest
+                  
+                enddo
+                
+                pass1=abs(det).lt.dettest
+                
+              enddo
+              
+              if(abs(det).lt.dettest)call error(idnode,306)
+              
+c     store indices used
+              
+              ind(id,1)=i1
+              ind(id,2)=i2
+              ind(id,3)=i3
+              
+c     store coefficients 
+              
+              do j=1,9
+                
+                gaxs(id,j)=bb(j)
+                
+              enddo
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+c     check that rigid unit does not contain frozen atoms
+        
+        safe=.true.
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            if(lstfrz(i).ne.0)safe=.false.
+            
+          enddo
+          
+        enddo
+        
+c     global check on error condition
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)call error(idnode,360)
+        
+c     quaternions for all rigid groups in system
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          i1=lstrgd(jr+ind(id,1))
+          i2=lstrgd(jr+ind(id,2))
+          i3=lstrgd(jr+ind(id,3))
+          
+          jr=jr+numgsit(id)
+          
+c     group basis vectors
+          
+          aa(1)=xxx(i1)-xxx(i2)
+          aa(4)=yyy(i1)-yyy(i2)
+          aa(7)=zzz(i1)-zzz(i2)
+          
+          call images(imcon,0,1,1,cell,aa(1),aa(4),aa(7))
+          
+          if(rotmin(id).gt.1.d-5)then
+            
+            aa(2)=xxx(i1)-xxx(i3)
+            aa(5)=yyy(i1)-yyy(i3)
+            aa(8)=zzz(i1)-zzz(i3)
+            
+          else
+            
+            rsq=sqrt(aa(1)**2+aa(4)**2+aa(7)**2)
+            
+            if(abs(aa(7)/rsq).gt.0.5d0)then
+              
+              rsq=sqrt(aa(4)**2+aa(7)**2)
+              aa(2)=0.d0
+              aa(5)=aa(7)/rsq
+              aa(8)=-aa(4)/rsq
+              
+            elseif(abs(aa(4)/rsq).gt.0.5d0)then
+              
+              rsq=sqrt(aa(4)**2+aa(1)**2)
+              aa(2)=-aa(4)/rsq
+              aa(5)=aa(1)/rsq
+              aa(8)=0.d0
+              
+            elseif(abs(aa(1)/rsq).gt.0.5d0)then
+              
+              rsq=sqrt(aa(1)**2+aa(7)**2)
+              aa(2)=-aa(7)/rsq
+              aa(5)=0.d0
+              aa(8)=aa(1)/rsq
+              
+            endif
+            
+          endif
+          
+          call images(imcon,0,1,1,cell,aa(2),aa(5),aa(8))
+          
+          aa(3)=aa(4)*aa(8)-aa(7)*aa(5)
+          aa(6)=aa(7)*aa(2)-aa(1)*aa(8)
+          aa(9)=aa(1)*aa(5)-aa(4)*aa(2)
+          
+c     group rotational matrix
+          
+          rot(1)=gaxs(id,1)*aa(1)+gaxs(id,4)*aa(2)+gaxs(id,7)*aa(3)
+          rot(2)=gaxs(id,2)*aa(1)+gaxs(id,5)*aa(2)+gaxs(id,8)*aa(3)
+          rot(3)=gaxs(id,3)*aa(1)+gaxs(id,6)*aa(2)+gaxs(id,9)*aa(3)
+          rot(4)=gaxs(id,1)*aa(4)+gaxs(id,4)*aa(5)+gaxs(id,7)*aa(6)
+          rot(5)=gaxs(id,2)*aa(4)+gaxs(id,5)*aa(5)+gaxs(id,8)*aa(6)
+          rot(6)=gaxs(id,3)*aa(4)+gaxs(id,6)*aa(5)+gaxs(id,9)*aa(6)
+          rot(7)=gaxs(id,1)*aa(7)+gaxs(id,4)*aa(8)+gaxs(id,7)*aa(9)
+          rot(8)=gaxs(id,2)*aa(7)+gaxs(id,5)*aa(8)+gaxs(id,8)*aa(9)
+          rot(9)=gaxs(id,3)*aa(7)+gaxs(id,6)*aa(8)+gaxs(id,9)*aa(9)
+          
+c     determine quaternions from rotational matrix
+          
+          aq=rot(1)+rot(5)
+          bq=rot(2)-rot(4)
+          cq=rot(6)-rot(8)
+          dq=rot(2)+rot(4)
+          eq=rot(3)+rot(7)
+          fq=rot(6)+rot(8)
+          gq=rot(3)-rot(7)
+          hq=rot(1)-rot(5)
+          
+          q0(ig)=0.5d0*sqrt(aq+sqrt(aq*aq+bq*bq))
+          
+          if(q0(ig).gt.1.d-4)then
+            
+            q1(ig)=-0.25d0*cq/q0(ig)
+            q2(ig)=0.25d0*gq/q0(ig)
+            q3(ig)=-0.25d0*bq/q0(ig)
+            
+          else
+            
+            q1(ig)=0.5d0*sqrt(hq+sqrt(hq*hq+dq*dq))
+            
+            if(q1(ig).gt.1.d-4)then
+              
+              q2(ig)=0.25d0*dq/q1(ig)
+              q3(ig)=0.25d0*eq/q1(ig)
+              
+            else
+              
+              q2(ig)=0.5d0*sqrt(-hq+sqrt(hq*hq+dq*dq))
+              
+              if(q2(ig).gt.1.d-4)then
+                
+                q3(ig)=0.25d0*fq/q2(ig)
+                
+              else
+                
+                q3(ig)=1.d0
+                
+              endif
+              
+            endif
+            
+          endif
+          
+c     normalise quaternions
+          
+          rnorm=1.d0/sqrt(q0(ig)**2+q1(ig)**2+q2(ig)**2+q3(ig)**2)
+          q0(ig)=rnorm*q0(ig)
+          q1(ig)=rnorm*q1(ig)
+          q2(ig)=rnorm*q2(ig)
+          q3(ig)=rnorm*q3(ig)
+          
+        enddo
+        
+c     test for redundant degrees of freedom
+c     and ensure rotational inertias are non-zero
+        
+        degrot=0.d0
+        
+        if(lsolva)then
+          degrot_sol(:)=0.d0
+        endif
+        
+        do ig=1,ngrp
+          
+          id=lstgtp(ig)
+          rotall=1.d0/max(1.d-5,rotinx(id,1)+rotiny(id,1)+
+     x      rotinz(id,1))
+          
+          if(rotall*rotinx(id,1).lt.1.d-5)then
+            degrot=degrot-1.d0
+          endif
+          
+          if(rotall*rotiny(id,1).lt.1.d-5)then
+            degrot=degrot-1.d0
+          endif
+          
+          if(rotall*rotinz(id,1).lt.1d-5)then
+            degrot=degrot-1.d0
+          endif
+          
+        enddo
+        
+c     rotational degrees of freedom and rigid body contribution
+c     to total degrees of freedom
+        
+        degrot=degrot+dble(ngrp)*3.d0
+        degfre=degrot+dble(ngrp)*3.d0
+        
+        if(lsolva)then
+          
+          fngrp=1
+          lngrp=0
+          
+          do itmols=1,mxtmls
+            
+            lngrp=lngrp+nummols(itmols)*numgrp(itmols)
+            
+            do ig=fngrp,lngrp
+              
+              id=lstgtp(ig)
+              rotall=1.d0/max(1.d-5,rotinx(id,1)+rotiny(id,1)+
+     x          rotinz(id,1))
+              
+              if(rotall*rotinx(id,1).lt.1.d-5)then
+                degrot_sol(itmols)=degrot_sol(itmols)-1.d0
+              endif
+              
+              if(rotall*rotiny(id,1).lt.1.d-5)then
+                degrot_sol(itmols)=degrot_sol(itmols)-1.d0
+              endif
+              
+              if(rotall*rotinz(id,1).lt.1d-5)then
+                degrot_sol(itmols)=degrot_sol(itmols)-1.d0
+              endif
+              
+            enddo
+            
+            fngrp=lngrp+1
+            
+          enddo
+          
+        endif
+        
+c     summarise results
+        
+        if(idnode.eq.0)then
+          
+          if(gmass(1).gt.0.d0)then
+            
+            write(nrite,'(/,/,12x,a)')' summary of rigid body set up'
+            
+            do id=1,mxungp
+              
+              if(gmass(id).gt.0.d0)then
+                
+                write(nrite,'(/,a,i10)')' group of type ',id
+                write(nrite,'(12x,a,f20.10)')' total mass    ',
+     x            gmass(id)
+                write(nrite,'(12x,a,3f20.10)')' rot. inertia  ',
+     x            rotinx(id,1),rotiny(id,1),rotinz(id,1)
+                write(nrite,'(/,12x,a,3(8x,a7))')' site','a coord',
+     x            'b coord','c coord'
+                do j=1,numgsit(id)
+                  write(nrite,'(12x,i5,1p,3e15.5)')j,gxx(id,j),
+     x              gyy(id,j),gzz(id,j)
+                enddo
+                
+              endif
+              
+            enddo
+            
+          endif
+          
+        endif
+        
+c     find number of unique groups 
+        
+        ngp=0
+        do ig=1,ngrp
+          ngp=max(ngp,lstgtp(ig))
+        enddo
+        
+c     calculate reciprocal of rotational inertias 
+        
+        do id=1,ngp
+          
+          rotlim=max(1.d-2,rotinx(id,1)+rotiny(id,1)+
+     x      rotinz(id,1))*1.d-5
+          
+          if(rotinx(id,1).lt.rotlim)then
+            rotinx(id,2)=0.d0
+          else
+            rotinx(id,2)=1.d0/rotinx(id,1)
+          endif
+          
+          if(rotiny(id,1).lt.rotlim)then
+            rotiny(id,2)=0.d0
+          else
+            rotiny(id,2)=1.d0/rotiny(id,1)
+          endif
+          
+          if(rotinz(id,1).lt.rotlim)then
+            rotinz(id,2)=0.d0
+          else
+            rotinz(id,2)=1.d0/rotinz(id,1)
+          endif
+          
+        enddo
+        
+c     Check of quaternion set up with atomic positions
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     group type
+          
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          rot(1)=q0(ig)**2+q1(ig)**2-q2(ig)**2-q3(ig)**2
+          rot(2)=2.d0*(q1(ig)*q2(ig)-q0(ig)*q3(ig))
+          rot(3)=2.d0*(q1(ig)*q3(ig)+q0(ig)*q2(ig))
+          rot(4)=2.d0*(q1(ig)*q2(ig)+q0(ig)*q3(ig))
+          rot(5)=q0(ig)**2-q1(ig)**2+q2(ig)**2-q3(ig)**2
+          rot(6)=2.d0*(q2(ig)*q3(ig)-q0(ig)*q1(ig))
+          rot(7)=2.d0*(q1(ig)*q3(ig)-q0(ig)*q2(ig))
+          rot(8)=2.d0*(q2(ig)*q3(ig)+q0(ig)*q1(ig))
+          rot(9)=q0(ig)**2-q1(ig)**2-q2(ig)**2+q3(ig)**2
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxt(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x        rot(3)*gzz(id,j)+gcmx(ig)
+            yyt(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x        rot(6)*gzz(id,j)+gcmy(ig)
+            zzt(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x        rot(9)*gzz(id,j)+gcmz(ig)
+            
+            
+            txx(jr)=xxx(i)-xxt(i)
+            tyy(jr)=yyy(i)-yyt(i)
+            tzz(jr)=zzz(i)-zzt(i)
+            
+          enddo
+          
+        enddo
+        
+        call images(imcon,0,1,jr,cell,txx,tyy,tzz)
+        
+c     set tolerance for testing quaternion setup.
+        
+        rsq=0.d0
+        tol=1.d-2
+        
+        do i=1,jr
+          
+          rrr=txx(i)**2+tyy(i)**2+tzz(i)**2
+          if(rrr.gt.tol)then 
+            
+            rsq=rrr
+            
+          endif
+          
+        enddo
+        
+c     exit if error in set up
+        
+        safe=.true.
+        if(rsq.gt.tol)safe=.false.
+        if(mxnode.gt.1)call gstate(safe)
+        
+        if(.not.safe)call  error(idnode,310)
+        
+c     sort lstgot into ascending order
+        
+        call shellsort(jt,lstgot)
+        
+c     check that no site is in more than 1 rigid group
+        
+        i=1
+        safe=.true.
+        do while(i.lt.jt)
+          
+          i=i+1
+          linear=.true.
+          do while(linear)
+            
+            linear=.false.
+            
+            if(lstgot(i).eq.lstgot(i-1))then
+              
+              linear=.true.
+              safe=.false.
+              jt=jt-1
+              
+              do j=i,jt
+                lstgot(j)=lstgot(j+1)
+              enddo
+              
+            endif
+            
+            if(i.ge.jt)linear=.false.
+            
+          enddo
+          
+        enddo
+        
+        if(.not.safe)call error(idnode,320)
+        
+c     list of 'free' sites
+        
+        ii=1
+        jj=0
+        do i=1,natms
+          
+          if(lstgot(ii).eq.i)then
+            
+            ii=ii+1
+            
+          else
+            
+            if(lstfrz(i).eq.0)then
+              jj=jj+1
+              lstfre(jj)=i
+            endif
+            
+          endif
+          
+        enddo
+        
+c     number of free sites
+        
+        ntfree=jj
+        
+c     list of atoms integrated on this node
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          jr=jr+numgsit(id)
+          
+        enddo
+        
+        do i=1,jr
+          lstme(i)=lstrgd(i)
+        enddo
+        
+c     block parameters for free atoms
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+        do i=ifre1,ifre2
+          
+          jr=jr+1
+          lstme(jr)=lstfre(i)
+          
+        enddo
+        
+c     exchange quaternion data with other nodes
+        
+        if(mxnode.gt.1)call merge4
+     x    (idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+      if(lsolva)lstgot_sol(:)=lstgot(:)
+      
+c     deallocate work arrays
+      
+      deallocate (ind,lstgot,stat=fail(1))
+      deallocate (txx,tyy,tzz,stat=fail(2))
+      deallocate (xxt,yyt,zzt,stat=fail(3))
+      deallocate (gaxs,rotmin,stat=fail(4))
+      deallocate (accum,stat=fail(5))
+      
+      return
+      end subroutine quatbook
+      
+      subroutine abort_field_read(kode,idnode,nfield)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for aborting FIELD file read
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer kode,idnode,nfield
+      
+      if(idnode.eq.0)close (nfield)
+      
+      if(kode.eq.1)then
+        
+c     end of field file error exit
+        
+        call error(idnode,52)
+        
+      elseif(kode.eq.2)then
+        
+c     unrecognised directive in field file
+        
+        call error(idnode,4)
+        
+      endif
+      
+      return
+      end subroutine abort_field_read
+      
+      subroutine abort_control_read(kode,idnode,nread)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for aborting CONTROL file read
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer kode,idnode,nread
+      
+      if(idnode.eq.0)close (nread)
+      
+      if(kode.eq.1)then
+        
+c     end of control file error exit
+        
+        call error(idnode,53)
+        
+      elseif(kode.eq.2)then
+        
+c     general error exit from field file processing
+        
+        call error(idnode,0)
+        
+      endif
+      
+      return
+      end subroutine abort_control_read
+      
+      subroutine abort_config_read(kode,idnode,nconf)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for aborting CONTROL file read
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer kode,idnode,nconf
+      
+      if(idnode.eq.0)close (nconf)
+      
+      if(kode.eq.1)then
+        
+c     general error exit from field file processing
+        
+        call error(idnode,54)
+        
+      elseif(kode.eq.2)then
+        
+c     end of config file error exit
+        
+        call error(idnode,55)
+        
+      endif
+      
+      return
+      end subroutine abort_config_read
+      
+      subroutine neutbook(lneut,idnode,natms,nneut)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for neutral group bookkeeping
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    nov 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lneut,safe
+      integer idnode,natms,nneut,i
+      
+      safe=.true.
+      
+c     neutral group bookkeeping: sites must be listed consecutively
+      
+      if(lneut)then
+        
+        if(lstneu(1).ne.1)call error(idnode,230)
+        
+        neulst(1)=1
+        nneut=1
+        
+        do i=2,natms
+          
+          safe=.false.
+          if(lstneu(i).eq.lstneu(i-1))safe=.true.
+          if(lstneu(i).eq.lstneu(i-1)+1)then
+            
+            safe=.true.
+            nneut=nneut+1
+            if(nneut.gt.mxneut)call error(idnode,220)
+            neulst(nneut)=i
+            
+          endif
+          
+          if(.not.safe)call error(idnode,230)
+          
+        enddo
+        
+        neulst(nneut+1)=natms+1
+        
+      endif
+      
+      return
+      
+      end subroutine neutbook
+      
+      subroutine intlist
+     x  (lshmov,lcnb,idnode,mxnode,natms,nscons,ntangl,ntbond,
+     x  ntcons,ntdihd,ntinv,ntpmls,ntteth,ntshl,ntpmf,nspmf,ngrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the interaction lists
+c     for the entire simulated system
+c     
+c     parallel replicated dat version : block data
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith        july 1992
+c     amended   - t.forester      oct 1993
+c     amended   - t.forester      dec 1994 : block data
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lshmov,safe1,lcnb,lchk,lfail
+      integer idnode,mxnode,natms,nscons,ntangl,ntbond,ntcons
+      integer ntdihd,ntinv,ntpmls,ntteth,ntshl,ntpmf,nspmf
+      integer ibonds,jbonds,kbonds,ipmf,jpmf,iangle,jangle,kangle
+      integer idihed,jdihed,kdihed,iinver,jinver,kinver,iteths
+      integer jteths,kteths,ishels,jshels,kshels,ntbon0,ntpmf0
+      integer ntang0,ntdih0,ntinv0,nttet0,ntshl0,ntcon0,idum
+      integer itmols,isite,iconst,jconst,kconst,ibnd1,ibnd2,ipmf1
+      integer ipmf2,iang1,iang2,idih1,idih2,iinv1,iinv2,itet1
+      integer itet2,ishl1,ishl2,imols,lbonds,lpmf,jj,nnn,langle
+      integer ldihed,linver,lteths,lshels,i,ii,ntmp,klo,khi,ngrp
+      integer klo0,ifail,iloop,nnode,nscons0,nscons1,icon,fail
+      integer kcons,id,jdnode,lconst,itry,iatom,jatom,j,nfail
+      real(8) tol
+      
+      integer, allocatable :: itest(:),index(:),kscons(:)
+      integer, allocatable :: msite(:),mconst(:),listin(:)
+      
+      dimension fail(4)
+      
+      data fail/0,0,0,0/
+      
+c     allocate work arrays
+      
+      allocate (itest(mxtmls),index(mxtmls),stat=fail(1))
+      allocate (msite(mxtmls),mconst(mxtmls),stat=fail(2))
+      allocate (listin(mxatms),stat=fail(3))
+      allocate (kscons(0:mxproc-1),stat=fail(4))
+      do i=1,4
+        if(fail(i).ne.0)call error(idnode,1800)
+      enddo
+      
+c     initialise bookkeeping indices
+      
+      ibonds=0
+      jbonds=0
+      kbonds=0
+      ipmf=0
+      jpmf=0
+      iangle=0
+      jangle=0
+      kangle=0
+      idihed=0
+      jdihed=0
+      kdihed=0
+      iinver=0
+      jinver=0
+      kinver=0
+      iteths=0
+      jteths=0
+      kteths=0
+      ishels=0
+      jshels=0
+      kshels=0
+      safe=.true.
+      safe1=.true.
+      
+c     find total number of bonds,pmf constraints,bond constraints,
+c     angles,dihedrals,inversions, tethers,core-shells, in system 
+c     - ignoring frozen atoms
+      
+      ntbon0=0
+      ntpmf0=0
+      ntcon0=0
+      ntang0=0
+      ntdih0=0
+      ntinv0=0
+      nttet0=0
+      ntshl0=0
+      nscons=0
+      ntcons=0
+      
+      do itmols=1,ntpmls
+        
+        ntbon0=ntbon0+nummols(itmols)*numbonds(itmols)
+        ntpmf0=ntpmf0+nummols(itmols)*numpmf(itmols)
+        ntcon0=ntcon0+nummols(itmols)*numcon(itmols)
+        ntang0=ntang0+nummols(itmols)*numang(itmols)
+        ntdih0=ntdih0+nummols(itmols)*numdih(itmols)
+        ntinv0=ntinv0+nummols(itmols)*numinv(itmols)
+        nttet0=nttet0+nummols(itmols)*numteth(itmols)
+        ntshl0=ntshl0+nummols(itmols)*numshl(itmols)
+        
+      enddo
+      
+      isite=0
+      iconst=0
+      jconst=0
+      kconst=0
+      
+c     first and last index of bonds, angles etc for this node
+      
+      ibnd1=(idnode*ntbon0)/mxnode+1
+      ibnd2=((idnode+1)*ntbon0)/mxnode
+      
+      ipmf1=(idnode*ntpmf0)/mxnode+1
+      ipmf2=((idnode+1)*ntpmf0)/mxnode
+      ntpmf=ntpmf0
+      nspmf=ipmf2+1-ipmf1
+      
+      iang1=(idnode*ntang0)/mxnode+1
+      iang2=((idnode+1)*ntang0)/mxnode
+      
+      idih1=(idnode*ntdih0)/mxnode+1
+      idih2=((idnode+1)*ntdih0)/mxnode
+      
+      iinv1=(idnode*ntinv0)/mxnode+1
+      iinv2=((idnode+1)*ntinv0)/mxnode
+      
+      itet1=(idnode*nttet0)/mxnode+1
+      itet2=((idnode+1)*nttet0)/mxnode
+      
+      ishl1=(idnode*ntshl0)/mxnode+1
+      ishl2=((idnode+1)*ntshl0)/mxnode
+      
+c     loop over molecule types
+      
+      do itmols=1,ntpmls
+        
+        
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+          
+c     construct bond constraint list later
+c     construct chemical bond interaction list
+          
+          do lbonds=1,numbonds(itmols)
+            
+            ibonds=ibonds+1
+            
+            if(ibonds.ge.ibnd1.and.ibonds.le.ibnd2)then
+              
+              jbonds=jbonds+1
+              if(jbonds.le.mxbond)then
+                
+                listbnd(jbonds,1)=lbonds+kbonds
+                listbnd(jbonds,2)=lstbnd(lbonds+kbonds,1)
+     x            +isite
+                listbnd(jbonds,3)=lstbnd(lbonds+kbonds,2)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,31)
+          
+c     construct pmf site lists - no exclusions
+          
+          do lpmf=1,numpmf(itmols)
+            
+            ipmf=ipmf+1
+            
+            if(ipmf.ge.ipmf1.and.ipmf.le.ipmf2)then
+              
+              jpmf=jpmf+1
+              if(jpmf.le.mspmf)then
+                
+                nnn=npmf(1)+npmf(2)
+                if(nnn.le.mxspmf)then
+                  
+                  do jj=1,npmf(1)+npmf(2)
+                    lstpmf(jj,jpmf)=indpmf(jj)+isite
+                  enddo
+                  
+                else
+                  
+                  safe=.false.
+                  
+                endif
+                
+              else
+                
+                safe1=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe1)
+          if(.not.safe1)call error(idnode,458)
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,460)
+          
+c     construct valence angle interaction list
+          
+          do langle=1,numang(itmols)
+            
+            iangle=iangle+1
+            
+            if(iangle.ge.iang1.and.iangle.le.iang2)then
+              
+              jangle=jangle+1
+              if(jangle.le.mxangl)then
+                
+                listang(jangle,1)=langle+kangle
+                listang(jangle,2)=lstang(langle+kangle,1)
+     x            +isite
+                listang(jangle,3)=lstang(langle+kangle,2)
+     x            +isite
+                listang(jangle,4)=lstang(langle+kangle,3)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,51)
+          
+c     construct dihedral angle interaction list
+          
+          do ldihed=1,numdih(itmols)
+            
+            idihed=idihed+1
+            
+            if(idihed.ge.idih1.and.idihed.le.idih2)then
+              
+              jdihed=jdihed+1
+              if(jdihed.le.mxdihd)then
+                
+                listdih(jdihed,1)=ldihed+kdihed
+                listdih(jdihed,2)=lstdih(ldihed+kdihed,1)
+     x            +isite
+                listdih(jdihed,3)=lstdih(ldihed+kdihed,2)
+     x            +isite
+                listdih(jdihed,4)=lstdih(ldihed+kdihed,3)
+     x            +isite
+                listdih(jdihed,5)=lstdih(ldihed+kdihed,4)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,61)
+          
+c     construct inversion potential list
+          
+          do linver=1,numinv(itmols)
+            
+            iinver=iinver+1
+            
+            if(iinver.ge.iinv1.and.iinver.le.iinv2)then
+              
+              jinver=jinver+1
+              if(jinver.le.mxinv)then
+                
+                listinv(jinver,1)=linver+kinver
+                listinv(jinver,2)=lstinv(linver+kinver,1)
+     x            +isite
+                listinv(jinver,3)=lstinv(linver+kinver,2)
+     x            +isite
+                listinv(jinver,4)=lstinv(linver+kinver,3)
+     x            +isite
+                listinv(jinver,5)=lstinv(linver+kinver,4)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,77)
+          
+c     construct tethered atoms interaction list
+          
+          do lteths=1,numteth(itmols)
+            
+            iteths=iteths+1
+            
+            if(iteths.ge.itet1.and.iteths.le.itet2)then
+              
+              jteths=jteths+1
+              if(jteths.le.msteth)then
+                
+                listtet(jteths,1)=lteths+kteths
+                listtet(jteths,2)=lsttet(lteths+kteths)+isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,63)
+          
+c     construct core-shell list
+          
+          do lshels=1,numshl(itmols)
+            
+            ishels=ishels+1
+            
+            if(ishels.ge.ishl1.and.ishels.le.ishl2)then
+              
+              jshels=jshels+1
+              if(jshels.le.mxshl)then
+                
+                listshl(jshels,1)=lshels+kshels
+                listshl(jshels,2)=lstshl(lshels+kshels,1)
+     x            +isite
+                listshl(jshels,3)=lstshl(lshels+kshels,2)
+     x            +isite
+                
+              else
+                
+                safe=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          if(mxnode.gt.1)call gstate(safe)
+          if(.not.safe)call error(idnode,59)
+          
+          isite=isite+numsit(itmols)
+          
+        enddo
+        
+        kbonds=kbonds+numbonds(itmols)
+        kangle=kangle+numang(itmols)
+        kdihed=kdihed+numdih(itmols)
+        kinver=kinver+numinv(itmols)
+        kteths=kteths+numteth(itmols)
+        kshels=kshels+numshl(itmols)
+        
+      enddo
+      
+c     store array counters for bookkeeping
+      
+      ntbond=ibonds
+      ntangl=iangle
+      ntdihd=idihed
+      ntinv=iinver
+      ntteth=iteths
+      ntshl=ishels
+      
+c     pass bond constraint information to other nodes
+      
+      if(ntcon0.gt.0)then
+        
+        ntcons=ntcon0
+        
+c     find starting site no. and constraint no. for each molec. type
+        
+        msite(1)=0
+        mconst(1)=0
+        
+        do itmols=2,ntpmls
+          
+          msite(itmols)=msite(itmols-1)+numsit(itmols-1)*
+     x      nummols(itmols-1)
+          mconst(itmols)=mconst(itmols-1)+numcon(itmols-1)
+          
+        enddo
+        
+c     sort molecules into ascending order of number of constraints
+        
+        do i=1,ntpmls
+          
+          itest(i)=numcon(i)
+          index(i)=0
+          
+        enddo
+        
+        call shellsort(ntpmls,itest)
+        
+        do i=1,ntpmls
+          
+          lchk=.true.
+          do j=1,ntpmls
+            
+            if(itest(i).eq.numcon(j))then
+              
+              if(lchk)then 
+                index(i)=j
+                lchk=.false.
+                
+              endif
+              
+              do ii=1,i-1
+                if(index(ii).eq.j)lchk=.true.
+              enddo
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+c     load balance to within 10%
+        
+        tol=1.0d0+(0.10d0)/2.d0
+        kcons=(ntcons)/mxnode
+        ntmp=0
+        
+c     find smallest constrained molecule to allocate to a node
+        
+        do i=1,ntpmls
+          
+          if(ntmp.le.mxnode)then
+            
+            if(numcon(index(i)).gt.0)then
+              ntmp=ntmp+nummols(index(i))
+              klo=max(0,kcons-numcon(index(i))/2)
+              khi=klo+numcon(index(i))+1
+            endif
+            
+          endif
+          
+        enddo
+        
+c     reset hi/lo limits if molecules contain too many constraints
+        
+        if(dble(khi)/dble(max(1,klo)).gt.tol)then
+          klo=nint(dble(kcons)/tol)
+          khi=nint(dble(kcons)*tol)+1
+        endif
+        
+c     store lo value for later
+        
+        klo0=klo
+        
+c     begin assignment of constraints ----------------------------------
+        
+        ifail=-1
+        lfail=.true.
+        do while(lfail)
+          
+          ifail=ifail+1
+          
+          if(ifail.gt.ntpmls)then
+            call error(idnode,432)
+          endif
+          
+          iconst=0
+          jconst=0
+          kconst=0
+          lconst=0
+          
+c     zero running totals of constraints on each processor
+          
+          do id=0,mxnode-1
+            kscons(id)=0
+          enddo
+          
+          iloop=0
+          lfail=.false.
+          iconst=0
+          jconst=0
+          nnode=0
+          
+c     assign difficult molecules in blocks
+          
+          if(ifail.gt.0)then
+            
+            nfail=0
+            do i=1,ifail
+              
+              ii=ntpmls+1-i
+              nfail=nfail+nummols(index(ii))*numcon(index(ii))
+              
+            enddo
+            
+c     decide on number of processors to split over
+            
+            nnode=int(dble(nfail)/dble(max(kcons,1))+1.d0/tol)
+            nnode=max(2,nnode)
+            nnode=min(nnode,mxnode)
+            
+c     assign to processors 0..nnode-1
+            
+            do id=0,nnode-1
+              
+              nscons0=(id*nfail)/nnode+1
+              nscons1=((id+1)*nfail)/nnode
+              
+              kscons(id)=nscons1+1-nscons0
+              
+            enddo
+            
+c     this processors block
+            
+            nscons0=(idnode*nfail)/nnode+1
+            nscons1=((idnode+1)*nfail)/nnode
+            
+c     assign in blocks
+            
+            do itmols=ntpmls,ntpmls-ifail+1,-1
+              
+              ii=index(itmols)
+              icon=numcon(ii)
+              kconst=mconst(ii)
+              
+              do imols=1,nummols(ii)
+                
+                isite=msite(ii)+(imols-1)*numsit(ii)
+                
+c     construct bond constraint list
+                
+                do lconst=1,numcon(ii)
+                  
+                  iconst=iconst+1
+                  
+                  if(iconst.ge.nscons0.and.iconst.le.nscons1)then
+                    
+                    jconst=jconst+1
+                    
+                    if(jconst.le.mxcons)then
+                      
+                      listcon(jconst,1)=lconst+kconst
+                      iatom=lstcon(lconst+kconst,1)+isite
+                      jatom=lstcon(lconst+kconst,2)+isite
+                      
+                      listcon(jconst,2)=iatom
+                      listcon(jconst,3)=jatom
+                      
+                    else
+                      
+                      safe=.false.
+                      
+                    endif
+                    
+                  endif
+                  
+                enddo
+                
+              enddo
+              
+            enddo
+            
+          endif
+          
+c     assign non-problematic molecules
+          
+          jdnode=mod(nnode+1,mxnode)
+          
+          do itmols=ntpmls-ifail,1,-1
+            
+            ii=index(itmols)
+            icon=numcon(ii)
+            kconst=mconst(ii)
+            
+            do imols=1,nummols(ii)
+              
+              itry=0
+              lchk=.true.
+              do while(lchk)
+                
+                if(kscons(jdnode)+icon.le.klo)then
+                  
+                  if(jdnode.ne.idnode)then
+                    kscons(jdnode)=kscons(jdnode)+icon
+                    jdnode=mod(jdnode+1,mxnode)
+                    lchk=.false.
+                  else
+                    
+c     construct bond constraint list
+                    
+                    isite=msite(ii)+(imols-1)*numsit(ii)
+                    do lconst=1,numcon(ii)
+                      
+                      jconst=jconst+1
+                      
+                      if(jconst.le.mxcons)then
+                        
+                        listcon(jconst,1)=lconst+kconst
+                        iatom=lstcon(lconst+kconst,1)+isite
+                        jatom=lstcon(lconst+kconst,2)+isite
+                        listcon(jconst,2)=iatom
+                        listcon(jconst,3)=jatom
+                        
+                      else
+                        
+                        safe=.false.
+                        
+                      endif
+                      
+                    enddo
+                    
+                    kscons(jdnode)=kscons(jdnode)+icon
+                    jdnode=mod(jdnode+1,mxnode)
+                    lchk=.false.
+                    
+                  endif
+                  
+                else
+                  
+                  jdnode=mod(jdnode+1,mxnode)
+                  lchk=.true.
+                  itry=itry+1
+                  
+                endif
+                
+                if(lchk.and.itry.gt.mxnode)then
+                  
+                  klo=kcons
+                  kcons=khi
+                  itry=0
+                  iloop=iloop+1
+                  
+                endif
+                
+c     split molecule across nodes if have to
+                
+                if(iloop.gt.3)then
+                  lfail=.true.
+                  kcons=ntcons/mxnode
+                  klo=klo0
+                  lchk=.false.
+                endif
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+c     check no node has less than minimum number
+          
+          do id=0,mxnode-1
+            if(kscons(id).lt.klo0)then 
+              lfail=.true.
+            endif
+          enddo
+          
+        enddo
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)then
+          
+          if(mxnode.gt.1)call gimax(jconst,1,idum)
+          if(idnode.eq.0)write(nrite,'(a,i10,a,i10)')
+     x      'Number of constraints found ',jconst,'Max allowed ',mxcons
+          
+          call error(idnode,41)
+          
+        endif
+        
+        nscons=kscons(idnode)
+        
+        call passcon
+     x    (lshmov,idnode,mxnode,natms,nscons,lashap,lishap,listme,
+     x    listin,listot,listcon,lstfrz)
+        
+      endif
+      
+      if(npmf(1).gt.0)then
+        
+        call passpmf
+     x    (idnode,mxnode,natms,nspmf,listpm,listin,lstpmt,lstpmf,npmf)
+        
+      endif
+      
+c     pass rigid body data
+      
+      lcnb=.false.
+      if(ntcons.gt.0.and.ngrp.gt.0)then
+        
+        call passquat
+     x    (lcnb,idnode,mxnode,natms,ngrp,nscons,ntpmls,listin,
+     x    listcon,lstrgd,lstout,lstcsit,lstgtp,nummols,numgrp,
+     x    numgsit)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate(itest,index,msite,stat=fail(1))
+      deallocate(mconst,kscons,listin,stat=fail(2))
+      
+      return
+      end subroutine intlist
+      
+      subroutine ensemble_selection
+     x  (directive,lens,kill,idnode,keyens,mode,taut,taup)
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting the ensemble and reading 
+c     the required parameters
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical kill,lens
+      integer keyens,idnode,idum,mode
+      real(8) taut,taup
+      
+      if(findstring('nve',directive,idum))then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'microcanonical ensemble')")
+        if(lens)then
+          call error(idnode,-414)
+          kill=.true.
+        endif
+        lens=.true.
+        
+      elseif(findstring('nvt',directive,idum))then
+        
+        if(findstring('evans',directive,idum))then
+          
+          keyens=1
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Evans Gaussian temperature constraints',
+     x      ' in use')")
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('ber',directive,idum))then
+          
+          keyens=2
+          taut=dblstr(directive,69,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Berendsen thermostat',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4)")
+     x      taut
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('hoover',directive,idum))then
+          
+          keyens=3
+          taut=dblstr(directive,69,idum)
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Nose-Hoover ',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4)")
+     x      taut
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        else
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+      elseif(findstring('npt',directive,idum))then
+        
+        if(findstring('ber',directive,idum))then
+          
+          keyens=4
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Berendsen isotropic N-P-T',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('hoover',directive,idum))then
+          
+          keyens=5
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Nose-Hoover  (Melchionna) isotropic N-P-T ',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        else
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+      elseif(findstring('nst',directive,idum))then
+        
+        mode=0
+        if(findstring('block',directive,idum))mode=1
+        if(findstring('surf',directive,idum))mode=2
+        if(findstring('slab',directive,idum))mode=3
+        
+        if(findstring('ber',directive,idum))then
+          
+          keyens=6
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Berendsen anisotropic N-P-T',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        elseif(findstring('hoover',directive,idum))then
+          
+          keyens=7
+          taut=dblstr(directive,lenrec,idum)
+          taup=dblstr(directive,lenrec,idum)
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'Nose-Hoover (Melchionna) anisotropic N-P-T ',
+     x      /,1x,'thermostat relaxation time     ',1p,e12.4,
+     x      /,1x,'barostat relaxation time       ',1p,e12.4)")
+     x      taut,taup
+          if(lens)then
+            call error(idnode,-414)
+            kill=.true.
+          endif
+          lens=.true.
+          
+        else
+          
+          kill=.true.
+          if(idnode.eq.0)write(nrite,"(/,/,100a1)")record
+          call error(idnode,-3)
+          
+        endif
+        
+        if(idnode.eq.0)then
+          
+          if(mode.eq.0)then
+            write(nrite,"(/,1x,'NST mode 0 X<>Y<>Z')")
+          elseif(mode.eq.1)then
+            write(nrite,
+     x        "(/,1x,'NST mode 1 X<>Y<>Z (rectangular block)')")
+          elseif(mode.eq.2)then
+            write(nrite,
+     x        "(/,1x,'NST mode 2 X=Y<>Z (liquid surface)')")
+          elseif(mode.eq.3)then
+            write(nrite,
+     x        "(/,1x,'NST mode 3 X<>Y<>Z (solid slab)')")
+          endif
+          
+        endif
+        
+      elseif(findstring('pmf',directive,idum))then
+        
+        keyens=8
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'potential of mean force calculation (NVE)')")
+        if(lens)then
+          call error(idnode,-414)
+          kill=.true.
+        endif
+        lens=.true.
+        
+      else
+        
+        call error(idnode,-436)
+        kill=.true.
+        
+      endif
+      
+      return
+      end subroutine ensemble_selection
+      
+      subroutine neb_option
+     x  (directive,lneb,lminopt,idnode,numneb,keytol,sprneb,
+     x  opttol,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for NEB option
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit
+      character*1 directive(lenrec)
+      logical lneb,lminopt,endneb,safe
+      integer numneb,idnode,keytol,i,idum
+      real(8) sprneb,opttol,hyp_units
+      
+      if(lminopt)call error(idnode,225)
+      lminopt=.true.
+      lneb=.true.
+      endneb=.false.
+      numneb=intstr(directive,lenrec,idum)
+      if(numneb.eq.0)numneb=1
+      numneb=min(maxneb,numneb)
+      
+      hyp_units=1.d0
+      do while(.not.endneb)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+          cycle
+        elseif(findstring('endneb',directive,idum))then
+          endneb=.true.
+        elseif(findstring('units',directive,idum))then
+          hyp_units=energy_unit()
+          call getword(cunit,directive,8,lenrec)
+          call getword(cunit,directive,8,lenrec)
+        elseif(findstring('basin_1',directive,idum))then
+          call striptext(directive,lenrec,1)
+          do i=1,numneb
+            bsn_1(i)=intstr(directive,lenrec,idum)
+          enddo
+        elseif(findstring('basin_2',directive,idum))then
+          call striptext(directive,lenrec,1)
+          do i=1,numneb
+            bsn_2(i)=intstr(directive,lenrec,idum)
+          enddo
+        elseif(findstring('neb_spring',directive,idum))then
+          sprneb=dblstr(directive,lenrec,idum)
+        elseif(findstring('forc',directive,idum))then
+          keytol=0
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('ener',directive,idum))then
+          keytol=1
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('posi',directive,idum))then
+          keytol=2
+          opttol=dblstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,"(/,1x,'NEB calculation controls')")
+        write(nrite,"(/,1x,'identity of basin 1            ',
+     x    10i10)")(bsn_1(i),i=1,numneb)
+        write(nrite,"(1x,'identity of basin 2            ',
+     x    10i10)")(bsn_2(i),i=1,numneb)
+        write(nrite,
+     x    "(1x,'NEB spring constant            ',e12.4,
+     x    /,1x,'minimisation tolerance         ',e12.4,
+     x    /,1x,'energy units                   ',2x,a8)")
+     x    sprneb,opttol,cunit
+        
+        call print_optim(keytol)
+        
+      endif
+      
+c     units conversion
+      
+      sprneb=sprneb*hyp_units
+      if(keytol.lt.2)opttol=opttol*hyp_units
+      
+      return
+      end subroutine  neb_option
+      
+      subroutine bpd_option
+     x  (directive,seek,lbpd,ltad,lminopt,prechk,nebgo,keybpd,idnode,
+     x  nblock,ntrack,keytol,ebias,vmin,catchrad,sprneb,opttol,
+     x  hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for bias potential
+c     dynamics option
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit,seek
+      character*1 directive(lenrec)
+      logical lbpd,ltad,lminopt,prechk,endbpd,safe,nebgo
+      integer keybpd,idnode,nblock,ntrack,keytol,idum
+      real(8) ebias,vmin,catchrad,sprneb,opttol,hyp_units
+      
+      if(lminopt)call error(idnode,225)
+      if(ltad)call error(idnode,2355)
+      lminopt=.true.
+      lbpd=.true.
+      endbpd=.false.
+      cunit=" dl_poly"
+      if(idnode.eq.0)
+     x  write(nrite,"(/,1x,'bias potential dynamics controls')")
+      
+      if(findstring('dyn',directive,idum))then
+        
+        keybpd=1
+        hyp_units=energy_unit()
+        ebias=dblstr(directive,lenrec,idum)
+        vmin=dblstr(directive,lenrec,idum)
+        call getword(cunit,directive,8,lenrec)
+        if(idnode.eq.0)write(nrite,"(
+     x    1x,'dynamics option selected       ',
+     x    /,1x,'bias potential E_bias  (kelvin)',f10.4,
+     x    /,1x,'bias potential V_min   (kelvin)',f10.4
+     x    /,1x,'energy units                   ',2x,a8)")
+     x    ebias,vmin,cunit
+        
+      elseif(findstring('path',directive,idum))then
+        
+        keybpd=2
+        nebgo=.true.
+        hyp_units=1.d0
+        do while(.not.endbpd)
+          
+          call getrec(safe,idnode,nread)
+          if(.not.safe)call abort_control_read(1,idnode,nread)
+          call lowcase(record,lenrec)
+          call strip(record,lenrec)
+          call copystring(record,directive,lenrec)
+          
+          if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+            cycle
+          elseif(findstring('endbpd',directive,idum))then
+            endbpd=.true.
+          elseif(findstring('pre',directive,idum))then
+            prechk=.true.
+            if(findstring('false',directive,idum))prechk=.false.
+          elseif(findstring('noneb',directive,idum))then
+            nebgo=.false.
+          elseif(findstring('target',directive,idum))then
+            call getword(seek,directive,8,lenrec)
+            call getword(seek,directive,8,lenrec)
+          elseif(findstring('units',directive,idum))then
+            hyp_units=energy_unit()
+            call getword(cunit,directive,8,lenrec)
+            call getword(cunit,directive,8,lenrec)
+          elseif(findstring('ebias',directive,idum))then
+            ebias=dblstr(directive,lenrec,idum)
+          elseif(findstring('vmin',directive,idum))then
+            vmin=dblstr(directive,lenrec,idum)
+          elseif(findstring('num_block',directive,idum))then
+            nblock=intstr(directive,lenrec,idum)
+          elseif(findstring('num_track',directive,idum))then
+            ntrack=intstr(directive,lenrec,idum)
+          elseif(findstring('catch_radius',directive,idum))then
+            catchrad=dblstr(directive,lenrec,idum)
+          elseif(findstring('neb_spring',directive,idum))then
+            sprneb=dblstr(directive,lenrec,idum)
+          elseif(findstring('forc',directive,idum))then
+            keytol=0
+            opttol=dblstr(directive,lenrec,idum)
+          elseif(findstring('ener',directive,idum))then
+            keytol=1
+            opttol=dblstr(directive,lenrec,idum)
+          elseif(findstring('posi',directive,idum))then
+            keytol=2
+            opttol=dblstr(directive,lenrec,idum)
+          endif
+          
+        enddo
+        
+        if(idnode.eq.0)then
+          
+          write(nrite,"(
+     x      1x,'dynamics with path analysis selected',
+     x      /,1x,'bias potential E_bias  (kelvin)',f10.4,
+     x      /,1x,'bias potential V_min   (kelvin)',f10.4,
+     x      /,1x,'steps per time block           ',i10,
+     x      /,1x,'steps per tracking block       ',i10,
+     x      /,1x,'configuration catch radius  (A)',f10.4,
+     x      /,1x,'minimisation tolerance         ',e12.4,
+     x      /,1x,'atom type to be tracked        ',2x,a8,
+     x      /,1x,'energy units                   ',2x,a8)")
+     x      ebias,vmin,nblock,ntrack,catchrad,opttol,seek,cunit
+          if(nebgo)write(nrite,
+     x      "(1x,'NEB spring constant            ',e12.4)")sprneb
+          if(prechk)write(nrite,
+     x      "(1x,'transition prechecking option selected')")
+          call print_optim(keytol)
+          
+        endif
+        
+c     energy unit conversions
+        
+        sprneb=sprneb*hyp_units
+        if(keytol.lt.2)opttol=opttol*hyp_units
+        
+      endif
+      
+      return
+      end subroutine bpd_option
+      
+      subroutine tad_option
+     x  (directive,ltad,lbpd,lminopt,prechk,tadall,idnode,nblock,
+     x  ntrack,blkout,keytol,catchrad,sprneb,tlow,deltad,opttol,
+     x  hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for TAD option
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 cunit
+      character*1 directive(lenrec)
+      logical ltad,lbpd,lminopt,prechk,tadall,endtad,safe
+      integer idnode,nblock,ntrack,blkout,keytol,idum
+      real(8) catchrad,sprneb,deltad,tlow,opttol,hyp_units
+      
+      if(lminopt)call error(idnode,225)
+      if(lbpd)call error(idnode,2355)
+      lminopt=.true.
+      ltad=.true.
+      endtad=.false.
+      hyp_units=1.d0
+      
+      do while(.not.endtad)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+          cycle
+        elseif(findstring('endtad',directive,idum))then
+          endtad=.true.
+        elseif(findstring('pre',directive,idum))then
+          prechk=.true.
+          if(findstring('false',directive,idum))prechk=.false.
+        elseif(findstring('all',directive,idum))then
+          tadall=.true.
+          if(findstring('false',directive,idum))tadall=.false.
+        elseif(findstring('units',directive,idum))then
+          hyp_units=energy_unit()
+          call getword(cunit,directive,8,lenrec)
+          call getword(cunit,directive,8,lenrec)
+        elseif(findstring('num_block',directive,idum))then
+          nblock=intstr(directive,lenrec,idum)
+        elseif(findstring('num_track',directive,idum))then
+          ntrack=intstr(directive,lenrec,idum)
+        elseif(findstring('blackout',directive,idum))then
+          blkout=intstr(directive,lenrec,idum)
+        elseif(findstring('catch_radius',directive,idum))then
+          catchrad=dblstr(directive,lenrec,idum)
+        elseif(findstring('neb_spring',directive,idum))then
+          sprneb=dblstr(directive,lenrec,idum)
+        elseif(findstring('deltad',directive,idum))then
+          deltad=dblstr(directive,lenrec,idum)
+        elseif(findstring('low_temp',directive,idum))then
+          tlow=dblstr(directive,lenrec,idum)
+        elseif(findstring('forc',directive,idum))then
+          keytol=0
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('ener',directive,idum))then
+          keytol=1
+          opttol=dblstr(directive,lenrec,idum)
+        elseif(findstring('posi',directive,idum))then
+          keytol=2
+          opttol=dblstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'TAD dynamics controls'
+     x    /,1x,'steps per time block           ',i10,
+     x    /,1x,'steps per tracking block       ',i10,
+     x    /,1x,'steps in blackout periods      ',i10,
+     x    /,1x,'configuration catch radius     ',1p,e12.4,
+     x    /,1x,'NEB spring constant            ',e12.4,
+     x    /,1x,'stopping parameter             ',e12.4,
+     x    /,1x,'target low temperature         ',e12.4,
+     x    /,1x,'minimisation tolerance         ',e12.4,
+     x    /,1x,'energy units                   ',2x,a8)")
+     x    nblock,ntrack,blkout,catchrad,sprneb,deltad,
+     x    tlow,opttol,cunit
+        if(prechk)write(nrite,
+     x    "(1x,'transition prechecking option selected')")
+        if(tadall)write(nrite,
+     x    "(1x,'option for all basins analysis selected')")
+        call print_optim(keytol)
+        
+      endif
+      
+c     energy unit conversions
+      
+      sprneb=sprneb*hyp_units
+      if(keytol.lt.2)opttol=opttol*hyp_units
+      
+      return
+      end subroutine tad_option
+
+      subroutine metadyn_option
+     x  (directive,lmetadyn,lstein,ltet,lglobpe,llocpe,idnode,
+     x  ncolvar,nq4,nq6,ntet,hkey,meta_step_int,globpe_scale,
+     x  locpe_scale,ref_W_aug,h_aug,wt_Dt)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for metadynamics option
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2011
+c     
+c     note: default values are set in metafreeze_module
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lmetadyn,endmet,lstein,ltet,lglobpe,llocpe,safe
+      integer idnode,idum,ncolvar,nq4,nq6,ntet,hkey,meta_step_int
+      real(8) globpe_scale,locpe_scale,ref_W_aug,h_aug,wt_Dt
+      
+      lmetadyn=.true.
+      endmet=.false.          
+      
+      do while(.not.endmet)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(record(1).eq.'#'.or.record(1).eq.'&')then
+c     information only - skip record
+          cycle
+        elseif(findstring('endmet',directive,idum))then
+          endmet=.true.
+        elseif(findstring('ncolvar',directive,idum))then
+          ncolvar=intstr(directive,lenrec,idum)
+        elseif(findstring('lstein',directive,idum))then
+          lstein=.true.
+          if(findstring('false',directive,idum))lstein=.false.
+        elseif(findstring('ltet',directive,idum))then
+          ltet=.true.
+          if(findstring('false',directive,idum))ltet=.false.
+        elseif(findstring('lglobpe',directive,idum))then
+          lglobpe=.true.
+          if(findstring('false',directive,idum))lglobpe=.false.
+        elseif(findstring('llocpe',directive,idum))then
+          llocpe=.true.
+          if(findstring('false',directive,idum))llocpe=.false.
+        elseif(findstring('globpe_scale',directive,idum))then
+          globpe_scale=dblstr(directive,lenrec,idum)
+        elseif(findstring('locpe_scale',directive,idum))then
+          locpe_scale=dblstr(directive,lenrec,idum)
+        elseif(findstring('nq4',directive,idum))then
+          nq4=intstr(directive,lenrec,idum)
+          nq4=intstr(directive,lenrec,idum) ! do twice - number in name!
+        elseif(findstring('nq6',directive,idum))then
+          nq6=intstr(directive,lenrec,idum)
+          nq6=intstr(directive,lenrec,idum) ! do twice - number in name!
+        elseif(findstring('ntet',directive,idum))then
+          ntet=intstr(directive,lenrec,idum)
+        elseif(findstring('meta_step_int',directive,idum))then
+          meta_step_int=intstr(directive,lenrec,idum)
+        elseif(findstring('ref_w_aug',directive,idum))then
+          ref_W_aug=dblstr(directive,lenrec,idum)
+        elseif(findstring('h_aug',directive,idum))then
+          h_aug=dblstr(directive,lenrec,idum)
+        elseif(findstring('hkey',directive,idum))then
+          hkey=intstr(directive,lenrec,idum)
+        elseif(findstring('wt_dt',directive,idum))then
+          wt_dt=dblstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'metadynamics controls'
+     x    /,1x,'total number of collective variables',i10,
+     x    /,1x,'steinhardt parameters option (Q4/Q6)',l10,
+     x    /,1x,'tetrahedral parameters option (zeta)',l10,
+     x    /,1x,'global potential parameter option   ',l10,
+     x    /,1x,'local potential parameter option    ',l10,
+     x    /,1x,'global potential param. scale factor',e12.4,
+     x    /,1x,'local potential param. scale factor ',e12.4)")
+     x    ncolvar,lstein,ltet,lglobpe,llocpe,globpe_scale,locpe_scale
+        
+        write(nrite,
+     x    "(  1x,'number of Q4 atom pair types        ',i10,
+     x      /,1x,'number of Q6 atom pair types        ',i10,
+     x      /,1x,'number of zeta atom triplet types   ',i10)")
+     x    nq4,nq6,ntet
+        
+        write(nrite,
+     x    "(  1x,'gaussian deposition interval        ',i10,
+     x      /,1x,'reference gaussian height           ',e12.4,
+     x      /,1x,'gaussian width parameter            ',e12.4,
+     x      /,1x,'height control key                  ',i10,
+     x      /,1x,'well-tempered control parameter     ',e12.4)")
+     x    meta_step_int,ref_W_aug,h_aug,hkey,wt_Dt
+        
+      endif
+            
+      return
+      end subroutine metadyn_option
+      
+      subroutine ewald_selection
+     x  (directive,lhke,lspme,lewald,lcut,lforc,kill,idnode,keyfce,
+     x  imcon,nhko,nlatt,kmax1,kmax2,kmax3,alpha,rcut)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting the ewald method and reading 
+c     the required parameters
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lhke,lspme,lewald,lcut,lforc,kill,safe
+      integer idnode,keyfce,imcon,nhko,nlatt,kmax1,kmax2,kmax3,idum
+      integer kmaxpow2
+      real(8) alpha,rcut,eps,tol,fac,tol1
+      
+      lhke=findstring('hke',directive,idum)
+      lspme=findstring('spme',directive,idum)
+      lewald=findstring('ewald',directive,idum)
+      if(lewald)keyfce=2
+      if(lspme)keyfce=12
+      if(lhke)keyfce=14
+      if(idnode.eq.0)open(nconf,file='CONFIG')
+      call getrec(safe,idnode,nconf)
+      call getrec(safe,idnode,nconf)
+      imcon=intstr(record,lenrec,idum)
+      imcon=intstr(record,lenrec,idum)
+      if(.not.lhke.and.(imcon.eq.0.or.imcon.eq.6))then
+        
+        call error(idnode,-180)
+        kill=.true.
+        
+      endif
+      
+      if(findstring('precision',directive,idum))then
+        
+        eps=dblstr(directive,lenrec,idum)
+        if(idnode.eq.0)write(nrite,
+     x    "(/,1x,'Ewald sum  precision    ',7x,1p,e12.4)")eps
+        
+        if(lhke)then
+          
+          nhko=min(intstr(directive,lenrec,idum),3)
+          nlatt=min(intstr(directive,lenrec,idum),2)
+          if(nlatt.eq.0)nlatt=1
+          if(nhko.eq.0)nhko=1
+          
+        endif
+        
+        if(.not.lcut)then
+          call error(idnode,-433)
+          kill=.true.
+        else
+          
+c     retreive cell vectors
+          
+          call getrec(safe,idnode,nconf)
+          cell(1)=dblstr(record,lenrec,idum)
+          cell(2)=dblstr(record,lenrec,idum)
+          cell(3)=dblstr(record,lenrec,idum)
+          call getrec(safe,idnode,nconf)
+          cell(4)=dblstr(record,lenrec,idum)
+          cell(5)=dblstr(record,lenrec,idum)
+          cell(6)=dblstr(record,lenrec,idum)
+          call getrec(safe,idnode,nconf)
+          cell(7)=dblstr(record,lenrec,idum)
+          cell(8)=dblstr(record,lenrec,idum)
+          cell(9)=dblstr(record,lenrec,idum)
+          
+c     compute alpha and the kmax
+          
+          if(lewald.or.lspme)then
+            
+            call dcell(cell,celprp)
+            eps=min(abs(eps),0.5d0)
+            tol=sqrt(abs(log(eps*rcut)))
+            alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+            tol1=sqrt(-log(eps*rcut*(2.d0*tol*alpha)**2))
+            fac=1.d0
+            if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)
+     x        fac=2.d0**(1.d0/3.d0)
+            kmax1=nint(0.25d0+fac*celprp(1)*alpha*tol1/pi)
+            kmax2=nint(0.25d0+fac*celprp(2)*alpha*tol1/pi)
+            kmax3=nint(0.25d0+fac*celprp(3)*alpha*tol1/pi)
+            
+          elseif(lhke)then
+            
+            if(nhko.eq.0)then
+              if(eps.le.1.d-6)then
+                alpha=3.46d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=3.14d0/rcut
+              else
+                alpha=2.76d0/rcut
+              endif
+            elseif(nhko.eq.1)then
+              if(eps.le.1.d-6)then
+                alpha=4.37d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=4.08d0/rcut
+              else
+                alpha=3.75d0/rcut
+              endif                
+            elseif(nhko.eq.2)then
+              if(eps.le.1.d-6)then
+                alpha=5.01d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=4.74d0/rcut
+              else
+                alpha=4.44d0/rcut
+              endif
+            elseif(nhko.eq.3)then
+              if(eps.le.1.d-6)then
+                alpha=5.55d0/rcut
+              elseif(eps.le.1.d-5)then
+                alpha=5.28d0/rcut
+              else
+                alpha=5.00d0/rcut
+              endif
+            endif
+            alpha=alpha/dble(2*nlatt+1)
+            if(abs(cell(9)).lt.1.d-8)cell(9)=1.d0
+            call dcell(cell,celprp)
+            tol=2.d0*alpha*sqrt(abs(log(eps*alpha)))
+            tol1=2.d0*alpha*sqrt(abs(log(eps*alpha*tol)))
+            kmax1=nint(0.25d0+0.5d0*celprp(1)*tol1/pi)
+            kmax2=nint(0.25d0+0.5d0*celprp(2)*tol1/pi)
+            kmax3=1
+            
+          endif
+          
+        endif
+        
+      else
+        
+        alpha=dblstr(directive,lenrec,idum)
+        kmax1=intstr(directive,lenrec,idum)
+        kmax2=intstr(directive,lenrec,idum)
+        
+        if(lhke)then
+          
+          kmax3=1
+          nhko=min(intstr(directive,lenrec,idum),3)
+          nlatt=min(intstr(directive,lenrec,idum),2)
+          
+        else
+          
+          kmax3=intstr(directive,lenrec,idum)
+          
+        endif
+        
+      endif
+      
+c     if spme double kmax and set to next power of 2, with current upper
+c     limit of 512.
+      
+      if(lspme)then
+        
+        kmaxpow2=1
+        do while (kmax1.gt.kmaxpow2.and.kmaxpow2.lt.256)
+          kmaxpow2=kmaxpow2 * 2
+        enddo
+        kmax1=2 * kmaxpow2
+        
+        kmaxpow2=1
+        do while (kmax2.gt.kmaxpow2.and.kmaxpow2.lt.256)
+          kmaxpow2=kmaxpow2 * 2
+        enddo
+        kmax2=2 * kmaxpow2
+        
+        kmaxpow2=1
+        do while (kmax3.gt.kmaxpow2.and.kmaxpow2.lt.256)
+          kmaxpow2=kmaxpow2 * 2
+        enddo
+        kmax3=2 * kmaxpow2
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        close(nconf)
+        
+        if(lspme)then
+          
+          write(nrite,
+     x      "(/,1x,'Electrostatics : SPME  ')")
+          
+          write(nrite,
+     x      "(/,1x,'Ewald convergence parameter    ',1p,e12.4,
+     x      /,1x,'Ewald kmax1 kmax2 kmax3     ',3i5)")
+     x      alpha,kmax1/2,kmax2/2,kmax3/2
+          
+        elseif(lhke)then
+          
+          write(nrite,
+     x      "(/,1x,'Electrostatics : Hautman-Klein-Ewald sum  ')")
+          
+          write(nrite,
+     x      "(/,1x,'Ewald convergence parameter    ',1p,e12.4,
+     x      /,1x,'Ewald kmax1 kmax2              ',2i5)")
+     x      alpha,kmax1,kmax2
+          
+          write(nrite,
+     x      "(1x,'HKE expansion order     ',7x,i10,
+     x      /,1x,'HKE lattice control     ',7x,i10)")nhko,nlatt
+          
+        else
+          
+          write(nrite,
+     x      "(/,1x,'Electrostatics : Ewald sum  ')")
+          
+          write(nrite,
+     x      "(/,1x,'Ewald convergence parameter    ',1p,e12.4,
+     x      /,1x,'Ewald kmax1 kmax2 kmax3     ',3i5)")
+     x      alpha,kmax1,kmax2,kmax3
+          
+        endif
+        
+      endif
+      
+      if(lspme)then
+        
+c     Initialize fft tables
+        
+CFFTW             call fftw3d_f77_create_plan
+CFFTW     x           (fplan,kmaxd,kmaxe,kmaxf,
+CFFTW     x            FFTW_FORWARD,FFTW_ESTIMATE+FFTW_IN_PLACE)
+CFFTW
+CFFTW             call fftw3d_f77_create_plan
+CFFTW     x           (bplan,kmaxd,kmaxe,kmaxf,
+CFFTW     x            FFTW_BACKWARD,FFTW_ESTIMATE+FFTW_IN_PLACE)
+        
+CSGIC             call zzfft3d( 0,kmaxd,kmaxe,kmaxf,1.d0,dummy,1,1,
+CSGIC     x                     dummy,1,1,ffttable,dummy,dummy )
+        
+CCRAY             call ccfft3d( 0,kmaxd,kmaxe,kmaxf,1.d0,dummy,1,1,
+CCRAY     x                     dummy,1,1,ffttable,dummy,dummy )
+        
+      endif
+      
+      if(lspme)then
+        
+        if(kmax1.gt.kmaxd.or.kmax2.gt.kmaxe.or.kmax3.gt.kmaxf)then
+          
+          kill=.true.
+          call error(idnode,-185)
+          
+        endif
+        
+      elseif(lhke)then
+        
+        if(kmax2.gt.kmaxb)then
+          
+          kill=.true.
+          call error(idnode,-185)
+          
+        endif
+        
+      else
+        
+        if(kmax2.gt.kmaxb.or.kmax3.gt.kmaxc)then
+          
+          kill=.true.
+          call error(idnode,-185)
+          
+        endif
+        
+      endif
+      
+      if(lforc)then
+        call  error(idnode,-416)
+        kill=.true.
+      endif
+      lforc=.true.
+      
+      return
+      end subroutine ewald_selection
+      
+      subroutine print_optim(keytol)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for printing the optimisation option
+c     the required parameters
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer keytol
+      
+      if(keytol.eq.0)then
+        write(nrite,
+     x    "(1x,'convergence to minimum force selected')")
+      elseif(keytol.eq.1)then
+        write(nrite,
+     x    "(1x,'convergence to minimum energy selected')")
+      else
+        write(nrite,
+     x    "(1x,'convergence to minimum position selected')")
+      endif
+      
+      return
+      end subroutine print_optim
+      
+      function energy_unit()
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for assigning energy conversion factors
+c     copyright - daresbury laboratory
+c     author    - w. smith    feb 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idum
+      real(8) energy_unit
+      
+      energy_unit=1.d0
+      if(findstring('ev',record,idum))then
+        energy_unit=9648.530821d0
+      elseif(findstring('kev',record,idum))then
+        energy_unit=9648530.821d0
+      elseif(findstring('kcal',record,idum))then
+        energy_unit=418.4d0
+      elseif(findstring('kj',record,idum))then
+        energy_unit=1.d2
+      elseif(findstring('k',record,idum))then
+        energy_unit=boltz
+      endif
+      
+      return
+      end function energy_unit
+      
+      subroutine solvation_option
+     x  (directive,lsolva,idnode,nsolva,isolva)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for solvation option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lsolva,endsol,safe
+      integer idnode,nsolva,isolva,idum
+      
+      lsolva=.true.
+      endsol=.false.
+      
+      nsolva=intstr(directive,lenrec,idum)
+      isolva=intstr(directive,lenrec,idum)
+      
+      if(nsolva.eq.0.and.isolva.eq.0)then
+        
+        do while(.not.endsol)
+          
+          call getrec(safe,idnode,nread)
+          if(.not.safe)call abort_control_read(1,idnode,nread)
+          call lowcase(record,lenrec)
+          call strip(record,lenrec)
+          call copystring(record,directive,lenrec)
+          
+          if(findstring('endsol',directive,idum))then
+            endsol=.true.
+          elseif(findstring('enddec',directive,idum))then
+            endsol=.true.
+          elseif(findstring('start',directive,idum))then
+            nsolva=intstr(directive,lenrec,idum)
+          elseif(findstring('inter',directive,idum))then
+            isolva=max(intstr(directive,lenrec,idum),1)
+          endif
+          
+        enddo
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'solvation calculation selected',
+     x    /,1x,'start of solvation calculation ',i10,
+     x    /,1x,'solvation calculation interval ',i10)")
+     x    nsolva,isolva
+        
+      endif
+      
+      return
+      end subroutine solvation_option
+      
+      subroutine free_energy_option(directive,lfree,lfrmas,idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for free energy option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lfree,lfrmas,endfre,safe
+      integer idnode,idum
+      
+      mfree=1
+      kfree=1
+      lfree=.true.
+      lfrmas=.false.
+      endfre=.false.
+      
+      do while(.not.endfre)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(findstring('endfre',directive,idum))then
+          endfre=.true.
+        elseif(findstring('start',directive,idum))then
+          nfrn=intstr(directive,lenrec,idum)
+        elseif(findstring('interval',directive,idum))then
+          ifrn=intstr(directive,lenrec,idum)
+        elseif(findstring('lambda',directive,idum))then
+          pfree=dblstr(directive,lenrec,idum)
+        elseif(findstring('mix',directive,idum))then
+          mfree=intstr(directive,lenrec,idum)
+        elseif(findstring('expo',directive,idum))then
+          kfree=intstr(directive,lenrec,idum)
+        elseif(findstring('reset_mass',directive,idum))then
+          lfrmas=.true.
+          if(findstring('false',directive,idum))lfrmas=.false.
+        elseif(findstring('system_a',directive,idum))then
+          ind_fre(1)=intstr(directive,lenrec,idum)
+          ind_fre(2)=intstr(directive,lenrec,idum)
+        elseif(findstring('system_b',directive,idum))then
+          ind_fre(3)=intstr(directive,lenrec,idum)
+          ind_fre(4)=intstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(mfree.eq.1)kfree=1
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'free energy option selected',
+     x    /,1x,'start of free energy calculation ',i10,
+     x    /,1x,'sampling interval                ',i10,
+     x    /,1x,'free energy parameter (lambda)   ',f10.3,
+     x    /,1x,'mixing rule selected             ',i10,
+     x    /,1x,'mixing rule exponent             ',i10,
+     x    /,1x,'system A first atom              ',i10,
+     x    /,1x,'system A last atom               ',i10,
+     x    /,1x,'system B first atom              ',i10,
+     x    /,1x,'system B last atom               ',i10,
+     x    /,1x,'mass scaling option              ',l10)")
+     x    nfrn,ifrn,pfree,mfree,kfree,ind_fre,lfrmas
+        
+      endif
+      
+c     define free energy scaling parameters
+
+      call freegen()
+      
+      return
+      end subroutine free_energy_option
+      
+      subroutine excitation_option
+     x  (directive,lsolva,lexcite,lghost,idnode,nsolva,isolva)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for excitation option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lsolva,lexcite,lghost,endexc,safe
+      integer idnode,nsolva,isolva,idum
+      
+      lsolva=.true.
+      lghost=.true.
+      lexcite=.true.
+      endexc=.false.
+      
+      do while(.not.endexc)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(findstring('endexc',directive,idum))then
+          endexc=.true.
+        elseif(findstring('start',directive,idum))then
+          nsolva=intstr(directive,lenrec,idum)
+        elseif(findstring('inter',directive,idum))then
+          isolva=intstr(directive,lenrec,idum)
+        elseif(findstring('system_a',directive,idum))then
+          ind_fre(1)=intstr(directive,lenrec,idum)
+          ind_fre(2)=intstr(directive,lenrec,idum)
+        elseif(findstring('system_b',directive,idum))then
+          ind_fre(3)=intstr(directive,lenrec,idum)
+          ind_fre(4)=intstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'excitation option selected',
+     x    /,1x,'energy decomposition start       ',i10,
+     x    /,1x,'energy decomposition interval    ',i10,
+     x    /,1x,'system A first atom              ',i10,
+     x    /,1x,'system A last atom               ',i10,
+     x    /,1x,'system B first atom              ',i10,
+     x    /,1x,'system B last atom               ',i10)")
+     x   nsolva,isolva,ind_fre
+        
+      endif
+      
+      return
+      end subroutine excitation_option
+      
+      subroutine switching_option
+     x  (directive,lsolva,lswitch,lghost,idnode,nsolva,isolva)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading parameters for switching option
+c     copyright - daresbury laboratory
+c     authors   - w. smith and p.-a. cazade jul 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 directive(lenrec)
+      logical lsolva,lswitch,lghost,endswi,safe
+      integer idnode,nsolva,isolva,idum
+      
+      lsolva=.true.
+      lghost=.true.
+      lswitch=.true.
+      endswi=.false.
+      niswitch=0
+      
+      do while(.not.endswi)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abort_control_read(1,idnode,nread)
+        call lowcase(record,lenrec)
+        call strip(record,lenrec)
+        call copystring(record,directive,lenrec)
+        
+        if(findstring('endswi',directive,idum))then
+          endswi=.true.
+        elseif(findstring('start',directive,idum))then
+          nsolva=intstr(directive,lenrec,idum)
+        elseif(findstring('inter',directive,idum))then
+          isolva=intstr(directive,lenrec,idum)
+        elseif(findstring('period',directive,idum))then
+          niswitch=max(intstr(directive,lenrec,idum),2)
+        elseif(findstring('system_a',directive,idum))then
+          ind_fre(1)=intstr(directive,lenrec,idum)
+          ind_fre(2)=intstr(directive,lenrec,idum)
+        elseif(findstring('system_b',directive,idum))then
+          ind_fre(3)=intstr(directive,lenrec,idum)
+          ind_fre(4)=intstr(directive,lenrec,idum)
+        endif
+        
+      enddo
+      
+      if(niswitch.eq.0)niswitch=nsolva
+      nswitch=nsolva
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,1x,'switching option selected',
+     x    /,1x,'energy decomposition start       ',i10,
+     x    /,1x,'energy decomposition interval    ',i10,
+     x    /,1x,'switching period                 ',i10,
+     x    /,1x,'system A first atom              ',i10,
+     x    /,1x,'system A last atom               ',i10,
+     x    /,1x,'system B first atom              ',i10,
+     x    /,1x,'system B last atom               ',i10)")
+     x   nsolva,isolva,niswitch,ind_fre
+        
+      endif
+      
+      return
+      end subroutine switching_option
+      
+      end module define_system_module
+      
diff -urN dl_class_1.9.orig/srcmod/dihedral_module.f dl_class_1.9/srcmod/dihedral_module.f
--- dl_class_1.9.orig/srcmod/dihedral_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/dihedral_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1121 @@
+      module dihedral_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining dihedral potential arrays
+c     copyright - daresbury laboratory
+c     
+c     author  - w. smith     sep 2003
+c     adapted - p.-a. cazade oct 2007 : solvation, free energy, etc.
+c     adapted - w.smith      jan 2011 : metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use metafreeze_module
+      use parse_module
+      use property_module
+      use setup_module
+      use site_module
+      use solvation_module
+      use utility_module
+      use vdw_module
+      
+      implicit none
+      
+      real(8), allocatable :: prmdih(:,:)
+      integer, allocatable :: listdih(:,:)
+      integer, allocatable :: numdih(:),keydih(:),lstdih(:,:)
+      
+      save prmdih,listdih,numdih,keydih,lstdih
+      
+      contains
+      
+      subroutine alloc_dih_arrays(idnode)
+      
+      implicit none
+      
+      integer i,fail,idnode
+      dimension fail(5)
+      
+      do i=1,5
+        fail(i)=0
+      enddo
+      
+      allocate (prmdih(mxtdih,mxpdih),stat=fail(1))
+      allocate (numdih(mxtmls),stat=fail(2))
+      allocate (keydih(mxtdih),stat=fail(3))
+      allocate (lstdih(mxtdih,4),stat=fail(4))
+      allocate (listdih(mxdihd,5),stat=fail(5))
+      
+      do i=1,5
+        if(fail(i).gt.0)call error(idnode,1011)
+      enddo
+      
+      do i=1,mxtmls
+        numdih(i)=0
+      enddo
+      
+      end subroutine alloc_dih_arrays
+      
+      subroutine define_dihedrals
+     x  (safe,idnode,itmols,ndihed,nsite,engunit)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining dihedral angles
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe
+      character*8 keyword
+      character*1 message(80)
+      integer idnode,itmols,ndihed,nsite,ntmp,idih,idih1,i
+      integer iatm1,iatm2,iatm3,iatm4,idum,isite1,isite2,isite3
+      integer isite4,ia,ja
+      real(8) engunit
+      
+      ntmp=intstr(record,lenrec,idum)
+      numdih(itmols)=numdih(itmols)+ntmp
+      if(idnode.eq.0)then
+        write(nrite,"(/,1x,'number of dihedral angles',
+     x    6x,i10)")ntmp
+        write(nrite,"(/,/,1x,'dihedral angle details:',
+     x    /,/,21x,7x,'key',5x,'index',5x,'index',5x,
+     x    'index',5x,'index',5x,'f-const',7x,'angle',
+     x    8x,'trig',4x,'1-4 elec',5x,'1-4 vdw',/)")
+      endif
+      
+      idih1=numdih(itmols)
+      do idih=1,idih1
+        
+c     read dihedral bond angle potential parameters
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        
+        call copystring(record,message,80)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+        iatm1=intstr(record,lenrec,idum)
+        iatm2=intstr(record,lenrec,idum)
+        iatm3=intstr(record,lenrec,idum)
+        iatm4=intstr(record,lenrec,idum)
+        
+c     test for frozen atom pairs
+        
+        isite1=nsite-numsit(itmols)+iatm1
+        isite2=nsite-numsit(itmols)+iatm2
+        isite3=nsite-numsit(itmols)+iatm3
+        isite4=nsite-numsit(itmols)+iatm4
+        
+        if(lfzsit(isite1)*lfzsit(isite2)*
+     x    lfzsit(isite3)*lfzsit(isite4).ne.0)then
+          
+          numdih(itmols)=numdih(itmols)-1
+          if(idnode.eq.0)write(nrite,'(14x,a16,40a1)')
+     x      '*** frozen *** ',(message(i),i=1,40)
+          
+        else
+          
+          ndihed=ndihed+1
+          
+          if(ndihed.gt.mxtdih)call error(idnode,60)
+          
+          if(keyword(1:4).eq.'cos ')then
+            keydih(ndihed)=1
+          elseif(keyword(1:4).eq.'harm')then
+            keydih(ndihed)=2
+          elseif(keyword(1:4).eq.'hcos')then
+            keydih(ndihed)=3
+          elseif(keyword(1:4).eq.'cos3')then
+            keydih(ndihed)=4
+          elseif(keyword(1:4).eq.'ryck')then
+            keydih(ndihed)=5
+          elseif(keyword(1:4).eq.'rbf')then 
+            keydih(ndihed)=6
+          elseif(keyword(1:4).eq.'opls')then 
+            keydih(ndihed)=7
+          else
+            if(idnode.eq.0)write(nrite,*)message
+            call error(idnode,448)
+          endif
+          
+          lstdih(ndihed,1)=iatm1
+          lstdih(ndihed,2)=iatm2
+          lstdih(ndihed,3)=iatm3
+          lstdih(ndihed,4)=iatm4
+          prmdih(ndihed,1)=dblstr(record,lenrec,idum)
+          prmdih(ndihed,2)=dblstr(record,lenrec,idum)
+          prmdih(ndihed,3)=dblstr(record,lenrec,idum)
+          prmdih(ndihed,4)=dblstr(record,lenrec,idum)
+          prmdih(ndihed,5)=dblstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(27x,a4,4i10,1p,e12.4,0p,9f12.6)")
+     x      keyword(1:4),(lstdih(ndihed,ia),ia=1,4),
+     x      (prmdih(ndihed,ja),ja=1,mxpdih)
+          
+c     convert energies to internal units and angles to radians
+          
+          prmdih(ndihed,1)=prmdih(ndihed,1)*engunit
+          
+          if(keydih(ndihed).eq.4)then
+            
+            prmdih(ndihed,2)=prmdih(ndihed,2)*engunit
+            prmdih(ndihed,3)=prmdih(ndihed,3)*engunit
+            
+          elseif(keydih(ndihed).eq.7)then
+            
+            prmdih(ndihed,2)=prmdih(ndihed,2)*engunit
+            prmdih(ndihed,3)=prmdih(ndihed,3)*engunit
+            prmdih(ndihed,4)=prmdih(ndihed,4)*engunit
+            prmdih(ndihed,5)=prmdih(ndihed,5)*(pi/180.d0)
+            
+          else
+            
+            prmdih(ndihed,2)=prmdih(ndihed,2)*(pi/180.d0)
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine define_dihedrals
+      
+      subroutine dihfrc
+     x  (lsolva,lfree,lexcite,idnode,imcon,mxnode,ntdihd,keyfce,
+     x  dlrpot,epsq,engcpe,engdih,engsrp,rcut,rvdw,alpha,vircpe,
+     x  virdih,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating dihedral energy and force 
+c     terms in molecular dynamics.
+c     
+c     version 3: scale factors for reduces electrostatic and vdw
+c     1-4 interactions.
+c     
+c     NOTE: assumes 1-4 interactions are in the exclude list
+c     
+c     block as opposed to stride version
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith       mar 1992
+c     modified  - t. forester    dec 1993
+c     modified  - t. forester    jun 1995 - stress tensor added
+c     modified  - a. smondyrev   may 2000 - ryckaert-bellemans potentials
+c     modified  - p.-a. cazade   oct 2007 - solvation etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lsolva,lfree,lexcite,lselect
+      logical idrive,jdrive,kdrive,ldrive
+      integer i,k,ii,kk,ntdihd,idnode,mxnode,idih1,idih2,ia,ib
+      integer ic,id,imcon,ka,kb,l,keyfce,fail1,fail2,fail3,kkk
+      real(8) phi,twopi,rtwopi,dterm,srpot
+      real(8) engdih,virdih,engc14,engs14,virs14,rrbc,xab,yab,erc,fer
+      real(8) zab,xbc,ybc,zbc,xcd,ycd,zcd,pbx,pby,pbz,pb2,rpb1,rpb2
+      real(8) pcx,pcy,pcz,pc2,rpc1,rpc2,pbpc,cosp,sinp,rsinp,exp1
+      real(8) gamma,fax,fay,faz,fcx,fcy,fcz,fb1x,fb1y,fb1z,fd1x,fd1y
+      real(8) fd1z,scale,xad,yad,zad,rad,chgprd,coul,fcoul,fx,fy,fz
+      real(8) ppp,dlrpot,t1,t2,vk0,vk1,vk2,gk0,gk1,gk2,epsq,engcpe
+      real(8) vircpe,rcut,rvdw,engsrp,virsrp,xac,yac,zac,vcon,fcon
+      real(8) virc14,b0,rfld0,rfld1,rfld2,alpha,a1,a2,a3,a4,a5,pp,tt
+      real(8) cou14_vir,vdw14_vir,strs(6),strs_loc(6)
+      real(8), allocatable :: xdab(:),ydab(:),zdab(:)
+      real(8), allocatable :: xdbc(:),ydbc(:),zdbc(:)
+      real(8), allocatable :: xdcd(:),ydcd(:),zdcd(:)
+      data a1,a2,a3/0.254829592d0,-0.284496736d0,1.421413741d0/
+      data a4,a5,pp/-1.453152027d0,1.061405429d0,0.3275911d0/
+      data fail1,fail2,fail3/0,0,0/
+      
+      allocate (xdab(msbad),ydab(msbad),zdab(msbad),stat=fail1)
+      allocate (xdbc(msbad),ydbc(msbad),zdbc(msbad),stat=fail2)
+      allocate (xdcd(msbad),ydcd(msbad),zdcd(msbad),stat=fail3)
+      if(fail1.ne.0.or.fail2.ne.0.or.fail3.ne.0)
+     x  call error(idnode,1060)
+      
+      twopi=2.d0*pi
+      rtwopi=1.d0/twopi
+      safe=.true.
+      
+c     check size of work arrays
+      
+      if((ntdihd-mxnode+1)/mxnode.gt.msbad) call error(idnode,421)
+      
+c     block indices
+      
+      idih1=(idnode*ntdihd)/mxnode+1
+      idih2=((idnode+1)*ntdihd)/mxnode
+      
+c     initialise accumulators
+      
+      engdih=0.d0
+      virdih=0.d0
+      dih_fre=0.d0
+      dih_vir=0.d0
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+      if(lsolva)then
+        
+        lcomp(3)=.true.
+        dih_sol(:)=0.d0
+        if(lexcite)dih_exc(:)=0.d0
+        
+      endif
+      
+      if(keyfce/2.eq.4)then
+        
+c     constant terms for shifted coulombic potential
+        
+        tt=1.d0/(1.d0+pp*alpha*rcut)
+        exp1=exp(-(alpha*rcut)**2)
+        vcon=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rcut
+        fcon=(vcon+2.d0*(alpha/sqrpi)*exp1)/rcut
+        
+      elseif(keyfce/2.eq.5)then
+        
+c     constant terms for reaction field potential
+        
+        b0=2.d0*(epsq-1.d0)/(2.d0*epsq+1.d0)
+        rfld0=b0/rcut**3
+        rfld1=(1.d0+b0*0.5d0)/rcut
+        rfld2=rfld0*0.5d0
+        tt=1.d0/(1.d0+pp*alpha*rcut)
+        exp1=exp(-(alpha*rcut)**2)
+        vcon=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rcut
+        fcon=(vcon+2.d0*(alpha/sqrpi)*exp1)/rcut-rfld0*rcut
+        vcon=vcon+rfld2*rcut**2-rfld1
+        
+      endif
+      
+c     calculate bond vectors
+      
+      ii=0
+      do i=idih1,idih2
+        
+        ii=ii+1
+        
+c     indices of bonded atoms
+        
+        ia=listdih(ii,2)
+        ib=listdih(ii,3)
+        ic=listdih(ii,4)
+        id=listdih(ii,5)
+        
+c     define components of bond vectors
+        
+        xdab(ii)=xxx(ia)-xxx(ib)
+        ydab(ii)=yyy(ia)-yyy(ib)
+        zdab(ii)=zzz(ia)-zzz(ib)
+        
+        xdbc(ii)=xxx(ib)-xxx(ic)
+        ydbc(ii)=yyy(ib)-yyy(ic)
+        zdbc(ii)=zzz(ib)-zzz(ic)
+        
+        xdcd(ii)=xxx(ic)-xxx(id)
+        ydcd(ii)=yyy(ic)-yyy(id)
+        zdcd(ii)=zzz(ic)-zzz(id)
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,0,1,ii,cell,xdab,ydab,zdab)
+      call images(imcon,0,1,ii,cell,xdbc,ydbc,zdbc)
+      call images(imcon,0,1,ii,cell,xdcd,ydcd,zdcd)
+      
+c     zero dihedral energy accumulator
+      
+      engdih=0.d0
+      virdih=0.d0
+      
+c     zero scaled 1-4 electrostatic and short range potential accumulators
+      
+      engc14=0.d0
+      virc14=0.d0
+      engs14=0.d0
+      virs14=0.d0
+      vdw14_vir=0.d0
+      cou14_vir=0.d0
+      
+c     loop over all specified dihedrals
+      
+      ii=0
+      do i=idih1,idih2
+        
+c     define components of bond vectors
+        
+        ii=ii+1
+        
+        xab=xdab(ii)
+        yab=ydab(ii)
+        zab=zdab(ii)
+        
+        xbc=xdbc(ii)
+        ybc=ydbc(ii)
+        zbc=zdbc(ii)
+        rrbc=1.d0/sqrt(xbc*xbc+ybc*ybc+zbc*zbc)
+        
+        xcd=xdcd(ii)
+        ycd=ydcd(ii)
+        zcd=zdcd(ii)
+        
+        xac=xab+xbc
+        yac=yab+ybc
+        zac=zab+zbc
+        
+c     construct first dihedral vector
+        
+        pbx=yab*zbc-zab*ybc
+        pby=zab*xbc-xab*zbc
+        pbz=xab*ybc-yab*xbc
+        pb2=pbx*pbx+pby*pby+pbz*pbz
+        rpb1=1.d0/sqrt(pb2)
+        rpb2=rpb1*rpb1
+        
+c     construct second dihedral vector
+        
+        pcx=ybc*zcd-zbc*ycd
+        pcy=zbc*xcd-xbc*zcd
+        pcz=xbc*ycd-ybc*xcd
+        pc2=pcx*pcx+pcy*pcy+pcz*pcz
+        rpc1=1.d0/sqrt(pc2)
+        rpc2=rpc1*rpc1
+        
+c     determine dihedral angle 
+        
+        pbpc=pbx*pcx+pby*pcy+pbz*pcz
+        cosp=pbpc*rpb1*rpc1
+        sinp=(xbc*(pcy*pbz-pcz*pby)+ybc*(pbx*pcz-pbz*pcx)+
+     x    zbc*(pcx*pby-pcy*pbx))*(rpb1*rpc1*rrbc)
+        
+        phi=atan2(sinp,cosp)
+        
+c     avoid singularity in sinp
+        
+        sinp=sign(max(1.d-8,abs(sinp)),sinp)
+        rsinp=1.d0/sinp
+        
+c     selection of potential energy function type
+        
+        kk=listdih(ii,1)
+        
+c     calculate potential energy and scalar force term
+        
+        if(keydih(kk).eq.1)then
+          
+c     key=1 for torsion dihedral potential
+          
+          dterm=prmdih(kk,1)*(1.d0+cos(prmdih(kk,3)*phi-
+     x      prmdih(kk,2)))
+          gamma=-rpb1*rpc1*rsinp*prmdih(kk,1)*prmdih(kk,3)*
+     x      sin(prmdih(kk,3)*phi-prmdih(kk,2))
+          
+        else if(keydih(kk).eq.2)then
+          
+c     key=2 for harmonic improper dihedral
+          
+          phi=phi-prmdih(kk,2)
+          phi=phi-nint(phi*rtwopi)*twopi
+          dterm=0.5d0*prmdih(kk,1)*(phi*phi)
+          gamma=rpb1*rpc1*rsinp*prmdih(kk,1)*phi
+          
+        else if(keydih(kk).eq.3)then
+          
+c     key=3 for harmonic cosine dihedral
+          
+          dterm=0.5d0*prmdih(kk,1)*(cos(phi)-
+     x      cos(prmdih(kk,2)))**2
+          gamma=-rpb1*rpc1*prmdih(kk,1)*(cos(phi)-cos(prmdih(kk,2)))
+          
+        else if(keydih(kk).eq.4)then
+          
+c     key=4 for 3-term cosine dihedral
+          
+          dterm=0.5d0*(prmdih(kk,1)*(1.d0+cos(phi))+
+     x      prmdih(kk,2)*(1.d0-cos(2.d0*phi))+prmdih(kk,3)*
+     x      (1.d0+cos(3.d0*phi)))
+          gamma=-rpb1*rpc1*rsinp*0.5d0*(prmdih(kk,1)*sin(phi)-
+     x      2.d0*prmdih(kk,2)*sin(2.d0*phi)+3.d0*prmdih(kk,3)*
+     x      sin(3.d0*phi))
+          
+        else if(keydih(kk).eq.5)then
+          
+c     key=5 for ryckaert-bellemans potential      
+c     chem.phys.lett., vol.30, p.123, 1975.
+c     ATTENTION !!! Modified to have trans configuration
+c     correspond to phi=180 rather than 
+c     phi=0 as in original form.
+          
+          dterm=prmdih(kk,1)*(1.116d0-1.462d0*cos(phi)-
+     x      1.578d0*(cos(phi))**2+0.368d0*(cos(phi))**3+
+     x      3.156d0*(cos(phi))**4+3.788d0*(cos(phi))**5)
+          gamma=prmdih(kk,1)*(1.462d0+3.156d0*cos(phi)-
+     x      1.104d0*(cos(phi))**2-12.624d0*(cos(phi))**3-
+     x      18.94d0*(cos(phi))**4)*rpb1*rpc1
+          
+        else if(keydih(kk).eq.6)then
+          
+c     key=6 for fluorinated ryckaert-bellemans potential
+c     Rice at al., JCP 104, 2101, (1996).
+          
+          dterm=prmdih(kk,1)*(3.55d0-2.78d0*cos(phi)-
+     x      3.56d0*(cos(phi))**2-1.64d0*(cos(phi))**3+
+     x      7.13d0*(cos(phi))**4+12.84d0*(cos(phi))**5+
+     x      9.67d0*exp(-56.d0*(phi-pi)**2))
+          gamma=(prmdih(kk,1)*(2.78d0+7.12d0*cos(phi)+
+     x      4.92d0*(cos(phi))**2-28.52d0*(cos(phi))**3-
+     x      64.2d0*(cos(phi))**4)-1083.04d0*(phi-pi)*
+     x      exp(-56.0*(phi-pi)**2))*rpb1*rpc1
+          
+        else if(keydih(kk).eq.7)then
+          
+c     key=7 for opls cosine dihedral
+          
+          phi=phi-prmdih(kk,5)
+          dterm=prmdih(kk,1)+0.5d0*(prmdih(kk,2)*
+     x      (1.d0+cos(phi))+prmdih(kk,3)*(1.d0-cos(2.d0*phi))+
+     x      prmdih(kk,4)*(1.d0+cos(3.d0*phi)))
+          gamma=-0.5d0*(prmdih(kk,2)*sin(phi)-2.d0*prmdih(kk,3)*
+     x      sin(2.d0*phi)+3.d0*prmdih(kk,4)*sin(3.d0*phi))*rpb1*
+     x      rpc1*rsinp
+          
+        else
+          
+c     undefined potential
+          
+          safe=.false.
+          dterm=0.d0
+          gamma=0.d0
+          
+        endif
+        
+c     indices of bonded atoms
+        
+        ia=listdih(ii,2)
+        ib=listdih(ii,3)
+        ic=listdih(ii,4)
+        id=listdih(ii,5)
+        
+c     metadynamics local definitions
+        
+        if(lmetadyn)then
+          
+          idrive=driven(ltype(ia))
+          jdrive=driven(ltype(ib))
+          kdrive=driven(ltype(ic))
+          ldrive=driven(ltype(id))
+          
+        endif
+        
+c     set selection control for angle potential
+        
+        lselect=.true.
+        
+        if(lexcite)then
+          
+c     selected excitation option
+          
+          if((atm_fre(ia).ne.1).and.(atm_fre(ib).ne.1).and.
+     x      (atm_fre(ic).ne.1).and.(atm_fre(id).ne.1))then
+            
+c     reset selection control
+            
+            lselect=(atm_fre(ia)+atm_fre(ib)+atm_fre(ic)+
+     x        atm_fre(id).eq.0)
+            
+            if(lsolva)then
+              dih_exc(atmolt(ia))=dih_exc(atmolt(ia))+dterm
+            endif
+            
+          endif
+          
+        elseif(lfree)then
+          
+c     selected free energy option
+          
+          if((atm_fre(ia).eq.1).or.(atm_fre(ib).eq.1).or.
+     x      (atm_fre(ic).eq.1).or.(atm_fre(id).eq.1))then
+            
+c     set hamiltonian mixing parameter
+            
+            dih_fre=dih_fre-dterm
+            dterm=lambda1*dterm
+            gamma=lambda1*gamma
+            
+          elseif((atm_fre(ia).eq.2).or.(atm_fre(ib).eq.2).or.
+     x        (atm_fre(ic).eq.2).or.(atm_fre(id).eq.2))then
+            
+c     set hamiltonian mixing parameter
+            
+            dih_fre=dih_fre+dterm
+            dterm=lambda2*dterm
+            gamma=lambda2*gamma
+            
+          endif
+          
+        endif
+        
+        if(lselect)then
+          
+c     calculate potential energy
+          
+          engdih=engdih+dterm
+          
+c     calculate solvation energy for dihedral term
+          
+          if(lsolva)then
+            dih_sol(atmolt(ia))=dih_sol(atmolt(ia))+dterm
+          endif
+          
+c     calculate atomic forces for dihedral term
+          
+          fax=gamma*((-pcy*zbc+pcz*ybc)-pbpc*rpb2*(-pby*zbc+pbz*ybc))
+          fay=gamma*(( pcx*zbc-pcz*xbc)-pbpc*rpb2*( pbx*zbc-pbz*xbc))
+          faz=gamma*((-pcx*ybc+pcy*xbc)-pbpc*rpb2*(-pbx*ybc+pby*xbc))
+          
+          fcx=gamma*((-pcy*zab+pcz*yab)-pbpc*rpb2*(-pby*zab+pbz*yab))
+          fcy=gamma*(( pcx*zab-pcz*xab)-pbpc*rpb2*( pbx*zab-pbz*xab))
+          fcz=gamma*((-pcx*yab+pcy*xab)-pbpc*rpb2*(-pbx*yab+pby*xab))
+          
+          fb1x=gamma*((-pby*zcd+pbz*ycd)-pbpc*rpc2*(-pcy*zcd+pcz*ycd))
+          fb1y=gamma*(( pbx*zcd-pbz*xcd)-pbpc*rpc2*( pcx*zcd-pcz*xcd))
+          fb1z=gamma*((-pbx*ycd+pby*xcd)-pbpc*rpc2*(-pcx*ycd+pcy*xcd))
+          
+          fd1x=gamma*((-pby*zbc+pbz*ybc)-pbpc*rpc2*(-pcy*zbc+pcz*ybc))
+          fd1y=gamma*(( pbx*zbc-pbz*xbc)-pbpc*rpc2*( pcx*zbc-pcz*xbc))
+          fd1z=gamma*((-pbx*ybc+pby*xbc)-pbpc*rpc2*(-pcx*ybc+pcy*xbc))
+          
+          fxx(ia)=fxx(ia)+fax
+          fyy(ia)=fyy(ia)+fay
+          fzz(ia)=fzz(ia)+faz
+          
+          fxx(ib)=fxx(ib)-fax-fcx+fb1x
+          fyy(ib)=fyy(ib)-fay-fcy+fb1y
+          fzz(ib)=fzz(ib)-faz-fcz+fb1z
+          
+          fxx(ic)=fxx(ic)+fcx-fb1x-fd1x
+          fyy(ic)=fyy(ic)+fcy-fb1y-fd1y
+          fzz(ic)=fzz(ic)+fcz-fb1z-fd1z
+          
+          fxx(id)=fxx(id)+fd1x
+          fyy(id)=fyy(id)+fd1y
+          fzz(id)=fzz(id)+fd1z
+          
+c     stress tensor for dihedral term
+          
+          strs(1)=strs(1)+xab*fax+xbc*(fb1x-fcx)-xcd*fd1x 
+          strs(2)=strs(2)+yab*fax+ybc*(fb1x-fcx)-ycd*fd1x 
+          strs(3)=strs(3)+zab*fax+zbc*(fb1x-fcx)-zcd*fd1x 
+          strs(4)=strs(4)+yab*fay+ybc*(fb1y-fcy)-ycd*fd1y 
+          strs(5)=strs(5)+yab*faz+ybc*(fb1z-fcz)-ycd*fd1z 
+          strs(6)=strs(6)+zab*faz+zbc*(fb1z-fcz)-zcd*fd1z 
+          
+        endif
+        
+c     metadynamics local parameters
+        
+        if(lmetadyn.and.(idrive.or.jdrive.or.kdrive.or.ldrive))then
+          
+c     local energy (no virial)
+          
+          eng_loc=eng_loc+dterm
+          
+c     local forces
+          
+          fxx_loc(ia)=fxx_loc(ia)+fax
+          fyy_loc(ia)=fyy_loc(ia)+fay
+          fzz_loc(ia)=fzz_loc(ia)+faz
+          
+          fxx_loc(ib)=fxx_loc(ib)-fax-fcx+fb1x
+          fyy_loc(ib)=fyy_loc(ib)-fay-fcy+fb1y
+          fzz_loc(ib)=fzz_loc(ib)-faz-fcz+fb1z
+          
+          fxx_loc(ic)=fxx_loc(ic)+fcx-fb1x-fd1x
+          fyy_loc(ic)=fyy_loc(ic)+fcy-fb1y-fd1y
+          fzz_loc(ic)=fzz_loc(ic)+fcz-fb1z-fd1z
+          
+          fxx_loc(id)=fxx_loc(id)+fd1x
+          fyy_loc(id)=fyy_loc(id)+fd1y
+          fzz_loc(id)=fzz_loc(id)+fd1z
+          
+c     local stress tensor
+          
+          strs_loc(1)=strs_loc(1)+xab*fax+xbc*(fb1x-fcx)-xcd*fd1x
+          strs_loc(2)=strs_loc(2)+yab*fax+ybc*(fb1x-fcx)-ycd*fd1x
+          strs_loc(3)=strs_loc(3)+zab*fax+zbc*(fb1x-fcx)-zcd*fd1x
+          strs_loc(4)=strs_loc(4)+yab*fay+ybc*(fb1y-fcy)-ycd*fd1y
+          strs_loc(5)=strs_loc(5)+yab*faz+ybc*(fb1z-fcz)-ycd*fd1z
+          strs_loc(6)=strs_loc(6)+zab*faz+zbc*(fb1z-fcz)-zcd*fd1z
+          
+        endif
+        
+c     calculate 1-4 dihedral interactions (coulombic and short ranged)
+c     assumes 1-4 interactions are in the exclude list
+        
+        kk=listdih(ii,1)
+        
+c     bypass OPLS 1-4 terms (not present)
+        
+        if(keydih(kk).ne.7)then
+          
+c     1-4 electrostatics : adjust by weighting factor
+          
+          scale=prmdih(kk,4)
+          
+          xad=xac+xcd
+          yad=yac+ycd
+          zad=zac+zcd
+          
+          rad=sqrt(xad**2+yad**2+zad**2)
+          
+c     scaled charge product*dielectric
+          
+          chgprd=scale*chge(ia)*chge(id)*r4pie0
+          coul=0.d0
+          fcoul=0.d0
+          
+c     truncation of potential for all schemes except ewald sum
+          
+          if(abs(chgprd).gt.1.d-10.and.keyfce.gt.0)then
+            
+c     electrostatics by ewald sum
+            
+            if(keyfce/2.eq.1.or.keyfce/2.eq.6.or.keyfce/2.eq.7)then
+              
+              coul=chgprd/(epsq*rad)
+              fcoul=coul/(rad**2)
+              
+c     distance dependent dielectric
+              
+            elseif(rcut.gt.rad)then
+              
+              if(keyfce/2.eq.2)then
+                
+                coul=chgprd/(epsq*rad**2)
+                fcoul=2.0d0*coul/(rad**2)
+                
+c     unmodified coulombic
+                
+              else if(keyfce/2.eq.3)then
+                
+                coul=chgprd/(epsq*rad)
+                fcoul=coul/(rad**2)
+                
+c     truncated and shifted coulombic
+                
+              else if(keyfce/2.eq.4)then
+                
+                tt=1.d0/(1.d0+pp*alpha*rad)
+                exp1=exp(-(alpha*rad)**2)
+                erc=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rad
+                fer=(erc+2.d0*(alpha/sqrpi)*exp1)/rad**2
+                
+c     calculate potential energy and forces
+                
+                coul=chgprd*(erc-vcon+fcon*(rad-rcut))/epsq
+                fcoul=chgprd*(fer-fcon/rad)/epsq
+                
+c     reaction field
+                
+              else if(keyfce/2.eq.5)then
+                
+                tt=1.d0/(1.d0+pp*alpha*rad)
+                exp1=exp(-(alpha*rad)**2)
+                erc=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rad
+                fer=(erc+2.d0*(alpha/sqrpi)*exp1)/rad**2
+                coul=chgprd*(erc-vcon+fcon*(rad-rcut)+
+     x            rfld2*rad*rad-rfld1)
+                fcoul=chgprd*(fer-fcon/rad-rfld0)
+                
+              elseif(keyfce/2.eq.0)then
+                
+                coul=0.d0
+                fcoul=0.d0
+                
+              else
+                
+                call error(idnode,446)
+                
+              endif
+              
+            endif
+            
+c     set selection control for coulombic 1-4 terms
+            
+            lselect=.true.
+            
+c     set double index
+            
+            if(lsolva)kkk=loc2(atmolt(ia),atmolt(id))
+            
+            if(lexcite)then
+              
+c     selected excitation option
+              
+              if((atm_fre(ia).ne.1).and.(atm_fre(id).ne.1))then
+                
+c     set selection control
+                
+                lselect=(atm_fre(ia)+atm_fre(id).eq.0)
+                
+                if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+                
+              endif
+              
+            elseif(lfree)then
+              
+c     selected free energy option
+              
+              if((atm_fre(ia).eq.1).or.(atm_fre(id).eq.1))then
+                
+c     set hamiltonian mixing parameter
+                
+                cou_fre=cou_fre-coul
+                cou14_vir=cou14_vir+fcoul*rad**2
+                coul=lambda1*coul
+                fcoul=lambda1*fcoul
+                
+              elseif((atm_fre(ia).eq.2).or.(atm_fre(id).eq.2))then
+                
+c     set hamiltonian mixing parameter
+                
+                cou_fre=cou_fre+coul
+                cou14_vir=cou14_vir-fcoul*rad**2
+                coul=lambda2*coul
+                fcoul=lambda2*fcoul
+                
+              endif
+              
+            endif
+            
+            if(lselect)then
+              
+c     electrostatic energy and virial for 1-4 term
+              
+              engc14=engc14+coul
+              virc14=virc14-fcoul*rad**2
+              
+c     solvation energy for coulombic 1-4 term
+              
+              if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+              
+c     coulombic force for 1-4 term
+              
+              fx=fcoul*xad
+              fy=fcoul*yad
+              fz=fcoul*zad
+              
+              fxx(ia)=fxx(ia)+fx
+              fyy(ia)=fyy(ia)+fy
+              fzz(ia)=fzz(ia)+fz
+              
+              fxx(id)=fxx(id)-fx
+              fyy(id)=fyy(id)-fy
+              fzz(id)=fzz(id)-fz
+              
+c     stress tensor for coulombic 1-4 term
+              
+              strs(1)=strs(1)+xad*fx
+              strs(2)=strs(2)+xad*fy
+              strs(3)=strs(3)+xad*fz
+              strs(4)=strs(4)+yad*fy
+              strs(5)=strs(5)+yad*fz
+              strs(6)=strs(6)+zad*fz
+            
+            endif
+            
+c     metadynamics local parameters
+            
+            if(lmetadyn.and.(idrive.or.ldrive))then
+              
+c     local energy and virial
+              
+              eng_loc=eng_loc+coul
+              vir_loc=vir_loc-fcoul*rad**2
+              
+c     local forces
+              
+              fxx_loc(ia)=fxx_loc(ia)+fx
+              fyy_loc(ia)=fyy_loc(ia)+fy
+              fzz_loc(ia)=fzz_loc(ia)+fz
+              
+              fxx_loc(id)=fxx_loc(id)-fx
+              fyy_loc(id)=fyy_loc(id)-fy
+              fzz_loc(id)=fzz_loc(id)-fz
+              
+c     local stress tensor
+              
+              strs_loc(1)=strs_loc(1)+xad*fx
+              strs_loc(2)=strs_loc(2)+xad*fy
+              strs_loc(3)=strs_loc(3)+xad*fz
+              strs_loc(4)=strs_loc(4)+yad*fy
+              strs_loc(5)=strs_loc(5)+yad*fz
+              strs_loc(6)=strs_loc(6)+zad*fz
+              
+            endif
+            
+          endif
+          
+c     1-4 short ranged : adjust by weighting factor
+          
+          scale=prmdih(kk,5)
+          gamma=0.d0
+          
+          if(mod(keyfce,2).eq.1)then
+            
+c     atomic and potential function indices
+            
+            ka=max(ltype(ia),ltype(id))
+            kb=min(ltype(ia),ltype(id))
+            k=lstvdw((ka*(ka-1))/2+kb)
+            
+            if(abs(scale*vvv(1,k)).gt.1.d-10)then
+              
+c     apply truncation of potential
+              
+              if(rvdw.gt.rad)then
+                
+c     determine interpolation panel for force arrays
+                
+                l=int(rad/dlrpot)
+                ppp=rad/dlrpot-dble(l)
+                
+c     calculate interaction energy using 3-point interpolation
+                
+                vk0=vvv(l,k)
+                vk1=vvv(l+1,k)
+                vk2=vvv(l+2,k)
+                
+                t1=vk0+(vk1-vk0)*ppp
+                t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+                
+                srpot=scale*(t1+(t2-t1)*ppp*0.5d0)
+                
+c     calculate forces using 3-point interpolation
+                
+                gk0=ggg(l,k)
+                gk1=ggg(l+1,k)
+                gk2=ggg(l+2,k)
+                
+                t1=gk0+(gk1-gk0)*ppp
+                t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+                
+                gamma=scale*(t1+(t2-t1)*ppp*0.5d0)/(rad**2)
+                
+c     set selection control for short ranged 1-4 terms
+                
+                lselect=.true.
+                
+c     set double index
+                
+                if(lsolva)kkk=loc2(atmolt(ia),atmolt(id))
+                
+                if(lexcite)then
+                  
+c     selected excitation option
+                  
+                  if((atm_fre(ia).ne.1).and.(atm_fre(id).ne.1))then
+                    
+c     set selection control
+                    
+                    lselect=(atm_fre(ia)+atm_fre(id).eq.0)
+                    
+                    if(lsolva)vdw_exc(kkk)=vdw_exc(kkk)+srpot
+                    
+                  endif
+                  
+                elseif(lfree)then
+                  
+c     selected free energy option
+                  
+                  if((atm_fre(ia).eq.1).or.(atm_fre(id).eq.1))then
+                    
+c     set hamiltonian mixing parameter
+                    
+                    vdw_fre=vdw_fre-srpot
+                    vdw14_vir=vdw14_vir+gamma*rad**2
+                    srpot=lambda1*srpot
+                    gamma=lambda1*gamma
+                    
+                  elseif((atm_fre(ia).eq.2).or.(atm_fre(id).eq.2))then
+                    
+c     set hamiltonian mixing parameter
+                    
+                    vdw_fre=vdw_fre+srpot
+                    vdw14_vir=vdw14_vir-gamma*rad**2
+                    srpot=lambda2*srpot
+                    gamma=lambda2*gamma
+                    
+                  endif
+                  
+                endif
+                
+                if(lselect)then
+                  
+c     short ranged energy and virial for 1-4 term
+                  
+                  engs14=engs14+srpot
+                  virs14=virs14-gamma*rad**2
+                  
+c     solvation energy for short ranged 1-4 term
+                  
+                  if(lsolva)vdw_sol(kkk)=vdw_sol(kkk)+srpot
+                  
+c     short ranged forces for 1-4 term
+                  
+                  fx=gamma*xad
+                  fy=gamma*yad
+                  fz=gamma*zad
+                  
+                  fxx(ia)=fxx(ia)+fx
+                  fyy(ia)=fyy(ia)+fy
+                  fzz(ia)=fzz(ia)+fz
+                  
+                  fxx(id)=fxx(id)-fx
+                  fyy(id)=fyy(id)-fy
+                  fzz(id)=fzz(id)-fz
+                  
+c     stress tensor for short ranged 1-4 term
+                  
+                  strs(1)=strs(1)+xad*fx
+                  strs(2)=strs(2)+xad*fy
+                  strs(3)=strs(3)+xad*fz
+                  strs(4)=strs(4)+yad*fy
+                  strs(5)=strs(5)+yad*fz
+                  strs(6)=strs(6)+zad*fz
+                  
+                endif
+                
+c     metadynamics local parameters
+                  
+                if(lmetadyn.and.(idrive.or.ldrive))then
+                  
+c     local energy and virial
+                  
+                  eng_loc=eng_loc+srpot
+                  vir_loc=vir_loc-gamma*rad**2
+                  
+c     local forces
+                  
+                  fxx_loc(ia)=fxx_loc(ia)+fx
+                  fyy_loc(ia)=fyy_loc(ia)+fy
+                  fzz_loc(ia)=fzz_loc(ia)+fz
+                  
+                  fxx_loc(id)=fxx_loc(id)-fx
+                  fyy_loc(id)=fyy_loc(id)-fy
+                  fzz_loc(id)=fzz_loc(id)-fz
+                  
+c     stress tensor for short ranged 1-4 term
+                  
+                  strs_loc(1)=strs_loc(1)+xad*fx
+                  strs_loc(2)=strs_loc(2)+xad*fy
+                  strs_loc(3)=strs_loc(3)+xad*fz
+                  strs_loc(4)=strs_loc(4)+yad*fy
+                  strs_loc(5)=strs_loc(5)+yad*fz
+                  strs_loc(6)=strs_loc(6)+zad*fz
+                  
+                endif
+                
+              endif
+              
+            endif
+            
+          endif
+          
+        endif
+
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+c     sum contributions to potentials
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engdih
+        buffer(2)=engc14
+        buffer(3)=virc14
+        buffer(4)=engs14
+        buffer(5)=virs14
+        buffer(6)=dih_fre
+        buffer(7)=dih_vir
+        buffer(8)=vdw14_vir
+        buffer(9)=cou14_vir
+        call gdsum(buffer(1),9,buffer(10))
+        engdih=buffer(1)
+        engc14=buffer(2)
+        virc14=buffer(3)
+        engs14=buffer(4)
+        virs14=buffer(5)
+        dih_fre=buffer(6)
+        dih_vir=buffer(7)
+        vdw14_vir=buffer(8)
+        cou14_vir=buffer(9)
+        
+        if(lsolva)then
+          
+          call gdsum(dih_sol(1),mxtmls,buffer(1))
+          if(lexcite)call gdsum(dih_exc(1),mxtmls,buffer(1))
+          
+        endif
+        
+      endif
+      
+      engcpe=engcpe+engc14
+      vircpe=vircpe+virc14
+      engsrp=engsrp+engs14
+      virsrp=virsrp+virs14
+      vdw_vir=vdw_vir+vdw14_vir
+      cou_vir=cou_vir+cou14_vir
+      
+c     check for undefined potentials
+      
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)call error(idnode,448)
+      
+      deallocate (xdab,ydab,zdab,stat=fail1)
+      deallocate (xdbc,ydbc,zdbc,stat=fail2)
+      deallocate (xdcd,ydcd,zdcd,stat=fail3)
+      
+      return
+      end subroutine dihfrc
+      
+      end module dihedral_module
diff -urN dl_class_1.9.orig/srcmod/dlpoly.f dl_class_1.9/srcmod/dlpoly.f
--- dl_class_1.9.orig/srcmod/dlpoly.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/dlpoly.f	2015-11-07 16:58:03.488054793 +0100
@@ -0,0 +1,951 @@
+      program dlpoly_classic
+      
+c***********************************************************************
+c     
+c     dl_poly classic is an stfc/ccp5 program package for the 
+c     dynamical simulation of molecular systems.
+c     
+c     dl_poly is the copyright of the stfc daresbury laboratory, 
+c     daresbury, warrington wa4 4ad. 
+c     
+c     neither the stfc, daresbury laboratory, ccp5 nor the authors
+c     of this package claim that it is free from errors and do not
+c     accept liability for any loss or damage that may arise from
+c     its use. it is the users responsibility to verify that the 
+c     package dl_poly is fit for the purpose the user intends for
+c     it.
+c     
+c     users of this package are recommended to consult the dl_poly
+c     user manual for the full description of its use and purpose.
+c     
+c     authors: w.smith and t.r.forester 1995
+c     copyright daresbury laboratory 1995
+c     
+c                       DL_POLY CLASSIC VERSION 1.9
+c
+c***********************************************************************
+      
+c     declare required modules
+      
+      use angles_module
+      use bonds_module
+      use config_module
+      use core_shell_module
+      use define_system_module
+      use dihedral_module
+      use driver_module
+      use ewald_module
+      use exclude_module
+      use external_field_module
+      use forces_module
+      use four_body_module
+      use hkewald_module
+      use hyper_dynamics_module
+      use integrator_module
+      use inversion_module
+      use metal_module
+      use metafreeze_module
+      use nlist_builders_module
+      use pair_module
+      use pmf_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use solvation_module
+      use spme_module
+      use temp_scalers_module
+      use tersoff_module
+      use tether_module
+      use three_body_module
+      use utility_module
+      use vdw_module
+      
+      implicit none
+      
+      character*1 hms,dec
+      character*8 seek
+      
+      logical ltscal,lzeql,loptim,ltraj,lgofr,lpgr,lfcap,recycle
+      logical newlst,lneut,loglnk,lnsq,lzden,lshmov,lcnb,ltad,lneb
+      logical stropt,lzero,nolink,newgau,lminim,lminnow,lhit,lbpd
+      logical prechk,tadall,lexcite,lsolva,lfree,lfrmas,lswitch
+      logical lghost,llswitch,lnfic,nebgo,lpsoc,redirect
+      
+      integer npage,lines,idnode,mxnode,memr,intsta,istraj,nsbzdn
+      integer keyens,keyfce,keyres,keytrj,kmax1,kmax2,kmax3,multt
+      integer nstack,nstbgr,nstbpo,nhko,nlatt,nstbts,nsteql,nstraj
+      integer nstrun,nospl,keyfld,natms,ngrp,ntpatm,ntpmls,ntpvdw
+      integer ntptbp,ntpmet,ntpfbp,nshels,imcon,levcfg,nneut,minstp
+      integer ntangl,ntbond,ntcons,ntdihd,ntinv,ntpmf,nspmf,ntfree
+      integer ntteth,ntshl,nstep,numacc,numrdf,nzden,nscons,i,k
+      integer ntpter,keyshl,isw,keyver,keystr,keytol,numgau,khit
+      integer nhit,keybpd,ntrack,nblock,blkout,numneb,nturn,mode
+      integer natms2,ntghost,nsolva,isolva,nofic
+      
+      real(8) alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup
+      real(8) taut,temp,timcls,timjob,tolnce,tstep,tzero,dlrpot,drewd
+      real(8) engunit,rcuttb,rctter,rcutfb,degfre,degrot,chit,conint
+      real(8) elrc,virlrc,engbnd,volm,degshl,chip,virbnd,engang,virang
+      real(8) engdih,virdih,enginv,virinv,engtbp,virtbp,engter,virter
+      real(8) engfbp,virfbp,engsrp,virsrp,engcpe,vircpe,vircon,vircom
+      real(8) engfld,virfld,engshl,virshl,shlke,engtet,virtet,virpmf
+      real(8) consv,engke,engrot,sigma,virtot,engcfg,prntim,simtim
+      real(8) stpeng,stpeth,stpprs,stptmp,stpvir,stpvol,width,zlen
+      real(8) timelp,engmet,virmet,pass0,pass1,pass2,rlxtol,opttol
+      real(8) catchrad,sprneb,deltad,tlow,engtke,ehit,xhit,yhit,zhit
+      real(8) ebias,vmin,hyp_units,estar,chit_shl,sigma_shl
+      real(8) engord,virord
+      real(8), allocatable :: tbuffer(:)
+      
+      data timelp/0.d0/,lminnow/.false./,ntrack/10/
+      data npage,lines/8,0/,recycle/.true./
+      data pass0/0.d0/,pass1/0.d0/,pass2/0.d0/
+      data delr,epsq,press,quattol,rprim,rvdw/6*0.d0/
+      data temp,timcls,timjob,tolnce,rlxtol/5*0.d0/
+      
+c     set up the communications
+      
+      call initcomms()
+      call gsync()
+      
+c     determine processor identities
+      
+      call machine(idnode,mxnode)
+            
+c     activate for limited-life executable
+      
+CBOMB      call bomb(idnode,2008,6,30)
+      
+      allocate (tbuffer(10),stat=memr)
+      
+      call parset(redirect,idnode,mxnode,tbuffer)
+      
+c     open main printing file
+      
+      if(.not.redirect.and.idnode.eq.0)open(nrite,file='OUTPUT')
+      if(idnode.eq.0) write (nrite,
+     x  "(/,20x,'DL_POLY Classic 1.9',
+     x  /,/,30x,'Running on ',i4,' nodes',/,/)") mxnode
+
+c     allocate arrays for each function
+      
+      call alloc_ang_arrays(idnode)
+      call alloc_bnd_arrays(idnode)
+      call alloc_config_arrays(idnode)
+      call alloc_csh_arrays(idnode)
+      call alloc_dih_arrays(idnode)
+      call alloc_ewald_arrays(idnode)
+      call alloc_exc_arrays(idnode)
+      call alloc_exi_arrays(idnode)
+      call alloc_fbp_arrays(idnode)
+      call alloc_fld_arrays(idnode)
+      call alloc_free_arrays(idnode)
+      call alloc_hke_arrays(idnode)
+      call alloc_hyper_arrays(idnode)
+      call alloc_inv_arrays(idnode)
+      call alloc_met_arrays(idnode)
+      call alloc_pair_arrays(idnode)
+      call alloc_pmf_arrays(idnode)
+      call alloc_prp_arrays(idnode)
+      call alloc_rgbdy_arrays(idnode)
+      call alloc_shake_arrays(idnode)
+      call alloc_site_arrays(idnode)
+      call alloc_sol_arrays(idnode)
+      call alloc_spme_arrays(idnode)
+      call alloc_tbp_arrays(idnode)
+      call alloc_ter_arrays(idnode)
+      call alloc_tet_arrays(idnode)
+      call alloc_vdw_arrays(idnode)
+      
+c     start clock
+      
+      call timchk(0,tzero)
+      
+c     input the control parameters defining the simulation
+      
+      call simdef
+     x  (seek,lfcap,lgofr,lnsq,loptim,lzero,lminim,lpgr,ltraj,ltscal,
+     x  lzeql,lzden,nolink,newgau,lhit,lbpd,ltad,lneb,prechk,tadall,
+     x  lsolva,lfree,lfrmas,lexcite,lswitch,lghost,lnfic,nebgo,lpsoc,
+     x  idnode,minstp,intsta,istraj,keybpd,keyens,keyfce,keyres,keyver,
+     x  keytrj,kmax1,kmax2,kmax3,multt,nstack,nstbgr,nsbzdn,nstbpo,
+     x  nhko,nlatt,nstbts,nsteql,nstraj,nstrun,nospl,keytol,numgau,
+     x  khit,nhit,nblock,ntrack,blkout,numneb,mode,nsolva,isolva,nofic,
+     x  alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup,taut,
+     x  temp,timcls,timjob,tolnce,tstep,rlxtol,opttol,zlen,ehit,xhit,
+     x  yhit,zhit,ebias,vmin,catchrad,sprneb,deltad,tlow,hyp_units)
+      
+c     input the system force field
+      
+      call sysdef
+     x  (lneut,lnsq,lsolva,lfree,lexcite,lswitch,lghost,idnode,keyfce,
+     x  keyfld,natms,ngrp,ntpatm,ntpmls,ntpvdw,ntptbp,ntpmet,ntpfbp,
+     x  ntpter,nshels,keyshl,ntghost,keyver,dlrpot,engunit,rvdw,rcuttb,
+     x  rctter,rcutfb)
+      
+      if(ntpmet.gt.0.and.multt.gt.1)call error(idnode,153)
+      
+c     construct initial configuration of system
+      
+      call sysgen
+     x  (loglnk,lneut,nolink,lfree,lfrmas,idnode,imcon,keyens,
+     x  keyfce,keyres,levcfg,multt,mxnode,ntpmls,delr,rcut,volm)
+      
+c     construct initial bookkeeping arrays
+      
+      call sysbook
+     x  (loglnk,lneut,lshmov,lcnb,lsolva,lghost,idnode,imcon,
+     x  mxnode,natms,nneut,ngrp,nscons,ntangl,ntbond,ntcons,
+     x  ntdihd,ntinv,ntpmls,ntpmf,nspmf,ntfree,ntteth,ntshl,
+     x  ntghost,degfre,degrot)
+      
+c     reset atom numbers for excitation simulation
+      
+      if(lghost)then
+        natms2=natms-ntghost
+      else
+        natms2=natms
+      endif
+      
+c     set initial system temperature
+      
+      call systemp
+     x  (idnode,imcon,keyres,mxnode,natms2,ngrp,nscons,ntcons,
+     x  ntfree,ntshl,levcfg,keyshl,degfre,degshl,degrot,temp,
+     x  tolnce)
+      
+c     read thermodynamic and structural data from restart file
+      
+      call sysinit
+     x  (lgofr,lzden,lsolva,lfree,lghost,lpsoc,idnode,imcon,keyfce,
+     x  keyres,mxnode,natms,ntshl,nstep,numacc,numrdf,ntpatm,
+     x  ntpmet,ntpvdw,nzden,chip,chit,conint,elrc,engunit,virlrc,
+     x  rvdw,volm,virtot,vircom,tboost,chit_shl)
+      
+c     metadynamics by d. quigley
+      
+      if(lmetadyn) then
+
+c        make copy of excluded atom list for use by metadynamics
+         call exclude_copy_mtd(idnode)
+
+c        initialise metadynamics, read order parameter definitions etc.
+         call define_metadynamics(idnode,mxnode,natms,ntpatm,temp)   
+
+      end if
+
+c     synchronise LRC, SIC and system charge terms for switching
+      
+      llswitch=.false.
+      if(lswitch)then
+        
+        if(nstep.ge.nswitch)then
+          
+          if(mod((nstep-nswitch)/niswitch,2).eq.0)then
+            
+            call switch_atm(lfrmas)
+            call switch(elrc,virlrc)
+            llswitch=.true.
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c PluMeD modifications
+
+      if(lplumed)then
+        call init_metadyn
+     x (natms, tstep, weight, chge, imcon, engunit,
+     x  trim(plumedfile)//char(0))
+        if(idnode==0)then
+         write(nrite,'(/a22)' )"-- PLUMED ENABLED --  "
+         write(nrite,'(a22,a)')"   PLUMED INPUT FILE: ",trim(plumedfile)
+        endif
+        call flush(nrite)
+      endif
+
+c PluMeD modifications
+
+c     zero long range component of stress
+      
+      do i=1,9
+        stresl(i)=0.d0
+      enddo
+      
+c     zero contraint terms
+      
+      vircon=0.d0
+      virpmf=0.d0
+      if(lminim.or.loptim.or.ntcons.eq.0)then
+
+        do i=1,9
+          strcns(i)=0.d0
+        enddo
+
+      endif
+
+c     define target kinetic energy
+      
+      sigma=temp*boltz*degfre*0.5d0
+      
+c     metadynamics by d. quigley
+      
+      sigma_shl=boltz*degshl*0.5d0      
+      
+c     convert BPD parameters to internal units
+      
+      if(lbpd)then
+        
+        ebias=0.5d0*boltz*degfre*ebias
+        vmin=0.5d0*boltz*degfre*vmin
+        
+      endif
+      
+c     time check
+
+      call timchk(1,tzero)
+
+c     control variable for structure optimizer
+      
+      keystr=0
+      stropt=.false.
+      
+      if(lminim)then
+        
+c     first step of minimisation programme
+
+        if(idnode.eq.0)write(nrite,"(1x,120('-'))")
+        
+        call minimiser
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,imcon,keyfce,
+     x    keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,mxnode,natms,
+     x    ngrp,nhko,nlatt,nneut,nospl,nscons,ntcons,nstbgr,nstep,
+     x    nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,
+     x    ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,alpha,delr,dlrpot,
+     x    drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,enginv,
+     x    engshl,engsrp,engtbp,engter,engtet,epsq,fmax,opttol,rctter,
+     x    rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp,tstep,
+     x    virang,virbnd,vircpe,virdih,virfbp,virfld,virinv,virlrc,
+     x    virmet,virshl,virsrp,virtbp,virter,virtet,volm,engmet,
+     x    virtot,sigma,tolnce,engunit,engord,virord)
+      
+c     calculate initial conditions for velocity verlet
+      
+      elseif(keyver.eq.1.and.nstep.eq.0)then
+        
+c     kinetic stress tensor at start
+        
+        call dcell(cell,celprp)
+        width=min(celprp(7),celprp(8),celprp(9))
+        call kinstress(natms,idnode,mxnode,stress)
+        engke=0.5d0*(stress(1)+stress(5)+stress(9))
+        do i=1,9
+          stress(i)=stress(i)/dble(mxnode)
+        enddo
+        
+c     calculate initial forces
+        
+        call molecular_dynamics
+     x    (lfcap,lgofr,lneut,lnsq,loglnk,loptim,lzeql,lzero,
+     x    newlst,stropt,recycle,ltad,lsolva,lfree,lghost,
+     x    idnode,imcon,keyfce,keyfld,keyshl,keystr,keytol,kmax1,
+     x    kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,nneut,
+     x    nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,
+     x    ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,
+     x    ntteth,ntcons,numrdf,nsolva,isolva,alpha,delr,dlrpot,
+     x    drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,
+     x    enginv,engshl,engsrp,engtbp,engter,engtet,epsq,fmax,
+     x    opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,shlke,
+     x    engcfg,temp,tstep,virang,virbnd,vircpe,virdih,
+     x    virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x    virtbp,virter,virtet,volm,engmet,virtot,engord,virord)
+        
+c     bias potential dynamics option - reset forces
+        
+        if(lbpd)call bpd_forces(natms,keybpd,vmin,ebias,temp,engcfg)
+        
+      endif
+      
+      if(ltad.or.(lbpd.and.keybpd.eq.2))then
+        
+c     construct the first reference state
+        
+        call hyper_start
+     x    (ltad,lbpd,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,idnode,
+     x    imcon,keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,
+     x    mxnode,natms,ngrp,nhko,nlatt,nneut,nospl,nscons,nstbgr,
+     x    nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,
+     x    ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,ntcons,ntrack,alpha,
+     x    delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,opttol,rctter,
+     x    rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep,volm,sigma,
+     x    hyp_units)
+        
+      endif
+      
+c     perform selected NEB calculation
+        
+      if(lneb)then
+        
+        do i=1,numneb
+          
+          call neb_driver
+     x      (lfcap,lneut,lnsq,loglnk,lzeql,newlst,lneb,bsn_1(i),
+     x      bsn_2(i),idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x      keytol,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,ngrp,
+     x      ntcons,ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,
+     x      keyshl,ntfree,keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,
+     x      ntshl,nscons,delr,dlrpot,engcpe,engsrp,epsq,rcut,
+     x      rprim,rvdw,vircpe,virsrp,alpha,drewd,volm,
+     x      engmet,virmet,elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,
+     x      engfbp,virfbp,rctter,engter,virter,engbnd,virbnd,
+     x      engang,virang,engdih,virdih,enginv,virinv,engtet,
+     x      virtet,engshl,shlke,virshl,engfld,virfld,engcfg,fmax,
+     x      temp,tstep,opttol,sprneb,hyp_units)
+          
+          call scan_profile(nturn,estar)
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,"(1x,120('-'))")
+            write(nrite,'(1x,"TRA",3i6,1p,4e14.5)')
+     x        bsn_1(i),bsn_2(i),nturn,estar/hyp_units
+            write(nrite,"(1x,120('-'))")
+            
+          endif
+          
+        enddo
+        
+c     bypass the MD cycle for this option
+        
+        recycle=.false.
+        
+      endif
+        
+c***********************************************************************
+c     start of molecular dynamics calculations
+c***********************************************************************
+      
+      do while(recycle)
+        
+c     increase step counter
+        
+        nstep=nstep+1
+        recycle=(nstep.lt.nstrun)
+        
+c     store velocities for free energy or solvation simulation
+        
+        if(keyver.eq.0)then
+          
+          if(lsolva)then
+            
+            vxo_sol(:)=vxx(:)
+            vyo_sol(:)=vyy(:)
+            vzo_sol(:)=vzz(:)
+            
+          elseif(lfree)then
+            
+            vxo_fre(:)=vxx(:)
+            vyo_fre(:)=vyy(:)
+            vzo_fre(:)=vzz(:)
+            
+          endif
+          
+        endif
+        
+c     molecular switching option for excitation
+        
+        if(lswitch)then
+          
+          if(nstep.ge.nswitch)then
+            
+            if(mod(nstep-nswitch,niswitch).eq.0)then
+              
+              call switch_atm(lfrmas)
+              call switch(elrc,virlrc)
+              llswitch=.not.llswitch
+              
+            endif
+            
+          endif
+          
+        endif
+        
+c     switch on the minimiser
+        
+        if(lminim)then
+          
+          lminnow=(mod(nstep,minstp).eq.0)
+          
+        endif
+        
+c     conserved quantity (other than K + U)
+        
+        consv=0.d0
+        
+c     energy accumulators
+        
+        if(.not.lminnow)then
+          
+          engke=0.d0
+          engrot=0.d0
+        
+        endif
+        
+c     calculate volume of simulation cell
+        
+        if(imcon.ne.0.and.imcon.ne.6)then
+          
+          call dcell(cell,celprp)
+          volm=celprp(10)
+          if(imcon.eq.4)then
+            
+            volm=0.5d0*celprp(10)
+            
+          elseif(imcon.eq.5)then
+            
+            volm=0.5d0*celprp(10)
+            
+          elseif(imcon.eq.7)then
+            
+            volm=0.5d0*celprp(10)
+            
+          endif
+          
+        else
+          
+          volm=0.d0
+          
+        endif
+        
+c     reset sutton chen long range corrections (constant pressure only)
+        
+        if(ntpmet.gt.0.and.keyens.ge.4.and.keyens.le.7) then
+          
+          call lrcmetal
+     x      (idnode,imcon,natms,ntpatm,engunit,rvdw,volm)
+          
+        endif
+        
+c     activate the impact option at designated time step
+        
+        if(lhit.and.nstep.eq.nhit)call impact
+     x    (khit,natms,idnode,mxnode,ehit,xhit,yhit,zhit)
+        
+c     integrate equations of motion stage 1 of velocity verlet
+        
+        if(keyver.gt.0)then
+          
+          isw=1
+          if(.not.loptim)then
+            
+            if(llswitch)call copy_force(idnode,mxnode)
+            
+            call vv_integrate
+     x      (lcnb,lshmov,lnfic,isw,idnode,mxnode,imcon,natms2,nstep,
+     x      ngrp,keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,
+     x      nofic,ntshl,keyshl,tstep,engke,engrot,tolnce,vircon,vircom,
+     x      virtot,temp,press,volm,sigma,taut,taup,chit,chip,consv,
+     x      conint,elrc,virlrc,virpmf,chit_shl,sigma_shl)
+            
+            if(lghost)call update_ghost(idnode,mxnode)
+            
+            if(lfree.or.lghost)
+     x        call lrcorrect_fre(lfree,volm,elrc,virlrc)
+            if(lsolva)call lrcorrect_sol(lghost,volm)
+            
+          endif
+
+c     scale t=0 tether reference positions (constant pressure only)
+          
+          if(keyens.ge.4.and.keyens.le.7) then
+            
+            call xscale(idnode,mxnode,natms,keyens,imcon,tstep)
+            
+          endif
+          
+        endif
+        
+        if(lminnow)then
+          
+          call minimiser
+     x      (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,imcon,keyfce,
+     x      keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,mxnode,natms,
+     x      ngrp,nhko,nlatt,nneut,nospl,nscons,ntcons,nstbgr,nstep,
+     x      nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,
+     x      ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,alpha,delr,dlrpot,
+     x      drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,enginv,
+     x      engshl,engsrp,engtbp,engter,engtet,epsq,fmax,opttol,rctter,
+     x      rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp,tstep,
+     x      virang,virbnd,vircpe,virdih,virfbp,virfld,virinv,virlrc,
+     x      virmet,virshl,virsrp,virtbp,virter,virtet,volm,engmet,
+     x      virtot,sigma,tolnce,engunit,engord,virord)
+        
+        elseif(loptim.or.keyshl.ne.2)then
+          
+          call molecular_dynamics
+     x      (lfcap,lgofr,lneut,lnsq,loglnk,loptim,lzeql,lzero,
+     x      newlst,stropt,recycle,ltad,lsolva,lfree,lghost,
+     x      idnode,imcon,keyfce,keyfld,keyshl,keystr,keytol,kmax1,
+     x      kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,nneut,
+     x      nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,
+     x      ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,
+     x      ntteth,ntcons,numrdf,nsolva,isolva,alpha,delr,dlrpot,
+     x      drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,
+     x      enginv,engshl,engsrp,engtbp,engter,engtet,epsq,fmax,
+     x      opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,shlke,
+     x      engcfg,temp,tstep,virang,virbnd,vircpe,virdih,
+     x      virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x      virtbp,virter,virtet,volm,engmet,virtot,engord,virord)
+          
+        else
+          
+          call shell_relaxation
+     x      (lfcap,lgofr,lneut,lnsq,loglnk,lzeql,newlst,ltad,lsolva,
+     x      lfree,lghost,idnode,imcon,keyfce,keyfld,keyshl,
+     x      kmax1,kmax2,kmax3,multt,mxnode,natms,nhko,nlatt,nneut,
+     x      nospl,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntinv,
+     x      ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,
+     x      ntpmls,nsolva,isolva,alpha,delr,dlrpot,drewd,elrc,engang,
+     x      engbnd,engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp,
+     x      engtbp,engter,engtet,epsq,fmax,rctter,rcut,rcutfb,rcuttb,
+     x      rprim,rvdw,shlke,engcfg,temp,tstep,virang,virbnd,vircpe,
+     x      virdih,virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x      virtbp,virter,virtet,volm,engmet,virtot,rlxtol,pass0,
+     x      pass1,pass2,engord,virord)
+          
+        endif
+        
+c     bias potential dynamics option - reset forces
+        
+        if(lbpd)call bpd_forces(natms,keybpd,vmin,ebias,temp,engcfg)
+        
+c     switching option for excitation simulation
+        
+        if(llswitch)call copy_force(idnode,mxnode)
+        
+c     integrate equations of motion
+        
+        if(keyver.eq.0)then
+          
+c     integrate equations of motion by leapfrog verlet
+          
+          if(.not.(loptim.or.lminnow))call lf_integrate
+     x      (lcnb,lshmov,lnfic,idnode,mxnode,imcon,natms2,nstep,ngrp,
+     x      keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,nofic,
+     x      tstep,engke,engrot,tolnce,quattol,vircon,vircom,virtot,
+     x      temp,press,volm,sigma,taut,taup,chit,chip,consv,conint,
+     x      elrc,virlrc,virpmf)
+          
+        else if(keyver.gt.0)then
+          
+c     integrate equations of motion by velocity verlet (stage 2)
+          
+          isw=2
+          if(.not.loptim)call vv_integrate
+     x      (lcnb,lshmov,lnfic,isw,idnode,mxnode,imcon,natms2,nstep,
+     x      ngrp,keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,
+     x      nofic,ntshl,keyshl,tstep,engke,engrot,tolnce,vircon,vircom,
+     x      virtot,temp,press,volm,sigma,taut,taup,chit,chip,consv,
+     x      conint,elrc,virlrc,virpmf,chit_shl,sigma_shl)
+          
+        endif
+        
+c     update the atomic positions for the ghost molecule
+        
+        if(lghost)call update_ghost(idnode,mxnode)
+        
+c     long range correction adjustment for free energy and solvation
+        
+        if(lsolva)call lrcorrect_sol(lghost,volm)
+        
+        if(lfree.or.lghost)
+     x    call lrcorrect_fre(lfree,volm,elrc,virlrc)
+        if(lsolva)call lrcorrect_sol(lghost,volm)
+        
+c     application of transition analysis procedures
+        
+        if(ltad.or.(lbpd.and.keybpd.eq.2))then
+          
+          engtke=engke+engrot
+          call hyper_driver
+     x      (seek,ltad,lbpd,recycle,lfcap,lneut,lnsq,loglnk,lzeql,
+     x      newlst,prechk,tadall,nebgo,nblock,ntrack,idnode,imcon,
+     x      keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,
+     x      mxnode,natms,ngrp,ntcons,nhko,nlatt,nneut,nospl,nscons,
+     x      nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,
+     x      ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,blkout,
+     x      alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,
+     x      opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,
+     x      tstep,volm,engcfg,catchrad,sprneb,deltad,tlow,engtke,
+     x      tolnce,hyp_units,ebias,vmin)
+          
+        endif
+        
+c     reset average boost factor in BPD during equilibration
+      
+      if(lbpd.and.keybpd.eq.1)then
+      
+        if(lzeql.and.nstep.le.nsteql)then
+          
+          numbpd=0
+          tboost=0.d0
+          
+        endif
+        
+      endif
+      
+c     calculate shell kinetic energy
+        
+        if(keyshl.eq.1)then
+          
+          call corshl(idnode,mxnode,ntshl,shlke)
+          
+        endif
+        
+c     scale t=0 tether reference positions (constant pressure only)
+        
+        if(keyver.eq.0.and.keyens.ge.4.and.keyens.le.7) then
+          
+          call xscale(idnode,mxnode,natms,keyens,imcon,tstep)
+          
+        endif
+        
+c     apply temperature scaling
+        
+        if((ltscal.and.nstep.le.nsteql).and.
+     x    mod(nstep-nsteql,nstbts).eq.0)then
+          
+          chit=0.d0
+          chit_shl=0.d0
+          chip=0.d0
+          do i=1,9
+            eta(i)=0.d0
+          enddo
+          
+          if(keyshl.eq.1) then
+            
+            do k=1,4
+              
+              call vscaleg(idnode,mxnode,imcon,natms2,ngrp,sigma)
+              call shlqnch(idnode,mxnode,ntshl,temp)
+              
+            enddo
+            
+          else
+            
+            call vscaleg(idnode,mxnode,imcon,natms2,ngrp,sigma)
+            
+          endif
+          
+        endif
+        
+c     reset atom velocities at intervals if required
+        
+        if(newgau)then
+          
+          if(mod(nstep,numgau).eq.0)call regauss
+     x      (idnode,imcon,mxnode,natms2,ngrp,nscons,ntcons,
+     x      ntshl,keyshl,sigma,temp,tolnce)
+          
+        endif
+        
+c     calculate physical quantities
+        
+        if(nstep.gt.0)call static
+     x    (lbpd,lzeql,idnode,intsta,imcon,keyens,natms,nstack,
+     x    nstep,nsteql,ntpatm,numacc,mxnode,nblock,keybpd,numbpd,
+     x    consv,degfre,degrot,engang,engbnd,engcpe,engdih,enginv,
+     x    engke,engrot,engsrp,engunit,engcfg,stpeng,stpeth,stpprs,
+     x    stptmp,stpvir,stpvol,tstep,virbnd,engfbp,vircom,vircon,
+     x    vircpe,virsrp,engfld,virfld,engtbp,virtbp,virpmf,virshl,
+     x    engshl,engtet,virtet,degshl,shlke,virang,width,engmet,
+     x    virmet,engter,virter,boost,tboost)
+        
+c     z density calculation
+        
+        if(lzden.and.((.not.lzeql).or.(nstep.gt.nsteql))) then
+          
+          call zden0(idnode,natms,mxnode,nzden,zlen)
+          
+        endif
+        
+c     terminate program if boundary conditions violated
+        
+        if(imcon.gt.0.and.rcut.gt.width)then
+          
+          levcfg=2
+          call revive
+     x      (lgofr,lzden,idnode,imcon,mxnode,natms,levcfg,nstep,nzden,
+     x      numacc,numrdf,chip,chit,conint,tstep,engcfg,virtot,vircom,
+     x      tboost,chit_shl)
+          call error(idnode,95)
+          
+        endif
+        
+c     line-printer output every nstbpo steps
+        
+        if(nstep.eq.1.or.(nstep.gt.1.and.mod(nstep,nstbpo).eq.0))then
+          
+          call timchk(0,timelp)
+          if(idnode.eq.0)then
+            
+            call get_prntime(hms,timelp,prntim)
+            call get_simtime(dec,nstep,tstep,simtim)
+            if(mod(lines,npage).eq.0)
+     x        write(nrite,"(1x,120('-'),
+     x        /,/,1x,'    step',5x,'eng_tot',4x,'temp_tot',5x,
+     x        'eng_cfg',5x,'eng_vdw',5x,'eng_cou',5x,'eng_bnd',
+     x        5x,'eng_ang',5x,'eng_dih',5x,'eng_tet',/,1x,
+     x        'time    ',5x,' eng_pv',4x,'temp_rot',5x,'vir_cfg',
+     x        5x,'vir_vdw',5x,'vir_cou',5x,'vir_bnd',5x,'vir_ang',
+     x        5x,'vir_con',5x,'vir_tet',/,1x,'cpu time',6x,
+     x        'volume',4x,'temp_shl',5x,'eng_shl',5x,'vir_shl',
+     x        7x,'alpha',8x,'beta',7x,'gamma',5x,'vir_pmf',
+     x        7x,'press',/,/,
+     x        1x,120('-'))")
+            write(nrite,"(1x,i8,1p,9e12.4,/,1x,0p,f7.3,a1,1p,9e12.4,
+     x        /,1x,0p,f7.3,a1,1p,9e12.4)")
+     x        nstep,(stpval(i),i=1,9),
+     x        simtim,dec,(stpval(i),i=10,18),
+     x        prntim,hms,(stpval(i),i=19,27)
+            write(nrite,"(/,1x,' rolling',1p,9e12.4,/,1x,'averages',
+     x        1p,9e12.4,/,9x,1p,9e12.4)") (ravval(i),i=1,27)
+            write(nrite,"(1x,120('-'))")
+            
+          endif
+          
+          lines=lines+1
+          
+        endif
+        
+c     report end of equilibration period
+        
+        if((.not.loptim).and.(.not.lzero).and.(nstep.ge.nsteql))then
+          
+          if((ltscal.and.idnode.eq.0).and.(nstep.eq.nsteql))
+     x      write(nrite,"(/,/,1x,'switching off temperature ',
+     x      'scaling at step ',i6,/,/,/,1x,120('-'))") nstep
+          ltscal=.false.
+          
+        endif
+        
+c     write trajectory data
+        
+        if(ltraj.and.nstep.ge.nstraj) then
+          if(idnode.eq.0.and.mod(nstep-nstraj,istraj).eq.0)then
+            
+            call traject
+     x        (ltraj,idnode,imcon,istraj,keytrj,natms,
+     x        nstraj,nstep,tstep)
+            
+          endif
+          
+        endif
+        
+c     write solvation energy file
+        
+        if(lsolva.and.nstep.ge.nsolva)then
+          
+          if(mod(nstep-nsolva,isolva).eq.0)then
+            
+            call solva_temp(idnode,mxnode,natms2,keyver)
+            call solvation_write(lexcite,lswitch,idnode,natms,
+     x        nstep,nsolva,isolva,tstep,engunit,elrc)
+            
+          endif
+          
+        endif
+        
+c     write free energy file
+        
+        if(lfree.and.nstep.ge.nfrn)then
+          
+          if(mod(nstep-nfrn,ifrn).eq.0)then
+            
+            call free_kinetic(lfrmas,idnode,mxnode,keyver)
+            call free_energy_write(idnode,nstep,engunit)
+          
+          endif
+          
+        endif
+        
+c     save restart data in event of system crash
+        
+        if(mod(nstep,ndump).eq.0.and.nstep.ne.nstrun)then
+          
+          levcfg=2
+          call revive
+     x      (lgofr,lzden,idnode,imcon,mxnode,natms,levcfg,nstep,nzden,
+     x      numacc,numrdf,chip,chit,conint,tstep,engcfg,virtot,vircom,
+     x      tboost,chit_shl)
+          
+          if(ltad.or.lbpd)
+     x      call hyper_close(ltad,idnode,mxnode,natms,nsteql)
+          
+        endif
+        
+c     cycle time check
+        
+        call timchk(0,timelp)
+        recycle=(recycle.and.timjob-timelp.gt.timcls)
+        
+      enddo
+      
+c***********************************************************************
+c     end of molecular dynamics calculations
+c***********************************************************************
+      
+c     last time check
+        
+      call timchk(0,timelp)
+      call get_prntime(hms,timjob,prntim)
+      if(idnode.eq.0)write(nrite,
+     x  "(/,/,1x,'run terminating. elapsed cpu time = ',1p,e13.5,
+     x  ', job time = ',0p,f7.3,a1,', close time = ',f7.2,'s',/)")
+     x  timelp,prntim,hms,timcls
+      
+c     shell relaxation convergence statistics
+      
+      if(.not.loptim.and.keyshl.eq.2)then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,/,1x,'shell relaxation statistics : average cycles = ',
+     x    f8.3,' maximum cycles = ',f8.3)")pass1,pass2
+      
+      endif
+
+c     produce summary of simulation
+      
+      levcfg=2
+      if(loptim)levcfg=0
+      if(.not.lneb)call result
+     x  (ltad,lbpd,lgofr,lpgr,lzden,idnode,imcon,keyens,mxnode,natms,
+     x  levcfg,nzden,nstep,ntpatm,numacc,numrdf,keybpd,chip,chit,
+     x  conint,rcut,tstep,engcfg,volm,virtot,vircom,zlen,tboost,
+     x  chit_shl)
+      
+c     write hyperdynamics restart file
+      
+      if(ltad.or.lbpd)
+     x  call hyper_close(ltad,idnode,mxnode,natms,nsteql)
+      
+c     close output channels
+      
+      if(idnode.eq.0) then
+        
+        close (nrite)
+        close (nstats)
+        close (nhist)
+        close (nevnt)
+        
+      endif
+      
+c     terminate job
+      
+      call exitcomms()
+      
+      end
diff -urN dl_class_1.9.orig/srcmod/dlpoly.f.preplumed dl_class_1.9/srcmod/dlpoly.f.preplumed
--- dl_class_1.9.orig/srcmod/dlpoly.f.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/dlpoly.f.preplumed	2012-04-24 18:30:31.000000000 +0200
@@ -0,0 +1,936 @@
+      program dlpoly_classic
+      
+c***********************************************************************
+c     
+c     dl_poly classic is an stfc/ccp5 program package for the 
+c     dynamical simulation of molecular systems.
+c     
+c     dl_poly is the copyright of the stfc daresbury laboratory, 
+c     daresbury, warrington wa4 4ad. 
+c     
+c     neither the stfc, daresbury laboratory, ccp5 nor the authors
+c     of this package claim that it is free from errors and do not
+c     accept liability for any loss or damage that may arise from
+c     its use. it is the users responsibility to verify that the 
+c     package dl_poly is fit for the purpose the user intends for
+c     it.
+c     
+c     users of this package are recommended to consult the dl_poly
+c     user manual for the full description of its use and purpose.
+c     
+c     authors: w.smith and t.r.forester 1995
+c     copyright daresbury laboratory 1995
+c     
+c                       DL_POLY CLASSIC VERSION 1.9
+c
+c***********************************************************************
+      
+c     declare required modules
+      
+      use angles_module
+      use bonds_module
+      use config_module
+      use core_shell_module
+      use define_system_module
+      use dihedral_module
+      use driver_module
+      use ewald_module
+      use exclude_module
+      use external_field_module
+      use forces_module
+      use four_body_module
+      use hkewald_module
+      use hyper_dynamics_module
+      use integrator_module
+      use inversion_module
+      use metal_module
+      use metafreeze_module
+      use nlist_builders_module
+      use pair_module
+      use pmf_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use solvation_module
+      use spme_module
+      use temp_scalers_module
+      use tersoff_module
+      use tether_module
+      use three_body_module
+      use utility_module
+      use vdw_module
+      
+      implicit none
+      
+      character*1 hms,dec
+      character*8 seek
+      
+      logical ltscal,lzeql,loptim,ltraj,lgofr,lpgr,lfcap,recycle
+      logical newlst,lneut,loglnk,lnsq,lzden,lshmov,lcnb,ltad,lneb
+      logical stropt,lzero,nolink,newgau,lminim,lminnow,lhit,lbpd
+      logical prechk,tadall,lexcite,lsolva,lfree,lfrmas,lswitch
+      logical lghost,llswitch,lnfic,nebgo,lpsoc,redirect
+      
+      integer npage,lines,idnode,mxnode,memr,intsta,istraj,nsbzdn
+      integer keyens,keyfce,keyres,keytrj,kmax1,kmax2,kmax3,multt
+      integer nstack,nstbgr,nstbpo,nhko,nlatt,nstbts,nsteql,nstraj
+      integer nstrun,nospl,keyfld,natms,ngrp,ntpatm,ntpmls,ntpvdw
+      integer ntptbp,ntpmet,ntpfbp,nshels,imcon,levcfg,nneut,minstp
+      integer ntangl,ntbond,ntcons,ntdihd,ntinv,ntpmf,nspmf,ntfree
+      integer ntteth,ntshl,nstep,numacc,numrdf,nzden,nscons,i,k
+      integer ntpter,keyshl,isw,keyver,keystr,keytol,numgau,khit
+      integer nhit,keybpd,ntrack,nblock,blkout,numneb,nturn,mode
+      integer natms2,ntghost,nsolva,isolva,nofic
+      
+      real(8) alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup
+      real(8) taut,temp,timcls,timjob,tolnce,tstep,tzero,dlrpot,drewd
+      real(8) engunit,rcuttb,rctter,rcutfb,degfre,degrot,chit,conint
+      real(8) elrc,virlrc,engbnd,volm,degshl,chip,virbnd,engang,virang
+      real(8) engdih,virdih,enginv,virinv,engtbp,virtbp,engter,virter
+      real(8) engfbp,virfbp,engsrp,virsrp,engcpe,vircpe,vircon,vircom
+      real(8) engfld,virfld,engshl,virshl,shlke,engtet,virtet,virpmf
+      real(8) consv,engke,engrot,sigma,virtot,engcfg,prntim,simtim
+      real(8) stpeng,stpeth,stpprs,stptmp,stpvir,stpvol,width,zlen
+      real(8) timelp,engmet,virmet,pass0,pass1,pass2,rlxtol,opttol
+      real(8) catchrad,sprneb,deltad,tlow,engtke,ehit,xhit,yhit,zhit
+      real(8) ebias,vmin,hyp_units,estar,chit_shl,sigma_shl
+      real(8) engord,virord
+      real(8), allocatable :: tbuffer(:)
+      
+      data timelp/0.d0/,lminnow/.false./,ntrack/10/
+      data npage,lines/8,0/,recycle/.true./
+      data pass0/0.d0/,pass1/0.d0/,pass2/0.d0/
+      data delr,epsq,press,quattol,rprim,rvdw/6*0.d0/
+      data temp,timcls,timjob,tolnce,rlxtol/5*0.d0/
+      
+c     set up the communications
+      
+      call initcomms()
+      call gsync()
+      
+c     determine processor identities
+      
+      call machine(idnode,mxnode)
+            
+c     activate for limited-life executable
+      
+CBOMB      call bomb(idnode,2008,6,30)
+      
+      allocate (tbuffer(10),stat=memr)
+      
+      call parset(redirect,idnode,mxnode,tbuffer)
+      
+c     open main printing file
+      
+      if(.not.redirect.and.idnode.eq.0)open(nrite,file='OUTPUT')
+      if(idnode.eq.0) write (nrite,
+     x  "(/,20x,'DL_POLY Classic 1.9',
+     x  /,/,30x,'Running on ',i4,' nodes',/,/)") mxnode
+
+c     allocate arrays for each function
+      
+      call alloc_ang_arrays(idnode)
+      call alloc_bnd_arrays(idnode)
+      call alloc_config_arrays(idnode)
+      call alloc_csh_arrays(idnode)
+      call alloc_dih_arrays(idnode)
+      call alloc_ewald_arrays(idnode)
+      call alloc_exc_arrays(idnode)
+      call alloc_exi_arrays(idnode)
+      call alloc_fbp_arrays(idnode)
+      call alloc_fld_arrays(idnode)
+      call alloc_free_arrays(idnode)
+      call alloc_hke_arrays(idnode)
+      call alloc_hyper_arrays(idnode)
+      call alloc_inv_arrays(idnode)
+      call alloc_met_arrays(idnode)
+      call alloc_pair_arrays(idnode)
+      call alloc_pmf_arrays(idnode)
+      call alloc_prp_arrays(idnode)
+      call alloc_rgbdy_arrays(idnode)
+      call alloc_shake_arrays(idnode)
+      call alloc_site_arrays(idnode)
+      call alloc_sol_arrays(idnode)
+      call alloc_spme_arrays(idnode)
+      call alloc_tbp_arrays(idnode)
+      call alloc_ter_arrays(idnode)
+      call alloc_tet_arrays(idnode)
+      call alloc_vdw_arrays(idnode)
+      
+c     start clock
+      
+      call timchk(0,tzero)
+      
+c     input the control parameters defining the simulation
+      
+      call simdef
+     x  (seek,lfcap,lgofr,lnsq,loptim,lzero,lminim,lpgr,ltraj,ltscal,
+     x  lzeql,lzden,nolink,newgau,lhit,lbpd,ltad,lneb,prechk,tadall,
+     x  lsolva,lfree,lfrmas,lexcite,lswitch,lghost,lnfic,nebgo,lpsoc,
+     x  idnode,minstp,intsta,istraj,keybpd,keyens,keyfce,keyres,keyver,
+     x  keytrj,kmax1,kmax2,kmax3,multt,nstack,nstbgr,nsbzdn,nstbpo,
+     x  nhko,nlatt,nstbts,nsteql,nstraj,nstrun,nospl,keytol,numgau,
+     x  khit,nhit,nblock,ntrack,blkout,numneb,mode,nsolva,isolva,nofic,
+     x  alpha,delr,epsq,fmax,press,quattol,rcut,rprim,rvdw,taup,taut,
+     x  temp,timcls,timjob,tolnce,tstep,rlxtol,opttol,zlen,ehit,xhit,
+     x  yhit,zhit,ebias,vmin,catchrad,sprneb,deltad,tlow,hyp_units)
+      
+c     input the system force field
+      
+      call sysdef
+     x  (lneut,lnsq,lsolva,lfree,lexcite,lswitch,lghost,idnode,keyfce,
+     x  keyfld,natms,ngrp,ntpatm,ntpmls,ntpvdw,ntptbp,ntpmet,ntpfbp,
+     x  ntpter,nshels,keyshl,ntghost,keyver,dlrpot,engunit,rvdw,rcuttb,
+     x  rctter,rcutfb)
+      
+      if(ntpmet.gt.0.and.multt.gt.1)call error(idnode,153)
+      
+c     construct initial configuration of system
+      
+      call sysgen
+     x  (loglnk,lneut,nolink,lfree,lfrmas,idnode,imcon,keyens,
+     x  keyfce,keyres,levcfg,multt,mxnode,ntpmls,delr,rcut,volm)
+      
+c     construct initial bookkeeping arrays
+      
+      call sysbook
+     x  (loglnk,lneut,lshmov,lcnb,lsolva,lghost,idnode,imcon,
+     x  mxnode,natms,nneut,ngrp,nscons,ntangl,ntbond,ntcons,
+     x  ntdihd,ntinv,ntpmls,ntpmf,nspmf,ntfree,ntteth,ntshl,
+     x  ntghost,degfre,degrot)
+      
+c     reset atom numbers for excitation simulation
+      
+      if(lghost)then
+        natms2=natms-ntghost
+      else
+        natms2=natms
+      endif
+      
+c     set initial system temperature
+      
+      call systemp
+     x  (idnode,imcon,keyres,mxnode,natms2,ngrp,nscons,ntcons,
+     x  ntfree,ntshl,levcfg,keyshl,degfre,degshl,degrot,temp,
+     x  tolnce)
+      
+c     read thermodynamic and structural data from restart file
+      
+      call sysinit
+     x  (lgofr,lzden,lsolva,lfree,lghost,lpsoc,idnode,imcon,keyfce,
+     x  keyres,mxnode,natms,ntshl,nstep,numacc,numrdf,ntpatm,
+     x  ntpmet,ntpvdw,nzden,chip,chit,conint,elrc,engunit,virlrc,
+     x  rvdw,volm,virtot,vircom,tboost,chit_shl)
+      
+c     metadynamics by d. quigley
+      
+      if(lmetadyn) then
+
+c        make copy of excluded atom list for use by metadynamics
+         call exclude_copy_mtd(idnode)
+
+c        initialise metadynamics, read order parameter definitions etc.
+         call define_metadynamics(idnode,mxnode,natms,ntpatm,temp)   
+
+      end if
+
+c     synchronise LRC, SIC and system charge terms for switching
+      
+      llswitch=.false.
+      if(lswitch)then
+        
+        if(nstep.ge.nswitch)then
+          
+          if(mod((nstep-nswitch)/niswitch,2).eq.0)then
+            
+            call switch_atm(lfrmas)
+            call switch(elrc,virlrc)
+            llswitch=.true.
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     zero long range component of stress
+      
+      do i=1,9
+        stresl(i)=0.d0
+      enddo
+      
+c     zero contraint terms
+      
+      vircon=0.d0
+      virpmf=0.d0
+      if(lminim.or.loptim.or.ntcons.eq.0)then
+
+        do i=1,9
+          strcns(i)=0.d0
+        enddo
+
+      endif
+
+c     define target kinetic energy
+      
+      sigma=temp*boltz*degfre*0.5d0
+      
+c     metadynamics by d. quigley
+      
+      sigma_shl=boltz*degshl*0.5d0      
+      
+c     convert BPD parameters to internal units
+      
+      if(lbpd)then
+        
+        ebias=0.5d0*boltz*degfre*ebias
+        vmin=0.5d0*boltz*degfre*vmin
+        
+      endif
+      
+c     time check
+
+      call timchk(1,tzero)
+
+c     control variable for structure optimizer
+      
+      keystr=0
+      stropt=.false.
+      
+      if(lminim)then
+        
+c     first step of minimisation programme
+
+        if(idnode.eq.0)write(nrite,"(1x,120('-'))")
+        
+        call minimiser
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,imcon,keyfce,
+     x    keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,mxnode,natms,
+     x    ngrp,nhko,nlatt,nneut,nospl,nscons,ntcons,nstbgr,nstep,
+     x    nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,
+     x    ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,alpha,delr,dlrpot,
+     x    drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,enginv,
+     x    engshl,engsrp,engtbp,engter,engtet,epsq,fmax,opttol,rctter,
+     x    rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp,tstep,
+     x    virang,virbnd,vircpe,virdih,virfbp,virfld,virinv,virlrc,
+     x    virmet,virshl,virsrp,virtbp,virter,virtet,volm,engmet,
+     x    virtot,sigma,tolnce,engunit,engord,virord)
+      
+c     calculate initial conditions for velocity verlet
+      
+      elseif(keyver.eq.1.and.nstep.eq.0)then
+        
+c     kinetic stress tensor at start
+        
+        call dcell(cell,celprp)
+        width=min(celprp(7),celprp(8),celprp(9))
+        call kinstress(natms,idnode,mxnode,stress)
+        engke=0.5d0*(stress(1)+stress(5)+stress(9))
+        do i=1,9
+          stress(i)=stress(i)/dble(mxnode)
+        enddo
+        
+c     calculate initial forces
+        
+        call molecular_dynamics
+     x    (lfcap,lgofr,lneut,lnsq,loglnk,loptim,lzeql,lzero,
+     x    newlst,stropt,recycle,ltad,lsolva,lfree,lghost,
+     x    idnode,imcon,keyfce,keyfld,keyshl,keystr,keytol,kmax1,
+     x    kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,nneut,
+     x    nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,
+     x    ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,
+     x    ntteth,ntcons,numrdf,nsolva,isolva,alpha,delr,dlrpot,
+     x    drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,
+     x    enginv,engshl,engsrp,engtbp,engter,engtet,epsq,fmax,
+     x    opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,shlke,
+     x    engcfg,temp,tstep,virang,virbnd,vircpe,virdih,
+     x    virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x    virtbp,virter,virtet,volm,engmet,virtot,engord,virord)
+        
+c     bias potential dynamics option - reset forces
+        
+        if(lbpd)call bpd_forces(natms,keybpd,vmin,ebias,temp,engcfg)
+        
+      endif
+      
+      if(ltad.or.(lbpd.and.keybpd.eq.2))then
+        
+c     construct the first reference state
+        
+        call hyper_start
+     x    (ltad,lbpd,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,idnode,
+     x    imcon,keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,
+     x    mxnode,natms,ngrp,nhko,nlatt,nneut,nospl,nscons,nstbgr,
+     x    nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,
+     x    ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,ntcons,ntrack,alpha,
+     x    delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,opttol,rctter,
+     x    rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep,volm,sigma,
+     x    hyp_units)
+        
+      endif
+      
+c     perform selected NEB calculation
+        
+      if(lneb)then
+        
+        do i=1,numneb
+          
+          call neb_driver
+     x      (lfcap,lneut,lnsq,loglnk,lzeql,newlst,lneb,bsn_1(i),
+     x      bsn_2(i),idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x      keytol,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,ngrp,
+     x      ntcons,ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,
+     x      keyshl,ntfree,keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,
+     x      ntshl,nscons,delr,dlrpot,engcpe,engsrp,epsq,rcut,
+     x      rprim,rvdw,vircpe,virsrp,alpha,drewd,volm,
+     x      engmet,virmet,elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,
+     x      engfbp,virfbp,rctter,engter,virter,engbnd,virbnd,
+     x      engang,virang,engdih,virdih,enginv,virinv,engtet,
+     x      virtet,engshl,shlke,virshl,engfld,virfld,engcfg,fmax,
+     x      temp,tstep,opttol,sprneb,hyp_units)
+          
+          call scan_profile(nturn,estar)
+          
+          if(idnode.eq.0)then
+            
+            write(nrite,"(1x,120('-'))")
+            write(nrite,'(1x,"TRA",3i6,1p,4e14.5)')
+     x        bsn_1(i),bsn_2(i),nturn,estar/hyp_units
+            write(nrite,"(1x,120('-'))")
+            
+          endif
+          
+        enddo
+        
+c     bypass the MD cycle for this option
+        
+        recycle=.false.
+        
+      endif
+        
+c***********************************************************************
+c     start of molecular dynamics calculations
+c***********************************************************************
+      
+      do while(recycle)
+        
+c     increase step counter
+        
+        nstep=nstep+1
+        recycle=(nstep.lt.nstrun)
+        
+c     store velocities for free energy or solvation simulation
+        
+        if(keyver.eq.0)then
+          
+          if(lsolva)then
+            
+            vxo_sol(:)=vxx(:)
+            vyo_sol(:)=vyy(:)
+            vzo_sol(:)=vzz(:)
+            
+          elseif(lfree)then
+            
+            vxo_fre(:)=vxx(:)
+            vyo_fre(:)=vyy(:)
+            vzo_fre(:)=vzz(:)
+            
+          endif
+          
+        endif
+        
+c     molecular switching option for excitation
+        
+        if(lswitch)then
+          
+          if(nstep.ge.nswitch)then
+            
+            if(mod(nstep-nswitch,niswitch).eq.0)then
+              
+              call switch_atm(lfrmas)
+              call switch(elrc,virlrc)
+              llswitch=.not.llswitch
+              
+            endif
+            
+          endif
+          
+        endif
+        
+c     switch on the minimiser
+        
+        if(lminim)then
+          
+          lminnow=(mod(nstep,minstp).eq.0)
+          
+        endif
+        
+c     conserved quantity (other than K + U)
+        
+        consv=0.d0
+        
+c     energy accumulators
+        
+        if(.not.lminnow)then
+          
+          engke=0.d0
+          engrot=0.d0
+        
+        endif
+        
+c     calculate volume of simulation cell
+        
+        if(imcon.ne.0.and.imcon.ne.6)then
+          
+          call dcell(cell,celprp)
+          volm=celprp(10)
+          if(imcon.eq.4)then
+            
+            volm=0.5d0*celprp(10)
+            
+          elseif(imcon.eq.5)then
+            
+            volm=0.5d0*celprp(10)
+            
+          elseif(imcon.eq.7)then
+            
+            volm=0.5d0*celprp(10)
+            
+          endif
+          
+        else
+          
+          volm=0.d0
+          
+        endif
+        
+c     reset sutton chen long range corrections (constant pressure only)
+        
+        if(ntpmet.gt.0.and.keyens.ge.4.and.keyens.le.7) then
+          
+          call lrcmetal
+     x      (idnode,imcon,natms,ntpatm,engunit,rvdw,volm)
+          
+        endif
+        
+c     activate the impact option at designated time step
+        
+        if(lhit.and.nstep.eq.nhit)call impact
+     x    (khit,natms,idnode,mxnode,ehit,xhit,yhit,zhit)
+        
+c     integrate equations of motion stage 1 of velocity verlet
+        
+        if(keyver.gt.0)then
+          
+          isw=1
+          if(.not.loptim)then
+            
+            if(llswitch)call copy_force(idnode,mxnode)
+            
+            call vv_integrate
+     x      (lcnb,lshmov,lnfic,isw,idnode,mxnode,imcon,natms2,nstep,
+     x      ngrp,keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,
+     x      nofic,ntshl,keyshl,tstep,engke,engrot,tolnce,vircon,vircom,
+     x      virtot,temp,press,volm,sigma,taut,taup,chit,chip,consv,
+     x      conint,elrc,virlrc,virpmf,chit_shl,sigma_shl)
+            
+            if(lghost)call update_ghost(idnode,mxnode)
+            
+            if(lfree.or.lghost)
+     x        call lrcorrect_fre(lfree,volm,elrc,virlrc)
+            if(lsolva)call lrcorrect_sol(lghost,volm)
+            
+          endif
+
+c     scale t=0 tether reference positions (constant pressure only)
+          
+          if(keyens.ge.4.and.keyens.le.7) then
+            
+            call xscale(idnode,mxnode,natms,keyens,imcon,tstep)
+            
+          endif
+          
+        endif
+        
+        if(lminnow)then
+          
+          call minimiser
+     x      (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,imcon,keyfce,
+     x      keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,mxnode,natms,
+     x      ngrp,nhko,nlatt,nneut,nospl,nscons,ntcons,nstbgr,nstep,
+     x      nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,
+     x      ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,alpha,delr,dlrpot,
+     x      drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,enginv,
+     x      engshl,engsrp,engtbp,engter,engtet,epsq,fmax,opttol,rctter,
+     x      rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp,tstep,
+     x      virang,virbnd,vircpe,virdih,virfbp,virfld,virinv,virlrc,
+     x      virmet,virshl,virsrp,virtbp,virter,virtet,volm,engmet,
+     x      virtot,sigma,tolnce,engunit,engord,virord)
+        
+        elseif(loptim.or.keyshl.ne.2)then
+          
+          call molecular_dynamics
+     x      (lfcap,lgofr,lneut,lnsq,loglnk,loptim,lzeql,lzero,
+     x      newlst,stropt,recycle,ltad,lsolva,lfree,lghost,
+     x      idnode,imcon,keyfce,keyfld,keyshl,keystr,keytol,kmax1,
+     x      kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,nneut,
+     x      nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,
+     x      ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,
+     x      ntteth,ntcons,numrdf,nsolva,isolva,alpha,delr,dlrpot,
+     x      drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,
+     x      enginv,engshl,engsrp,engtbp,engter,engtet,epsq,fmax,
+     x      opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,shlke,
+     x      engcfg,temp,tstep,virang,virbnd,vircpe,virdih,
+     x      virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x      virtbp,virter,virtet,volm,engmet,virtot,engord,virord)
+          
+        else
+          
+          call shell_relaxation
+     x      (lfcap,lgofr,lneut,lnsq,loglnk,lzeql,newlst,ltad,lsolva,
+     x      lfree,lghost,idnode,imcon,keyfce,keyfld,keyshl,
+     x      kmax1,kmax2,kmax3,multt,mxnode,natms,nhko,nlatt,nneut,
+     x      nospl,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntinv,
+     x      ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,
+     x      ntpmls,nsolva,isolva,alpha,delr,dlrpot,drewd,elrc,engang,
+     x      engbnd,engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp,
+     x      engtbp,engter,engtet,epsq,fmax,rctter,rcut,rcutfb,rcuttb,
+     x      rprim,rvdw,shlke,engcfg,temp,tstep,virang,virbnd,vircpe,
+     x      virdih,virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x      virtbp,virter,virtet,volm,engmet,virtot,rlxtol,pass0,
+     x      pass1,pass2,engord,virord)
+          
+        endif
+        
+c     bias potential dynamics option - reset forces
+        
+        if(lbpd)call bpd_forces(natms,keybpd,vmin,ebias,temp,engcfg)
+        
+c     switching option for excitation simulation
+        
+        if(llswitch)call copy_force(idnode,mxnode)
+        
+c     integrate equations of motion
+        
+        if(keyver.eq.0)then
+          
+c     integrate equations of motion by leapfrog verlet
+          
+          if(.not.(loptim.or.lminnow))call lf_integrate
+     x      (lcnb,lshmov,lnfic,idnode,mxnode,imcon,natms2,nstep,ngrp,
+     x      keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,nofic,
+     x      tstep,engke,engrot,tolnce,quattol,vircon,vircom,virtot,
+     x      temp,press,volm,sigma,taut,taup,chit,chip,consv,conint,
+     x      elrc,virlrc,virpmf)
+          
+        else if(keyver.gt.0)then
+          
+c     integrate equations of motion by velocity verlet (stage 2)
+          
+          isw=2
+          if(.not.loptim)call vv_integrate
+     x      (lcnb,lshmov,lnfic,isw,idnode,mxnode,imcon,natms2,nstep,
+     x      ngrp,keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,
+     x      nofic,ntshl,keyshl,tstep,engke,engrot,tolnce,vircon,vircom,
+     x      virtot,temp,press,volm,sigma,taut,taup,chit,chip,consv,
+     x      conint,elrc,virlrc,virpmf,chit_shl,sigma_shl)
+          
+        endif
+        
+c     update the atomic positions for the ghost molecule
+        
+        if(lghost)call update_ghost(idnode,mxnode)
+        
+c     long range correction adjustment for free energy and solvation
+        
+        if(lsolva)call lrcorrect_sol(lghost,volm)
+        
+        if(lfree.or.lghost)
+     x    call lrcorrect_fre(lfree,volm,elrc,virlrc)
+        if(lsolva)call lrcorrect_sol(lghost,volm)
+        
+c     application of transition analysis procedures
+        
+        if(ltad.or.(lbpd.and.keybpd.eq.2))then
+          
+          engtke=engke+engrot
+          call hyper_driver
+     x      (seek,ltad,lbpd,recycle,lfcap,lneut,lnsq,loglnk,lzeql,
+     x      newlst,prechk,tadall,nebgo,nblock,ntrack,idnode,imcon,
+     x      keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,
+     x      mxnode,natms,ngrp,ntcons,nhko,nlatt,nneut,nospl,nscons,
+     x      nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,
+     x      ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,blkout,
+     x      alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,
+     x      opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,
+     x      tstep,volm,engcfg,catchrad,sprneb,deltad,tlow,engtke,
+     x      tolnce,hyp_units,ebias,vmin)
+          
+        endif
+        
+c     reset average boost factor in BPD during equilibration
+      
+      if(lbpd.and.keybpd.eq.1)then
+      
+        if(lzeql.and.nstep.le.nsteql)then
+          
+          numbpd=0
+          tboost=0.d0
+          
+        endif
+        
+      endif
+      
+c     calculate shell kinetic energy
+        
+        if(keyshl.eq.1)then
+          
+          call corshl(idnode,mxnode,ntshl,shlke)
+          
+        endif
+        
+c     scale t=0 tether reference positions (constant pressure only)
+        
+        if(keyver.eq.0.and.keyens.ge.4.and.keyens.le.7) then
+          
+          call xscale(idnode,mxnode,natms,keyens,imcon,tstep)
+          
+        endif
+        
+c     apply temperature scaling
+        
+        if((ltscal.and.nstep.le.nsteql).and.
+     x    mod(nstep-nsteql,nstbts).eq.0)then
+          
+          chit=0.d0
+          chit_shl=0.d0
+          chip=0.d0
+          do i=1,9
+            eta(i)=0.d0
+          enddo
+          
+          if(keyshl.eq.1) then
+            
+            do k=1,4
+              
+              call vscaleg(idnode,mxnode,imcon,natms2,ngrp,sigma)
+              call shlqnch(idnode,mxnode,ntshl,temp)
+              
+            enddo
+            
+          else
+            
+            call vscaleg(idnode,mxnode,imcon,natms2,ngrp,sigma)
+            
+          endif
+          
+        endif
+        
+c     reset atom velocities at intervals if required
+        
+        if(newgau)then
+          
+          if(mod(nstep,numgau).eq.0)call regauss
+     x      (idnode,imcon,mxnode,natms2,ngrp,nscons,ntcons,
+     x      ntshl,keyshl,sigma,temp,tolnce)
+          
+        endif
+        
+c     calculate physical quantities
+        
+        if(nstep.gt.0)call static
+     x    (lbpd,lzeql,idnode,intsta,imcon,keyens,natms,nstack,
+     x    nstep,nsteql,ntpatm,numacc,mxnode,nblock,keybpd,numbpd,
+     x    consv,degfre,degrot,engang,engbnd,engcpe,engdih,enginv,
+     x    engke,engrot,engsrp,engunit,engcfg,stpeng,stpeth,stpprs,
+     x    stptmp,stpvir,stpvol,tstep,virbnd,engfbp,vircom,vircon,
+     x    vircpe,virsrp,engfld,virfld,engtbp,virtbp,virpmf,virshl,
+     x    engshl,engtet,virtet,degshl,shlke,virang,width,engmet,
+     x    virmet,engter,virter,boost,tboost)
+        
+c     z density calculation
+        
+        if(lzden.and.((.not.lzeql).or.(nstep.gt.nsteql))) then
+          
+          call zden0(idnode,natms,mxnode,nzden,zlen)
+          
+        endif
+        
+c     terminate program if boundary conditions violated
+        
+        if(imcon.gt.0.and.rcut.gt.width)then
+          
+          levcfg=2
+          call revive
+     x      (lgofr,lzden,idnode,imcon,mxnode,natms,levcfg,nstep,nzden,
+     x      numacc,numrdf,chip,chit,conint,tstep,engcfg,virtot,vircom,
+     x      tboost,chit_shl)
+          call error(idnode,95)
+          
+        endif
+        
+c     line-printer output every nstbpo steps
+        
+        if(nstep.eq.1.or.(nstep.gt.1.and.mod(nstep,nstbpo).eq.0))then
+          
+          call timchk(0,timelp)
+          if(idnode.eq.0)then
+            
+            call get_prntime(hms,timelp,prntim)
+            call get_simtime(dec,nstep,tstep,simtim)
+            if(mod(lines,npage).eq.0)
+     x        write(nrite,"(1x,120('-'),
+     x        /,/,1x,'    step',5x,'eng_tot',4x,'temp_tot',5x,
+     x        'eng_cfg',5x,'eng_vdw',5x,'eng_cou',5x,'eng_bnd',
+     x        5x,'eng_ang',5x,'eng_dih',5x,'eng_tet',/,1x,
+     x        'time    ',5x,' eng_pv',4x,'temp_rot',5x,'vir_cfg',
+     x        5x,'vir_vdw',5x,'vir_cou',5x,'vir_bnd',5x,'vir_ang',
+     x        5x,'vir_con',5x,'vir_tet',/,1x,'cpu time',6x,
+     x        'volume',4x,'temp_shl',5x,'eng_shl',5x,'vir_shl',
+     x        7x,'alpha',8x,'beta',7x,'gamma',5x,'vir_pmf',
+     x        7x,'press',/,/,
+     x        1x,120('-'))")
+            write(nrite,"(1x,i8,1p,9e12.4,/,1x,0p,f7.3,a1,1p,9e12.4,
+     x        /,1x,0p,f7.3,a1,1p,9e12.4)")
+     x        nstep,(stpval(i),i=1,9),
+     x        simtim,dec,(stpval(i),i=10,18),
+     x        prntim,hms,(stpval(i),i=19,27)
+            write(nrite,"(/,1x,' rolling',1p,9e12.4,/,1x,'averages',
+     x        1p,9e12.4,/,9x,1p,9e12.4)") (ravval(i),i=1,27)
+            write(nrite,"(1x,120('-'))")
+            
+          endif
+          
+          lines=lines+1
+          
+        endif
+        
+c     report end of equilibration period
+        
+        if((.not.loptim).and.(.not.lzero).and.(nstep.ge.nsteql))then
+          
+          if((ltscal.and.idnode.eq.0).and.(nstep.eq.nsteql))
+     x      write(nrite,"(/,/,1x,'switching off temperature ',
+     x      'scaling at step ',i6,/,/,/,1x,120('-'))") nstep
+          ltscal=.false.
+          
+        endif
+        
+c     write trajectory data
+        
+        if(ltraj.and.nstep.ge.nstraj) then
+          if(idnode.eq.0.and.mod(nstep-nstraj,istraj).eq.0)then
+            
+            call traject
+     x        (ltraj,idnode,imcon,istraj,keytrj,natms,
+     x        nstraj,nstep,tstep)
+            
+          endif
+          
+        endif
+        
+c     write solvation energy file
+        
+        if(lsolva.and.nstep.ge.nsolva)then
+          
+          if(mod(nstep-nsolva,isolva).eq.0)then
+            
+            call solva_temp(idnode,mxnode,natms2,keyver)
+            call solvation_write(lexcite,lswitch,idnode,natms,
+     x        nstep,nsolva,isolva,tstep,engunit,elrc)
+            
+          endif
+          
+        endif
+        
+c     write free energy file
+        
+        if(lfree.and.nstep.ge.nfrn)then
+          
+          if(mod(nstep-nfrn,ifrn).eq.0)then
+            
+            call free_kinetic(lfrmas,idnode,mxnode,keyver)
+            call free_energy_write(idnode,nstep,engunit)
+          
+          endif
+          
+        endif
+        
+c     save restart data in event of system crash
+        
+        if(mod(nstep,ndump).eq.0.and.nstep.ne.nstrun)then
+          
+          levcfg=2
+          call revive
+     x      (lgofr,lzden,idnode,imcon,mxnode,natms,levcfg,nstep,nzden,
+     x      numacc,numrdf,chip,chit,conint,tstep,engcfg,virtot,vircom,
+     x      tboost,chit_shl)
+          
+          if(ltad.or.lbpd)
+     x      call hyper_close(ltad,idnode,mxnode,natms,nsteql)
+          
+        endif
+        
+c     cycle time check
+        
+        call timchk(0,timelp)
+        recycle=(recycle.and.timjob-timelp.gt.timcls)
+        
+      enddo
+      
+c***********************************************************************
+c     end of molecular dynamics calculations
+c***********************************************************************
+      
+c     last time check
+        
+      call timchk(0,timelp)
+      call get_prntime(hms,timjob,prntim)
+      if(idnode.eq.0)write(nrite,
+     x  "(/,/,1x,'run terminating. elapsed cpu time = ',1p,e13.5,
+     x  ', job time = ',0p,f7.3,a1,', close time = ',f7.2,'s',/)")
+     x  timelp,prntim,hms,timcls
+      
+c     shell relaxation convergence statistics
+      
+      if(.not.loptim.and.keyshl.eq.2)then
+        
+        if(idnode.eq.0)write(nrite,
+     x    "(/,/,1x,'shell relaxation statistics : average cycles = ',
+     x    f8.3,' maximum cycles = ',f8.3)")pass1,pass2
+      
+      endif
+
+c     produce summary of simulation
+      
+      levcfg=2
+      if(loptim)levcfg=0
+      if(.not.lneb)call result
+     x  (ltad,lbpd,lgofr,lpgr,lzden,idnode,imcon,keyens,mxnode,natms,
+     x  levcfg,nzden,nstep,ntpatm,numacc,numrdf,keybpd,chip,chit,
+     x  conint,rcut,tstep,engcfg,volm,virtot,vircom,zlen,tboost,
+     x  chit_shl)
+      
+c     write hyperdynamics restart file
+      
+      if(ltad.or.lbpd)
+     x  call hyper_close(ltad,idnode,mxnode,natms,nsteql)
+      
+c     close output channels
+      
+      if(idnode.eq.0) then
+        
+        close (nrite)
+        close (nstats)
+        close (nhist)
+        close (nevnt)
+        
+      endif
+      
+c     terminate job
+      
+      call exitcomms()
+      
+      end
diff -urN dl_class_1.9.orig/srcmod/driver_module.f dl_class_1.9/srcmod/driver_module.f
--- dl_class_1.9.orig/srcmod/driver_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/driver_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,498 @@
+      module driver_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining simulation driver routines
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     adapted   - d.quigley   nov 2010 metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use forces_module
+      use nlist_builders_module
+      use optimiser_module
+      use temp_scalers_module
+      
+      implicit none
+      
+      integer, parameter :: mxpass=250
+      
+      contains
+
+      subroutine molecular_dynamics
+     x  (lfcap,lgofr,lneut,lnsq,loglnk,loptim,lzeql,lzero,newlst,
+     x  stropt,cycle,ltad,lsolva,lfree,lghost,idnode,imcon,
+     x  keyfce,keyfld,keyshl,keystr,keytol,kmax1,kmax2,kmax3,multt,
+     x  mxnode,natms,ngrp,nhko,nlatt,nneut,nospl,nscons,nstbgr,nstep,
+     x  nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,
+     x  ntpter,ntpvdw,ntshl,ntteth,ntcons,numrdf,nsolva,isolva,
+     x  alpha,delr,dlrpot,drewd,elrc,engang,engbnd,engcpe,engdih,
+     x  engfbp,engfld,enginv,engshl,engsrp,engtbp,engter,engtet,
+     x  epsq,fmax,opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,shlke,
+     x  engcfg,temp,tstep,virang,virbnd,vircpe,virdih,virfbp,virfld,
+     x  virinv,virlrc,virmet,virshl,virsrp,virtbp,virter,virtet,volm,
+     x  engmet,virtot,engord,virord)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for controlling subroutine calls in a standard
+c     molecular dynamics simulation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     adapted   - d.quigley   nov 2010 metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lfcap,lgofr,lneut,lnsq,loglnk,loptim,lzeql,lzero
+      logical newlst,stropt,cycle,ltad,lsolva,lfree,lghost
+      
+      integer idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons
+      integer keystr,kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp
+      integer nhko,nlatt,nneut,nospl,nscons,nstbgr,nstep,nsteql
+      integer ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet
+      integer ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,nsolva
+      integer isolva
+      
+      real(8) alpha,delr,dlrpot,drewd,elrc,engang,engbnd
+      real(8) engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp
+      real(8) engtbp,engter,engtet,epsq,fmax,opttol,rctter
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp
+      real(8) tstep,virang,virbnd,vircpe,virdih,virfbp
+      real(8) virfld,virinv,virlrc,virmet,virshl,virsrp
+      real(8) virtbp,virter,virtet,volm,engmet,virtot
+      real(8) engord,virord
+      
+c     construct verlet neighbour list
+      
+      call nlist_driver
+     x  (newlst,lneut,lnsq,loglnk,ltad,natms,idnode,mxnode,imcon,
+     x  nneut,keyfce,rcut,delr,tstep)
+      
+c     calculate atomic forces
+      
+      call force_manager
+     x  (newlst,lneut,lnsq,lgofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x  lghost,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x  numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x  ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x  keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x  isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x  vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x  rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x  virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x  virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x  engcfg,fmax,temp,engord,virord)
+      
+c     frozen atoms option
+      
+      call freeze(natms)
+      
+c     structure optimisation
+      
+      if(loptim.or.lzero)then
+        
+        call optimisation_selector
+     x    (loptim,stropt,lzero,idnode,mxnode,natms,imcon,ntcons,
+     x    nscons,ngrp,ntfree,keystr,keytol,engcfg,tstep,opttol)
+        
+        if(stropt.and.idnode.eq.0)
+     x    write(nrite,"(/,/,1x,'structure optimisation converged ',
+     x    'at step ',i6,/,/,/,1x,120('-'))") nstep
+        
+        cycle=(cycle.and.(.not.stropt))
+        
+      endif
+      
+c     total virial (excluding constraint virial and c.o.m virial)
+c     for npt routines     note: virsrp already includes virlrc
+      
+      virtot=vircpe+virsrp+virbnd+virtbp+virter+virfld+
+     x  virang+virshl+virtet+virmet+virord
+      
+      return
+      end subroutine molecular_dynamics
+      
+      subroutine shell_relaxation
+     x  (lfcap,lgofr,lneut,lnsq,loglnk,lzeql,newlst,ltad,lsolva,
+     x  lfree,lghost,idnode,imcon,keyfce,keyfld,keyshl,
+     x  kmax1,kmax2,kmax3,multt,mxnode,natms,nhko,nlatt,nneut,
+     x  nospl,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntinv,
+     x  ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,
+     x  ntpmls,nsolva,isolva,alpha,delr,dlrpot,drewd,elrc,engang,
+     x  engbnd,engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp,
+     x  engtbp,engter,engtet,epsq,fmax,rctter,rcut,rcutfb,rcuttb,
+     x  rprim,rvdw,shlke,engcfg,temp,tstep,virang,virbnd,vircpe,
+     x  virdih,virfbp,virfld,virinv,virlrc,virmet,virshl,virsrp,
+     x  virtbp,virter,virtet,volm,engmet,virtot,rlxtol,pass0,
+     x  pass1,pass2,engord,virord)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for controlling subroutine calls in a
+c     relaxed shell molecular dynamics simulation
+c
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     adapted   - d.quigley   nov 2010 metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical,save :: lfirst = .true.
+      logical lfcap,lgofr,lneut,lnsq,loglnk,lzeql,ltad
+      logical newlst,relaxed,shgofr,lsolva,lfree,lghost
+
+      integer idnode,imcon,keyfce,keyfld,keyshl
+      integer kmax1,kmax2,kmax3,multt,mxnode,natms
+      integer nhko,nlatt,nneut,nospl,nstbgr,nstep,nsteql
+      integer ntangl,ntbond,ntdihd,ntinv,ntpfbp,ntpmet
+      integer ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf
+      integer keyrlx,ntpmls,pass,nsolva,isolva,ia,ib,ishl
+
+      real(8) alpha,delr,dlrpot,drewd,elrc,engang,engbnd
+      real(8) engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp
+      real(8) engtbp,engter,engtet,epsq,fmax,rctter
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp
+      real(8) tstep,virang,virbnd,vircpe,virdih,virfbp
+      real(8) virfld,virinv,virlrc,virmet,virshl,virsrp
+      real(8) virtbp,virter,virtet,volm,engmet,virtot,rlxtol
+      real(8) pass0,pass1,pass2,engord,virord
+      
+      real(8),allocatable,dimension(:),save :: xdcs,ydcs,zdcs 
+
+      pass=0
+      keyrlx=0
+      shgofr=lgofr
+      relaxed=.false.
+ 
+      if(lfirst)then
+        
+        allocate(xdcs(1:ntshl))
+        allocate(ydcs(1:ntshl))
+        allocate(zdcs(1:ntshl))
+        lfirst = .false.
+        
+      else
+        
+        do ishl=1,ntshl
+          
+          ia=listshl(ishl,2)
+          ib=listshl(ishl,3)
+          xxx(ib)=xxx(ia)+xdcs(ishl)
+          yyy(ib)=yyy(ia)+ydcs(ishl)
+          zzz(ib)=zzz(ia)+zdcs(ishl)
+          
+        enddo
+        
+      endif
+      
+      do while(.not.relaxed.and.pass.le.mxpass)
+        
+c     construct verlet neighbour list
+        
+        call nlist_driver
+     x    (newlst,lneut,lnsq,loglnk,ltad,natms,idnode,mxnode,imcon,
+     x    nneut,keyfce,rcut,delr,tstep)
+        
+c     calculate atomic forces
+        
+        call force_manager
+     x    (newlst,lneut,lnsq,shgofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x    lghost,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x    numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x    ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x    keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x    isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x    vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x    rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x    virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x    virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x    engcfg,fmax,temp,engord,virord)
+        
+c     frozen atoms option
+        
+        call freeze(natms)
+        
+c     total virial (excluding constraint virial and c.o.m virial)
+c     for npt routines     note: virsrp already includes virlrc
+        
+        virtot=vircpe+virsrp+virbnd+virtbp+virter+virfld+
+     x    virang+virshl+virtet+virmet+virord
+        
+c     relaxed shell option
+        
+        call relax_shells
+     x    (relaxed,keyrlx,idnode,mxnode,natms,ntpmls,tstep,
+     x    rlxtol)
+        
+        if(relaxed)then
+          
+          pass1=pass0*pass1
+          pass0=pass0+1.d0
+          pass1=pass1/pass0+pass/pass0
+          pass2=max(dble(pass),pass2)
+c$$$          write(104,'("Relaxed shells before step: ",I5)')pass+1          
+          
+        endif
+        
+        pass=pass+1
+        if(pass.gt.mxpass)call error(idnode,1950)
+        shgofr=.false.
+        
+c     end of shell relaxation
+        
+      enddo
+      
+c     store vector connecting the cores to the shells
+      
+      do ishl=1,ntshl
+        
+        ia=listshl(ishl,2)
+        ib=listshl(ishl,3)
+        xdcs(ishl)=xxx(ib)-xxx(ia)
+        ydcs(ishl)=yyy(ib)-yyy(ia)
+        zdcs(ishl)=zzz(ib)-zzz(ia)
+        
+      enddo
+      
+      call images(imcon,0,1,ntshl,cell,xdcs,ydcs,zdcs)
+      
+      return
+      end subroutine shell_relaxation
+
+      subroutine minimiser
+     x  (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,imcon,keyfce,
+     x  keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,mxnode,natms,
+     x  ngrp,nhko,nlatt,nneut,nospl,nscons,ntcons,nstbgr,nstep,
+     x  nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,
+     x  ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,alpha,delr,dlrpot,
+     x  drewd,elrc,engang,engbnd,engcpe,engdih,engfbp,engfld,enginv,
+     x  engshl,engsrp,engtbp,engter,engtet,epsq,fmax,opttol,rctter,
+     x  rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp,tstep,
+     x  virang,virbnd,vircpe,virdih,virfbp,virfld,virinv,virlrc,
+     x  virmet,virshl,virsrp,virtbp,virter,virtet,volm,engmet,
+     x  virtot,sigma,tolnce,engunit,engord,virord)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for controlling subroutine calls in a
+c     minimisation simulation
+c
+c     copyright - daresbury laboratory
+c     author    - w. smith    may 2007
+c     adapted   - d.quigley   nov 2010 metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lfcap,lneut,lnsq,loglnk,lzeql,newlst,stropt,shgofr
+      logical conopt,newjob,ltad,lsolva,lfree,lghost
+      
+      integer idnode,imcon,keyfce,keyfld,keyshl,keystr,pass,i
+      integer kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,keytol
+      integer nhko,nlatt,nneut,nospl,nscons,nstbgr,nstep,nsteql
+      integer ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet
+      integer ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf,ntcons
+      integer fail,nsolva,isolva
+
+      real(8) alpha,delr,dlrpot,drewd,elrc,engang,engbnd
+      real(8) engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp
+      real(8) engtbp,engter,engtet,epsq,fmax,opttol,rctter,sigma
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp
+      real(8) tstep,virang,virbnd,vircpe,virdih,virfbp
+      real(8) virfld,virinv,virlrc,virmet,virshl,virsrp,tolnce
+      real(8) virtbp,virter,virtet,volm,engmet,virtot,engcon
+      real(8) cfgmin,engunit,hnorm,grad0,grad1,ff1,sgn
+      real(8) engord,virord
+      
+      real(8), allocatable :: sxx(:),syy(:),szz(:)
+      
+      save cfgmin,newjob
+      
+      data newjob/.true./
+      
+      pass=0
+      keystr=0
+      shgofr=.false.
+      stropt=.false.
+      
+c     dummy variables
+      
+      ltad=.false.
+      lsolva=.false.
+      lfree=.false.
+      lghost=.false.
+      nsolva=0
+      isolva=1
+      
+c$$$c     diagnostic printing (not usually active)
+c$$$
+c$$$      if(idnode.eq.0)then
+c$$$        
+c$$$        write(nrite,"(1x,120('-'),
+c$$$     x    /,/,1x,'    pass',5x,'eng_cfg',5x,'eng_vdw',5x,'eng_cou',
+c$$$     x    5x,'eng_bnd',5x,'eng_ang',5x,'eng_dih',5x,'eng_tet',
+c$$$     x    5x,'eng_met',/,1x,120('-'))")
+c$$$        
+c$$$      endif
+      
+      do while(.not.stropt.and.pass.lt.mxpass)
+        
+        pass=pass+1
+        
+c     construct verlet neighbour list
+        
+        call nlist_driver
+     x    (newlst,lneut,lnsq,loglnk,ltad,natms,idnode,mxnode,imcon,
+     x    nneut,keyfce,rcut,delr,tstep)
+        
+c     calculate atomic forces
+        
+        call force_manager
+     x    (newlst,lneut,lnsq,shgofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x    lghost,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x    numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x    ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x    keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x    isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x    vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x    rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x    virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x    virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x    engcfg,fmax,temp,engord,virord)
+        
+c     frozen atoms option
+        
+        call freeze(natms)
+        
+c     total virial (excluding constraint virial and c.o.m virial)
+c     for npt routines     note: virsrp already includes virlrc
+        
+        virtot=vircpe+virsrp+virbnd+virtbp+virter+virfld+
+     x    virang+virshl+virtet+virmet+virord
+        
+c     conjugate gradient structure optimisation
+        
+        call strucopt
+     x    (stropt,keystr,keytol,idnode,mxnode,natms,ntcons,nscons,
+     x    imcon,ngrp,ntfree,tstep,opttol,engcfg,hnorm,grad0,grad1,
+     x    ff1,sgn)
+        
+c$$$c     diagnostic printing (not usually active)
+c$$$
+c$$$        if(idnode.eq.0)then
+c$$$          
+c$$$          write(nrite,"(1x,i8,1p,8e12.4)")
+c$$$     x      pass,engcfg/engunit,engsrp/engunit,engcpe/engunit,
+c$$$     x      engbnd/engunit,engang/engunit,engdih/engunit,engtet/
+c$$$     x      engunit,engmet/engunit
+c$$$          write(nrite,"(1x,120('-'))")
+c$$$          
+c$$$        endif
+
+c     end of structure minimisation
+        
+      enddo
+      
+c     ensure constraints are satisfied
+      
+      if(stropt.and.ntcons.gt.0)then
+        
+        allocate(sxx(mxatms),syy(mxatms),szz(mxatms),stat=fail)
+        if(fail.ne.0)call error(idnode,9999)
+        
+c     store current forces
+        
+        do i=1,natms
+          
+          sxx(i)=fxx(i)
+          syy(i)=fyy(i)
+          szz(i)=fzz(i)
+          
+        enddo
+        
+        keystr=0
+        conopt=.false.
+        
+        do while(.not.conopt.and.pass.lt.mxpass)
+
+          pass=pass+1
+          engcon=0.d0
+          
+          do i=1,natms
+            
+            fxx(i)=0.d0
+            fyy(i)=0.d0
+            fzz(i)=0.d0
+            
+          enddo
+          
+c     conjugate gradient structure optimisation of constraint bonds
+          
+          call strucopt
+     x      (conopt,keystr,keytol,idnode,mxnode,natms,ntcons,nscons,
+     x      imcon,ngrp,ntfree,tstep,opttol,engcon,hnorm,grad0,grad1,
+     x      ff1,sgn)
+          
+        enddo
+        
+c     restore current forces
+        
+        do i=1,natms
+          
+          fxx(i)=sxx(i)
+          fyy(i)=syy(i)
+          fzz(i)=szz(i)
+          
+        enddo
+        
+        deallocate(sxx,syy,szz,stat=fail)
+        
+      endif
+      
+c     write data summary
+      
+      if(idnode.eq.0)then
+        
+        if(stropt)then
+          
+          write(nrite,'(1x,"minimisation converged after ",i6," cycles"
+     x      ," energy minimum: ",1pe12.4)')pass,engcfg/engunit
+          
+        else
+          
+          write(nrite,'(1x,"minimisation NOT converged after ",i6,
+     x      " cycles")')pass
+          
+        endif
+        
+        write(nrite,"(1x,120('-'))")
+        
+      endif
+      
+c     reset velocities after structure optimisation
+      
+      call regauss(idnode,imcon,mxnode,natms,ngrp,nscons,ntcons,
+     x  ntshl,keyshl,sigma,temp,tolnce)
+      
+c     write out minimised structure if lowest obtained so far
+      
+      if(newjob.or.cfgmin.gt.engcfg)then
+        
+        if(idnode.eq.0)call config_write('CFGMIN',0,imcon,natms,engcfg)
+        cfgmin=engcfg
+        newjob=.false.
+        
+      endif
+      
+      return
+      end subroutine minimiser
+      
+      end module driver_module
diff -urN dl_class_1.9.orig/srcmod/ensemble_tools_module.f dl_class_1.9/srcmod/ensemble_tools_module.f
--- dl_class_1.9.orig/srcmod/ensemble_tools_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/ensemble_tools_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1934 @@
+      module ensemble_tools_module
+
+c***********************************************************************
+c     
+c     dl_poly module defining tools for ensemble simulations
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+      
+      use config_module
+      use core_shell_module
+      use property_module
+      use rigid_body_module
+      use utility_module
+      
+      contains
+      
+      function getmass(natms,idnode,mxnode)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate total system mass
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer natms,idnode,mxnode,i,iatm0,iatm1
+      real(8) getmass
+      
+      iatm0 = (idnode*natms)/mxnode+1
+      iatm1 = ((idnode+1)*natms)/mxnode
+
+      getmass=0.d0
+
+      do i=iatm0,iatm1
+
+        getmass=getmass+weight(i)
+
+      enddo
+
+      if(mxnode.gt.1)then
+        
+        buffer(1)=getmass
+        call gdsum(buffer(1),1,buffer(2))
+        getmass=buffer(1)
+        
+      endif
+      
+      return
+      end function getmass
+
+      subroutine getcom(natms,idnode,mxnode,totmas,com)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate system centre of mass
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer natms,idnode,mxnode,i,iatm0,iatm1
+      real(8) totmas
+      
+      real(8) com(3)
+      
+      iatm0 = (idnode*natms)/mxnode+1
+      iatm1 = ((idnode+1)*natms)/mxnode
+
+      com(1)=0.d0
+      com(2)=0.d0
+      com(3)=0.d0
+      
+      do i=iatm0,iatm1
+        
+        com(1)=com(1)+weight(i)*xxx(i)
+        com(2)=com(2)+weight(i)*yyy(i)
+        com(3)=com(3)+weight(i)*zzz(i)
+
+      enddo
+
+      if(mxnode.gt.1) call gdsum(com,3,buffer)
+
+      com(1)=com(1)/totmas
+      com(2)=com(2)/totmas
+      com(3)=com(3)/totmas
+
+      return
+      end subroutine getcom
+
+      subroutine getvom(natms,idnode,mxnode,totmas,vom)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate system centre of mass
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer natms,idnode,mxnode,i,iatm0,iatm1
+      real(8) totmas
+      
+      real(8) vom(3)
+      
+      iatm0 = (idnode*natms)/mxnode+1
+      iatm1 = ((idnode+1)*natms)/mxnode
+
+      vom(1)=0.d0
+      vom(2)=0.d0
+      vom(3)=0.d0
+      
+      do i=iatm0,iatm1
+        
+        vom(1)=vom(1)+weight(i)*vxx(i)
+        vom(2)=vom(2)+weight(i)*vyy(i)
+        vom(3)=vom(3)+weight(i)*vzz(i)
+
+      enddo
+
+      if(mxnode.gt.1) call gdsum(vom,3,buffer)
+
+      vom(1)=vom(1)/totmas
+      vom(2)=vom(2)/totmas
+      vom(3)=vom(3)/totmas
+
+      return
+      end subroutine getvom
+
+      subroutine nvtscale
+     x  (idnode,mxnode,natms,engke,sigma,tstep,qmass,taut,chit,conint)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NVT thermostat
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms,i,iatm0,iatm1
+      real(8) engke,sigma,tstep,qmass,chit,conint,scale,taut
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     calculate kinetic energy
+      
+      engke=getkin(natms,idnode,mxnode)
+
+c     update chit to 1/2 step
+      
+      chit=chit+tstep*(engke-sigma)/qmass
+
+c     thermostat the velocities
+      
+      scale=exp(-tstep*chit)
+
+      do i=iatm0,iatm1
+        
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+      engke=engke*scale**2
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit*qmass/taut**2
+
+c     update chit to full step
+      
+      chit=chit+tstep*(engke-sigma)/qmass
+      
+      return
+      end subroutine nvtscale
+
+      subroutine nptscale_t
+     x  (idnode,mxnode,natms,engke,temp,sigma,tstep,pmass,qmass,taut,
+     x  chip,chit,conint)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NPT thermostat
+c
+c     copyright daresbury laboratory
+c     author - w.smith july 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms,i,iatm0,iatm1
+      real(8) engke,temp,sigma,tstep,pmass,qmass,chip,chit,conint,scale
+      real(8) taut
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     calculate kinetic energy
+      
+      engke=getkin(natms,idnode,mxnode)
+
+c     update chit to 1/2 step
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip**2-boltz*temp)/qmass
+
+c     thermostat the velocities
+      
+      scale=exp(-tstep*chit)
+
+      do i=iatm0,iatm1
+        
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+      engke=engke*scale**2
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit*(qmass/taut**2+boltz*temp)
+
+c     update chit to full step
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip**2-boltz*temp)/qmass
+
+      return
+      end subroutine nptscale_t
+
+      subroutine nptscale_p
+     x  (idnode,mxnode,natms,engke,tstep,pmass,chip,chit,
+     x  volm,press,vircon,virtot)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT barostat
+c     
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c     
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,natms,i,iatm0,iatm1
+      real(8) engke,tstep,pmass,chip,press,vircon,virtot
+      real(8) volm,scale,chit
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     propagate chip to 1/2 step
+      
+      chip=chip+0.5d0*tstep*(((2.d0*engke-virtot-vircon)-
+     x  3.d0*press*volm)/pmass-chip*chit)
+
+c     barostat the velocities
+      
+      scale=exp(-tstep*chip)
+
+      do i=iatm0,iatm1
+        
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+      engke=engke*scale**2
+
+c     update volume parameter to full step
+      
+      volm=volm*exp(3.d0*tstep*chip)
+
+c     update chip to full step
+      
+      chip=chip+0.5d0*tstep*(((2.d0*engke-virtot-vircon)-
+     x  3.d0*press*volm)/pmass-chip*chit)
+      
+      return
+      end subroutine nptscale_p
+
+      subroutine nvtqscl
+     x  (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,sigma,
+     x   tstep,qmass,taut,chit,conint)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NVT thermostat
+c     to atomic, group and quaternion momenta
+c
+c     copyright daresbury laboratory
+c     author - w.smith april 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,j,igrp1,igrp2,ifre1,ifre2
+      integer ig
+      real(8) engke,engtrn,engrot,engfke,sigma,tstep,qmass,chit,taut
+      real(8) conint,scale
+
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     calculate kinetic energy
+      
+      engfke=getkinf(ntfree,idnode,mxnode)
+      call getking(ngrp,idnode,mxnode,engtrn,engrot)
+      engke=engfke+engtrn+engrot
+
+c     update chit to 1/2 step
+      
+      chit=chit+tstep*(engke-sigma)/qmass
+
+c     thermostat scale parameter
+      
+      scale=exp(-tstep*chit)
+
+c     thermostat free atoms
+
+      do j=ifre1,ifre2
+
+         i=lstfre(j)
+         vxx(i)=scale*vxx(i)
+         vyy(i)=scale*vyy(i)
+         vzz(i)=scale*vzz(i)
+        
+      enddo
+
+c     thermostat rigid body velocities
+
+      do ig=igrp1,igrp2
+         
+         omx(ig)=scale*omx(ig)
+         omy(ig)=scale*omy(ig)
+         omz(ig)=scale*omz(ig)
+         gvxx(ig)=scale*gvxx(ig)
+         gvyy(ig)=scale*gvyy(ig)
+         gvzz(ig)=scale*gvzz(ig)
+         
+      enddo
+
+c     scale kinetic energy
+
+      engfke=engfke*scale**2
+      engtrn=engtrn*scale**2
+      engrot=engrot*scale**2
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit*qmass/taut**2
+
+c     update chit to full step
+      
+      engke=engfke+engtrn+engrot
+      chit=chit+tstep*(engke-sigma)/qmass
+
+      return
+      end subroutine nvtqscl
+
+      subroutine nptqscl_t
+     x  (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,sigma,
+     x  tstep,pmass,qmass,taut,chip,chit,conint)
+
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT thermostat
+c     to atomic, group and quaternion momenta
+c     
+c     copyright daresbury laboratory
+c     author - w.smith april 2005
+c     
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,j,igrp1,igrp2,ifre1,ifre2
+      integer ig
+      real(8) engke,engtrn,engrot,engfke,sigma,tstep,qmass,chit,taut
+      real(8) conint,scale,chip,pmass,temp
+
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     calculate kinetic energy
+      
+      engfke=getkinf(ntfree,idnode,mxnode)
+      call getking(ngrp,idnode,mxnode,engtrn,engrot)
+      engke=engfke+engtrn+engrot
+
+c     update chit to 1/2 tstep
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip**2-boltz*temp)/qmass
+      
+c     thermostat scale parameter
+      
+      scale=exp(-tstep*chit)
+      
+c     thermostat free atoms
+      
+      do j=ifre1,ifre2
+        
+        i=lstfre(j)
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+      
+c     thermostat rigid body velocities
+      
+      do ig=igrp1,igrp2
+        
+        omx(ig)=scale*omx(ig)
+        omy(ig)=scale*omy(ig)
+        omz(ig)=scale*omz(ig)
+        gvxx(ig)=scale*gvxx(ig)
+        gvyy(ig)=scale*gvyy(ig)
+        gvzz(ig)=scale*gvzz(ig)
+        
+      enddo
+      
+c     scale kinetic energy
+      
+      engfke=engfke*scale**2
+      engtrn=engtrn*scale**2
+      engrot=engrot*scale**2
+      
+c     update chi to full tstep
+      
+      conint=conint+tstep*chit*(qmass/taut**2+boltz*temp)
+      
+c     update chit to full tstep
+      
+      engke=engfke+engtrn+engrot
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip**2-boltz*temp)/qmass
+      
+      return
+      end subroutine nptqscl_t
+
+      subroutine nptqscl_p
+     x  (idnode,mxnode,ntfree,ngrp,engfke,engtrn,tstep,pmass,
+     x  chip,chit,volm,press,vircon,virtot,vircom)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT barostat
+c     for system with atomic sites and rigid bodies
+c     
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c     
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,i,ngrp,ntfree,igrp1,igrp2,ifre1,ifre2
+      integer j,ig
+      real(8) engke,tstep,pmass,chip,press,vircon,virtot
+      real(8) vircom,volm,scale,engtrn,engfke,chit
+
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+
+c     propagate chip to 1/2 tstep
+      
+      engke=engfke+engtrn
+      chip=chip+0.5d0*tstep*(((2.d0*engke-virtot-vircon-vircom)-
+     x  3.d0*press*volm)/pmass-chip*chit)
+      
+c     barostat the free atom velocities
+      
+      scale=exp(-tstep*chip)
+      
+      do j=ifre1,ifre2
+        
+        i=lstfre(j)
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+      
+c     barostat the group translational velocities
+      
+      do ig=igrp1,igrp2
+        
+        gvxx(ig)=scale*gvxx(ig)
+        gvyy(ig)=scale*gvyy(ig)
+        gvzz(ig)=scale*gvzz(ig)
+        
+      enddo
+      
+c     scale kinetic energy
+      
+      engfke=engfke*scale**2
+      engtrn=engtrn*scale**2
+      
+c     update volume parameter to full tstep
+      
+      volm=volm*exp(3.d0*tstep*chip)
+      
+c     update chip to full tstep
+      
+      engke=engfke+engtrn
+      chip=chip+0.5d0*tstep*(((2.d0*engke-virtot-vircon-vircom)-
+     x  3.d0*press*volm)/pmass-chip*chit)
+      
+      return
+      end subroutine nptqscl_p
+
+      subroutine nstscale_t
+     x  (idnode,mxnode,natms,mode,engke,temp,sigma,tstep,
+     x  pmass,qmass,taut,chit,conint)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NST thermostat
+c
+c     copyright daresbury laboratory
+c     author - w.smith july 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms,mode,i,iatm0,iatm1
+      real(8) engke,temp,sigma,tstep,pmass,qmass,chip2,chit,conint,scale
+      real(8) taut,fac(0:3)
+      data fac/9.d0,3.d0,2.d0,5.d0/
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     calculate kinetic energy
+      
+      chip2=sdot0(9,eta,eta)
+      if(mode.eq.2)chip2=chip2-eta(1)**2
+      engke=getkin(natms,idnode,mxnode)
+
+c     update chit to 1/2 step
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip2-boltz*temp*fac(mode))/qmass
+
+c     thermostat the velocities
+      
+      scale=exp(-tstep*chit)
+      do i=iatm0,iatm1
+        
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+      engke=engke*scale**2
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit*(qmass/taut**2+boltz*temp*fac(mode))
+
+c     update chit to full step
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip2-boltz*temp*fac(mode))/qmass
+
+      return
+      end subroutine nstscale_t
+
+      subroutine nstscale_p
+     x  (idnode,mxnode,natms,mode,tstep,pmass,chit,press,volm)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT anisotropic barostat
+c     
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,natms,mode,i,iatm0,iatm1
+      real(8) tstep,pmass,press,volm,txx,tyy,tzz,chit
+      real(8) strkin(9),uni(9),celp(10)
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     calculate kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     propagate barostat momentum to 1/2 step
+
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)+strkin(i)-
+     x    press*volm*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+c     barostat the velocities
+      
+      do i=iatm0,iatm1
+        
+        txx=vxx(i)
+        tyy=vyy(i)
+        tzz=vzz(i)
+        vxx(i)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz)
+        vyy(i)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz)
+        vzz(i)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz)
+
+      enddo
+
+c     new cell vectors
+          
+      call cell_update(tstep,cell,eta)
+
+c     update volume to full time step
+
+      call dcell(cell,celp)
+      volm=celp(10)
+
+c     calculate kinetic energy and contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     propagate barostat momentum to full step
+
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)+strkin(i)-
+     x    press*volm*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+      
+      return
+      end subroutine nstscale_p
+
+      subroutine nstqscl_t
+     x  (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,temp,
+     x  sigma,tstep,pmass,qmass,taut,chit,conint)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NPT thermostat
+c     to atomic, group and quaternion momenta
+c
+c     copyright daresbury laboratory
+c     author - w.smith april 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,j,igrp1,igrp2,ifre1,ifre2
+      integer ig,mode
+      real(8) engke,engtrn,engrot,engfke,sigma,tstep,qmass,chit,taut
+      real(8) conint,scale,chip2,pmass,temp,fac(0:3)
+      data fac/9.d0,3.d0,2.d0,5.d0/
+
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     calculate kinetic energy
+      
+      chip2=sdot0(9,eta,eta)
+      if(mode.eq.2)chip2=chip2-eta(1)**2
+      engfke=getkinf(ntfree,idnode,mxnode)
+      call getking(ngrp,idnode,mxnode,engtrn,engrot)
+      engke=engfke+engtrn+engrot
+
+c     update chit to 1/2 step
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip2-boltz*temp*fac(mode))/qmass
+
+c     thermostat scale parameter
+      
+      scale=exp(-tstep*chit)
+
+c     thermostat free atoms
+
+      do j=ifre1,ifre2
+
+         i=lstfre(j)
+         vxx(i)=scale*vxx(i)
+         vyy(i)=scale*vyy(i)
+         vzz(i)=scale*vzz(i)
+        
+      enddo
+
+c     thermostat rigid body velocities
+
+      do ig=igrp1,igrp2
+         
+         omx(ig)=scale*omx(ig)
+         omy(ig)=scale*omy(ig)
+         omz(ig)=scale*omz(ig)
+         gvxx(ig)=scale*gvxx(ig)
+         gvyy(ig)=scale*gvyy(ig)
+         gvzz(ig)=scale*gvzz(ig)
+         
+      enddo
+
+c     scale kinetic energy
+
+      engfke=engfke*scale**2
+      engtrn=engtrn*scale**2
+      engrot=engrot*scale**2
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit*(qmass/taut**2+boltz*temp*fac(mode))
+
+c     update chit to full step
+      
+      engke=engfke+engtrn+engrot
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip2-boltz*temp*fac(mode))/qmass
+
+      return
+      end subroutine nstqscl_t
+
+      subroutine nstqscl_p
+     x  (idnode,mxnode,ntfree,ngrp,mode,tstep,pmass,chit,press,volm)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT anisotropic barostat
+c     for system with atomic sites and rigid bodies
+c     
+c     copyright daresbury laboratory
+c     author - w.smith may 2005
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,igrp1,igrp2,ifre1,ifre2,ig,j
+      integer mode
+      real(8) tstep,pmass,press,volm,txx,tyy,tzz,chit
+      real(8) strkin(9),strgrp(9),uni(9),celp(10)
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+
+c     propagate barostat momentum to 1/2 step
+      
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)-
+     x    press*volm*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+c     subtract kinetic contribution from stress tensor
+
+      call kinstressf(ntfree,idnode,mxnode,strkin)        
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+      do i=1,9
+        stress(i)=stress(i)-strkin(i)-strgrp(i)
+      enddo
+      
+c     barostat the free atom velocities
+      
+      do j=ifre1,ifre2
+        
+        i=lstfre(j)
+        txx=vxx(i)
+        tyy=vyy(i)
+        tzz=vzz(i)
+        vxx(i)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz)
+        vyy(i)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz)
+        vzz(i)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz)
+
+      enddo
+
+c     barostat the group translational velocities
+
+      do ig=igrp1,igrp2
+         
+         txx=gvxx(ig)
+         tyy=gvyy(ig)
+         tzz=gvzz(ig)
+         gvxx(ig)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz)
+         gvyy(ig)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz)
+         gvzz(ig)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz)
+         
+      enddo
+
+c     new cell vectors
+
+      call cell_update(tstep,cell,eta)
+      
+c     new system volume
+      
+      call dcell(cell,celp)
+      volm=celp(10)
+      
+c     add new kinetic contribution to stress tensor
+
+      call kinstressf(ntfree,idnode,mxnode,strkin)        
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)
+      enddo
+      
+c     propagate barostat momentum to full step
+
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)-
+     x    press*volm*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+      return
+      end subroutine nstqscl_p
+
+      subroutine nstqscl_t2
+     x  (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,temp,
+     x  sigma,tstep,pmass,qmass,taut,chit,conint,strkin,strgrp)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NPT thermostat
+c     to atomic, group and quaternion momenta
+c
+c     copyright daresbury laboratory
+c     author - w.smith april 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,j,igrp1,igrp2,ifre1,ifre2
+      integer ig,mode
+      real(8) engke,engtrn,engrot,engfke,sigma,tstep,qmass,chit,taut
+      real(8) conint,scale,chip2,pmass,temp,fac(0:3)
+      real(8) strkin(9),strgrp(9)
+      data fac/9.d0,3.d0,2.d0,5.d0/
+
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     remove old kinetic term from stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)-strkin(i)-strgrp(i)
+      enddo
+
+c     calculate kinetic energy
+      
+      chip2=sdot0(9,eta,eta)
+      if(mode.eq.2)chip2=chip2-eta(1)**2
+      engfke=getkinf(ntfree,idnode,mxnode)
+      call getking(ngrp,idnode,mxnode,engtrn,engrot)
+      engke=engfke+engtrn+engrot
+
+c     update chit to 1/2 step
+      
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip2-boltz*temp*fac(mode))/qmass
+
+c     thermostat scale parameter
+      
+      scale=exp(-tstep*chit)
+
+c     thermostat free atoms
+
+      do j=ifre1,ifre2
+
+         i=lstfre(j)
+         vxx(i)=scale*vxx(i)
+         vyy(i)=scale*vyy(i)
+         vzz(i)=scale*vzz(i)
+        
+      enddo
+
+c     thermostat rigid body velocities
+
+      do ig=igrp1,igrp2
+         
+         omx(ig)=scale*omx(ig)
+         omy(ig)=scale*omy(ig)
+         omz(ig)=scale*omz(ig)
+         gvxx(ig)=scale*gvxx(ig)
+         gvyy(ig)=scale*gvyy(ig)
+         gvzz(ig)=scale*gvzz(ig)
+         
+      enddo
+
+c     scale kinetic energy
+
+      engfke=engfke*scale**2
+      engtrn=engtrn*scale**2
+      engrot=engrot*scale**2
+
+c     scale kinetic energy tensors
+
+      do i=1,9
+
+        strkin(i)=strkin(i)*scale**2
+        strgrp(i)=strgrp(i)*scale**2
+
+      enddo
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit*(qmass/taut**2+boltz*temp*fac(mode))
+
+c     update chit to full step
+      
+      engke=engfke+engtrn+engrot
+      chit=chit+0.5d0*tstep*(2.d0*(engke-sigma)+
+     x  pmass*chip2-boltz*temp*fac(mode))/qmass
+
+c     add new kinetic terms to stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)
+      enddo
+
+      return
+      end subroutine nstqscl_t2
+
+      subroutine nstqscl_p2
+     x  (idnode,mxnode,ntfree,ngrp,mode,tstep,pmass,chit,press,volm,
+     x  strkin,strgrp)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT anisotropic barostat
+c     for system with atomic sites and rigid bodies
+c     
+c     copyright daresbury laboratory
+c     author - w.smith may 2005
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,igrp1,igrp2,ifre1,ifre2,ig,j
+      integer mode
+      real(8) tstep,pmass,press,volm,txx,tyy,tzz,chit
+      real(8) strkin(9),strgrp(9),uni(9),celp(10)
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+
+c     propagate barostat momentum to 1/2 step
+      
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)-
+     x    press*volm*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+c     subtract kinetic contribution from stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)-strkin(i)-strgrp(i)
+      enddo
+      
+c     barostat the free atom velocities
+      
+      do j=ifre1,ifre2
+        
+        i=lstfre(j)
+        txx=vxx(i)
+        tyy=vyy(i)
+        tzz=vzz(i)
+        vxx(i)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz)
+        vyy(i)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz)
+        vzz(i)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz)
+
+      enddo
+
+c     barostat the group translational velocities
+
+      do ig=igrp1,igrp2
+         
+         txx=gvxx(ig)
+         tyy=gvyy(ig)
+         tzz=gvzz(ig)
+         gvxx(ig)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz)
+         gvyy(ig)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz)
+         gvzz(ig)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz)
+         
+      enddo
+
+c     new cell vectors
+
+      call cell_update(tstep,cell,eta)
+      
+c     new system volume
+      
+      call dcell(cell,celp)
+      volm=celp(10)
+      
+c     add new kinetic contribution to stress tensor
+
+      call kinstressf(ntfree,idnode,mxnode,strkin)        
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)
+      enddo
+      
+c     propagate barostat momentum to full step
+
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)-
+     x    press*volm*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+      return
+      end subroutine nstqscl_p2
+
+      subroutine cell_update(tstep,cell,eta)
+
+c***********************************************************************
+c     
+c     dlpoly utility to update the cell vectors in the hoover 
+c     nst algorithms (velocity verlet version)
+c
+c     copyright daresbury laboratory
+c     author      w.smith  july 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer i
+      real(8) tstep,cell(9),eta(9),ctmp(9),uni(9)
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+      do i=1,9
+        ctmp(i)=uni(i)+tstep*eta(i)
+      enddo
+
+      call mat_mul(ctmp,cell,cell)
+      
+      return
+      end subroutine cell_update
+
+      subroutine cell_propagate(tstep,cell,eta)
+
+c***********************************************************************
+c     
+c     dlpoly utility to update the cell vectors in the hoover 
+c     nst algorithms (leapfrog version)
+c
+c     copyright daresbury laboratory
+c     author      w.smith  july 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer i
+      real(8) tstep
+      real(8) cell(9),eta(9),aaa(9),bbb(9),uni(9)
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+
+      do i=1,9
+        aaa(i)=tstep*eta(i)
+      enddo
+      
+      call mat_mul(aaa,aaa,bbb)
+      
+      do i=1,9
+        bbb(i)=uni(i)+aaa(i)+0.5d0*bbb(i)
+      enddo
+      
+      call mat_mul(bbb,cell,cell)
+
+      return
+      end subroutine cell_propagate
+
+      subroutine nstqmtk_p
+     x  (idnode,mxnode,ntfree,ngrp,mode,tstep,pmass,chit,press,volm,
+     x  engfke,engtrn,engrot,temp,sigma)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to integrate and apply NPT anisotropic barostat
+c     of martyna tobias and klein to atomic, group and quaternion 
+c     system with atomic sites and rigid bodies
+c     
+c     copyright daresbury laboratory
+c     author - w.smith may 2005
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,ntfree,ngrp,i,igrp1,igrp2,ifre1,ifre2,ig,j
+      integer mode
+      real(8) tstep,pmass,press,volm,txx,tyy,tzz,chit,temp,sigma,degfre
+      real(8) engtke,engfke,engtrn,engrot,trace
+      real(8) strkin(9),strgrp(9),uni(9),ctmp(9)
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+      degfre=2.d0*sigma/(temp*boltz)
+
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+
+c     calculate kinetic contribution to stress tensor
+
+      call kinstressf(ntfree,idnode,mxnode,strkin)        
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+c     propagate barostat momentum to 1/2 step
+
+      call invert(cell,ctmp,volm)
+      volm=abs(volm)
+      engtke=2.d0*(engfke+engtrn+engrot)/degfre
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)+strkin(i)+strgrp(i)+
+     x    (engtke-press*volm)*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+c     barostat the free atom velocities
+      
+      trace=(eta(1)+eta(5)+eta(9))/degfre
+
+      do j=ifre1,ifre2
+        
+        i=lstfre(j)
+        txx=vxx(i)
+        tyy=vyy(i)
+        tzz=vzz(i)
+        vxx(i)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz+trace)
+        vyy(i)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz+trace)
+        vzz(i)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz+trace)
+
+      enddo
+
+c     barostat the group translational velocities
+
+      do ig=igrp1,igrp2
+         
+         txx=gvxx(ig)
+         tyy=gvyy(ig)
+         tzz=gvzz(ig)
+         gvxx(ig)=txx-tstep*(eta(1)*txx+eta(4)*tyy+eta(7)*tzz+trace)
+         gvyy(ig)=tyy-tstep*(eta(2)*txx+eta(5)*tyy+eta(8)*tzz+trace)
+         gvzz(ig)=tzz-tstep*(eta(3)*txx+eta(6)*tyy+eta(9)*tzz+trace)
+         
+      enddo
+
+c     update volume to full time step
+
+      volm=volm*exp(tstep*(eta(1)+eta(5)+eta(9)))
+
+c     calculate kinetic contribution to stress tensor
+
+      call kinstressf(ntfree,idnode,mxnode,strkin)        
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+c     calculate new kinetic energy
+
+      engfke=getkinf(ntfree,idnode,mxnode)
+      call getking(ngrp,idnode,mxnode,engtrn,engrot)
+      engtke=2.d0*(engfke+engtrn+engrot)/degfre
+
+c     propagate barostat momentum to full step
+
+      do i=1,9
+        eta(i)=eta(i)+0.5d0*tstep*((stress(i)+strkin(i)+strgrp(i)+
+     x    (engtke-press*volm)*uni(i))/pmass-chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+      return
+      end subroutine nstqmtk_p
+
+      subroutine kinstr(idnode,mxnode,natms,tstep)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to calculate the kinetic energy contribution to
+c     the stress tensor
+c     
+c     assumes velocities are half-timestep behind forces
+c     
+c     replicated data version / block data
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester may 1994
+c     amended t.forester dec 1994 : block data
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms,i,iatm1,iatm2
+      real(8) tstep,vxt,vyt,vzt
+      
+c     block indices
+
+      iatm1 = (idnode*natms)/mxnode + 1
+      iatm2 = ((idnode+1)*natms)/mxnode
+
+      do i = iatm1,iatm2
+
+        if(rmass(i).gt.0.d0) then
+
+          vxt = vxx(i)+fxx(i)*rmass(i)*tstep*0.5d0
+          vyt = vyy(i)+fyy(i)*rmass(i)*tstep*0.5d0
+          vzt = vzz(i)+fzz(i)*rmass(i)*tstep*0.5d0
+
+          stress(1)=stress(1)-weight(i)*vxt*vxt
+          stress(2)=stress(2)-weight(i)*vxt*vyt
+          stress(3)=stress(3)-weight(i)*vxt*vzt
+          stress(4)=stress(4)-weight(i)*vyt*vxt
+          stress(5)=stress(5)-weight(i)*vyt*vyt
+          stress(6)=stress(6)-weight(i)*vyt*vzt
+          stress(7)=stress(7)-weight(i)*vzt*vxt
+          stress(8)=stress(8)-weight(i)*vzt*vyt
+          stress(9)=stress(9)-weight(i)*vzt*vzt
+
+        endif
+
+      enddo
+      
+      return
+      end subroutine kinstr
+      
+      function getkin(natms,idnode,mxnode)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate system kinetic energy
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w. smith january 2005 : f90 conversion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer natms,idnode,mxnode,i,iatm0,iatm1
+      real(8) getkin,engke
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+      engke=0.d0
+      
+      do i=iatm0,iatm1
+        engke=engke+weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+      enddo
+
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engke
+        call gdsum(buffer(1),1,buffer(2))
+        engke=buffer(1)
+        
+      endif
+
+      getkin=0.5d0*engke
+
+      return
+      end function getkin
+
+      function getkinf(ntfree,idnode,mxnode)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate kinetic energy of atoms not in
+c     rigid bodies
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w. smith january 2005 : f90 conversion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer ntfree,idnode,mxnode,i,j,ifre0,ifre1
+      real(8) getkinf,engke
+      
+      ifre0=(idnode*ntfree)/mxnode+1
+      ifre1=((idnode+1)*ntfree)/mxnode
+
+      engke=0.d0
+      
+      do j=ifre0,ifre1
+        
+        i=lstfre(j)
+        engke=engke+weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+
+      enddo
+
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engke
+        call gdsum(buffer(1),1,buffer(2))
+        engke=buffer(1)
+        
+      endif
+
+      getkinf=0.5d0*engke
+
+      return
+      end function getkinf
+
+      subroutine getking(ngrp,idnode,mxnode,engtrn,engrot)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate system kinetic energy
+c     for rigid groups only
+c
+c     copyright daresbury laboratory
+c     author - m.leslie february 2003
+c     amended - w.smith january 2005 : f90 conversion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer ngrp,idnode,mxnode,igrp1,igrp2,ig,id
+      real(8) engtrn,engrot
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+      engtrn=0.d0
+      engrot=0.d0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     group kinetic energy
+
+        engtrn=engtrn+
+     x    gmass(id)*(gvxx(ig)**2+gvyy(ig)**2+gvzz(ig)**2)
+
+c     rotational kinetic energy
+        
+        engrot=engrot+(rotinx(id,1)*omx(ig)**2
+     x    +rotiny(id,1)*omy(ig)**2
+     x    +rotinz(id,1)*omz(ig)**2)
+
+      enddo
+
+      if(mxnode.gt.1) then
+        
+        buffer(5)=engtrn
+        buffer(6)=engrot
+        call  gdsum(buffer(5),2,buffer(1))
+        engtrn=buffer(5)
+        engrot=buffer(6)
+        
+      endif
+
+      engtrn=0.5d0*engtrn
+      engrot=0.5d0*engrot
+
+      return
+      end subroutine getking
+
+      function getkint(ngrp,idnode,mxnode)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate translational kinetic energy
+c     for rigid groups only
+c
+c     copyright daresbury laboratory
+c     author  - w.smith october 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer ngrp,idnode,mxnode,igrp1,igrp2,ig,id
+      real(8) engtrn,getkint
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+      engtrn=0.d0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     group kinetic energy
+
+        engtrn=engtrn+
+     x    gmass(id)*(gvxx(ig)**2+gvyy(ig)**2+gvzz(ig)**2)
+
+      enddo
+
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engtrn
+        call gdsum(buffer(1),1,buffer(2))
+        engtrn=buffer(1)
+        
+      endif
+      
+      getkint=0.5d0*engtrn
+
+      return
+      end function getkint
+
+      function getkinr(ngrp,idnode,mxnode)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate rotational kinetic energy
+c     for rigid groups only
+c
+c     copyright daresbury laboratory
+c     author  - w.smith october 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer ngrp,idnode,mxnode,igrp1,igrp2,ig,id
+      real(8) engrot,getkinr
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+      engrot=0.d0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     rotational kinetic energy
+        
+        engrot=engrot+(rotinx(id,1)*omx(ig)**2
+     x    +rotiny(id,1)*omy(ig)**2
+     x    +rotinz(id,1)*omz(ig)**2)
+
+      enddo
+
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engrot
+        call gdsum(buffer(1),1,buffer(2))
+        engrot=buffer(1)
+        
+      endif
+      
+      getkinr=0.5d0*engrot
+      
+      return
+      end function getkinr
+
+      subroutine kinstress(natms,idnode,mxnode,stresh)
+
+c*********************************************************************
+c     
+c     dl_poly routine to calculate kinetic contribution to the 
+c     stress tensor
+c     
+c     copyright daresbury laboratory
+c     author - w.smith november 2002
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer natms,idnode,mxnode,iatm0,iatm1,i
+      real(8) stresh(9)
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     initialise stress tensor
+
+      do i=1,9
+        stresh(i)=0.d0
+      enddo
+
+c     kinetic contribution to stress tensor
+        
+      do i=iatm0,iatm1
+        
+        stresh(1)=stresh(1)+weight(i)*vxx(i)*vxx(i)
+        stresh(2)=stresh(2)+weight(i)*vxx(i)*vyy(i)
+        stresh(3)=stresh(3)+weight(i)*vxx(i)*vzz(i)
+        stresh(5)=stresh(5)+weight(i)*vyy(i)*vyy(i)
+        stresh(6)=stresh(6)+weight(i)*vyy(i)*vzz(i)
+        stresh(9)=stresh(9)+weight(i)*vzz(i)*vzz(i)
+        
+      enddo
+
+      stresh(4)=stresh(2)
+      stresh(7)=stresh(3)
+      stresh(8)=stresh(6)
+
+c     global sum of stress tensor
+      
+      if(mxnode.gt.1) call gdsum(stresh,9,buffer)
+        
+      return
+      end subroutine kinstress
+
+      subroutine kinstressg(ngrp,idnode,mxnode,stresh)
+
+c*********************************************************************
+c     
+c     dl_poly routine to calculate kinetic contribution to the 
+c     stress tensor
+c     
+c     copyright daresbury laboratory
+c     author - m.leslie february 2003
+c
+c*********************************************************************
+      
+      integer ngrp,idnode,mxnode,igrp1,igrp2,ig,id
+      real(8) stresh(9)
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     initialise stress tensor
+
+      do i=1,9
+        stresh(i)=0.d0
+      enddo
+
+c     kinetic contribution to stress tensor
+      
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+        stresh(1)=stresh(1)+gmass(id)*gvxx(ig)*gvxx(ig)
+        stresh(2)=stresh(2)+gmass(id)*gvxx(ig)*gvyy(ig)
+        stresh(3)=stresh(3)+gmass(id)*gvxx(ig)*gvzz(ig)
+        stresh(5)=stresh(5)+gmass(id)*gvyy(ig)*gvyy(ig)
+        stresh(6)=stresh(6)+gmass(id)*gvyy(ig)*gvzz(ig)
+        stresh(9)=stresh(9)+gmass(id)*gvzz(ig)*gvzz(ig)
+        
+      enddo
+      
+      stresh(4)=stresh(2)
+      stresh(7)=stresh(3)
+      stresh(8)=stresh(6)
+
+c     global sum of stress tensor
+      
+      if(mxnode.gt.1) call gdsum(stresh,9,buffer)
+        
+      return
+      end subroutine kinstressg
+
+      subroutine getkins(natms,idnode,mxnode,getkin)
+
+c*********************************************************************
+c
+c     dl_poly routine to calculate system kinetic energy
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005: f90 conversion
+c
+c*********************************************************************
+     
+      implicit none
+
+      integer natms,idnode,mxnode,iatm0,iatm1,i
+      real(8) getkin,engke
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+      engke=0.d0
+      
+      do i=iatm0,iatm1
+        engke=engke+weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+      enddo
+
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engke
+        call gdsum(buffer(1),1,buffer(2))
+        engke=buffer(1)
+        
+      endif
+
+      getkin=0.5d0*engke
+
+      return
+      end subroutine getkins
+
+      subroutine kinstressf(ntfree,idnode,mxnode,stresh)
+
+c*********************************************************************
+c     
+c     dl_poly routine to calculate kinetic contribution to the 
+c     stress tensor for unconstrained atoms
+c     
+c     copyright daresbury laboratory
+c     author - m.leslie february 2003
+c     amended - w.smith january 2005: f90 conversion
+c
+c*********************************************************************
+      
+      implicit none
+
+      integer ntfree,idnode,mxnode,i,ifre1,ifre2,ifre
+      real(8) stresh(9)
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+
+c     initialise stress tensor
+
+      do i=1,9
+        stresh(i)=0.d0
+      enddo
+
+c     kinetic contribution to stress tensor
+        
+      do ifre=ifre1,ifre2
+        
+        i=lstfre(ifre)
+        stresh(1)=stresh(1)+weight(i)*vxx(i)*vxx(i)
+        stresh(2)=stresh(2)+weight(i)*vxx(i)*vyy(i)
+        stresh(3)=stresh(3)+weight(i)*vxx(i)*vzz(i)
+        stresh(5)=stresh(5)+weight(i)*vyy(i)*vyy(i)
+        stresh(6)=stresh(6)+weight(i)*vyy(i)*vzz(i)
+        stresh(9)=stresh(9)+weight(i)*vzz(i)*vzz(i)
+        
+      enddo
+
+      stresh(4)=stresh(2)
+      stresh(7)=stresh(3)
+      stresh(8)=stresh(6)
+
+c     global sum of stress tensor
+      
+      if(mxnode.gt.1) call gdsum(stresh,9,buffer)
+        
+      return
+      end subroutine kinstressf
+      
+      subroutine nvtscale_shl
+     x  (idnode,mxnode,ntshl,shlke,sigma_shl,tstep,qmass_shl,
+     x   taut,chit_shl,conint)
+
+c*********************************************************************
+c
+c     dl_poly routine to integrate and apply NVT thermostat
+c     thermostats the core-shell relative motion
+c
+c     copyright daresbury laboratory
+c     author - w.smith october 2002
+c     amended - w.smith january 2005 : f90 conversion
+c     adapted - d. quigley      2006 : core-shell motion
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntshl,i,ishl1,ishl2,j,k,m
+      real(8) shlke,sigma_shl,tstep,qmass_shl,chit_shl,conint
+      real(8) dvx,dvy,dvz,tmx,tmy,tmz,rmu,scale,taut
+
+      ishl1=(idnode*ntshl)/mxnode+1
+      ishl2=((idnode+1)*ntshl)/mxnode
+
+c     calculate kinetic energy
+      
+      call corshl(idnode,mxnode,ntshl,shlke)
+
+c     update chit to 1/2 step
+      
+      chit_shl=chit_shl+tstep*(shlke-sigma_shl)/qmass_shl
+
+c     thermostat the velocities
+      
+      scale=exp(-tstep*chit_shl)
+
+      m=0
+      do k=ishl1,ishl2
+        
+        m=m+1
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+
+        rmu=(weight(i)*weight(j))/(weight(i)+weight(j))
+        
+        if(rmu.gt.0.d0)then
+          
+          dvx=vxx(j)-vxx(i)
+          dvy=vyy(j)-vyy(i)
+          dvz=vzz(j)-vzz(i)
+          
+          tmx=weight(i)*vxx(i)+weight(j)*vxx(j)
+          tmy=weight(i)*vyy(i)+weight(j)*vyy(j)
+          tmz=weight(i)*vzz(i)+weight(j)*vzz(j)
+          
+          vxx(i)=tmx/(weight(i)+weight(j))-scale*rmu*dvx/weight(i)
+          vxx(j)=tmx/(weight(i)+weight(j))+scale*rmu*dvx/weight(j)
+          vyy(i)=tmy/(weight(i)+weight(j))-scale*rmu*dvy/weight(i)
+          vyy(j)=tmy/(weight(i)+weight(j))+scale*rmu*dvy/weight(j)
+          vzz(i)=tmz/(weight(i)+weight(j))-scale*rmu*dvz/weight(i)
+          vzz(j)=tmz/(weight(i)+weight(j))+scale*rmu*dvz/weight(j)
+          
+        endif
+
+      enddo
+
+      shlke=shlke*scale**2
+
+c     update chi to full step
+      
+      conint=conint+tstep*chit_shl*qmass_shl/taut**2
+
+c     update chit to full step
+      
+      chit_shl=chit_shl+tstep*(shlke-sigma_shl)/qmass_shl
+
+      if(mxnode.gt.1) call shlmerge(idnode,mxnode,ntshl)
+      
+      return
+      end subroutine nvtscale_shl
+
+      end module ensemble_tools_module
+
diff -urN dl_class_1.9.orig/srcmod/error_module.f dl_class_1.9/srcmod/error_module.f
--- dl_class_1.9.orig/srcmod/error_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/error_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1513 @@
+      module error_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining bond potentials
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use setup_module
+      
+      contains
+      
+      subroutine error(idnode,iode)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for printing error messages and bringing
+c     about a controlled termination of the program
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     
+c     warning - this routine terminates the job. user must ensure
+c     that all nodes are informed of error condition before this
+c     subroutine is called. e.g. using subroutine gstate().
+c     
+c***********************************************************************
+      
+      use setup_module
+
+      implicit none
+
+      logical kill
+      integer idnode,iode,kode
+
+      kill=(iode.ge.0)
+      kode = abs(iode)
+      
+      if(idnode.eq.0)then
+        
+        if(kill)then
+          write(nrite,'(/,/,1x,a,i5)') 
+     x      'DL_POLY terminated due to error ', kode
+
+        else
+
+          write(nrite,'(/,/,1x,a,i5)') 
+     x      'DL_POLY will terminate due to error ', kode
+          
+        endif
+
+        if(kode.lt.50)then
+          
+          if(kode.eq. 0)then
+            
+c     dummy entry
+            
+          elseif(kode.eq. 3)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown directive found in CONTROL file'        
+          elseif(kode.eq. 4)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown directive found in FIELD file'
+          elseif(kode.eq. 5)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown energy unit requested'
+          elseif(kode.eq. 6)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - energy unit not specified'
+          elseif(kode.eq. 7)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - energy unit respecified'
+          elseif(kode.eq. 8)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - time step not specified'
+          elseif(kode.eq.10)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many molecule types specified'
+          elseif(kode.eq.11)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - duplicate molecule directive in FIELD file'
+          elseif(kode.eq.12)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown molecule directive in FIELD file'
+          elseif(kode.eq.13)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - molecular species not yet specified'
+          elseif(kode.eq.14)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many unique atom types specified'
+          elseif(kode.eq.15)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - duplicate pair potential specified'
+          elseif(kode.eq.16)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - strange exit from FIELD file processing'
+          elseif(kode.eq.17)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - strange exit from CONTROL file processing'
+          elseif(kode.eq.18)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - duplicate 3-body potential specified'
+          elseif(kode.eq.19)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - duplicate 4-body potential specified'
+          elseif(kode.eq.20)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many molecule sites specified'
+          elseif(kode.eq.21)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - duplicate tersoff potential specified'
+          elseif(kode.eq.22)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unsuitable radial increment in TABLE file'
+          elseif(kode.eq.23)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incompatible FIELD and TABLE file potentials'
+          elseif(kode.eq.24)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - end of file encountered in TABLE file'
+          elseif(kode.eq.25)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - wrong atom type found in CONFIG file'
+          elseif(kode.eq.26)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cutoff smaller than EAM potential range'
+          elseif(kode.eq.27)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incompatible FIELD and TABEAM file potentials'
+          elseif(kode.eq.28)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - transfer buffer too small in mettab'
+          elseif(kode.eq.29)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - end of file encountered in TABEAM file'
+          elseif(kode.eq.30)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many chemical bonds specified'
+          elseif(kode.eq.31)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many chemical bonds in system'
+          elseif(kode.eq.32)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - integer array memory allocation failure'
+          elseif(kode.eq.33)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - real array memory allocation failure'
+          elseif(kode.eq.34)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - character array memory allocation failure'
+          elseif(kode.eq.35)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - logical array  memory allocation failure'
+          elseif(kode.eq.36)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed fmet array allocation in mettab'
+          elseif(kode.eq.40)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many bond constraints specified'
+          elseif(kode.eq.41)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many bond constraints in system'
+          elseif(kode.eq.42)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - transfer buffer too small in merge1'
+          elseif(kode.eq.45)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many atoms in CONFIG file'
+          elseif(kode.eq.46)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - ewlbuf array too small in ewald1'
+          elseif(kode.eq.47)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - transfer buffer too small in merge'
+          elseif(kode.eq.48)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - transfer buffer too small in fortab'
+          elseif(kode.eq.49)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - frozen core-shell unit specified'
+          endif
+          
+        elseif(kode.lt.100)then
+          
+          if(kode.eq.50)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many bond angles specified'
+          elseif(kode.eq.51)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many bond angles in system'
+          elseif(kode.eq.52)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - end of FIELD file encountered'
+          elseif(kode.eq.53)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - end of CONTROL file encountered'
+          elseif(kode.eq.54)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - problem reading CONFIG file'
+          elseif(kode.eq.55)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - end of CONFIG file encountered'
+          elseif(kode.eq.57)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many core-shell units specified'
+          elseif(kode.eq.59)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many core-shell units in system'
+          elseif(kode.eq.60)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many dihedral angles specified'
+          elseif(kode.eq.61)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many dihedral angles in system'
+          elseif(kode.eq.62)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many tethered atoms specified'
+          elseif(kode.eq.63)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many tethered atoms in system'
+          elseif(kode.eq.65)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many excluded pairs specified'
+          elseif(kode.eq.66)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect boundary condition for HK ewald'
+          elseif(kode.eq.67)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect boundary condition in thbfrc'
+          elseif(kode.eq.69)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many link cells required in thbfrc'
+          elseif(kode.eq.70)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - constraint bond quench failure'
+          elseif(kode.eq.71)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many metal potentials specified'
+          elseif(kode.eq.72)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - different metal potential types specified'
+          elseif(kode.eq.73)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many inversion potentials specified'
+          elseif(kode.eq.75)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many atoms in specified system'
+          elseif(kode.eq.77)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many inversion potentials in system'
+          elseif(kode.eq.79)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect boundary condition in fbpfrc'
+          elseif(kode.eq.80)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many pair potentials specified'
+          elseif(kode.eq.81)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unidentified atom in pair potential list'
+          elseif(kode.eq.82)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - calculated pair potential index too large'
+          elseif(kode.eq.83)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many three body potentials specified'
+          elseif(kode.eq.84)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unidentified atom in 3-body potential list'
+          elseif(kode.eq.85)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - required velocities not in CONFIG file'
+          elseif(kode.eq.86)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - calculated 3-body potential index too large'
+          elseif(kode.eq.87)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many link cells required in fbpfrc'
+          elseif(kode.eq.88)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many tersoff potentials specified'
+          elseif(kode.eq.89)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many four body potentials specified'
+          elseif(kode.eq.90)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - system total electric charge nonzero'
+          elseif(kode.eq.91)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unidentified atom in 4-body potential list'
+          elseif(kode.eq.92)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unidentified atom in tersoff potential list'
+          elseif(kode.eq.93)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cannot use shell model with rigid molecules'
+          elseif(kode.eq.95)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - potential cutoff exceeds half-cell width'
+          elseif(kode.eq.97)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cannot use shell model with neutral groups'
+          elseif(kode.eq.99)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cannot use shell model with constraints'
+          endif
+          
+        elseif(kode.lt.150)then
+          
+          if(kode.eq.100)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - forces working arrays too small'
+          elseif(kode.eq.101)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - calculated 4-body potential index too large'
+          elseif(kode.eq.102)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - parameter mxproc exceeded in shake arrays'
+          elseif(kode.eq.103)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - parameter mxlshp exceeded in shake arrays'
+          elseif(kode.eq.105)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - shake algorithm failed to converge'
+          elseif(kode.eq.106)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neighbour list array too small in parlink '
+     x        //'subroutine'
+          elseif(kode.eq.107)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neighbour list array too small in parlinkneu '
+     x        //'subroutine'
+          elseif(kode.eq.108)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neighbour list array too small in parneulst '
+     x        //'subroutine'
+          elseif(kode.eq.109)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neighbour list array too small in parlst_nsq '
+     x        //'subroutine'
+          elseif(kode.eq.110)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neighbour list array too small in parlst '
+     x        //'subroutine'
+          elseif(kode.eq.112)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - vertest array too small'
+          elseif(kode.eq.120)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - invalid determinant in matrix inversion'
+          elseif(kode.eq.130)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect octahedral boundary condition'
+          elseif(kode.eq.135)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect hexagonal prism boundary condition'
+          elseif(kode.eq.140)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect dodecahedral boundary condition'
+          elseif(kode.eq.141)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - duplicate metal potential specified'
+          elseif(kode.eq.142)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - interpolation outside range of metal '//
+     x        'potential attempted'
+          elseif(kode.eq.145)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - no van der waals potentials defined'
+          endif
+          
+        elseif(kode.lt.200)then
+          
+          if(kode.eq.150)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown van der waals potential selected'
+          elseif(kode.eq.151)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown metal potential selected'
+          elseif(kode.eq.153)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - metals not permitted with multiple timestep'
+          elseif(kode.eq.160)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unaccounted for atoms in exclude list '
+          elseif(kode.eq.170)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many variables for statistic array '
+          elseif(kode.eq.180)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - Ewald sum requested in non-periodic system'
+          elseif(kode.eq.185)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many reciprocal space vectors'
+          elseif(kode.eq.186)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - transfer buffer array too small in sysgen'
+          elseif(kode.eq.190)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - buffer array too small in splice'
+          endif
+          
+        elseif(kode.lt.250)then
+          
+          if(kode.eq.200)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - rdf buffer array too small in revive'
+          elseif(kode.eq.220)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many neutral groups in system'
+          elseif(kode.eq.225)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - multiple selection of optimisation options'
+          elseif(kode.eq.230)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neutral groups improperly arranged'
+          endif
+          
+        elseif(kode.lt.300)then
+          
+          if(kode.eq.250)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - Ewald sum requested with neutral groups'
+          elseif(kode.eq.260)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - parameter mxexcl exceeded in excludeneu routine'
+          endif
+          
+        elseif(kode.lt.350)then
+          
+          if(kode.eq.300)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect boundary condition in parlink'
+          elseif(kode.eq.301)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many rigid body types '
+          elseif(kode.eq.302)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many sites in rigid body '
+          elseif(kode.eq.303)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many rigid bodies specified'
+          elseif(kode.eq.304)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many rigid body sites in system '
+          elseif(kode.eq.305)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - box size too small for link cells'
+          elseif(kode.eq.306)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed to find principal axis system'
+          elseif(kode.eq.310)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - quaternion setup failed '
+          elseif(kode.eq.320)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - site in multiple rigid bodies'
+          elseif(kode.eq.321)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - quaternion integrator failed'
+          elseif(kode.eq.330)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxewld parameter incorrect'
+          elseif(kode.eq.331)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxhke parameter incorrect'
+          elseif(kode.eq.332)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxhko parameter too small'
+          elseif(kode.eq.340)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - invalid integration option requested'
+          endif
+          
+        elseif(kode.lt.400)then
+          
+          if(kode.eq.350)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too few degrees of freedom'
+          elseif(kode.eq.360)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - frozen atom found in rigid body'
+          elseif(kode.eq.380)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - simulation temperature not specified'
+          elseif(kode.eq.381)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - simulation timestep not specified'
+          elseif(kode.eq.382)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - simulation cutoff not specified'
+          elseif(kode.eq.383)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - simulation forces option not specified'
+          elseif(kode.eq.384)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - verlet strip width not specified'
+          elseif(kode.eq.385)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - primary cutoff not specified'
+          elseif(kode.eq.386)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - primary cutoff larger than rcut'
+          elseif(kode.eq.387)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - system pressure not specified'
+          elseif(kode.eq.388)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - npt incompatible with multiple timestep'
+          elseif(kode.eq.389)then
+            write(nrite,'(/,/,1x,a)')
+     x        'number of pimd beads not specified in field file'
+          elseif(kode.eq.390)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - npt ensemble requested in non-periodic system'
+          elseif(kode.eq.391)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect number of pimd beads in config file'
+          elseif(kode.eq.392)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many link cells requested'
+          elseif(kode.eq.394)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - minimum image arrays exceeded'
+          elseif(kode.eq.396)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - interpolation array exceeded'
+          elseif(kode.eq.398)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cutoff too small for rprim and delr'
+          endif
+          
+        elseif(kode.lt.450)then
+          
+          if(kode.eq.400)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - rvdw greater than cutoff'
+          elseif(kode.eq.402)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - van der waals cutoff unset'
+          elseif(kode.eq.410)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cell not consistent with image convention'
+          elseif(kode.eq.412)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf parameter too small for shake routine'
+          elseif(kode.eq.414)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - conflicting ensemble options in CONTROL file'
+          elseif(kode.eq.416)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - conflicting force options in CONTROL file'
+          elseif(kode.eq.418)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - bond vector work arrays too small in bndfrc'
+          elseif(kode.eq.419)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - bond vector work arrays too small in angfrc'
+          elseif(kode.eq.420)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - bond vector work arrays too small in tethfrc'
+          elseif(kode.eq.421)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - bond vector work arrays too small in dihfrc'
+          elseif(kode.eq.422)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - all-pairs must use multiple timestep'
+          elseif(kode.eq.423)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - bond vector work arrays too small in shlfrc'
+          elseif(kode.eq.424)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - electrostatics incorrect for all-pairs'
+          elseif(kode.eq.425)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - transfer buffer array too small in shlmerge'
+          elseif(kode.eq.426)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - neutral groups not permitted with all-pairs'
+          elseif(kode.eq.427)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - bond vector work arrays too small in invfrc'
+          elseif(kode.eq.430)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - integration routine not available'
+          elseif(kode.eq.432)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - intlist failed to assign constraints '
+          elseif(kode.eq.433)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - specify rcut before the Ewald sum precision'
+          elseif(kode.eq.434)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - illegal entry into STRESS related routine'
+          elseif(kode.eq.435)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - specify rcut before the coulomb precision'
+          elseif(kode.eq.436)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unrecognised ensemble '
+          elseif(kode.eq.438)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - PMF constraints failed to converge'
+          elseif(kode.eq.440)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined angular potential'
+          elseif(kode.eq.442)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined three body potential'
+          elseif(kode.eq.443)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined four body potential'
+          elseif(kode.eq.444)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined bond potential'
+          elseif(kode.eq.445)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined many body potential'
+          elseif(kode.eq.446)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined electrostatic key in dihfrc'
+          elseif(kode.eq.447)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - 1-4 separation exceeds cutoff range'
+          elseif(kode.eq.448)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined dihedral potential'
+          elseif(kode.eq.449)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined inversion potential'
+          endif
+          
+        elseif(kode.lt.500)then
+          
+          if(kode.eq.450)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined tethering potential'
+          elseif(kode.eq.451)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - three body potential cutoff undefined'
+          elseif(kode.eq.452)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined pair potential'
+          elseif(kode.eq.453)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - four body potential cutoff undefined'
+          elseif(kode.eq.454)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined external field'
+          elseif(kode.eq.456)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - core and shell in same rigid unit'
+          elseif(kode.eq.458)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many PMF constraints - param. mspmf too '
+     x        //'small'
+          elseif(kode.eq.460)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many PMF sites - parameter mxspmf too small'
+          elseif(kode.eq.461)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined metal potential'
+          elseif(kode.eq.462)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - PMF UNIT  record expected'
+          elseif(kode.eq.463)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unidentified atom in metal potential list'
+          elseif(kode.eq.464)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - thermostat time constant must be > 0.d0'
+          elseif(kode.eq.465)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - calculated pair potential index too large'
+          elseif(kode.eq.466)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - barostat time constant must be > 0.d0'
+          elseif(kode.eq.468)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - r0 too large for snm potential with current '
+     x        //'cutoff'
+          elseif(kode.eq.470)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - n<m in definition of n-m potential'
+          elseif(kode.eq.474)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf too small in parlst subroutine'
+          elseif(kode.eq.475)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf too small in parlst_nsq subroutine'
+          elseif(kode.eq.476)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf too small in parneulst subroutine'
+          elseif(kode.eq.477)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf too small in prneulst subroutine'
+          elseif(kode.eq.478)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf too small in forcesneu subroutine'
+          elseif(kode.eq.479)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - mxxdf too small in multipleneu subroutine'
+          elseif(kode.eq.484)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - only one potential of mean force permitted'
+          elseif(kode.eq.486)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - HK real space screening function cutoff '
+     x        //'violation'
+          elseif(kode.eq.487)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - HK recip space screening function cutoff '
+     x        //'violation'
+          elseif(kode.eq.488)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - HK lattice control parameter set too large'
+          elseif(kode.eq.490)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - PMF parameter mxpmf too small in passpmf'
+          elseif(kode.eq.492)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - parameter mxcons < number of PMF constraints'
+          elseif(kode.eq.494)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error in csend: pvmfinitsend'
+          elseif(kode.eq.496)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error in csend: pvmfpack'
+          elseif(kode.eq.498)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error in csend: pvmfsend'
+          endif
+          
+        elseif(kode.lt.550)then
+          
+          if(kode.eq.500)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error in crecv: pvmfrecv'
+          elseif(kode.eq.502)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error in crecv: pvmfunpack'
+          elseif(kode.eq.504)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cutoff too large for TABLE file'
+          elseif(kode.eq.506)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - work arrays too small for quaternion integration'
+          elseif(kode.eq.508)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - rigid bodies not permitted with RESPA algorithm'
+          elseif(kode.eq.510)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - structure optimiser not permitted with RESPA'
+          elseif(kode.eq.513)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - SPME not available for given boundary conditions'
+          elseif(kode.eq.514)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - SPME routines have not been compiled in'
+          elseif(kode.eq.516)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - repeat of impact option specified'
+          endif
+          
+        elseif(kode.lt.650)then
+          
+          if(kode.eq.601)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - Ewald SPME incompatible with solvation'
+          elseif(kode.eq.602)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - Ewald HK incompatible with solvation'
+          endif
+          
+        elseif(kode.lt.1050)then
+          
+          if(kode.eq.1000)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of configuration arrays'
+          elseif(kode.eq.1010)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of angle arrays'
+          elseif(kode.eq.1011)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dihedral arrays'
+          elseif(kode.eq.1012)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of exclude arrays'
+          elseif(kode.eq.1013)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of rigid body arrays'
+          elseif(kode.eq.1014)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of vdw arrays'
+          elseif(kode.eq.1015)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of lr correction arrays'
+          elseif(kode.eq.1020)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of angle work arrays'
+          elseif(kode.eq.1030)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of bond arrays'
+          elseif(kode.eq.1040)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of bond work arrays'
+          endif
+          
+        elseif(kode.lt.1100)then
+          
+          if(kode.eq.1050)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dihedral arrays'
+          elseif(kode.eq.1060)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dihedral work arrays'
+          elseif(kode.eq.1070)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of constraint arrays'
+          elseif(kode.eq.1090)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of site arrays'
+          endif
+          
+        elseif(kode.lt.1050)then
+          
+          if(kode.eq.1100)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of core_shell arrays'
+          elseif(kode.eq.1115)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of hyperdynamics work arrays'
+          elseif(kode.eq.1120)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of inversion arrays'
+          elseif(kode.eq.1130)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of inversion work arrays' 
+          elseif(kode.eq.1140)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of four-body arrays'
+          endif
+          
+        elseif(kode.lt.1200)then
+          
+          if(kode.eq.1150)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of four-body work arrays'
+          elseif(kode.eq.1170)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of three-body arrays'
+          elseif(kode.eq.1180)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of three-body work arrays'
+          elseif(kode.eq.1200)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of external field arrays'
+          endif
+          
+        elseif(kode.lt.1250)then
+          
+          if(kode.eq.1210)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of pmf arrays'
+          elseif(kode.eq.1220)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of pmf_lf or pmf_vv '
+     x        //'work arrays'
+          elseif(kode.eq.1230)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of pmf_shake work arrays'
+          elseif(kode.eq.1240)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of ewald arrays'
+          endif
+          
+        elseif(kode.lt.1300)then
+          
+          if(kode.eq.1250)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of excluded atom arrays'
+          elseif(kode.eq.1260)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of tethering arrays'
+          elseif(kode.eq.1270)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of tethering work arrays'
+          elseif(kode.eq.1280)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of metal arrays'
+          elseif(kode.eq.1290)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvt_h0.f'
+          endif
+          
+        elseif(kode.lt.1350)then
+          
+          if(kode.eq.1300)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dens0 array in npt_b0.f'
+          elseif(kode.eq.1310)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in npt_b0.f'
+          elseif(kode.eq.1320)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dens0 array in npt_h0.f'
+          elseif(kode.eq.1330)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in npt_h0.f'
+          elseif(kode.eq.1340)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dens0 array in nst_b0.f'
+          endif
+          
+        elseif(kode.lt.1400)then
+          
+          if(kode.eq.1350)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nst_b0.f'
+          elseif(kode.eq.1360)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of dens0 array in nst_h0.f'
+          elseif(kode.eq.1370)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nst_h0.f'
+          elseif(kode.eq.1380)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nve_1.f'
+          elseif(kode.eq.1390)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvt_e1.f'
+          endif
+          
+        elseif(kode.lt.1450)then
+          
+          if(kode.eq.1400)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvt_b1.f'
+          elseif(kode.eq.1410)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvt_h1.f'
+          elseif(kode.eq.1420)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in npt_b1.f'
+          elseif(kode.eq.1430)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in npt_b1.f'
+          elseif(kode.eq.1440)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in npt_h1.f'
+          endif
+          
+        elseif(kode.lt.1500)then
+          
+          if(kode.eq.1450)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in npt_h1.f'
+          elseif(kode.eq.1460)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nst_b1.f'
+          elseif(kode.eq.1470)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nst_b1.f'
+          elseif(kode.eq.1480)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nst_h1.f'
+          elseif(kode.eq.1490)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nst_h1.f'
+          endif
+          
+        elseif(kode.lt.1550)then
+          
+          if(kode.eq.1500)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nveq_1.f'
+          elseif(kode.eq.1510)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvtq_b1.f'
+          elseif(kode.eq.1520)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvtq_h1.f'
+          elseif(kode.eq.1530)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nptq_b1.f'
+          elseif(kode.eq.1540)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nptq_b1.f'
+          endif
+          
+        elseif(kode.lt.1600)then
+          
+          if(kode.eq.1550)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nptq_h1.f'
+          elseif(kode.eq.1560)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nptq_h1.f'
+          elseif(kode.eq.1570)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nstq_b1.f'
+          elseif(kode.eq.1580)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nstq_b1.f'
+          elseif(kode.eq.1590)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nstq_h1.f'
+          endif
+          
+        elseif(kode.lt.1650)then
+          
+          if(kode.eq.1600)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nstq_h1.f'
+          elseif(kode.eq.1610)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in qshake.f'
+          elseif(kode.eq.1615)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in qrattle_q.f'
+          elseif(kode.eq.1620)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nveq_2.f'
+          elseif(kode.eq.1625)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in qrattle_v.f'
+          elseif(kode.eq.1630)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvtq_b2.f'
+          elseif(kode.eq.1640)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nvtq_h2.f'
+          endif
+          
+        elseif(kode.lt.1700)then
+          
+          if(kode.eq.1650)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nptq_b2.f'
+          elseif(kode.eq.1660)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nptq_b2.f'
+          elseif(kode.eq.1670)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nptq_h2.f'
+          elseif(kode.eq.1680)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nptq_h2.f'
+          elseif(kode.eq.1690)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nstq_b2.f'
+          endif
+          
+        elseif(kode.lt.1750)then
+          
+          if(kode.eq.1700)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nstq_b2.f'
+          elseif(kode.eq.1710)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of work arrays in nstq_h2.f'
+          elseif(kode.eq.1720)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of density array in nstq_h2.f'
+          elseif(kode.eq.1730)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of HK Ewald arrays'
+          elseif(kode.eq.1740)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of property arrays'
+          endif
+          
+        elseif(kode.lt.1800)then
+          
+          if(kode.eq.1750)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of spme arrays'
+          elseif(kode.eq.1760)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of ewald_spme.f work arrays'
+          elseif(kode.eq.1770)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of quench.f work arrays'
+          elseif(kode.eq.1780)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of quatqnch.f work arrays'
+          elseif(kode.eq.1790)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of quatbook.f work arrays'
+          endif
+          
+        elseif(kode.lt.1850)then
+          
+          if(kode.eq.1800)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of intlist.f work arrays'
+          elseif(kode.eq.1810)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of forces.f work arrays'
+          elseif(kode.eq.1820)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of forcesneu.f work arrays'
+          elseif(kode.eq.1830)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of neutlst.f work arrays'
+          elseif(kode.eq.1840)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of multiple.f work arrays'
+          endif
+          
+        elseif(kode.lt.1900)then
+          
+          if(kode.eq.1850)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of multipleneu.f work arrays'
+          elseif(kode.eq.1860)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of multiple_nsq.f work arrays'
+          elseif(kode.eq.1870)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of parlst_nsq.f work arrays'
+          elseif(kode.eq.1880)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of parlst.f work arrays'
+          elseif(kode.eq.1890)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of parlink.f work arrays'
+          endif
+          
+        elseif(kode.lt.1950)then
+          
+          if(kode.eq.1900)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of parlinkneu.f work arrays'
+          elseif(kode.eq.1910)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of parneulst.f work arrays'
+          elseif(kode.eq.1920)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of zero_kelvin.f work arrays'
+          elseif(kode.eq.1925)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of strucopt.f work arrays'
+          elseif(kode.eq.1930)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of vertest.f work arrays'
+          elseif(kode.eq.1940)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of pair arrays'
+          elseif(kode.eq.1945)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of tersoff arrays'
+          endif
+          
+        elseif(kode.lt.2000)then
+          
+          if(kode.eq.1950)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - shell relaxation cycle limit exceeded'
+          elseif(kode.eq.1951)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - no shell dynamics algorithm specified'
+          elseif(kode.eq.1953)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - tersoff radius of cutoff not defined'
+          elseif(kode.eq.1955)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of tersoff work arrays'
+          elseif(kode.eq.1960)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - conflicting shell option in FIELD file'
+          elseif(kode.eq.1970)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of shell_relax work arrays'
+          elseif(kode.eq.1972)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - unknown tersoff potential defined in FIELD file'
+          elseif(kode.eq.1974)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - incorrect period boundary in tersoff.f'
+          elseif(kode.eq.1976)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many link cells required in tersoff.f'
+          elseif(kode.eq.1977)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - tersoff.f requires 3x3x3 link cells minimum'
+          elseif(kode.eq.1978)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - undefined potential in tersoff.f'
+          elseif(kode.eq.1980)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvevv_1.f work arrays'
+          elseif(kode.eq.1990)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtvv_b1.f work arrays'
+          endif
+          
+        elseif(kode.lt.2050)then
+          
+          if(kode.eq.2000)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtvv_e1.f work arrays'
+          elseif(kode.eq.2010)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtvv_h1.f work arrays'
+          elseif(kode.eq.2020)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptvv_b1.f dens0 array'
+          elseif(kode.eq.2030)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptvv_b1.f work arrays'
+          elseif(kode.eq.2040)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptvv_h1.f dens0 array'
+          endif
+          
+        elseif(kode.lt.2100)then
+          
+          if(kode.eq.2050)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptvv_h1.f work arrays'
+          elseif(kode.eq.2060)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstvv_b1.f dens0 array'
+          elseif(kode.eq.2070)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstvv_b1.f work arrays'
+          elseif(kode.eq.2080)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstvv_h1.f dens0 array'
+          elseif(kode.eq.2090)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstvv_b1.f work arrays'
+          endif
+          
+        elseif(kode.lt.2150)then
+          
+          if(kode.eq.2100)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nveqvv_1.f work arrays'
+          elseif(kode.eq.2110)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nveqvv_2.f work arrays'
+          elseif(kode.eq.2120)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtqvv_b1.f work arrays'
+          elseif(kode.eq.2130)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtqvv_b2.f work arrays'
+          elseif(kode.eq.2140)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtqvv_h1.f work arrays'
+          endif
+          
+        elseif(kode.lt.2200)then
+          
+          if(kode.eq.2150)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nvtqvv_h2.f work arrays'
+          elseif(kode.eq.2160)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_b1.f dens0 array'
+          elseif(kode.eq.2170)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_b1.f work arrays'
+          elseif(kode.eq.2180)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_b2.f dens0 array'
+          elseif(kode.eq.2190)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_b2.f work arrays'
+          endif
+          
+        elseif(kode.lt.2250)then
+          
+          if(kode.eq.2200)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_h1.f dens0 array'
+          elseif(kode.eq.2210)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_h1.f work arrays'
+          elseif(kode.eq.2220)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_h2.f dens0 array'
+          elseif(kode.eq.2230)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nptqvv_h2.f work arrays'
+          elseif(kode.eq.2240)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_b1.f dens0 array'
+          endif
+          
+        elseif(kode.lt.2300)then
+          
+          if(kode.eq.2250)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_b1.f work arrays'
+          elseif(kode.eq.2260)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_b2.f dens0 array'
+          elseif(kode.eq.2270)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_b2.f work arrays'
+          elseif(kode.eq.2280)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_h1.f dens0 array'
+          elseif(kode.eq.2290)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_h1.f work arrays'
+          endif
+          
+        elseif(kode.lt.2350)then
+          
+          if(kode.eq.2300)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_h2.f dens0 array'
+          elseif(kode.eq.2310)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - failed allocation of nstqvv_h2.f work arrays'
+          elseif(kode.eq.2320)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - NEB convergence failure'
+          elseif(kode.eq.2330)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - too many basin files found - increase mxbsn'
+          elseif(kode.eq.2340)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - TAD diffs arrays exceeded '//
+     x        '- increase mxdiffs'
+          elseif(kode.eq.2341)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - HYPOLD file not TAD compatible'
+          endif
+          
+        elseif(kode.lt.2400)then
+          
+          if(kode.eq.2350)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - kinks found in NEB chain during optimisation'
+            
+          elseif(kode.eq.2355)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - cannot run both TAD and BPD together'
+            
+          elseif(kode.eq.2360)then
+            write(nrite,'(/,/,1x,a)')
+     x        'error - ensemble unavailable for metadynamics'
+            
+          endif
+          
+c     *****************important note********************
+c     error messages 2500 to 2550 reserved for metadynamics
+c     see subroutine mfrz_error in metafreeze_module
+
+        else
+          
+          write(nrite,'(/,/,1x,a)')
+     x      'error - undefined error code found'
+          
+        endif
+        
+      endif
+      
+      if(kill)then
+        
+c     close all i/o channels
+        
+        if(idnode.eq.0)then
+          close (nrite)
+          close (nhist)
+          close (nread)
+          close (nconf)
+          close (nstats)
+          close (nrest)
+          close (nfield)
+          close (ntable)
+          close (nevnt)
+        endif
+        
+        call gsync()
+        call exitcomms()
+        
+      endif
+      
+      return
+      end subroutine error
+      
+      subroutine warning(idnode,kode,a,b,c)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for printing warning messages and returning
+c     control back to the main program
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    april 1994
+c     
+c***********************************************************************
+      
+      use setup_module
+      
+      implicit none
+      
+      integer idnode,kode,ia,ib,ic
+      real(8) a,b,c
+      
+      if(idnode.eq.0)then
+        
+        if(kode.eq. 10)then
+          write(nrite,'(/,1x,a)')
+     x      ' *** warning - no pair forces in use ***'
+          
+        elseif(kode.eq. 20)then
+          
+          ia = nint(a)
+          ib = nint(b)
+          ic = nint(c)
+          write(nrite,'(/,1x,a50,i5,5x,a6,2i10)')
+     x      ' *** warning - : 1..4 scale factors reset for molecule ',
+     x      ia,'sites ',ib,ic
+          
+        elseif(kode.eq. 30)then
+          
+          write(nrite,'(/,1x,a)')
+     x      ' *** warning - atomistic cutoff with electrostatics ***'
+          
+        elseif(kode.eq. 40)then
+          
+          write(nrite,'(/,1x,a,/,1x,a,f12.6)')
+     x      ' *** warning - radial cutoff reset ***',
+     x      'new potential cutoff radius    ',a
+          
+        elseif(kode.eq. 50)then
+          
+          write(nrite,'(/,1x,a,/,1x,a,f12.6)')
+     x      ' *** warning - short range cutoff reset ***',
+     x      'new cutoff radius (rvdw)       ',a
+          
+        elseif(kode.eq. 60)then
+          
+          write(nrite,'(/,1x,a,f12.6,a)')
+     x      ' *** warning - total system charge:',a,' ***'
+          
+        elseif(kode.eq. 70)then
+          
+          write(nrite,'(/,1x,a,f12.6,a)')
+     x      ' *** warning - switching length reset to: ',a,' ***'
+          
+        elseif(kode.eq. 80)then
+          
+          write(nrite,'(/,1x,a,f12.6,a)')
+     x      ' *** warning -  requested thermostat unavailable ***'
+          
+        elseif(kode.eq. 90)then
+          
+          ia=nint(a)
+          ib=nint(b)
+          write(nrite,'(/,1x,a)')
+     x      ' *** warning -  cannot activate link cell option ***'
+          write(nrite,'(/,1x,a,i6,a,i6)')
+     x      ' *** you must change parameter mxcell from ',ib,' to ',ia
+          write(nrite,'(/,1x,a)')
+     x      ' *** using standard Brode-Ahlrichs list builder  ***'
+          
+        elseif(kode.eq.100)then
+          
+          write(nrite,'(/,1x,a,1p,e12.4,a)')
+     x      ' *** warning - HK real space screening function problem'
+     x      //' at cut off:',a,' ***'
+          
+        elseif(kode.eq.105)then
+          
+          write(nrite,'(/,1x,a,1p,e12.4,a)')
+     x      ' *** warning - HK recip space screening function problem'
+     x      //' at cut off:',a,' ***'
+          
+        elseif(kode.eq.110)then
+          
+          write(nrite,'(/,1x,a)')
+     x      ' *** warning - undefined atom-atom interactions set to '
+     x      //'zero ***'
+          
+        elseif(kode.eq.120)then
+          
+          write(nrite,'(/,1x,a)')
+     x      ' *** warning - RDF calculation cancelled - no pair forces'
+     x      //' defined ***'
+          
+        elseif(kode.eq.130)then
+          
+          ia=nint(a)
+          write(nrite,'(/,1x,a,i5,a)')
+     x      ' *** warning - RDF interval reset to',ia,' ***'
+          
+        elseif(kode.eq.140)then
+          
+          write(nrite,'(/,1x,a)')
+     x      ' *** warning - RDF calculation cancelled - free energy'
+     x      //' option in use ***'
+          
+        else
+          
+          write(nrite,'(/,1x,a)')
+     x      ' *** unspecified warning encountered ***'
+        endif
+        
+      endif
+      
+      return
+      end subroutine warning
+      
+      end module error_module
diff -urN dl_class_1.9.orig/srcmod/ewald_module.f dl_class_1.9/srcmod/ewald_module.f
--- dl_class_1.9.orig/srcmod/ewald_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/ewald_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1992 @@
+      module ewald_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining ewald sum arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     adapted for solvation, free energy and excitation
+c     - p.-a. cazade oct 2007
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use exclude_module
+      use metafreeze_module
+      use pair_module
+      use property_module
+      use setup_module
+      use solvation_module
+      
+      implicit none
+      
+      real(8), allocatable :: ckc(:),cks(:),clm(:),slm(:)
+      real(8), allocatable :: elc(:,:),els(:,:)
+      real(8), allocatable :: emc(:,:),ems(:,:)
+      real(8), allocatable :: enc(:,:),ens(:,:)
+      real(8), allocatable :: ewlbuf(:),erc(:),fer(:)
+      
+      save ckc,cks,clm,slm,elc,emc,enc,els,ems,ens,erc,fer,ewlbuf
+      
+      contains
+      
+      subroutine alloc_ewald_arrays(idnode)
+      
+      implicit none
+      
+      integer, parameter :: nnn=6
+      
+      integer i,fail,idnode
+      dimension fail(nnn)
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (ckc(mxewld),cks(mxewld),stat=fail(1))
+      allocate (clm(mxewld),slm(mxewld),stat=fail(2))
+      allocate (elc(mxewld,0:1),els(mxewld,0:1),stat=fail(3))
+      allocate (emc(mxewld,0:kmaxb),ems(mxewld,0:kmaxb),stat=fail(4))
+      allocate (enc(mxewld,0:kmaxc),ens(mxewld,0:kmaxc),stat=fail(5))
+      allocate (ewlbuf(mxebuf),erc(mxegrd),fer(mxegrd),stat=fail(6))
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1240)
+      enddo
+      
+      end subroutine alloc_ewald_arrays
+      
+      subroutine erfcgen(alpha,drewd,rcut)
+      
+c***********************************************************************
+c     
+c     dlpoly routine for generating interpolation tables for 
+c     erfc and its derivative - for use with ewald sum.
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester dec 1994
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i
+      real(8) alpha,drewd,rcut,a1,a2,a3,a4,a5,pp,rrr,rsq,tt,exp1
+      
+      data a1,a2,a3/0.254829592d0,-0.284496736d0,1.421413741d0/
+      data a4,a5,pp/-1.453152027d0,1.061405429d0,0.3275911d0/
+      
+c     look-up tables for real space part of ewald sum
+      
+      drewd=rcut/dble(mxegrd-4)
+      
+      do i=1,mxegrd
+        
+        rrr=dble(i)*drewd
+        rsq=rrr*rrr
+        tt=1.d0/(1.d0+pp*alpha*rrr)
+        exp1=exp(-(alpha*rrr)**2)
+        erc(i)=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rrr
+        fer(i)=(erc(i)+2.d0*(alpha/sqrpi)*exp1)/rsq
+        
+      enddo
+      
+      return
+      end subroutine erfcgen
+      
+      subroutine ewald1
+     x  (lsolva,llsolva,lfree,lghost,idnode,mxnode,natms,imcon,
+     x  kmax1,kmax2,kmax3,engcpe,vircpe,alpha,volm,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using ewald's method
+c     
+c     parallel replicated data version (part 1)
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith march 1992.
+c     modified  - t. forester april 1993: t3d adaptation
+c     modified  - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c     part 1 - reciprocal space terms (fourier part)
+c     
+c     note - in loop over all k vectors k=2pi(ll/cl,mm/cl,nn/cl)
+c     the values of ll,mm and nn are selected so that the symmetry of
+c     reciprocal lattice is taken into account i.e. the following
+c     rules apply.
+c     
+c     ll ranges over the values 0 to kmax1 only.
+c     
+c     mm ranges over 0 to kmax2 when ll=0 and over
+c     -kmax2 to kmax2 otherwise.
+c     nn ranges over 1 to kmax3 when ll=mm=0 and over
+c     -kmax3 to kmax3 otherwise.
+c     
+c     hence the result of the summation must be doubled at the end.
+c     
+c     stress tensor added t.forester may 1994
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newjob,lconsw,safe,leven,lsolva,llsolva,lfree,lghost
+      integer isol,jsol,ksol,iisol,jjsol,kksol,kstep
+      integer idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3
+      integer iatm0,iatm1,i,j,limit,l,npass,ipass,kkk,nmin
+      integer mmin,ll,m,mm,n,nn
+      real(8) engcpe,vircpe,alpha,volm,epsq,omg,qchg,qfix,qforce
+      real(8) twopi,rvolm,ralph,det,rcpcut,rcpct2,engsic,ssx
+      real(8) ssy,ssz,rkx1,rky1,rkz1,cs,rkx2,rky2,rkz2,eng1
+      real(8) rkx3,rky3,rkz3,rksq,ckcs,ckss,rrksq,akk,bkk,akv
+      real(8) scal1,scale,virprs,ckc1s,cks1s,ckc2s,cks2s,fkk
+      real(8) term1a,term2a,term1b,term2b
+      
+      dimension omg(9)
+      
+      save newjob,engsic,qchg
+      
+      data newjob/.true./,lconsw/.true./,safe/.true./,leven/.true./
+      
+      twopi=2.d0*pi
+      
+      kstep=2
+      if(lfree.or.lghost)kstep=6
+      
+      if(alpha.lt.1.d-6)return
+      if(mxewld.ne.msatms)call error(idnode,330)
+      
+c     set up atoms numbers for nodes
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     initialise coulombic potential energy
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     initalize stress tensor working arrays
+      
+      do i=1,9
+        omg(i)=0.d0
+      enddo
+      
+c     set working parameters
+      
+      rvolm=twopi/volm
+      ralph=-0.25d0/alpha**2
+      
+c     set switch for TO, RD and HP boundary conditions
+      
+      if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)then
+        
+        lconsw=.false.
+        rvolm=0.5d0*rvolm
+        
+      endif
+      
+c     construct reciprocal lattice vectors and set k vector range
+      
+      call invert(cell,rcell,det)
+      if(abs(det).lt.1.d-6)call error(idnode,120)
+      call dcell(rcell,buffer)
+      
+      rcpcut=min(dble(kmax1)*buffer(7),dble(kmax2)*buffer(8),
+     x  dble(kmax3)*buffer(9))
+      rcpcut=rcpcut*1.05d0*twopi
+      rcpct2=rcpcut**2
+      
+      if(newjob)then
+        
+c     calculate self interaction correction (sic) and net system charge
+        
+        qchg=0.d0
+        qchg0=0.d0
+        qchg1=0.d0
+        qchg2=0.d0
+        engsic=0.d0
+        engsic0=0.d0
+        engsic2=0.d0
+        
+c     set solvation charge correction variables
+        
+        if(lsolva)then
+          
+          qfix_sol(:)=0.d0
+          cou_sol_sic(:)=0.d0
+          if(lghost)then
+            
+            qfix_exc(:)=0.d0
+            cou_exc_sic(:)=0.d0
+            
+          endif
+          
+        endif
+        
+        if(lghost)then
+          
+c     set excitation sic and charge correction variables
+          
+          do i=iatm0,iatm1
+            
+            if(atm_fre(i).ne.2)then
+              qchg0=qchg0+chge(i)
+              engsic0=engsic0+chge(i)**2
+            endif
+            if(atm_fre(i).ne.1)then
+              qchg2=qchg2+chge(i)
+              engsic2=engsic2+chge(i)**2
+            endif
+            
+          enddo
+          
+        elseif(lfree)then
+          
+c     set free energy sic and charge correction variables
+          
+          do i=iatm0,iatm1
+            
+            if(atm_fre(i).eq.0)then
+              qchg0=qchg0+chge(i)
+              engsic0=engsic0+chge(i)**2
+            elseif(atm_fre(i).eq.1)then
+              qchg1=qchg1+chge(i)
+              engsic0=engsic0+lambda1*chge(i)**2
+              engsic2=engsic2-chge(i)**2
+            elseif(atm_fre(i).eq.2)then
+              qchg2=qchg2+chge(i)
+              engsic0=engsic0+lambda2*chge(i)**2
+              engsic2=engsic2+chge(i)**2
+            endif
+            
+          enddo
+          
+        else
+          
+c     set normal sic and charge correction variables
+          
+          do i=iatm0,iatm1
+            
+            qchg=qchg+chge(i)
+            engsic=engsic+chge(i)**2
+            
+          enddo
+          
+        endif
+        
+        if(lsolva)then
+          
+          if(lghost)then
+            
+c     set excitation sic and charge correction arrays
+            
+            do i=iatm0,iatm1
+              
+              kkk=loc2(atmolt(i),atmolt(i))
+              if(atm_fre(i).ne.2)then
+                cou_sol_sic(kkk)=cou_sol_sic(kkk)+chge(i)**2
+                qfix_sol(atmolt(i))=qfix_sol(atmolt(i))+chge(i)
+              endif
+              if(atm_fre(i).ne.1)then
+                cou_exc_sic(kkk)=cou_exc_sic(kkk)+chge(i)**2
+                qfix_exc(atmolt(i))=qfix_exc(atmolt(i))+chge(i)
+              endif
+              
+            enddo
+            
+          else
+            
+c     set solvation sic and charge correction arrays
+            
+            do i=iatm0,iatm1
+              
+              kkk=loc2(atmolt(i),atmolt(i))
+              cou_sol_sic(kkk)=cou_sol_sic(kkk)+chge(i)**2
+              qfix_sol(atmolt(i))=qfix_sol(atmolt(i))+chge(i)
+              
+            enddo
+            
+          endif
+          
+        endif
+        
+c     calculate global values for correction variables and arrays
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=qchg
+          buffer(2)=qchg0
+          buffer(3)=qchg1
+          buffer(4)=qchg2
+          call gdsum(buffer(1),4,buffer(5))
+          qchg=buffer(1)
+          qchg0=buffer(2)
+          qchg1=buffer(3)
+          qchg2=buffer(4)
+          if(lsolva)then
+            
+            call gdsum(qfix_sol(1),mxtmls,buffer(1))
+            if(lghost)call gdsum(qfix_exc(1),mxtmls,buffer(1))
+            
+          endif
+          
+        endif
+        
+c     store self interaction correction terms
+        
+        engsic=-r4pie0/epsq*alpha*engsic/sqrpi
+        engsic0=-r4pie0/epsq*alpha*engsic0/sqrpi
+        engsic2=-r4pie0/epsq*alpha*engsic2/sqrpi
+        
+        if(lsolva)then
+          
+          cou_sol_sic(:)=-r4pie0/epsq*alpha*cou_sol_sic(:)/sqrpi
+          if(lghost)cou_exc_sic(:)=-r4pie0/epsq*alpha*
+     x      cou_exc_sic(:)/sqrpi
+          
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      if(lfree.or.lghost)then
+        
+        qchg=qchg0
+        engsic=engsic0
+        
+      endif
+      
+c     calculate and store exponential factors
+c     convert real to reciprocal space coordinates
+      
+      i=0
+      
+      do j=iatm0,iatm1
+        
+        i=i+1
+        elc(i,0)=1.d0
+        emc(i,0)=1.d0
+        enc(i,0)=1.d0
+        els(i,0)=0.d0
+        ems(i,0)=0.d0
+        ens(i,0)=0.d0
+        ssx=rcell(1)*xxx(j)+rcell(4)*yyy(j)+rcell(7)*zzz(j)
+        ssy=rcell(2)*xxx(j)+rcell(5)*yyy(j)+rcell(8)*zzz(j)
+        ssz=rcell(3)*xxx(j)+rcell(6)*yyy(j)+rcell(9)*zzz(j)
+        elc(i,1)=cos(twopi*ssx)
+        emc(i,1)=cos(twopi*ssy)
+        enc(i,1)=cos(twopi*ssz)
+        els(i,1)=sin(twopi*ssx)
+        ems(i,1)=sin(twopi*ssy)
+        ens(i,1)=sin(twopi*ssz)
+        
+      enddo
+      
+      limit=i
+      
+      do l=2,kmax2
+        
+        do i=1,limit
+          
+          emc(i,l)=emc(i,l-1)*emc(i,1)-ems(i,l-1)*ems(i,1)
+          ems(i,l)=ems(i,l-1)*emc(i,1)+emc(i,l-1)*ems(i,1)
+          
+        enddo
+        
+      enddo
+      
+      do l=2,kmax3
+        
+        do i=1,limit
+          
+          enc(i,l)=enc(i,l-1)*enc(i,1)-ens(i,l-1)*ens(i,1)
+          ens(i,l)=ens(i,l-1)*enc(i,1)+enc(i,l-1)*ens(i,1)
+          
+        enddo
+        
+      enddo
+      
+c     start of main loop over k vectors
+      
+      npass=1
+      if(mxnode.gt.16)npass=2
+      if((mxnode.gt.1).and.(mxebuf.gt.5000))npass=2
+      
+      do ipass=1,npass
+        
+        kkk=0
+        mmin=0
+        nmin=1
+        if(llsolva)kksol=0
+        
+        do ll=0,kmax1
+          
+          l=ll
+          rkx1=twopi*dble(ll)*rcell(1)
+          rky1=twopi*dble(ll)*rcell(4)
+          rkz1=twopi*dble(ll)*rcell(7)
+          
+c     put cos(i,L) terms into cos(i,0) array
+          
+          if(l.eq.1)then
+            
+            do i=1,limit
+              
+              elc(i,0)=elc(i,1)
+              els(i,0)=els(i,1)
+              
+            enddo
+            
+          elseif(l.gt.1)then
+            
+            do i=1,limit
+              
+              cs=elc(i,0)
+              elc(i,0)=cs*elc(i,1)-els(i,0)*els(i,1)
+              els(i,0)=els(i,0)*elc(i,1)+cs*els(i,1)
+              
+            enddo
+            
+          endif
+          
+          do mm=mmin,kmax2
+            
+            m=iabs(mm)
+            rkx2=rkx1+twopi*dble(mm)*rcell(2)
+            rky2=rky1+twopi*dble(mm)*rcell(5)
+            rkz2=rkz1+twopi*dble(mm)*rcell(8)
+            
+c     set temporary products of exponential terms
+            
+            if(mm.ge.0)then
+              
+              do i=1,limit
+                
+                clm(i)=elc(i,0)*emc(i,m)-els(i,0)*ems(i,m)
+                slm(i)=els(i,0)*emc(i,m)+ems(i,m)*elc(i,0)
+                
+              enddo
+              
+            else
+              
+              do i=1,limit
+                
+                clm(i)=elc(i,0)*emc(i,m)+els(i,0)*ems(i,m)
+                slm(i)=els(i,0)*emc(i,m)-ems(i,m)*elc(i,0)
+                
+              enddo
+              
+            endif
+            
+            do nn=nmin,kmax3
+              
+              n=iabs(nn)
+              
+              if(.not.lconsw)then
+                
+                if(imcon.eq.7)then
+                  
+                  leven=(mod(l+m,2).eq.0)
+                  
+                else
+                  
+                  leven=(mod(l+m+n,2).eq.0)
+                  
+                endif
+                
+              endif
+              
+              if(lconsw.or.leven)then
+                
+                rkx3=rkx2+twopi*dble(nn)*rcell(3)
+                rky3=rky2+twopi*dble(nn)*rcell(6)
+                rkz3=rkz2+twopi*dble(nn)*rcell(9)
+                
+c     test on magnitude of k vector
+                
+                rksq=rkx3*rkx3+rky3*rky3+rkz3*rkz3
+                
+                if(rksq.le.rcpct2)then
+                  
+c     calculate exp(ikr) terms and product with charges
+                  
+                  i=0
+                  
+                  if(nn.ge.0)then
+                    
+                    if(lfree.or.lghost)then
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        if(atm_fre(j).eq.1)then
+                          ckc1(i)=chge(j)*(clm(i)*enc(i,n)-
+     x                      slm(i)*ens(i,n))
+                          cks1(i)=chge(j)*(slm(i)*enc(i,n)+
+     x                      clm(i)*ens(i,n))
+                        elseif(atm_fre(j).eq.2)then
+                          ckc2(i)=chge(j)*(clm(i)*enc(i,n)-
+     x                      slm(i)*ens(i,n))
+                          cks2(i)=chge(j)*(slm(i)*enc(i,n)+
+     x                      clm(i)*ens(i,n))
+                        else
+                          ckc(i)=chge(j)*(clm(i)*enc(i,n)-
+     x                      slm(i)*ens(i,n))
+                          cks(i)=chge(j)*(slm(i)*enc(i,n)+
+     x                      clm(i)*ens(i,n))
+                        endif
+                        
+                      enddo
+                      
+                    else
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        ckc(i)=chge(j)*(clm(i)*enc(i,n)-slm(i)*ens(i,n))
+                        cks(i)=chge(j)*(slm(i)*enc(i,n)+clm(i)*ens(i,n))
+                        
+                      enddo
+                      
+                    endif
+                    
+                  else
+                    
+                    if(lfree.or.lghost)then
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        if(atm_fre(j).eq.1)then
+                          ckc1(i)=chge(j)*(clm(i)*enc(i,n)+
+     x                      slm(i)*ens(i,n))
+                          cks1(i)=chge(j)*(slm(i)*enc(i,n)-
+     x                      clm(i)*ens(i,n))
+                        elseif(atm_fre(j).eq.2)then
+                          ckc2(i)=chge(j)*(clm(i)*enc(i,n)+
+     x                      slm(i)*ens(i,n))
+                          cks2(i)=chge(j)*(slm(i)*enc(i,n)-
+     x                      clm(i)*ens(i,n))
+                        else
+                          ckc(i)=chge(j)*(clm(i)*enc(i,n)+
+     x                      slm(i)*ens(i,n))
+                          cks(i)=chge(j)*(slm(i)*enc(i,n)-
+     x                      clm(i)*ens(i,n))
+                        endif
+                        
+                      enddo
+                      
+                    else
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        ckc(i)=chge(j)*(clm(i)*enc(i,n)+slm(i)*ens(i,n))
+                        cks(i)=chge(j)*(slm(i)*enc(i,n)-clm(i)*ens(i,n))
+                        
+                      enddo
+                      
+                    endif
+                    
+                  endif
+                  
+                  if(ipass.eq.1)then
+                    
+c     calculate vector sums
+                    
+                    ckcs=0.d0
+                    ckss=0.d0
+                    
+                    if(lfree.or.lghost)then
+                      
+                      ckc1s=0.d0
+                      cks1s=0.d0
+                      ckc2s=0.d0
+                      cks2s=0.d0
+                      
+                    endif
+                    
+                    if(llsolva)then
+                      
+                      ckc_sol_sum(:)=0.d0
+                      cks_sol_sum(:)=0.d0
+                      
+                      if(lghost)then
+                        ckc_fre_sum(:)=0.d0
+                        cks_fre_sum(:)=0.d0
+                      endif
+                      
+                    endif
+                    
+                    if(lfree.or.lghost)then
+                      
+                      i=0
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        if(atm_fre(j).eq.1)then
+                          ckc1s=ckc1s+ckc1(i)
+                          cks1s=cks1s+cks1(i)
+                        elseif(atm_fre(j).eq.2)then
+                          ckc2s=ckc2s+ckc2(i)
+                          cks2s=cks2s+cks2(i)
+                        else
+                          ckcs=ckcs+ckc(i)
+                          ckss=ckss+cks(i)
+                        endif
+                        
+                      enddo
+                      
+                    else
+                      
+                      do i=1,limit
+                        
+                        ckcs=ckcs+ckc(i)
+                        ckss=ckss+cks(i)
+                        
+                      enddo
+                      
+                    endif
+                    
+                    if(llsolva)then
+                      
+                      i=0
+                      if(lghost)then
+                        
+                        do j=iatm0,iatm1
+                          
+                          i=i+1
+                          if(atm_fre(j).eq.1)then
+                            ckc_sol_sum(atmolt(j))=
+     x                        ckc_sol_sum(atmolt(j))+ckc1(i)
+                            cks_sol_sum(atmolt(j))=
+     x                        cks_sol_sum(atmolt(j))+cks1(i)
+                          elseif(atm_fre(j).eq.2)then
+                            ckc_fre_sum(atmolt(j))=
+     x                        ckc_fre_sum(atmolt(j))+ckc2(i)
+                            cks_fre_sum(atmolt(j))=
+     x                        cks_fre_sum(atmolt(j))+cks2(i)
+                          else
+                            ckc_sol_sum(atmolt(j))=
+     x                        ckc_sol_sum(atmolt(j))+ckc(i)
+                            cks_sol_sum(atmolt(j))=
+     x                        cks_sol_sum(atmolt(j))+cks(i)
+                          endif
+                          
+                        enddo
+                        
+                      else
+                        
+                        do j=iatm0,iatm1
+                          
+                          i=i+1
+                          ckc_sol_sum(atmolt(j))=ckc_sol_sum(atmolt(j))+
+     x                      ckc(i)
+                          cks_sol_sum(atmolt(j))=cks_sol_sum(atmolt(j))+
+     x                      cks(i)
+                          
+                        enddo
+                        
+                      endif
+                      
+                    endif
+                    
+c     perform global summation of exp(ikr) terms or store if npass=2
+                    
+                    if(npass.eq.2)then
+                      
+                      if(kkk+kstep.le.mxebuf)then
+                        
+                        ewlbuf(kkk+1)=ckcs
+                        ewlbuf(kkk+2)=ckss
+                        
+                        if(lfree.or.lghost)then
+                          
+                          ewlbuf(kkk+3)=ckc1s
+                          ewlbuf(kkk+4)=cks1s
+                          ewlbuf(kkk+5)=ckc2s
+                          ewlbuf(kkk+6)=cks2s
+                          
+                        endif
+                        
+                        if(llsolva)then
+                          
+                          do isol=1,mxtmls
+                            
+                            ebuf_sol1(kksol+isol)=ckc_sol_sum(isol)
+                            ebuf_sol2(kksol+isol)=cks_sol_sum(isol)
+                            
+                            if(lghost)then
+                              
+                              ebuf_exc1(kksol+isol)=ckc_fre_sum(isol)
+                              ebuf_exc2(kksol+isol)=cks_fre_sum(isol)
+                              
+                            endif
+                            
+                          enddo
+                          
+                        endif
+                        
+                      else
+                        
+                        safe=.false.
+                        
+                      endif
+                      
+                    elseif(mxnode.gt.1)then
+                      
+                      buffer(1)=ckcs
+                      buffer(2)=ckss
+                      call gdsum(buffer(1),2,buffer(3))
+                      ckcs=buffer(1)
+                      ckss=buffer(2)
+                      
+                      if(lfree.or.lghost)then
+                        
+                        buffer(1)=ckc1s
+                        buffer(2)=cks1s
+                        buffer(3)=ckc2s
+                        buffer(4)=cks2s
+                        call gdsum(buffer(1),4,buffer(5))
+                        ckc1s=buffer(1)
+                        cks1s=buffer(2)
+                        ckc2s=buffer(3)
+                        cks2s=buffer(4)
+                        
+                      endif
+                      
+                      if(llsolva)then
+                        
+                        call gdsum(ckc_sol_sum(1),mxtmls,buffer(1))
+                        call gdsum(cks_sol_sum(1),mxtmls,buffer(1))
+                        
+                        if(lghost)then
+                          
+                          call gdsum(ckc_fre_sum(1),mxtmls,buffer(1))
+                          call gdsum(cks_fre_sum(1),mxtmls,buffer(1))
+                          
+                        endif
+                        
+                      endif
+                      
+                    endif
+                    
+                  endif
+                  
+                  if(ipass.eq.npass)then
+                    
+                    if(npass.eq.2)then
+                      
+                      ckcs=ewlbuf(kkk+1)
+                      ckss=ewlbuf(kkk+2)
+                      
+                      if(lfree.or.lghost)then
+                        
+                        ckc1s=ewlbuf(kkk+3)
+                        cks1s=ewlbuf(kkk+4)
+                        ckc2s=ewlbuf(kkk+5)
+                        cks2s=ewlbuf(kkk+6)
+                        
+                      endif
+                      
+                      if(llsolva)then
+                        
+                        do isol=1,mxtmls
+                          
+                          ckc_sol_sum(isol)=ebuf_sol1(kksol+isol)
+                          cks_sol_sum(isol)=ebuf_sol2(kksol+isol)
+                          
+                          if(lghost)then
+                            
+                            ckc_fre_sum(isol)=ebuf_exc1(kksol+isol)
+                            cks_fre_sum(isol)=ebuf_exc2(kksol+isol)
+                            
+                          endif
+                          
+                        enddo
+                        
+                      endif
+                      
+                    endif
+                    
+c     calculate akk coefficients
+                    
+                    rrksq=1.d0/rksq
+                    if(lconsw)then
+                      akk=exp(ralph*rksq)*rrksq
+                    else
+                      akk=4.0d0*exp(ralph*rksq)*rrksq
+                    endif
+                    bkk=akk
+                    akv=2.d0*akk*(rrksq-ralph)
+                    
+c     accumulate potential energy and virial terms
+                    
+                    if(lghost)then
+                      
+                      engcpe=engcpe+akk*((ckcs*ckcs+ckss*ckss)
+     x                  +(ckc1s*ckc1s+cks1s*cks1s)+2.d0*
+     x                  (ckc1s*ckcs+cks1s*ckss))
+                      virprs=akv*((ckcs*ckcs+ckss*ckss)
+     x                  +(ckc1s*ckc1s+cks1s*cks1s)+2.d0*
+     x                  (ckc1s*ckcs+cks1s*ckss))
+                      
+                    elseif(lfree)then
+                      
+                      term1a=(ckc1s*ckc1s+cks1s*cks1s)
+                      term1b=2.d0*(ckc1s*ckcs+cks1s*ckss)
+                      term2a=(ckc2s*ckc2s+cks2s*cks2s)
+                      term2b=2.d0*(ckc2s*ckcs+cks2s*ckss)
+                      
+                      engcpe=engcpe+akk*
+     x                  ((ckcs*ckcs+ckss*ckss)+
+     x                  lambda1*(term1a+term1b)+
+     x                  lambda2*(term2a+term2b))
+                      
+                      cou_fre=cou_fre+akk*
+     x                  ((term2a+term2b)-(term1a+term1b))
+                      
+                      virprs=akv*
+     x                  ((ckcs*ckcs+ckss*ckss)+
+     x                  lambda1*(term1a+term1b)+
+     x                  lambda2*(term2a+term2b))
+                      
+                      cou_vir=cou_vir+akv*rksq*
+     x                  ((term2a+term2b)-(term1a+term1b))
+                      
+                    else
+                      
+                      engcpe=engcpe+akk*(ckcs*ckcs+ckss*ckss)
+                      virprs=akv*(ckcs*ckcs+ckss*ckss)
+                      
+                    endif
+                    
+                    if(llsolva)then
+                      
+                      ksol=0
+                      do isol=1,mxtmls
+                        
+                        fkk=2.d0*akk
+                        do jsol=1,isol
+                          
+                          ksol=ksol+1
+                          if(isol.eq.jsol)fkk=akk
+                          
+                          cou_sol(ksol)=cou_sol(ksol)+
+     x                      fkk*(ckc_sol_sum(isol)*ckc_sol_sum(jsol)+
+     x                      cks_sol_sum(isol)*cks_sol_sum(jsol))
+                          
+                          if(lghost)then
+                            
+                            cou_exc(ksol)=cou_exc(ksol)+
+     x                        akk*(ckc_fre_sum(isol)*ckc_fre_sum(jsol)+
+     x                        cks_fre_sum(isol)*cks_fre_sum(jsol))
+                            
+                          endif
+                          
+                        enddo
+                        
+                      enddo
+                      
+                    endif
+                    
+c     contributions to stress tensor
+                    
+                    omg(1)=omg(1)-virprs*rkx3*rkx3
+                    omg(5)=omg(5)-virprs*rky3*rky3
+                    omg(9)=omg(9)-virprs*rkz3*rkz3
+                    omg(2)=omg(2)-virprs*rkx3*rky3
+                    omg(3)=omg(3)-virprs*rkx3*rkz3
+                    omg(6)=omg(6)-virprs*rky3*rkz3
+                    
+c     calculate force on each site
+                    
+                    i=0
+                    if(lghost)then
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        if(atm_fre(j).eq.2)then
+                          qforce=bkk*(cks2(i)*(ckcs+ckc2s)-
+     x                      ckc2(i)*(ckss+cks2s))
+                        elseif(atm_fre(j).eq.1)then
+                          qforce=bkk*(cks1(i)*(ckcs+ckc1s)-
+     x                      ckc1(i)*(ckss+cks1s))
+                        else
+                          qforce=bkk*(cks(i)*(ckcs+ckc1s)-
+     x                      ckc(i)*(ckss+cks1s))
+                        endif
+                        
+                        fxx(j)=fxx(j)+rkx3*qforce
+                        fyy(j)=fyy(j)+rky3*qforce
+                        fzz(j)=fzz(j)+rkz3*qforce
+                        
+                      enddo
+                      
+                    elseif(lfree)then
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        if(atm_fre(j).eq.0)then
+                          qforce=bkk*(cks(i)*(ckcs+lambda1*ckc1s+
+     x                      lambda2*ckc2s)-ckc(i)*(ckss+lambda1*
+     x                      cks1s+lambda2*cks2s))
+                        elseif(atm_fre(j).eq.1)then
+                          qforce=lambda1*bkk*(cks1(i)*(ckcs+ckc1s)
+     x                      -ckc1(i)*(ckss+cks1s))
+                        elseif(atm_fre(j).eq.2)then
+                          qforce=lambda2*bkk*(cks2(i)*(ckcs+ckc2s)
+     x                      -ckc2(i)*(ckss+cks2s))
+                        endif
+                        
+                        fxx(j)=fxx(j)+rkx3*qforce
+                        fyy(j)=fyy(j)+rky3*qforce
+                        fzz(j)=fzz(j)+rkz3*qforce
+                        
+                      enddo
+                      
+                    else
+                      
+                      do j=iatm0,iatm1
+                        
+                        i=i+1
+                        qforce=bkk*(cks(i)*ckcs-ckc(i)*ckss)
+                        fxx(j)=fxx(j)+rkx3*qforce
+                        fyy(j)=fyy(j)+rky3*qforce
+                        fzz(j)=fzz(j)+rkz3*qforce
+                        
+                      enddo
+                      
+                    endif
+                    
+c     end vector loop
+                    
+                  endif
+                  
+                  kkk=kkk+kstep
+                  
+                  if(llsolva)kksol=kksol+mxtmls
+                  
+                endif
+                
+              endif
+              
+            enddo
+            
+            nmin=-kmax3
+            
+          enddo
+          
+          mmin=-kmax2
+          
+        enddo
+        
+c     delayed global sum of exp(ikr) terms for npass=2 case
+        
+        if(ipass.eq.1.and.npass.eq.2)then
+          
+          if(safe)then
+            
+            call gdsum(ewlbuf,kkk,buffer)
+            
+            if(llsolva)then
+              
+              call gdsum(ebuf_sol1,kksol,buffer)
+              call gdsum(ebuf_sol2,kksol,buffer)
+              
+              if(lghost)then
+                
+                call gdsum(ebuf_exc1,kksol,buffer)
+                call gdsum(ebuf_exc2,kksol,buffer)
+                
+              endif
+              
+            endif
+            
+            do i=1,limit
+              
+              elc(i,0)=1.d0
+              els(i,0)=0.d0
+              
+            enddo
+            
+          else
+            
+            if(idnode.eq.0)then
+              
+              write(nrite,'(a,i10)')
+     x          'dimension of ewlbuf array required ',kkk
+              write(nrite,'(a,i10)')
+     x          'dimension of current  ewlbuf array ',mxebuf
+              
+            endif
+            
+            call error(idnode,46)
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+c     reduce sums by factor mxnode for global summation
+      
+      engcpe=engcpe/dble(mxnode)
+      
+      if(lfree)then
+        cou_fre=cou_fre/dble(mxnode)
+        cou_vir=cou_vir/dble(mxnode)
+      endif
+      
+      if(llsolva)then
+        cou_sol(:)=cou_sol(:)/dble(mxnode)
+        if(lghost)cou_exc(:)=cou_exc(:)/dble(mxnode)
+      endif
+      
+      do i=1,9
+        omg(i)=omg(i)/dble(mxnode)
+      enddo
+      
+c     correction for charged systems
+      
+      if(lfree)then
+        
+        qfix=-(0.5d0*pi*r4pie0/epsq)*(((qchg/alpha)**2+lambda1*
+     x    (qchg1/alpha)**2+lambda2*(qchg2/alpha)**2+2.d0*lambda1*
+     x    (qchg1/alpha)*(qchg/alpha)+2.d0*lambda2*(qchg2/alpha)*
+     x    (qchg/alpha))/volm)/dble(mxnode)
+        
+        qfix_fre=-(0.5d0*pi*r4pie0/epsq)*(((qchg2/alpha)**2-
+     x    (qchg1/alpha)**2+2.d0*(qchg2/alpha)*(qchg/alpha)
+     x    -2.d0*(qchg1/alpha)*(qchg/alpha))/volm)/dble(mxnode)
+        
+      else
+        
+        qfix=-(0.5d0*pi*r4pie0/epsq)*((qchg/alpha)**2/volm)/
+     x    dble(mxnode)
+        
+      endif
+      
+c     add self interaction correction to potential
+      
+      if(lconsw)then
+        
+        eng1=engcpe
+        engcpe=2.d0*rvolm*r4pie0*engcpe/epsq+engsic+qfix
+        
+        if(lfree)then
+          
+          cou_vir=2.d0*rvolm*r4pie0*(cou_vir-3.d0*cou_fre)/epsq-
+     x      3.d0*qfix_fre
+          cou_fre=2.d0*rvolm*r4pie0*cou_fre/epsq+qfix_fre+engsic2
+          
+        endif
+        
+        if(llsolva)then
+          
+          cou_sol(:)=2.d0*rvolm*r4pie0*cou_sol(:)/epsq+cou_sol_sic(:)
+          if(lghost)cou_exc(:)=2.d0*rvolm*r4pie0*cou_exc(:)/epsq+
+     x      cou_exc_sic(:)
+          
+        endif        
+        
+        scal1=2.d0*rvolm*r4pie0/epsq
+        scale=4.d0*rvolm*r4pie0/epsq
+        
+      else
+        
+        eng1=engcpe
+        engcpe=rvolm*r4pie0*engcpe/epsq+engsic+qfix
+        
+        if(lfree)then
+          
+          cou_vir=rvolm*r4pie0*(cou_vir-3.d0*cou_fre)/epsq-
+     x      3.d0*qfix_fre
+          cou_fre=rvolm*r4pie0*cou_fre/epsq+qfix_fre+engsic2
+          
+        endif
+        
+        if(llsolva)then
+          
+          cou_sol(:)=rvolm*r4pie0*cou_sol(:)/epsq+cou_sol_sic(:)
+          if(lghost)cou_exc(:)=rvolm*r4pie0*cou_exc(:)/epsq+
+     x      cou_exc_sic(:)
+          
+        endif        
+        
+        scal1=rvolm*r4pie0/epsq
+        scale=2.d0*rvolm*r4pie0/epsq
+        
+      endif
+      
+      if(llsolva)then
+        
+        ksol=0
+        do isol=1,mxtmls
+          
+          fkk=1.d0
+          do jsol=1,isol
+            
+            ksol=ksol+1
+            if(isol.eq.jsol)fkk=0.5d0
+            
+            cou_sol(ksol)=cou_sol(ksol)-
+     x        ((fkk*pi*r4pie0/epsq)*qfix_sol(isol)*
+     x        qfix_sol(jsol)/(alpha*alpha*volm*
+     x        dble(mxnode)))
+              
+            if(lghost)then
+              
+              cou_exc(ksol)=cou_exc(ksol)-
+     x          ((fkk*pi*r4pie0/epsq)*qfix_exc(isol)*
+     x          qfix_exc(jsol)/(alpha*alpha*volm*
+     x          dble(mxnode)))
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+      endif
+      
+c     calculate final forces
+      
+      do i=iatm0,iatm1
+        
+        fxx(i)=scale*fxx(i)
+        fyy(i)=scale*fyy(i)
+        fzz(i)=scale*fzz(i)
+        
+      enddo
+      
+c     calculate stress tensor (symmetrical)
+      
+      stress(1)=stress(1)+scal1*(omg(1)+eng1)+qfix
+      stress(2)=stress(2)+scal1*omg(2)
+      stress(3)=stress(3)+scal1*omg(3)
+      stress(4)=stress(4)+scal1*omg(2)
+      stress(5)=stress(5)+scal1*(omg(5)+eng1)+qfix
+      stress(6)=stress(6)+scal1*omg(6)
+      stress(7)=stress(7)+scal1*omg(3)
+      stress(8)=stress(8)+scal1*omg(6)
+      stress(9)=stress(9)+scal1*(omg(9)+eng1)+qfix
+      
+c     virial term
+      
+      vircpe=-scal1*(omg(1)+omg(5)+omg(9)+3.d0*eng1)-3.d0*qfix
+      
+      cou_fre=0.d0
+      cou_vir=0.d0
+      return
+      end subroutine ewald1
+      
+      subroutine ewald2
+     x  (lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,drewd,rcut,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using ewald's method
+c     
+c     parallel replicated data version (part 2)
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     T3d optimised. t.forester july 1994
+c     modified  - p.-a. cazade oct 2007: solvation, free energy etcc     
+c     part 2 - real space terms. 
+c     
+c     Tabulated potential in r space
+c     3pt interpolation
+c     
+c     t. forester March 1993
+c     {stress tensor : t.forester june 1994}
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer m,ik,iatm,jatm,ll,l1,l2,kkk
+      real(8) engcpe,vircpe,drewd,rcut,epsq
+      real(8) chgprd,rsq,rrr,ppp,vk0,vk1,vk2,t1,t2,erfcr,egamma
+      real(8) rcsq,rdrewd,chgea,fx,fy,fz,fi
+      real(8) strs(6),strs_loc(6)
+      
+      dimension fi(3)
+      
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+      
+c     reciprocal of interpolation interval
+      
+      rdrewd=1.d0/drewd
+      
+c     initialise stress tensor accumulators
+      
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      
+      if(abs(chgea).gt.1.d-10)then
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+        do m=1,ik
+          
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          if(lmetadyn)jdrive=driven(ltype(jatm))          
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+          
+          chgprd=chgea*chge(jatm)
+          
+c     Ignore interaction if product of charges is zero
+          
+          if(abs(chgprd).gt.1.d-10)then
+            
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+            
+c     apply truncation of potential
+            
+            if(rcsq.gt.rsq)then
+              
+              rrr=sqrt(rsq)              
+              
+              ll=int(rrr*rdrewd)
+              l1=ll+1
+              l2=ll+2
+              ppp=rrr*rdrewd-dble(ll)
+              
+c     calculate interaction energy using 3-point interpolation
+              
+              vk0=erc(ll)
+              vk1=erc(l1)
+              vk2=erc(l2)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              erfcr=(t1+(t2-t1)*ppp*0.5d0)*chgprd
+              
+c     calculate forces using 3pt interpolation
+              
+              vk0=fer(ll)
+              vk1=fer(l1)
+              vk2=fer(l2)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              egamma=(t1+(t2-t1)*ppp*0.5d0)*chgprd
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)cou_exc(kkk)=cou_exc(kkk)+erfcr
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-erfcr
+                  cou_vir=cou_vir+egamma*rsq
+                  erfcr=lambda1*erfcr
+                  egamma=lambda1*egamma
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre+erfcr
+                  cou_vir=cou_vir-egamma*rsq
+                  erfcr=lambda2*erfcr
+                  egamma=lambda2*egamma
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+                
+c     calculate potential energy and virial
+                
+                engcpe=engcpe+erfcr
+                vircpe=vircpe-egamma*rsq
+                
+c     calculate solvation energy
+                
+                if(lsolva)cou_sol(kkk)=cou_sol(kkk)+erfcr
+                
+c     calculate forces
+                
+                fx=egamma*xdf(m)
+                fy=egamma*ydf(m)
+                fz=egamma*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+                
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+                
+c     calculate stress tensor
+                
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+              
+c     metadynamics local parameters
+              
+              if(lmetadyn.and.(idrive.or.jdrive))then
+                
+c     local energy and virial
+                
+                eng_loc=eng_loc+erfcr
+                vir_loc=vir_loc-egamma*rsq
+                
+c     local forces
+                
+                fxx_loc(iatm)=fxx_loc(iatm)+fx
+                fyy_loc(iatm)=fyy_loc(iatm)+fy
+                fzz_loc(iatm)=fzz_loc(iatm)+fz
+                
+                fxx_loc(jatm)=fxx_loc(jatm)-fx
+                fyy_loc(jatm)=fyy_loc(jatm)-fy
+                fzz_loc(jatm)=fzz_loc(jatm)-fz
+                
+c     local stress tensor
+                
+                strs_loc(1)=strs_loc(1)+xdf(m)*fx
+                strs_loc(2)=strs_loc(2)+xdf(m)*fy
+                strs_loc(3)=strs_loc(3)+xdf(m)*fz
+                strs_loc(4)=strs_loc(4)+ydf(m)*fy
+                strs_loc(5)=strs_loc(5)+ydf(m)*fz
+                strs_loc(6)=strs_loc(6)+zdf(m)*fz
+                
+              endif
+              
+            endif
+            
+          endif
+          
+        enddo
+      
+c     load temps back to fxx(iatm) etc
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+        
+c     complete stress tensor
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+
+        if(lmetadyn)then
+          
+          stress_loc(1)=stress_loc(1)+strs_loc(1)
+          stress_loc(2)=stress_loc(2)+strs_loc(2)
+          stress_loc(3)=stress_loc(3)+strs_loc(3)
+          stress_loc(4)=stress_loc(4)+strs_loc(2)
+          stress_loc(5)=stress_loc(5)+strs_loc(4)
+          stress_loc(6)=stress_loc(6)+strs_loc(5)
+          stress_loc(7)=stress_loc(7)+strs_loc(3)
+          stress_loc(8)=stress_loc(8)+strs_loc(5)
+          stress_loc(9)=stress_loc(9)+strs_loc(6)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine ewald2
+      
+      subroutine ewald3
+     x  (lsolva,lfree,lghost,iatm,ilst,engcpe,vircpe,alpha,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using ewald's method
+c     
+c     parallel replicated data version (part 3)
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith dec 1992.
+c     modified  - p.-a. cazade oct 2007: solvation, free energy etcc     
+c     
+c     stress stensor added t.forester may 1994
+c     
+c***********************************************************************
+      implicit none
+      
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,jatm,ilst,m,kkk
+      real(8) engcpe,vircpe,alpha,epsq,a1,a2,a3
+      real(8) a4,a5,pp,rr3,r10,r42,r216,chgea,chgprd,rrr,rsq,alpr
+      real(8) alpr2,erfr,egamma,tt,exp1,fx,fy,fz
+      real(8) strs(6),strs_loc(6)
+      
+      data a1,a2,a3/0.254829592d0,-0.284496736d0,1.421413741d0/
+      data a4,a5,pp/-1.453152027d0,1.061405429d0,0.3275911d0/
+      data rr3/0.333333333333d0/,r10/0.1d0/,r42/0.02380952381d0/
+      data r216/4.62962962963d-3/
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     initialise stress accumulators
+      
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      
+      do m=1,nexatm(ilst)
+        
+c     atomic index and charge product
+        
+        jatm=lexatm(ilst,m)
+        if(lmetadyn)jdrive=driven(ltype(jatm))
+        
+        if(lskip)then
+          if(atm_fre(iatm)*atm_fre(jatm).eq. 2)cycle
+        endif
+        
+        chgprd=chgea*chge(jatm)
+        
+c     calculate interatomic distance
+        
+        rsq=xdf(m)**2+ydf(m)**2+zdf(m)**2
+        
+        rrr=sqrt(rsq)
+        alpr=rrr*alpha
+        alpr2=alpr*alpr
+        
+c     calculate error function and derivative
+        
+        if(alpr.lt.1.d-2)then
+          
+          erfr=2.d0*chgprd*(alpha/sqrpi)*
+     x      (1.d0+alpr2*(-rr3+alpr2*(r10+alpr2*(-r42+alpr2*r216))))
+          
+          egamma=-4.d0*chgprd*(alpha**3/sqrpi)*
+     x      (rr3+alpr2*(-2.d0*r10+alpr2*(3.d0*r42-4.d0*alpr2*r216)))
+          
+        else
+          
+          tt=1.d0/(1.d0+pp*alpha*rrr)
+          exp1=exp(-(alpha*rrr)**2)
+          erfr=(1.d0-tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1)*
+     x      chgprd/rrr
+          egamma=-(erfr-2.d0*chgprd*(alpha/sqrpi)*exp1)/rsq
+          
+        endif
+        
+c     set selection control
+        
+        lselect=.true.
+        
+c     set double index
+        
+        if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+        
+        if(lghost)then
+          
+c     selected excitation option
+          
+          if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+            
+c     reset selection control
+            
+            lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+            
+c     calculate solvation energy
+                  
+            if(lsolva)cou_exc(kkk)=cou_exc(kkk)-erfr
+            
+          endif
+          
+        elseif(lfree)then
+          
+c     selected free energy option
+          
+          if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+            
+c     set hamiltonian mixing parameter
+            
+            cou_fre=cou_fre+erfr
+            cou_vir=cou_vir+egamma*rsq
+            erfr=lambda1*erfr
+            egamma=lambda1*egamma
+            
+          elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+            
+c     set hamiltonian mixing parameter
+            
+            cou_fre=cou_fre-erfr
+            cou_vir=cou_vir-egamma*rsq
+            erfr=lambda2*erfr
+            egamma=lambda2*egamma
+            
+          endif
+          
+        endif
+        
+        if(lselect)then
+          
+c     calculate potential energy and virial
+
+          engcpe=engcpe-erfr
+          vircpe=vircpe-egamma*rsq
+        
+c     calculate solvation energy
+          
+          if(lsolva)cou_sol(kkk)=cou_sol(kkk)-erfr
+            
+c     calculate forces
+          
+          fx=egamma*xdf(m)
+          fy=egamma*ydf(m)
+          fz=egamma*zdf(m)
+          
+          fxx(iatm)=fxx(iatm)+fx
+          fyy(iatm)=fyy(iatm)+fy
+          fzz(iatm)=fzz(iatm)+fz
+          
+          fxx(jatm)=fxx(jatm)-fx
+          fyy(jatm)=fyy(jatm)-fy
+          fzz(jatm)=fzz(jatm)-fz
+          
+c     calculate stress tensor
+          
+          strs(1)=strs(1)+xdf(m)*fx
+          strs(2)=strs(2)+xdf(m)*fy
+          strs(3)=strs(3)+xdf(m)*fz
+          strs(4)=strs(4)+ydf(m)*fy
+          strs(5)=strs(5)+ydf(m)*fz
+          strs(6)=strs(6)+zdf(m)*fz
+          
+        endif
+        
+c     metadynamics local parameters
+        
+        if(lmetadyn.and.(idrive.or.jdrive))then
+          
+c     local energy and virial
+
+          eng_loc=eng_loc-erfr
+          vir_loc=vir_loc-egamma*rsq
+        
+c     local forces
+          
+          fxx_loc(iatm)=fxx_loc(iatm)+fx
+          fyy_loc(iatm)=fyy_loc(iatm)+fy
+          fzz_loc(iatm)=fzz_loc(iatm)+fz
+          
+          fxx_loc(jatm)=fxx_loc(jatm)-fx
+          fyy_loc(jatm)=fyy_loc(jatm)-fy
+          fzz_loc(jatm)=fzz_loc(jatm)-fz
+          
+c     local stress tensor
+          
+          strs_loc(1)=strs_loc(1)+xdf(m)*fx
+          strs_loc(2)=strs_loc(2)+xdf(m)*fy
+          strs_loc(3)=strs_loc(3)+xdf(m)*fz
+          strs_loc(4)=strs_loc(4)+ydf(m)*fy
+          strs_loc(5)=strs_loc(5)+ydf(m)*fz
+          strs_loc(6)=strs_loc(6)+zdf(m)*fz
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+      return
+      end subroutine ewald3
+      
+      subroutine ewald4(lsolva,lfree,lghost,iatm,ik,engcpe,vircpe,
+     x  engcpl,vircpl,drewd,rcut,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using ewald's method
+c     
+c     modified to allow direct calculation of primary (short-range)
+c     interactions for multiple-time step corrections
+c      
+c     primary neighbours are taken out of the Ewald sum
+c     electrostatics are evaluated directly instead
+c     
+c     parallel replicated data version (part 2)
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     
+c     modified  - t. forester february 1993
+c     
+c     part 2 - real space terms
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lghost,lselect,lskip
+      integer iatm,ik,m,jatm,ll,i,kkk
+      real(8) engcpe,vircpe,engcpl,vircpl,drewd,rcut,epsq,rrr
+      real(8) rcsq,rdrewd,strs,strl,chgea,fi,fli,rsq,chgprd,coul
+      real(8) vk0,vk1,vk2,t1,t2,erfcr,fcoul,egamma,fx,fy,fz,ppp
+      
+      dimension fi(3),fli(3),strs(6),strl(6)
+      
+CDIR$ CACHE_ALIGN fi
+CDIR$ CACHE_ALIGN fli
+      
+      lskip=(lfree.or.lghost)
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+      
+c     reciprocal of interpolation interval
+      
+      rdrewd=1.d0/drewd
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+      engcpl=0.d0
+      vircpl=0.d0
+      
+c     initialise stress tensor accumulators
+      
+      do i=1,6
+        
+        strs(i)=0.d0
+        strl(i)=0.d0
+        
+      enddo
+      
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      if(abs(chgea).gt.1.d-10)then
+        
+c     temporary arrays for cache aligning
+        
+        fi(1)=fxx(iatm)
+        fi(2)=fyy(iatm)
+        fi(3)=fzz(iatm)
+        
+        fli(1)=flx(iatm)
+        fli(2)=fly(iatm)
+        fli(3)=flz(iatm)
+        
+        do m=1,ik
+          
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          
+          if(lskip)then
+            if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+          endif
+          
+          chgprd=chgea*chge(jatm)
+          
+          if(abs(chgprd).gt.1.d-10)then
+            
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+            
+            if(rcsq.gt.rsq)then
+              
+c     coulombic energy and coulombic force
+              
+              rrr=sqrt(rsq)
+              coul=chgprd/rrr
+              fcoul=coul/rsq
+              
+c     calculate Ewald term using 3-point interpolation
+              
+              ll=int(rrr*rdrewd)
+              ppp=rrr*rdrewd-dble(ll)
+              
+              vk0=erc(ll)
+              vk1=erc(ll+1)
+              vk2=erc(ll+2)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              erfcr=(t1+(t2-t1)*ppp*0.5d0)*chgprd              
+              
+c     calculate Ewald forces using 3pt interpolation
+              
+              vk0=fer(ll)
+              vk1=fer(ll+1)
+              vk2=fer(ll+2)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              egamma=(t1+(t2-t1)*ppp*0.5d0)*chgprd
+              egamma=egamma-fcoul
+              
+c     set selection control
+              
+              lselect=.true.
+              
+c     set double index
+              
+              if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+              
+              if(lghost)then
+                
+c     selected excitation option
+                
+                if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                  
+c     reset selection control
+                  
+                  lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                  
+c     calculate solvation energy
+                  
+                  if(lsolva)then
+                    cou_exc(kkk)=cou_exc(kkk)+coul
+                    cou_exc_lng(kkk)=cou_exc_lng(kkk)+erfcr-coul
+                  endif
+                  
+                endif
+                
+              elseif(lfree)then
+                
+c     selected free energy option
+                
+                if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                  
+c     set hamiltonian mixing parameter
+                  
+                  cou_fre=cou_fre-coul
+                  cou_vir=cou_vir+fcoul*rsq
+                  coul=lambda1*coul
+                  erfcr=lambda1*erfcr
+                  egamma=lambda1*egamma
+                  
+                elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                  
+c     set hamiltonian mixing parameter
+
+                  cou_fre=cou_fre+coul
+                  cou_vir=cou_vir-fcoul*rsq
+                  coul=lambda2*coul
+                  erfcr=lambda2*erfcr
+                  egamma=lambda2*egamma
+                  
+                endif
+                
+              endif
+              
+              if(lselect)then
+                
+c     calculate potential energy and virial
+                
+                engcpe=engcpe+coul
+                engcpl=engcpl+erfcr-coul
+                vircpe=vircpe-fcoul*rsq
+                vircpl=vircpl-egamma*rsq
+                
+c     calculate solvation energy
+                
+                if(lsolva)then
+                  cou_sol(kkk)=cou_sol(kkk)+coul
+                  cou_sol_lng(kkk)=cou_sol_lng(kkk)+erfcr-coul
+                endif
+                
+c     add in contributions to the long-range force
+                
+                fx=egamma*xdf(m)
+                fy=egamma*ydf(m)
+                fz=egamma*zdf(m)
+                
+                fli(1)=fli(1)+fx
+                fli(2)=fli(2)+fy
+                fli(3)=fli(3)+fz
+                
+                flx(jatm)=flx(jatm)-fx
+                fly(jatm)=fly(jatm)-fy
+                flz(jatm)=flz(jatm)-fz
+                
+c     calculate stress tensor
+                
+                strl(1)=strl(1)+xdf(m)*fx
+                strl(2)=strl(2)+xdf(m)*fy
+                strl(3)=strl(3)+xdf(m)*fz
+                strl(4)=strl(4)+ydf(m)*fy
+                strl(5)=strl(5)+ydf(m)*fz
+                strl(6)=strl(6)+zdf(m)*fz
+              
+c     add in contributions to instantaneous force
+                
+                fx=fcoul*xdf(m)
+                fy=fcoul*ydf(m)
+                fz=fcoul*zdf(m)
+                
+                fi(1)=fi(1)+fx
+                fi(2)=fi(2)+fy
+                fi(3)=fi(3)+fz
+                
+                fxx(jatm)=fxx(jatm)-fx
+                fyy(jatm)=fyy(jatm)-fy
+                fzz(jatm)=fzz(jatm)-fz
+                
+c     calculate stress tensor
+                
+                strs(1)=strs(1)+xdf(m)*fx
+                strs(2)=strs(2)+xdf(m)*fy
+                strs(3)=strs(3)+xdf(m)*fz
+                strs(4)=strs(4)+ydf(m)*fy
+                strs(5)=strs(5)+ydf(m)*fz
+                strs(6)=strs(6)+zdf(m)*fz
+                
+              endif
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+c     copy back temporaries
+        
+        fxx(iatm)=fi(1)
+        fyy(iatm)=fi(2)
+        fzz(iatm)=fi(3)
+        
+        flx(iatm)=fli(1)
+        fly(iatm)=fli(2)
+        flz(iatm)=fli(3)
+        
+c     complete stress tensorS
+        
+        stresl(1)=stresl(1)+strl(1)
+        stresl(2)=stresl(2)+strl(2)
+        stresl(3)=stresl(3)+strl(3)
+        stresl(4)=stresl(4)+strl(2)
+        stresl(5)=stresl(5)+strl(4)
+        stresl(6)=stresl(6)+strl(5)
+        stresl(7)=stresl(7)+strl(3)
+        stresl(8)=stresl(8)+strl(5)
+        stresl(9)=stresl(9)+strl(6)
+        
+        stress(1)=stress(1)+strs(1)
+        stress(2)=stress(2)+strs(2)
+        stress(3)=stress(3)+strs(3)
+        stress(4)=stress(4)+strs(2)
+        stress(5)=stress(5)+strs(4)
+        stress(6)=stress(6)+strs(5)
+        stress(7)=stress(7)+strs(3)
+        stress(8)=stress(8)+strs(5)
+        stress(9)=stress(9)+strs(6)
+        
+      endif
+      
+      return
+      end subroutine ewald4
+      
+      end module ewald_module
diff -urN dl_class_1.9.orig/srcmod/exclude_module.f dl_class_1.9/srcmod/exclude_module.f
--- dl_class_1.9.orig/srcmod/exclude_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/exclude_module.f	2012-04-24 18:30:31.000000000 +0200
@@ -0,0 +1,1368 @@
+      module exclude_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining excluded atom arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use angles_module
+      use bonds_module
+      use config_module
+      use core_shell_module
+      use dihedral_module
+      use error_module
+      use inversion_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+
+      implicit none
+
+      integer, allocatable :: lexatm(:,:)
+      integer, allocatable :: nexatm(:),noxatm(:)
+
+      save lexatm,nexatm,noxatm
+
+      contains
+      
+      subroutine alloc_exc_arrays(idnode)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for allocating excluded atom arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=3
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (lexatm(msatms,mxexcl),stat=fail(1))
+      allocate (nexatm(msatms),stat=fail(2))
+      allocate (noxatm(msatms),stat=fail(3))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1012)
+      enddo
+
+      end subroutine alloc_exc_arrays
+
+      subroutine exclude(idnode,mxnode,natms,ntpmls)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the excluded pair
+c     interaction list of the system to be simulated
+c     
+c     keybnd < 0 distance restraint so not excluded
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith        june 1992
+c     
+c     rigid body exclusions added : t.forester nov 1993
+c     check on 1..4 scale factors : t.forester feb 1994
+c     inversion terms added       : w.smith    jul 1996
+c
+c***********************************************************************
+      
+      implicit none
+
+      logical newjob,check,safe,lchk
+      integer idnode,mxnode,natms,ntpmls,nsatms,ibig,i,ibonds
+      integer iangle,iconst,idihdr,invers,igrp,isite,ishels,ia,ib,k
+      integer ic,id,jz,j,jj,ia1,ib1,kk,jk,ntpsit,nlast,lexsav,itmols
+      real(8) a1,a2,a3
+      
+      save newjob
+      
+      data newjob/.true./
+      
+      if(newjob)then
+
+c     check on array allocations
+        
+        nsatms=(natms+mxnode-1)/mxnode
+        if(nsatms.gt.msatms)then
+          
+          if(idnode.eq.0)write(nrite,*)'make msatms >= ',nsatms
+          call error(idnode,100)
+          
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+c     variables for array bound checking
+
+      ibig=0
+      safe=.true.
+
+c     initialise excluded atom arrays
+      
+      do i=1,mxsite
+        
+        nexsit(i)=0
+        
+      enddo
+      
+      do i=1,msatms
+        
+        nexatm(i)=0
+        
+      enddo
+
+      do j=1,mxexcl
+        
+        do i=1,mxsite
+          
+          lexsit(i,j)=0
+          
+        enddo
+        
+        do i=1,msatms
+          
+          lexatm(i,j)=0
+          
+        enddo
+        
+      enddo
+      
+
+c     loop over molecules in system
+      
+      ibonds=0
+      iangle=0
+      iconst=0
+      idihdr=0
+      invers=0
+      igrp  =0
+      isite =0
+      ishels=0
+      
+      do itmols=1,ntpmls
+        
+c     exclude sites on basis of chemical bonds
+        
+        do i=1,numbonds(itmols)
+          
+          ibonds=ibonds+1
+          
+          if(keybnd(ibonds).gt.0)then
+            
+            ia=lstbnd(ibonds,1)+isite
+            ib=lstbnd(ibonds,2)+isite
+
+c     check interaction not already included
+
+            lchk=.true.
+            do jz=1,min(nexsit(ia),mxexcl)
+              if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(ia)=nexsit(ia)+1
+              nexsit(ib)=nexsit(ib)+1
+              if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(ia),nexsit(ib))
+                safe=.false.
+              else
+                lexsit(ia,nexsit(ia))=ib-isite
+                lexsit(ib,nexsit(ib))=ia-isite
+              endif
+            endif
+            
+          endif
+          
+        enddo
+        
+c     exclude sites on basis of bond constraints
+        
+        do i=1,numcon(itmols)
+          
+          iconst=iconst+1
+          ia=lstcon(iconst,1)+isite
+          ib=lstcon(iconst,2)+isite
+
+c     check interaction not already included
+
+          lchk=.true.
+          do jz=1,min(nexsit(ia),mxexcl)
+            if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ia)=nexsit(ia)+1
+            nexsit(ib)=nexsit(ib)+1
+            if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ia),nexsit(ib))
+              safe=.false.
+            else
+              lexsit(ia,nexsit(ia))=ib-isite
+              lexsit(ib,nexsit(ib))=ia-isite
+            endif
+          endif
+          
+        enddo
+        
+c     exclude sites on basis of bond angles
+        
+        do i=1,numang(itmols)
+          
+          iangle=iangle+1
+          if(keyang(iangle).gt.0)then
+            ia=lstang(iangle,1)+isite
+            ib=lstang(iangle,2)+isite
+            ic=lstang(iangle,3)+isite
+
+c     check if already added to lists ..
+c     ia - ib interaction
+
+            lchk=.true.
+            do jz=1,min(nexsit(ia),mxexcl)
+              if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(ia)=nexsit(ia)+1
+              nexsit(ib)=nexsit(ib)+1
+              if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(ia),nexsit(ib))
+                safe=.false.
+              else
+                lexsit(ia,nexsit(ia))=ib-isite
+                lexsit(ib,nexsit(ib))=ia-isite
+              endif
+            endif
+
+c     ib - ic interaction
+
+            lchk=.true.
+            do jz=1,min(nexsit(ib),mxexcl)
+              if(lexsit(ib,jz).eq.ic-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(ib)=nexsit(ib)+1
+              nexsit(ic)=nexsit(ic)+1
+              if(max(nexsit(ib),nexsit(ic)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(ib),nexsit(ic))
+                safe=.false.
+              else
+                lexsit(ib,nexsit(ib))=ic-isite
+                lexsit(ic,nexsit(ic))=ib-isite
+              endif
+            endif
+
+c     ia - ic interaction
+
+            lchk=.true.
+            do jz=1,min(nexsit(ia),mxexcl)
+              if(lexsit(ia,jz).eq.ic-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(ia)=nexsit(ia)+1
+              nexsit(ic)=nexsit(ic)+1
+              if(max(nexsit(ia),nexsit(ic)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(ia),nexsit(ic))
+                safe=.false.
+              else
+                lexsit(ia,nexsit(ia))=ic-isite
+                lexsit(ic,nexsit(ic))=ia-isite
+              endif
+            endif
+
+          endif
+          
+        enddo
+        
+c     exclude on basis of rigid groups
+        
+        do i=1,numgrp(itmols)
+          
+          igrp=igrp+1
+          id=listyp(igrp)
+          
+          do jj=1,numgsit(id)-1
+            
+            ia=lstgst(igrp,jj)+isite
+            
+            do jk=jj+1,numgsit(id)
+              
+              ib=lstgst(igrp,jk)+isite
+              
+c     check interaction not already included
+
+              lchk=.true.
+              do jz=1,min(nexsit(ia),mxexcl)
+                if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+              enddo
+              
+              if(lchk)then
+                nexsit(ia)=nexsit(ia)+1
+                nexsit(ib)=nexsit(ib)+1
+                if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+                  ibig=max(ibig,nexsit(ia),nexsit(ib))
+                  safe=.false.
+                else
+                  lexsit(ia,nexsit(ia))=ib-isite
+                  lexsit(ib,nexsit(ib))=ia-isite
+                endif
+              endif
+              
+            enddo
+            
+          enddo
+          
+        enddo
+        
+c     exclude sites on basis of 1-4 dihedral angles
+        
+        do i=1,numdih(itmols)
+          
+          idihdr=idihdr+1
+          ia=lstdih(idihdr,1)+isite
+          ib=lstdih(idihdr,2)+isite
+          ic=lstdih(idihdr,3)+isite
+          id=lstdih(idihdr,4)+isite
+          
+c     check if already added to lists ..
+c     ia - ib interaction
+          
+          lchk=.true.
+          do jz=1,min(nexsit(ia),mxexcl)
+            if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ia)=nexsit(ia)+1
+            nexsit(ib)=nexsit(ib)+1
+            if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ia),nexsit(ib))
+              safe=.false.
+            else
+              lexsit(ia,nexsit(ia))=ib-isite
+              lexsit(ib,nexsit(ib))=ia-isite
+            endif
+          endif
+          
+c     ib - ic interaction
+          
+          lchk=.true.
+          do jz=1,min(nexsit(ib),mxexcl)
+            if(lexsit(ib,jz).eq.ic-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ib)=nexsit(ib)+1
+            nexsit(ic)=nexsit(ic)+1
+            if(max(nexsit(ib),nexsit(ic)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ib),nexsit(ic))
+              safe=.false.
+            else
+              lexsit(ib,nexsit(ib))=ic-isite
+              lexsit(ic,nexsit(ic))=ib-isite
+            endif
+          endif
+          
+c     ia - ic interaction
+          
+          lchk=.true.
+          do jz=1,min(nexsit(ia),mxexcl)
+            if(lexsit(ia,jz).eq.ic-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ia)=nexsit(ia)+1
+            nexsit(ic)=nexsit(ic)+1
+            if(max(nexsit(ia),nexsit(ic)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ia),nexsit(ic))
+              safe=.false.
+            else
+              lexsit(ia,nexsit(ia))=ic-isite
+              lexsit(ic,nexsit(ic))=ia-isite
+            endif
+          endif
+          
+c     id - ib interaction
+          
+            lchk=.true.
+            do jz=1,min(nexsit(id),mxexcl)
+              if(lexsit(id,jz).eq.ib-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(id)=nexsit(id)+1
+              nexsit(ib)=nexsit(ib)+1
+              if(max(nexsit(id),nexsit(ib)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(id),nexsit(ib))
+                safe=.false.
+              else
+                lexsit(id,nexsit(id))=ib-isite
+                lexsit(ib,nexsit(ib))=id-isite
+              endif
+            endif
+            
+c     id - ic interaction
+            
+            lchk=.true.
+            do jz=1,min(nexsit(id),mxexcl)
+              if(lexsit(id,jz).eq.ic-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(id)=nexsit(id)+1
+              nexsit(ic)=nexsit(ic)+1
+              if(max(nexsit(id),nexsit(ic)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(id),nexsit(ic))
+                safe=.false.
+              else
+                lexsit(id,nexsit(id))=ic-isite
+                lexsit(ic,nexsit(ic))=id-isite
+              endif
+            endif
+            
+c     ia - id interaction: may need to reset vdw and elec scale factors
+            
+            lchk=.true.
+            do jz=1,min(nexsit(ia),mxexcl)
+              if(lexsit(ia,jz).eq.id-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              
+              nexsit(ia)=nexsit(ia)+1
+              nexsit(id)=nexsit(id)+1
+              if(max(nexsit(ia),nexsit(id)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(ia),nexsit(id))
+                safe=.false.
+              else
+                lexsit(ia,nexsit(ia))=id-isite
+                lexsit(id,nexsit(id))=ia-isite
+              endif
+              
+            elseif(keydih(idihdr).ne.7)then
+              
+c     if already excluded reset 1..4 vdw and coulombic scale factors
+              
+              check=((abs(prmdih(idihdr,4)).gt.1.d-10).or.
+     x          (abs(prmdih(idihdr,5)).gt.1.d-10))
+            
+              if(check)then
+                
+                a1=dble(itmols)
+                a2=dble(ia)
+                a3=dble(id)
+                call warning(idnode,20,a1,a2,a3)
+                
+                prmdih(idihdr,4)=0.d0
+                prmdih(idihdr,5)=0.d0
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+c     exclude sites on basis of inversion potentials
+        
+        do i=1,numinv(itmols)
+          
+          invers=invers+1
+          ia=lstinv(invers,1)+isite
+          ib=lstinv(invers,2)+isite
+          ic=lstinv(invers,3)+isite
+          id=lstinv(invers,4)+isite
+
+c     check if already added to lists ..
+c     ia - ib interaction
+
+          lchk=.true.
+          do jz=1,min(nexsit(ia),mxexcl)
+            if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ia)=nexsit(ia)+1
+            nexsit(ib)=nexsit(ib)+1
+            if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ia),nexsit(ib))
+              safe=.false.
+            else
+              lexsit(ia,nexsit(ia))=ib-isite
+              lexsit(ib,nexsit(ib))=ia-isite
+            endif
+          endif
+
+c     ib - ic interaction
+
+          lchk=.true.
+          do jz=1,min(nexsit(ib),mxexcl)
+            if(lexsit(ib,jz).eq.ic-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ib)=nexsit(ib)+1
+            nexsit(ic)=nexsit(ic)+1
+            if(max(nexsit(ib),nexsit(ic)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ib),nexsit(ic))
+              safe=.false.
+            else
+              lexsit(ib,nexsit(ib))=ic-isite
+              lexsit(ic,nexsit(ic))=ib-isite
+            endif
+          endif
+
+c     ia - ic interaction
+
+          lchk=.true.
+          do jz=1,min(nexsit(ia),mxexcl)
+            if(lexsit(ia,jz).eq.ic-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ia)=nexsit(ia)+1
+            nexsit(ic)=nexsit(ic)+1
+            if(max(nexsit(ia),nexsit(ic)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ia),nexsit(ic))
+              safe=.false.
+            else
+              lexsit(ia,nexsit(ia))=ic-isite
+              lexsit(ic,nexsit(ic))=ia-isite
+            endif
+          endif
+
+c     id - ib interaction
+
+            lchk=.true.
+            do jz=1,min(nexsit(id),mxexcl)
+              if(lexsit(id,jz).eq.ib-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(id)=nexsit(id)+1
+              nexsit(ib)=nexsit(ib)+1
+              if(max(nexsit(id),nexsit(ib)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(id),nexsit(ib))
+                safe=.false.
+              else
+                lexsit(id,nexsit(id))=ib-isite
+                lexsit(ib,nexsit(ib))=id-isite
+              endif
+            endif
+
+c     id - ic interaction
+
+            lchk=.true.
+            do jz=1,min(nexsit(id),mxexcl)
+              if(lexsit(id,jz).eq.ic-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(id)=nexsit(id)+1
+              nexsit(ic)=nexsit(ic)+1
+              if(max(nexsit(id),nexsit(ic)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(id),nexsit(ic))
+                safe=.false.
+              else
+                lexsit(id,nexsit(id))=ic-isite
+                lexsit(ic,nexsit(ic))=id-isite
+              endif
+            endif
+
+c     ia - id interaction
+
+            lchk=.true.
+            do jz=1,min(nexsit(ia),mxexcl)
+              if(lexsit(ia,jz).eq.id-isite)lchk=.false.
+            enddo
+            if(lchk)then
+              nexsit(ia)=nexsit(ia)+1
+              nexsit(id)=nexsit(id)+1
+              if(max(nexsit(ia),nexsit(id)).gt.mxexcl)then
+                ibig=max(ibig,nexsit(ia),nexsit(id))
+                safe=.false.
+              else
+                lexsit(ia,nexsit(ia))=id-isite
+                lexsit(id,nexsit(id))=ia-isite
+              endif
+
+          endif
+          
+        enddo
+        
+c     exclude sites on basis of core-shell units
+        
+        do i=1,numshl(itmols)
+          
+          ishels=ishels+1
+          
+          ia=lstshl(ishels,1)+isite
+          ib=lstshl(ishels,2)+isite
+
+c     check interaction not already included
+          
+          lchk=.true.
+          do jz=1,min(nexsit(ia),mxexcl)
+            if(lexsit(ia,jz).eq.ib-isite)lchk=.false.
+          enddo
+          if(lchk)then
+            nexsit(ia)=nexsit(ia)+1
+            nexsit(ib)=nexsit(ib)+1
+            if(max(nexsit(ia),nexsit(ib)).gt.mxexcl)then
+              ibig=max(ibig,nexsit(ia),nexsit(ib))
+              safe=.false.
+            else
+              lexsit(ia,nexsit(ia))=ib-isite
+              lexsit(ib,nexsit(ib))=ia-isite
+            endif
+          endif
+          
+c     exclude sites on basis of bonds to core-shell units
+
+          ibonds=ibonds-numbonds(itmols)
+          do kk=1,numbonds(itmols)
+            
+            ibonds=ibonds+1
+            
+            if(keybnd(ibonds).gt.0)then
+              
+              ia1=lstbnd(ibonds,1)+isite
+              ib1=lstbnd(ibonds,2)+isite
+
+              if(ia.eq.ia1)then
+
+c     check interaction not already included
+          
+                lchk=.true.
+                do jz=1,min(nexsit(ib1),mxexcl)
+                  if(lexsit(ib1,jz).eq.ib-isite)lchk=.false.
+                enddo
+                if(lchk)then
+                  nexsit(ib1)=nexsit(ib1)+1
+                  nexsit(ib)=nexsit(ib)+1
+                  if(max(nexsit(ib1),nexsit(ib)).gt.mxexcl)then
+                    ibig=max(ibig,nexsit(ib1),nexsit(ib))
+                    safe=.false.
+                  else
+                    lexsit(ib1,nexsit(ib1))=ib-isite
+                    lexsit(ib,nexsit(ib))=ib1-isite
+                  endif
+                endif
+
+              endif
+
+              if(ia.eq.ib1)then
+
+c     check interaction not already included
+          
+                lchk=.true.
+                do jz=1,min(nexsit(ia1),mxexcl)
+                  if(lexsit(ia1,jz).eq.ib-isite)lchk=.false.
+                enddo
+                if(lchk)then
+                  nexsit(ia1)=nexsit(ia1)+1
+                  nexsit(ib)=nexsit(ib)+1
+                  if(max(nexsit(ia1),nexsit(ib)).gt.mxexcl)then
+                    ibig=max(ibig,nexsit(ia1),nexsit(ib))
+                    safe=.false.
+                  else
+                    lexsit(ia1,nexsit(ia1))=ib-isite
+                    lexsit(ib,nexsit(ib))=ia1-isite
+                  endif
+                endif
+
+              endif
+
+              if(ib.eq.ia1)then
+
+c     check interaction not already included
+          
+                lchk=.true.
+                do jz=1,min(nexsit(ia),mxexcl)
+                  if(lexsit(ia,jz).eq.ib1-isite)lchk=.false.
+                enddo
+                if(lchk)then
+                  nexsit(ia)=nexsit(ia)+1
+                  nexsit(ib1)=nexsit(ib1)+1
+                  if(max(nexsit(ia),nexsit(ib1)).gt.mxexcl)then
+                    ibig=max(ibig,nexsit(ia),nexsit(ib1))
+                    safe=.false.
+                  else
+                    lexsit(ia,nexsit(ia))=ib1-isite
+                    lexsit(ib1,nexsit(ib1))=ia-isite
+                  endif
+                endif
+
+              endif
+              if(ib.eq.ib1)then
+
+c     check interaction not already included
+          
+                lchk=.true.
+                do jz=1,min(nexsit(ia),mxexcl)
+                  if(lexsit(ia,jz).eq.ia1-isite)lchk=.false.
+                enddo
+                if(lchk)then
+                  nexsit(ia)=nexsit(ia)+1
+                  nexsit(ia1)=nexsit(ia1)+1
+                  if(max(nexsit(ia),nexsit(ia1)).gt.mxexcl)then
+                    ibig=max(ibig,nexsit(ia),nexsit(ia1))
+                    safe=.false.
+                  else
+                    lexsit(ia,nexsit(ia))=ia1-isite
+                    lexsit(ia1,nexsit(ia1))=ia-isite
+                  endif
+                endif
+
+              endif
+
+            endif
+
+          enddo
+          
+c     exclude sites on basis of constraint bonds to core-shell units
+          
+          iconst=iconst-numcon(itmols)
+          do kk=1,numcon(itmols)
+            
+            iconst=iconst+1
+            
+            ia1=lstcon(iconst,1)+isite
+            ib1=lstcon(iconst,2)+isite
+
+            if(ia.eq.ia1)then
+
+c     check interaction not already included
+          
+              lchk=.true.
+              do jz=1,min(nexsit(ib1),mxexcl)
+                if(lexsit(ib1,jz).eq.ib-isite)lchk=.false.
+              enddo
+              if(lchk)then
+                nexsit(ib1)=nexsit(ib1)+1
+                nexsit(ib)=nexsit(ib)+1
+                if(max(nexsit(ib1),nexsit(ib)).gt.mxexcl)then
+                  ibig=max(ibig,nexsit(ib1),nexsit(ib))
+                  safe=.false.
+                else
+                  lexsit(ib1,nexsit(ib1))=ib-isite
+                  lexsit(ib,nexsit(ib))=ib1-isite
+                endif
+              endif
+
+            endif
+
+            if(ia.eq.ib1)then
+
+c     check interaction not already included
+          
+              lchk=.true.
+              do jz=1,min(nexsit(ia1),mxexcl)
+                if(lexsit(ia1,jz).eq.ib-isite)lchk=.false.
+              enddo
+              if(lchk)then
+                nexsit(ia1)=nexsit(ia1)+1
+                nexsit(ib)=nexsit(ib)+1
+                if(max(nexsit(ia1),nexsit(ib)).gt.mxexcl)then
+                  ibig=max(ibig,nexsit(ia1),nexsit(ib))
+                  safe=.false.
+                else
+                  lexsit(ia1,nexsit(ia1))=ib-isite
+                  lexsit(ib,nexsit(ib))=ia1-isite
+                endif
+              endif
+
+            endif
+
+            if(ib.eq.ia1)then
+
+c     check interaction not already included
+          
+              lchk=.true.
+              do jz=1,min(nexsit(ia),mxexcl)
+                if(lexsit(ia,jz).eq.ib1-isite)lchk=.false.
+              enddo
+              if(lchk)then
+                nexsit(ia)=nexsit(ia)+1
+                nexsit(ib1)=nexsit(ib1)+1
+                if(max(nexsit(ia),nexsit(ib1)).gt.mxexcl)then
+                  ibig=max(ibig,nexsit(ia),nexsit(ib1))
+                  safe=.false.
+                else
+                  lexsit(ia,nexsit(ia))=ib1-isite
+                  lexsit(ib1,nexsit(ib1))=ia-isite
+                endif
+              endif
+
+            endif
+            if(ib.eq.ib1)then
+
+c     check interaction not already included
+          
+              lchk=.true.
+              do jz=1,min(nexsit(ia),mxexcl)
+                if(lexsit(ia,jz).eq.ia1-isite)lchk=.false.
+              enddo
+              if(lchk)then
+                nexsit(ia)=nexsit(ia)+1
+                nexsit(ia1)=nexsit(ia1)+1
+                if(max(nexsit(ia),nexsit(ia1)).gt.mxexcl)then
+                  ibig=max(ibig,nexsit(ia),nexsit(ia1))
+                  safe=.false.
+                else
+                  lexsit(ia,nexsit(ia))=ia1-isite
+                  lexsit(ia1,nexsit(ia1))=ia-isite
+                endif
+              endif
+
+            endif
+
+          enddo
+          
+c     exclude sites on basis of rigid units involving  core or shell
+          
+          igrp=igrp-numgrp(itmols)
+          do kk=1,numgrp(itmols)
+          
+            igrp=igrp+1
+          
+            id=listyp(igrp)
+          
+            do jj=1,numgsit(id)
+            
+              ia1=lstgst(igrp,jj)+isite
+              if(ia1.eq.ia)then
+
+                do jk=1,numgsit(id)
+            
+                  if(jk.ne.jj)then
+                    ib1=lstgst(igrp,jk)+isite
+
+c     check interaction not already included
+          
+                    lchk=.true.
+                    do jz=1,min(nexsit(ib1),mxexcl)
+                      if(lexsit(ib1,jz).eq.ib-isite)lchk=.false.
+                    enddo
+                    if(lchk)then
+                      nexsit(ib1)=nexsit(ib1)+1
+                      nexsit(ib)=nexsit(ib)+1
+                      if(max(nexsit(ib1),nexsit(ib)).gt.mxexcl)then
+                        ibig=max(ibig,nexsit(ib1),nexsit(ib))
+                        safe=.false.
+                      else
+                        lexsit(ib1,nexsit(ib1))=ib-isite
+                        lexsit(ib,nexsit(ib))=ib1-isite
+                      endif
+                    endif
+
+                  endif
+
+                enddo
+                
+              endif
+
+              if(ia1.eq.ib)then
+
+                do jk=1,numgsit(id)
+            
+                  if(jk.ne.jj)then
+                    ib1=lstgst(igrp,jk)+isite
+
+c     check interaction not already included
+          
+                    lchk=.true.
+                    do jz=1,min(nexsit(ia),mxexcl)
+                      if(lexsit(ia,jz).eq.ib1-isite)lchk=.false.
+                    enddo
+                    if(lchk)then
+                      nexsit(ia)=nexsit(ia)+1
+                      nexsit(ib1)=nexsit(ib1)+1
+                      if(max(nexsit(ia),nexsit(ib1)).gt.mxexcl)then
+                        ibig=max(ibig,nexsit(ia),nexsit(ib1))
+                        safe=.false.
+                      else
+                        lexsit(ia,nexsit(ia))=ib1-isite
+                        lexsit(ib1,nexsit(ib1))=ia-isite
+                      endif
+
+                    endif
+
+                  endif
+
+                enddo
+                
+              endif
+
+            enddo
+
+          enddo
+
+        enddo
+
+        isite=isite+numsit(itmols)
+        
+      enddo
+      
+      ntpsit=isite
+
+c     check for exceeded array bounds
+      
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)then
+        if(mxnode.gt.1)call gimax(ibig,1,jj)
+        if(idnode.eq.0)write(nrite,*)'mxexcl must be at least ',ibig
+        if(idnode.eq.0)write(nrite,*)'mxexcl is currently     ',mxexcl
+        call error(idnode,65)
+      endif
+
+c     remove redundant entries from exclusion list
+c     (there shouldn't be any!)
+      
+      do i=1,ntpsit
+        
+        nlast=nexsit(i)
+        do j=1,nexsit(i)-1
+          
+          if(j.lt.nlast)then
+            
+            kk=j
+            do k=j+1,nexsit(i)
+              
+              if(lexsit(i,j).eq.lexsit(i,k))then
+                
+                nlast=nlast-1
+                lexsit(i,k)=0
+                
+              else if(lexsit(i,k).gt.0)then
+                
+                kk=kk+1
+                lexsav=lexsit(i,k)
+                lexsit(i,k)=0
+                lexsit(i,kk)=lexsav
+                
+              endif
+              
+            enddo
+            
+          endif
+          
+        enddo
+        
+        nexsit(i)=nlast
+        
+      enddo
+
+      
+      return
+      end subroutine exclude
+
+      subroutine excludeneu(idnode,mxnode,nneut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the excluded pair
+c     interaction list of the system to be simulated
+c     part 2 - neutral group implementation
+c     
+c     copyright - daresbury laboratory     1994
+c     author    - t. forester        march 1994
+c     
+c***********************************************************************
+      implicit none
+
+      logical lchk
+      integer idnode,mxnode,nneut,ibig,iatom,jatom,last,mpm2
+      integer npm2,m,ii,im,itmols,inoff,isoff,isit,iolsit,jm,jtmols
+      integer jnoff,jsoff,jsit,jolsit,jn1,jno1,jsite,jsite0,in1,ino1
+      integer jj0,isite,ij,idum,it
+      
+c     construct excluded pair list for verlet neighbour correction
+
+      ibig=0
+      iatom=0
+      jatom=0
+
+c     generate all atomic pairs and check for exclusions 
+c     with Brode Ahlrichs ordering of groups
+      
+      last=nneut
+      lchk=.true.
+      mpm2=nneut/2+1
+      npm2=(nneut-1)/2+1
+      
+c     outer loop over groups
+      
+      do m=1,mpm2
+        
+        if(m.gt.npm2)last=mpm2-1
+        
+c     inner loop over groups - include intragroup interactions
+        
+        ii=0
+        
+        do im=idnode+1,last,mxnode
+          
+          ii=ii+1
+
+c     first site in neutral group
+          
+          itmols=1
+          inoff=0
+          isoff=0
+          isit=numsit(itmols)*nummols(itmols)
+          iolsit=numsit(itmols)
+          
+c     calculate j group indices
+          
+          jm=im+m-1
+          if(jm.gt.nneut)jm=jm-nneut
+          
+c     inner loop over neutral groups
+          
+          jtmols=1
+          jnoff=0
+          jsoff=0
+          jsit=numsit(jtmols)*nummols(jtmols)
+          jolsit=numsit(jtmols)
+          
+c     test first sites in neutral group
+          
+          jatom=neulst(jm)        
+
+c     establish pointer to sets
+          
+          do while(jatom.gt.jsit)
+            
+            jtmols=jtmols+1
+            jnoff=jsit
+            jsoff=jsoff+jolsit
+            jsit=jsit+nummols(jtmols)*numsit(jtmols)
+            jolsit=numsit(jtmols)
+            
+          enddo
+          
+          jn1=jatom-jnoff
+          jno1=(jn1/jolsit)*jolsit
+          jsite=jn1-jno1
+          if(jsite.eq.0)then 
+            jsite=jolsit
+            jno1=jno1-jolsit
+          endif
+          jsite=jsite+jsoff
+          jsite0=jsite-1
+          
+          do iatom=neulst(im),neulst(im+1)-1
+            
+c     establish pointer to sets
+            
+            do while(iatom.gt.isit)
+              
+              itmols=itmols+1
+              inoff=isit
+              isoff=isoff+iolsit
+              isit=isit+nummols(itmols)*numsit(itmols)
+              iolsit=numsit(itmols)
+              
+            enddo
+            
+            in1=iatom-inoff
+            ino1=(in1/iolsit)*iolsit
+            isite=in1-ino1
+            if(isite.eq.0)then 
+              isite=iolsit
+              ino1=ino1-iolsit
+            endif
+            isite=isite+isoff
+            
+c     test im and jm are neutral groups on same molecule
+            
+            if((jnoff.eq.inoff).and.(ino1.eq.jno1))then
+            if(abs(im-jm).lt.iolsit)then
+              
+              jj0=neulst(jm)
+              jsite=jsite0
+              
+c     special case for im=jm (ie. same group)
+              
+              if(im.eq.jm)then 
+                
+                jj0=iatom+1
+                jsite=isite
+                
+              endif
+
+c     test for excluded interaction
+              
+              do jatom=jj0,neulst(jm+1)-1
+                
+                jsite=jsite+1
+                
+                do ij=1,nexsit(isite)
+                  
+                  if(lexsit(isite,ij).eq.jsite-jsoff)then
+                    
+                    it=nexatm(ii)
+                    
+                    if(it+2.gt.mxexcl)then
+                      
+                      ibig=max(it+2,ibig)
+                      nexatm(ii)=it+2
+                      lchk=.false.
+                      
+                    else
+                      
+                      lexatm(ii,it+1)=iatom
+                      lexatm(ii,it+2)=jatom
+                      nexatm(ii)=nexatm(ii)+2
+                      
+                    endif
+
+                  endif
+                  
+                enddo
+                
+              enddo
+              
+            endif
+            endif
+            
+          enddo
+          
+        enddo
+        
+      enddo
+
+c     global check
+      
+      call gstate(lchk)
+      if(.not.lchk)then
+        
+        if(mxnode.gt.1)call gimax(ibig,1,idum)
+        if(idnode.eq.0)write(nrite,*)'mxexcl must be at least ',ibig
+        if(idnode.eq.0)write(nrite,*)'mxexcl is currently     ',mxexcl
+        call error(idnode,260)
+
+      endif
+      
+      return
+      end subroutine excludeneu
+
+      subroutine exclude_link(idnode,mxnode,ntpmls)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the excluded pair
+c     interaction list of the system to be simulated
+c     
+c     part 2 - link cell implementation
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith        june 1992
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,ntpmls,iatom,jatom,lsite,ksite
+      integer itmols,imols,isite,kk,newatm,k
+
+c     construct excluded pair list for verlet neighbour correction
+      
+      iatom=0
+      jatom=0
+      lsite=0
+      ksite=0
+      
+      do itmols=1,ntpmls
+        
+        do imols=1,nummols(itmols)
+          
+          do isite=1,numsit(itmols)
+            
+            iatom=iatom+1
+            
+            if(mod(iatom-1,mxnode).eq.idnode)then
+              
+              kk=0
+              jatom=jatom+1
+              
+              do k=1,nexsit(ksite+isite)
+                
+                newatm=lexsit(ksite+isite,k)+lsite
+                
+                kk=kk+1
+                lexatm(jatom,kk)=newatm
+                
+              enddo
+              
+              nexatm(jatom)=kk
+              
+            endif
+            
+          enddo
+          
+          lsite=lsite+numsit(itmols)
+          
+        enddo
+        
+        ksite=ksite+numsit(itmols)
+        
+      enddo
+      
+      return
+      end subroutine exclude_link
+
+      subroutine exclude_atom(idnode,mxnode,natms,ntpmls)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the excluded pair
+c     interaction list of the system to be simulated
+c     part 2 
+c
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith        june 1992
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms,ntpmls,iatom,jatom,lsite
+      integer ksite,itmols,isite,imols,k,kk,newatm,j,latom,i,ii
+
+c     construct excluded pair list for verlet neighbour correction
+      
+      iatom=0
+      jatom=0
+      lsite=0
+      ksite=0
+      
+      do itmols=1,ntpmls
+        
+        do imols=1,nummols(itmols)
+          
+          do isite=1,numsit(itmols)
+            
+            iatom=iatom+1
+            
+            if(mod(iatom-1,mxnode).eq.idnode)then
+              
+              kk=0
+              jatom=jatom+1
+              
+              do k=1,nexsit(ksite+isite)
+                
+                newatm=lexsit(ksite+isite,k)+lsite
+
+c     keep only brode-ahlrichs combinations of indices
+                
+                if(((newatm.gt.iatom).and.
+     x            (newatm-iatom.le.natms/2)).or.
+     x            ((newatm.lt.iatom).and.
+     x            (newatm+natms-iatom.le.(natms-1)/2)))then
+                  
+                  kk=kk+1
+                  lexatm(jatom,kk)=newatm
+                  
+                  if(kk.gt.1)then
+                    
+c     sort the excluded atom list in ascending indices
+
+                    do j=kk,2,-1
+                      
+                      if(lexatm(jatom,j).lt.lexatm(jatom,j-1))
+     x                  then
+                        latom=lexatm(jatom,j)
+                        lexatm(jatom,j)=lexatm(jatom,j-1)
+                        lexatm(jatom,j-1)=latom
+                      endif
+                      
+                    enddo
+                    
+                  endif
+                  
+                endif
+                
+              enddo
+              
+              nexatm(jatom)=kk
+              
+            endif
+            
+          enddo
+          
+          lsite=lsite+numsit(itmols)
+          
+        enddo
+        
+        ksite=ksite+numsit(itmols)
+        
+      enddo
+      
+c     final sort into brode-ahlrichs ordering
+      
+      ii=0
+      do i=1+idnode,natms,mxnode
+        
+        ii=ii+1
+        do j=1,nexatm(ii)
+          
+          if(lexatm(ii,1).lt.i)then
+            
+            latom=lexatm(ii,1)
+            
+            do k=1,nexatm(ii)-1
+              
+              lexatm(ii,k)=lexatm(ii,k+1)
+              
+            enddo
+            
+            lexatm(ii,nexatm(ii))=latom
+            
+          endif
+          
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine exclude_atom
+
+      subroutine exclude_copy_mtd(idnode)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for copying excluded atom arrays into 
+c     the metadynamics module for use in computing order parameters
+c
+c     author    - d. quigley    April 2012
+c     
+c***********************************************************************
+      use metafreeze_module, only : mtd_lexatm,mtd_nexatm
+      implicit none
+      integer, parameter :: nnn=2
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+c     data needed by metadynamics module
+      allocate (mtd_lexatm(msatms,mxexcl),stat=fail(1))
+      allocate (mtd_nexatm(msatms)       ,stat=fail(2))
+
+      do i=1,nnn
+        if(fail(i).gt.0) call error(idnode,1012)
+      enddo
+
+
+c     copy exclude list into metafreeze module
+      mtd_nexatm = nexatm
+      mtd_lexatm = lexatm
+
+      return
+      end subroutine exclude_copy_mtd
+      
+      end module exclude_module
+
diff -urN dl_class_1.9.orig/srcmod/external_field_module.f dl_class_1.9/srcmod/external_field_module.f
--- dl_class_1.9.orig/srcmod/external_field_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/external_field_module.f	2014-02-27 13:49:34.000000000 +0100
@@ -0,0 +1,347 @@
+      module external_field_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining external field potential arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    oct 2003
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use parse_module
+      use setup_module
+      use utility_module
+      
+      implicit none
+      
+      real(8), allocatable :: prmfld(:)
+      
+      save prmfld
+      
+      contains
+      
+      subroutine alloc_fld_arrays(idnode)
+      
+      implicit none
+      
+      integer fail,idnode
+      
+      data fail/0/
+      
+      allocate (prmfld(mxfld),stat=fail)
+      if(fail.ne.0)call error(idnode,1200)
+      
+      end subroutine alloc_fld_arrays
+      
+      subroutine define_external_field
+     x  (safe,lunits,idnode,keyfld,engunit)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine to define external fields
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     amended   - p.-l. chau  jun 2009 z-restraint option
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lunits
+      character*8 keyword
+      character*1 message(80)
+      integer idnode,keyfld,nfld,i,k,idum
+      real(8) engunit
+      
+      call getrec(safe,idnode,nfield)
+      if(.not.safe)return
+      
+      call strip(record,lenrec)
+      call lowcase(record,lenrec)
+      call copystring(record,message,80)
+      call getword(keyword,record,4,lenrec)
+      
+      if(keyword(1:4).eq.'elec') then
+        keyfld=1 
+      elseif(keyword(1:4).eq.'oshr') then
+        keyfld=2
+      elseif(keyword(1:4).eq.'shrx') then
+        keyfld=3
+      elseif(keyword(1:4).eq.'grav') then
+        keyfld=4
+      elseif(keyword(1:4).eq.'magn') then
+        keyfld=5
+      elseif(keyword(1:4).eq.'sphr') then
+        keyfld=6
+      elseif(keyword(1:4).eq.'zbnd') then
+        keyfld=7
+      elseif(keyword(1:4).eq.'zres') then
+        keyfld=9
+      else
+        if(idnode.eq.0) write(nrite,*) message
+        call error(idnode,454)
+      endif
+      
+      do i=1,mxfld
+        prmfld(i)=0.d0
+      enddo
+      
+      nfld=intstr(record,lenrec,idum)
+      if(nfld.eq.0)nfld=5
+      call getrec(safe,idnode,nfield)
+      if(.not.safe)return
+      do k=1,nfld
+        
+        prmfld(k)=dblstr(record,lenrec,idum)
+        if(idum.gt.lenrec.and.k.lt.nfld)then
+          
+          call getrec(safe,idnode,nfield)
+          if(.not.safe)return
+          
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0) then
+        
+        write(nrite,"(/,/,1x,'external field key ',13x,a4,
+     x    /,/,30x,'external field parameters')") keyword(1:4)
+        write(nrite,"(2(/,1x,1p,5e15.5))") prmfld
+        
+      endif      
+      
+c     convert to internal units
+      
+      if(keyfld.eq.1.or.keyfld.eq.4.or.keyfld.eq.5) then
+        
+        if(.not.lunits)call error(idnode,6)
+        
+        do i=1,3
+          prmfld(i)=prmfld(i)*engunit
+        enddo
+        
+      elseif(keyfld.eq.2.or.keyfld.eq.6.or.keyfld.eq.7) then
+        
+        prmfld(1)=prmfld(1)*engunit
+        
+      elseif(keyfld.eq.9) then
+        
+        prmfld(3)=prmfld(3)*engunit
+        
+      endif
+      
+      return
+      end subroutine define_external_field
+      
+      subroutine extnfld
+     x  (idnode,imcon,keyfld,mxnode,natms,engfld,virfld)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for application of an external field
+c     
+c     replicated data version / block data
+c     
+c     copyright daresbury laboratory 1993
+c     author  -    t.forester october 1993
+c     amended -    t.forester dec 1994
+c     amended -    p.-l. chau jun 2009 z-restraint option
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer idnode,imcon,keyfld,mxnode,natms,iatm1,iatm2,i,j
+      integer istart,ifinish,numresat
+      real(8) engfld,virfld,rz,rrr,gamma,zdif,totwgt
+      real(8) com(3)
+      
+c     energy and virial accumulators 
+      
+      engfld=0.d0
+      virfld=0.d0
+      
+c     block indices
+      
+      iatm1=(idnode*natms)/mxnode+1
+      iatm2=((idnode+1)*natms)/mxnode
+      
+      if(keyfld.eq.1) then
+        
+c     electric field: prmfld(1-3) are field components
+        
+        do i=iatm1,iatm2
+          
+          fxx(i)=fxx(i)+chge(i)*prmfld(1)
+          fyy(i)=fyy(i)+chge(i)*prmfld(2)
+          fzz(i)=fzz(i)+chge(i)*prmfld(3)
+          
+        enddo
+        
+      elseif(keyfld.eq.2) then
+        
+c     oscillating shear: orthorhombic box:  Fx=a*cos(b.2.pi.z/L)
+        
+        rz=2.d0*pi/cell(9)
+        
+        do i=iatm1,iatm2
+          
+          fxx(i)=fxx(i)+prmfld(1)*cos(prmfld(2)*zzz(i)*rz)
+          
+        enddo
+        
+      elseif(keyfld.eq.3.and.imcon.eq.6) then
+        
+c     continuous shear of walls : 2D periodic box (imcon=6)
+c     shear rate=prmfld(1) angstrom per ps for atoms at
+c     abs(z) > prmfld(2)
+        
+        do i=iatm1,iatm2
+          
+          if(abs(zzz(i)).gt.prmfld(2)) then
+            
+            vxx(i)=0.5d0*sign(prmfld(1),zzz(i))
+            
+          endif
+          
+        enddo
+        
+      elseif(keyfld.eq.4) then
+        
+c     gravitational field: field components given by prmfld(1-3)
+        
+        do i=iatm1,iatm2
+          
+          fxx(i)=fxx(i)+prmfld(1)*weight(i)
+          fyy(i)=fyy(i)+prmfld(2)*weight(i)
+          fzz(i)=fzz(i)+prmfld(3)*weight(i)
+          
+        enddo
+        
+      elseif(keyfld.eq.5) then
+        
+c     magnetic field: field components given by prmfld(1-3)
+        
+        do i=iatm1,iatm2
+          
+          fxx(i)=fxx(i)+(vyy(i)*prmfld(3)-vzz(i)*prmfld(2))
+     x      *chge(i)
+          fyy(i)=fyy(i)+(vzz(i)*prmfld(1)-vxx(i)*prmfld(3))
+     x      *chge(i)
+          fzz(i)=fzz(i)+(vxx(i)*prmfld(2)-vyy(i)*prmfld(1))
+     x      *chge(i)
+          
+        enddo
+        
+      elseif(keyfld.eq.6) then
+        
+c     containing sphere : r^(-n) potential
+        
+        do i=iatm1,iatm2
+          
+          rrr=sqrt(xxx(i)**2+yyy(i)**2+zzz(i)**2)
+          if(rrr.gt.prmfld(4)) then
+            rrr=prmfld(2)-rrr
+            if(rrr.lt.0.d0) rrr=0.1d0
+            
+            gamma =prmfld(1)*rrr**(-prmfld(3))
+            engfld=engfld+gamma
+            
+            gamma=-prmfld(3)*gamma/((prmfld(2)-rrr)*rrr)
+            
+            fxx(i)=fxx(i)+gamma*xxx(i)
+            fyy(i)=fyy(i)+gamma*yyy(i)
+            fzz(i)=fzz(i)+gamma*zzz(i)
+            
+          endif
+          
+        enddo
+        
+      elseif(keyfld.eq.7) then
+        
+c     repulsive wall (harmonic) starting at z0
+        
+        do i=iatm1,iatm2
+          
+          if(prmfld(3)*zzz(i).gt.prmfld(3)*prmfld(2)) then
+            
+            zdif=zzz(i)-prmfld(2)
+            gamma=-prmfld(1)*zdif
+            
+            fzz(i)=fzz(i)+gamma
+            engfld=engfld-gamma*zdif/2.
+            
+          endif
+          
+        enddo
+        
+      elseif(keyfld.eq.9) then
+        
+c     keyfld=9. restrain molecule z-position
+c     prmfld(1) is number of first atom of restrained molecule
+c     prmfld(2) is number of last atom of restrained molecule
+c     prmfld(3) is the restraining constant
+c     prmfld(4) is z-min
+c     prmfld(5) is z-max
+        
+        istart=nint(prmfld(1))
+        ifinish=nint(prmfld(2))
+        numresat=ifinish-istart+1
+        
+c     calculate the centre of mass of the molecule
+        
+        call getcom_mol(istart,ifinish,imcon,idnode,mxnode,totwgt,com)
+        
+c     apply restraint force according to location
+        
+        if(com(3).lt.prmfld(4))then
+          
+c     if centre of mass is below z-min, activate restraining force
+          
+          do i=istart,ifinish
+            
+            fzz(i)=fzz(i)-prmfld(3)*(weight(i)/totwgt)*
+     x        (com(3)-prmfld(4))/mxnode
+            
+          enddo
+          
+        elseif(com(3).gt.prmfld(5))then
+          
+c     if centre of mass if above z-max, activate restraining force
+          
+          do i=istart,ifinish
+            
+            fzz(i)=fzz(i)-prmfld(3)*(weight(i)/totwgt)*
+     x        (com(3)-prmfld(5))/mxnode
+            
+          enddo
+          
+        endif
+        
+      else
+        
+c     unidentified field potential error exit
+        
+        call error(idnode,454)
+        
+      endif
+      
+c     global sum of external field potential and virial
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engfld
+        buffer(2)=virfld
+        call gdsum(buffer(1),2,buffer(3))
+        engfld=buffer(1)
+        virfld=buffer(2)
+        
+      endif
+      
+      return
+      end subroutine extnfld
+      
+      end module external_field_module
diff -urN dl_class_1.9.orig/srcmod/forces_module.f dl_class_1.9/srcmod/forces_module.f
--- dl_class_1.9.orig/srcmod/forces_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/forces_module.f	2015-11-07 16:58:03.490054852 +0100
@@ -0,0 +1,2959 @@
+      module forces_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for calculation of atomic forces
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     adapted   - d. quigley : metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use coulomb_module
+      use error_module
+      use ewald_module
+      use exclude_module
+      use external_field_module
+      use four_body_module
+      use hkewald_module
+      use metafreeze_module
+      use metal_module
+      use neu_coul_module
+      use nlist_builders_module
+      use pair_module
+      use property_module
+      use setup_module
+      use solvation_module
+      use spme_module
+      use tersoff_module
+      use three_body_module
+      use utility_module
+      use vdw_module
+      
+      contains
+      
+      subroutine force_manager
+     x  (newlst,lneut,lnsq,lgofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x  lghost,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x  numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x  ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x  keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x  isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x  vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x  rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x  virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x  virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x  engcfg,fmax,temp,engord,virord)
+      
+c*********************************************************************
+c     
+c     dl_poly subroutine to manage the calculation of the atomic forces
+c     from all force field terms.
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      logical newlst,lneut,lnsq,lgofr,lzeql,loglnk,lfcap,lsolva
+      logical lfree,lghost,llsolva
+      
+      integer idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,numrdf
+      integer keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,ntpmet
+      integer i,nospl,multt,nneut,ntbond,ntangl,ntdihd,nsolva,isolva
+      integer ntinv,ntteth,ntshl,ntptbp,ntpfbp,ntpter,keyshl,keyfld
+      
+      real(8) delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw
+      real(8) vircpe,virsrp,alpha,drewd,volm,engmet,virmet
+      real(8) elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp
+      real(8) rctter,engter,virter,engbnd,virbnd,engang,virang,engdih
+      real(8) virdih,enginv,virinv,engtet,virtet,engshl,virshl,engfld
+      real(8) virfld,fmax,temp,shlke,engcfg,tmpeng,tmpvir,engord,virord
+      
+      llsolva=.false.
+      
+c     initialize energy and virial accumulators
+      
+      engbnd=0.d0
+      virbnd=0.d0
+      engang=0.d0
+      virang=0.d0
+      engdih=0.d0
+      virdih=0.d0
+      enginv=0.d0
+      virinv=0.d0
+      engtbp=0.d0
+      virtbp=0.d0
+      engter=0.d0
+      virter=0.d0
+      engfbp=0.d0
+      virfbp=0.d0
+      engsrp=0.d0
+      virsrp=0.d0
+      engcpe=0.d0
+      vircpe=0.d0
+      engfld=0.d0
+      virfld=0.d0
+      engshl=0.d0
+      virshl=0.d0
+      shlke =0.d0
+      engtet=0.d0
+      virtet=0.d0
+      engmet=0.d0
+      virmet=0.d0
+      virord=0.0d0
+      engord=0.0d0
+      
+      if(lmetadyn)then
+        
+        eng_loc=0.0d0
+        vir_loc=0.0d0
+        fxx_loc(:)=0.0d0
+        fyy_loc(:)=0.0d0
+        fzz_loc(:)=0.0d0
+        stress_loc(:)=0.0d0
+        
+      endif
+      
+c     initialise free energy accumulators
+      
+      if(lfree)then
+        
+        ang_fre=0.d0
+        bnd_fre=0.d0
+        dih_fre=0.d0
+        inv_fre=0.d0
+        tbp_fre=0.d0
+        fbp_fre=0.d0
+        cou_fre=0.d0
+        vdw_fre=0.d0
+        shl_fre=0.d0
+        ang_vir=0.d0
+        bnd_vir=0.d0
+        dih_vir=0.d0
+        inv_vir=0.d0
+        tbp_vir=0.d0
+        fbp_vir=0.d0
+        cou_vir=0.d0
+        vdw_vir=0.d0
+        shl_vir=0.d0
+        eng_cfg_fre=0.d0
+        vir_cfg_fre=0.d0
+        
+      endif
+      
+c     initialise solvation and excitation arrays
+      
+      if(lsolva)then
+        
+        if(keyfce/2.gt.0)lcomp(6)=.true.
+        if(mod(keyfce,2).eq.1)lcomp(7)=.true.
+        if(mod(nstep-nsolva,isolva).eq.0)then
+          
+          llsolva=.true.
+          cou_sol(:)=0.d0
+          vdw_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            cou_exc(:)=0.d0
+            vdw_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     initialise the force arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+c     zero stress tensor
+      
+      if(nstep.gt.0)then
+        
+        do i=1,9
+          stress(i)=0.d0
+        enddo
+        
+      endif
+      
+      if(keyfce.gt.0)then
+        
+c     calculate pair forces, including coulombic forces
+        
+        if(lnsq)then
+          
+c     multiple timestep - all-pairs
+          
+          call multiple_nsq
+     x      (lnsq,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x      imcon,keyfce,multt,mxnode,natms,nstep,nstbgr,nsteql,
+     x      numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x      rcut,rprim,rvdw,vircpe,virsrp)
+          
+        elseif(.not.lneut)then         
+          
+c     single timestep
+          
+          if(multt.eq.1)then
+            
+            call forces
+     x        (loglnk,lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,
+     x        keyfce,kmax1,kmax2,kmax3,nhko,nlatt,mxnode,ntpvdw,
+     x        ntpmet,natms,nstbgr,nstep,nsteql,numrdf,nospl,nsolva,
+     x        isolva,alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rvdw,
+     x        vircpe,virsrp,volm,engmet,virmet)
+            
+          else
+            
+            call multiple
+     x        (loglnk,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x        imcon,keyfce,nlatt,kmax1,kmax2,kmax3,nhko,multt,
+     x        mxnode,natms,nstep,nstbgr,nsteql,numrdf,nospl,nsolva,
+     x        isolva,alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rprim,
+     x        rvdw,vircpe,virsrp,volm)
+            
+          endif
+          
+        elseif(lneut)then
+          
+c     neutral groups
+          
+          if(multt.eq.1)then
+            
+            call forces_neu
+     x        (lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,keyfce,
+     x        mxnode,natms,nneut,nstbgr,nstep,nsteql,numrdf,nsolva,
+     x        isolva,dlrpot,engcpe,engsrp,epsq,rcut,rvdw,alpha,
+     x        vircpe,virsrp)
+            
+          else
+            
+            call multiple_neu
+     x        (lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,imcon,
+     x        keyfce,multt,mxnode,natms,nneut,nstbgr,nstep,nsteql,
+     x        numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x        rprim,rcut,rvdw,alpha,vircpe,virsrp)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     add in long range corrections to energy and pressure
+      
+      engsrp=engsrp+elrc
+      virsrp=virsrp+virlrc
+      engmet=engmet+elrcm(0)
+      virmet=virmet+vlrcm(0)
+      if(lfree)then
+        vdw_fre=vdw_fre+elrc_fre
+        vdw_vir=vdw_vir+vlrc_fre
+      endif
+      
+c     calculate three body forces
+      
+      if(ntptbp.gt.0)call thbfrc
+     x  (llsolva,lfree,lghost,idnode,mxnode,natms,imcon,rcuttb,
+     x  engtbp,virtbp)
+      
+c     calculate four body forces
+      
+      if(ntpfbp.gt.0)call fbpfrc
+     x  (llsolva,lfree,lghost,idnode,mxnode,natms,imcon,rcutfb,
+     x  engfbp,virfbp)
+      
+c     calculate tersoff potential forces
+      
+      if(ntpter.gt.0)call tersoff
+     x  (idnode,mxnode,natms,imcon,rctter,engter,virter)
+      
+c     calculate bond forces
+      
+      if(ntbond.gt.0)call bndfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntbond,epsq,
+     x  engbnd,virbnd)
+      
+c     calculate valence angle forces
+      
+      if(ntangl.gt.0)call angfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntangl,engang,virang)
+      
+c     calculate dihedral forces
+      
+      if(ntdihd.gt.0)call dihfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntdihd,keyfce,dlrpot,
+     x  epsq,engcpe,engdih,engsrp,rcut,rvdw,alpha,vircpe,virdih,virsrp)
+      
+c     calculate inversion forces
+      
+      if(ntinv.gt.0)call invfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntinv,enginv,virinv)
+      
+c     calculate tethered atom forces
+      
+      if(ntteth.gt.0)call tethfrc
+     x  (idnode,mxnode,imcon,natms,nstep,ntteth,engtet,virtet)
+      
+c     calculate shell model forces
+      
+      if(keyshl.gt.0)call shlfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntshl,engshl,virshl)
+      
+c     external field
+      
+      if(keyfld.gt.0)call extnfld
+     x  (idnode,imcon,keyfld,mxnode,natms,engfld,virfld)
+      
+c     metadynamics option : use potential energy as order parameter
+      
+      if(lmetadyn)then
+        
+        tmpeng=engsrp+engcpe+engbnd+engang+engdih+engfld+
+     x         engtbp+engfbp+engshl+enginv+engter+engmet
+        
+        tmpvir=vircpe+virsrp+virbnd+virtbp+virter+virfld+
+     x         virang+virshl+virtet+virmet
+        
+        call metafreeze_driver
+     x    (imcon,natms,temp,nstep,tmpeng,tmpvir,engord,virord)
+        
+      endif
+      
+c     global summation of force arrays (basic replicated data strategy)
+      
+      call global_sum_forces(natms,mxnode,fxx,fyy,fzz)
+      
+c     global sum of stress arrays
+      
+      if(mxnode.gt.1)call gdsum(stress,9,buffer)
+      
+c     add long range correction to diagonal terms of stress tensor
+      
+      stress(1)=stress(1)-(virlrc+vlrcm(0))/3.d0
+      stress(5)=stress(5)-(virlrc+vlrcm(0))/3.d0
+      stress(9)=stress(9)-(virlrc+vlrcm(0))/3.d0
+      
+c     cap forces in equilibration mode
+      
+      if(nstep.le.nsteql.and.lfcap)
+     x  call fcap(lfcap,natms,fmax,temp)
+      
+c     total configuration energy
+      
+      engcfg=engsrp+engcpe+engbnd+engang+engdih+engfld+engtbp+
+     x  engfbp+engshl+enginv+engter+engmet
+     
+cPluMeD modifications
+
+      if(lplumed) call meta_force_calculation
+     x  (cell,nstep,xxx,yyy,zzz,fxx,fyy,fzz,engcfg)
+
+c PluMeD modifications
+ 
+c     total derivative of the configurational free energy
+      
+      if(lfree)then
+        
+        eng_cfg_fre=dlambda*(ang_fre+bnd_fre+dih_fre+inv_fre+
+     x    tbp_fre+fbp_fre+cou_fre+vdw_fre+shl_fre)
+        vir_cfg_fre=dlambda*(ang_vir+bnd_vir+dih_vir+inv_vir+
+     x    tbp_vir+fbp_vir+cou_vir+vdw_vir+shl_vir)
+        
+      endif
+      
+c     sum solvation and excitation energies for pair forces
+      
+      if(mxnode.gt.1)then
+        
+        if(llsolva)then
+          
+          call gdsum(vdw_sol,mxtmls_sol2,buffer)
+          call gdsum(cou_sol,mxtmls_sol2,buffer)
+          
+          if(lghost)then
+            
+            call gdsum(vdw_exc,mxtmls_exc2,buffer)
+            call gdsum(cou_exc,mxtmls_exc2,buffer)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     add long range corrections to solvation terms
+      
+      if(lsolva)then
+        
+        vdw_sol(:)=vdw_sol(:)+elrc_sol(:)
+        if(lghost)vdw_exc(:)=vdw_exc(:)+elrc_exc(:)
+        
+      endif
+      
+      return
+      end subroutine force_manager
+      
+      subroutine forces
+     x  (loglnk,lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,keyfce,
+     x  kmax1,kmax2,kmax3,nhko,nlatt,mxnode,ntpvdw,ntpmet,natms,
+     x  nstbgr,nstep,nsteql,numrdf,nospl,nsolva,isolva,alpha,dlrpot,
+     x  drewd,engcpe,engsrp,epsq,rcut,rvdw,vircpe,virsrp,volm,engmet,
+     x  virmet)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating interatomic forces
+c     using the verlet neighbour list
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     amended  - t. forester sept 1994
+c     amended  - w. smith june 1995 for metal potentials
+c     
+c     key:
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ Ewald sum                         : ewald1,2,3
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ truncated and shifted coulombic   : coul4
+c     = 10,11 ----- reaction field                    : coul3
+c     = 12,13 ----- Smoothed Particle Mesh Ewald      : ewald[_spme,2,3]
+c     = 14,15 ----- Hautman-Klein-Ewald               : hkewald1,2,3
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lgofr,lzeql,loglnk,lewald,lspme,lhke,newjob,lcshft,safe
+      logical lsolva,lfree,lghost,llsolva
+      
+      integer idnode,imcon,keyfce,kmax1,kmax2,kmax3,nhko,nlatt
+      integer mxnode,ntpvdw,natms,nstbgr,nstep,nsteql,numrdf
+      integer ntpmet,nospl,nsolva,isolva,i,j,k,ii
+      
+      real(8) alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rvdw,eps
+      real(8) vircpe,virsrp,volm,engacc,engac1,viracc,engmet,virmet
+      
+      save newjob
+      
+      data newjob/.true./
+      
+      safe=.true.
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+      lhke=(keyfce/2.eq.7)
+      lspme=(keyfce/2.eq.6)
+      lewald=(keyfce/2.eq.1)
+      lcshft=(keyfce/2.eq.4.or.keyfce/2.eq.5)
+      
+c     create ewald interpolation arrays
+      
+      if(newjob)then
+        
+        if(lhke)then
+          
+          call hkgen(idnode,nhko,nlatt,alpha,drewd,rcut)
+          
+        else if(lewald.or.lspme.or.lcshft)then
+          
+          call erfcgen(alpha,drewd,rcut)
+          
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+c     initialise force arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+c     calculate local density in metals
+      
+      if(ntpmet.gt.0)then
+        
+        call metdens
+     x    (idnode,imcon,mxnode,natms,engmet,virmet)
+        
+        stress(1)=stress(1)-virmet/3.d0
+        stress(5)=stress(5)-virmet/3.d0
+        stress(9)=stress(9)-virmet/3.d0
+        
+      endif
+      
+c     fourier contribution to coulombic forces in Ewald sum
+      
+      if(lewald)then
+        
+        call ewald1
+     x    (lsolva,llsolva,lfree,lghost,idnode,mxnode,natms,imcon,
+     x    kmax1,kmax2,kmax3,engac1,viracc,alpha,volm,epsq)
+        
+        engcpe=engcpe+engac1
+        vircpe=vircpe+viracc
+        
+      endif
+      
+c     hautman-klein-ewald method
+      
+      if(lhke)then
+        
+c     fourier terms of hk-ewald
+        
+        call hkewald1
+     x    (idnode,mxnode,natms,imcon,nhko,kmax1,kmax2,
+     x    engacc,viracc,alpha,epsq)
+        
+        engcpe=engcpe+engacc
+        vircpe=vircpe+viracc
+        
+c     real space terms of hk-ewald
+        
+        call hkewald2
+     x    (idnode,mxnode,nhko,nlatt,imcon,natms,engacc,viracc,
+     x    drewd,rcut,epsq)
+        
+        engcpe=engcpe+engacc
+        vircpe=vircpe+viracc
+        
+      endif
+      
+c     smoothed particle mesh ewald
+      
+      if(lspme)then
+        
+        call ewald_spme
+     x    (idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3,nospl,
+     x    engac1,viracc,alpha,volm,epsq)
+        
+        engcpe=engcpe+engac1
+        vircpe=vircpe+viracc
+        
+      endif
+      
+c     outer loop over atoms
+      
+      ii=0
+      
+      do i=idnode+1,natms,mxnode
+        
+        ii=ii+1
+        
+c     calculate interatomic distances
+        
+        do k=1,lentry(ii)
+          
+          j=list(ii,k)
+          ilist(k)=j
+          
+          xdf(k)=xxx(i)-xxx(j)
+          ydf(k)=yyy(i)-yyy(j)
+          zdf(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary conditions
+        
+        call images(imcon,0,1,lentry(ii),cell,xdf,ydf,zdf)
+        
+c     square of distances
+        
+        do k=1,lentry(ii)
+          
+          rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+          
+        enddo
+        
+c     calculate metal forces and potential
+        
+        if(ntpmet.gt.0)then
+          
+          call metfrc(safe,i,lentry(ii),engacc,viracc)
+          
+          engmet=engmet+engacc
+          virmet=virmet+viracc
+          
+        endif
+        
+c     calculate short range force and potential terms
+        
+        if(ntpvdw.gt.0.and.mod(keyfce,2).eq.1)then
+          
+          call srfrce
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,
+     x      rvdw,dlrpot)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+c     (real space contributions to ewald sum)
+        
+        if(lewald.or.lspme)then
+          
+          call ewald2(llsolva,lfree,lghost,i,lentry(ii),engacc,
+     x      viracc,drewd,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.2)then
+          
+          call coul2
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call coul4
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+c     accumulate radial distribution functions
+        
+        if(lgofr.and.((.not.lzeql).or.(nstep.gt.nsteql)))then
+          
+          if(mod(nstep,nstbgr).eq.0)then
+            
+            call rdf0(i,lentry(ii),rcut)
+            
+          endif
+          
+        endif
+        
+      enddo      
+      
+c     check metal interpolation is safe
+      
+      if(ntpmet.gt.0)then
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)call error(idnode,142)
+        
+      endif
+      
+c     calculate corrections for intramolecular coulomb terms in
+c     Ewald sum
+      
+      if(lewald.or.lspme.or.lhke)then
+        
+        eps=epsq
+        if(loglnk)eps=eps*2.0d0
+        
+c     outer loop over atoms
+        
+        ii=0
+        
+        do i=idnode+1,natms,mxnode
+          
+          ii=ii+1
+          
+c     calculate interatomic distances
+          
+          do k=1,nexatm(ii)
+            
+            j=lexatm(ii,k)
+            jlist(k)=j
+            
+            xdf(k)=xxx(i)-xxx(j)
+            ydf(k)=yyy(i)-yyy(j)
+            zdf(k)=zzz(i)-zzz(j)
+            
+          enddo
+          
+c     periodic boundary condition
+          
+          call images(imcon,0,1,nexatm(ii),cell,xdf,ydf,zdf)
+          
+c     calculate correction terms
+          
+          if(lhke)then
+            
+            call hkewald3(i,ii,engacc,viracc,eps)
+            
+          else
+            
+            call ewald3
+     x        (llsolva,lfree,lghost,i,ii,engacc,viracc,alpha,eps)
+            
+          endif
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        enddo
+        
+      endif
+      
+c     counter for rdf statistics outside loop structure
+      
+      if(lgofr.and.((.not.lzeql).or.(nstep.gt.nsteql)))then
+        
+        if(mod(nstep,nstbgr).eq.0)then
+          
+          numrdf=numrdf+1
+          
+        endif
+        
+      endif
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=engmet
+        buffer(6)=virmet
+        buffer(7)=vdw_fre
+        buffer(8)=cou_fre
+        buffer(9)=vdw_vir
+        buffer(10)=cou_vir
+        call gdsum(buffer(1),10,buffer(11))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        engmet=buffer(5)
+        virmet=buffer(6)
+        vdw_fre=buffer(7)
+        cou_fre=buffer(8)
+        vdw_vir=buffer(9)
+        cou_vir=buffer(10)
+        
+      endif
+      
+      return
+      end subroutine forces
+      
+      subroutine forces_neu
+     x  (lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,keyfce,
+     x  mxnode,natms,nneut,nstbgr,nstep,nsteql,numrdf,nsolva,
+     x  isolva,dlrpot,engcpe,engsrp,epsq,rcut,rvdw,alpha,
+     x  vircpe,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating interatomic forces
+c     using the verlet neighbour list
+c     neutral group implemenation - no Ewald sum option
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     
+c     modified  - t. forester april 1993
+c     key:
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ invalid
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ invalid
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lgofr,lzeql,newlst,lchk,lsolva,lfree,lghost,llsolva
+      
+      integer idnode,imcon,keyfce,mxnode,natms,nneut,nstbgr
+      integer nstep,nsteql,numrdf,i,fail,jneu,jj0,jj1,j
+      integer ibig,ia,ineu,isn,ik,nsolva,isolva
+      real(8) dlrpot,engcpe,engsrp,epsq,rcut,rvdw,vircpe
+      real(8) virsrp,engacc,viracc,anorm,alpha
+      
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      
+      dimension fail(2)
+      
+      data fail/0,0/
+      
+c     allocate working arrays
+      
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(1))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(2))
+      do i=1,2
+        if(fail(i).ne.0)call error(idnode,1820)
+      enddo
+      
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+      
+c     initialise force and stress arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=0.d0
+      enddo
+      
+c     initialise energy and virial accumulators
+      
+      engcpe=0.d0
+      engsrp=0.d0
+      vircpe=0.d0
+      virsrp=0.d0
+      
+c     intra group vectors com
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-xxx(jj0)
+          tyy(j)=yyy(j)-yyy(jj0)
+          tzz(j)=zzz(j)-zzz(jj0)
+          
+        enddo
+        
+      enddo
+      
+      call images(imcon,0,1,natms,cell,txx,tyy,tzz)
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          xxx(j)=txx(j)+xxx(jj0)
+          yyy(j)=tyy(j)+yyy(jj0)
+          zzz(j)=tzz(j)+zzz(jj0)
+          
+        enddo
+        
+c     centre of molecule
+        
+        uxx(jneu)=0.d0
+        uyy(jneu)=0.d0
+        uzz(jneu)=0.d0
+        anorm=1.d0/dble(jj1-jj0+1)
+        
+        do j=jj0,jj1
+          
+          uxx(jneu)=uxx(jneu)+xxx(j)*anorm
+          uyy(jneu)=uyy(jneu)+yyy(j)*anorm
+          uzz(jneu)=uzz(jneu)+zzz(j)*anorm
+          
+        enddo
+        
+c     vector from site to geometric centre
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-uxx(jneu)
+          tyy(j)=yyy(j)-uyy(jneu)
+          tzz(j)=zzz(j)-uzz(jneu)
+          
+        enddo
+        
+      enddo
+      
+c     outer loop over neutral groups
+      
+      lchk=.true.
+      ibig=0
+      ia=0
+      
+      do ineu=idnode+1,nneut,mxnode
+        
+        ia=ia+1
+        
+c     calculate interatomic distances
+        
+        newlst=.true.
+        
+        isn=1
+        call neutlst
+     x    (newlst,lchk,isn,imcon,idnode,ineu,ia,ik,
+     x    txx,tyy,tzz,uxx,uyy,uzz)
+        
+c     trap possible array bound exception 
+        
+        ibig=max(ibig,ik)
+        if(ik.gt.mxxdf)ik=0
+        
+c     calculate short range force and potential terms
+        
+        if(mod(keyfce,2).eq.1)then
+          
+          call srfrceneu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,dlrpot,rvdw)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+        
+        if(keyfce/2.eq.2)then
+          
+          call coul2neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call error(idnode,250)
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq,rcut,alpha)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+c     accumulate radial distribution functions
+        
+        if( ((.not.lzeql).or.(nstep.gt.nsteql)).and.(lgofr).and.
+     x    mod(nstep,nstbgr).eq.0)then
+          
+          call rdf0neu(ik,rcut)
+          
+        endif
+        
+      enddo
+      
+c     check on validity of call to neutlst
+      
+      if(mxnode.gt.1)call gstate(lchk)
+      if(.not.lchk)then 
+        call gimax(ibig,1,i)
+        if(idnode.eq.0)write(nrite,*)'mxxdf must be at least ',ibig
+        if(idnode.eq.0)write(nrite,*)'mxxdf is currently ',mxxdf
+        call  error(idnode,478)
+      endif
+      
+      if(keyfce/2.eq.1.or.keyfce/2.eq.6)call error(idnode,250)
+      
+c     counter for rdf statistics outside loop structure
+      
+      if( ((.not.lzeql).or.(nstep.gt.nsteql)).and.(lgofr).and.
+     x  mod(nstep,nstbgr).eq.0)numrdf=numrdf+1
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=vdw_fre
+        buffer(6)=cou_fre
+        buffer(7)=vdw_vir
+        buffer(8)=cou_vir
+        call gdsum(buffer(1),8,buffer(9))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        vdw_fre=buffer(5)
+        cou_fre=buffer(6)
+        vdw_vir=buffer(7)
+        cou_vir=buffer(8)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,stat=fail(2))
+      
+      return
+      end subroutine forces_neu
+      
+      subroutine multiple
+     x  (loglnk,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x  imcon,keyfce,nlatt,kmax1,kmax2,kmax3,nhko,multt,
+     x  mxnode,natms,nstep,nstbgr,nsteql,numrdf,nospl,nsolva,
+     x  isolva,alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rprim,
+     x  rvdw,vircpe,virsrp,volm)
+c***************************************************************************
+c     
+c     dl_poly subroutine for multiple time step algorithm
+c     reciprocal space calculated on long time steps.
+c     
+c     copyright daresbury laboratory
+c     
+c     author  t. forester,  may 1993
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ Ewald sum                         : ewald1,2,3,4
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ truncated and shifted coulombic   : coul4
+c     = 10,11 ----- reaction field                    : coul3
+c     = 12,13 ----- Smoothed Particle Mesh Ewald      : ewald[_spme,2,3,4]
+c     = 14,15 ----- Hautman-Klein-Ewald               : hkewald1,2,3,4
+c     
+c****************************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=5
+
+      logical newplst,newlst,lgofr,lzeql,lgr,loglnk,lewald,lspme
+      logical lhke,newjob,lcshft,lsolva,lfree,lghost,llsolva
+      integer idnode,imcon,keyfce,nlatt,kmax1,kmax2,kmax3,nhko,multt
+      integer mxnode,natms,nstep,nstbgr,nsteql,numrdf,nospl,fail
+      integer numlsts,i,nstep0,nsolva,isolva,ii,k,j,ik
+      real(8) alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rprim,rvdw
+      real(8) vircpe,virsrp,volm,stresp,engcpl,engacc,viracc,engac1
+      real(8) vircpl,eps,ann,engsr1,viracl,engsrl,virsrl,virac2,engcp1
+      real(8) vircp1,engacl,engac2,virsr1
+      
+      real(8), allocatable :: fpx(:),fpy(:),fpz(:)
+      real(8), allocatable :: vdw_sol_put(:),cou_sol_put(:)
+      real(8), allocatable :: vdw_exc_put(:),cou_exc_put(:)
+      
+      dimension stresp(9),fail(nnn)
+      
+      save engcpl,engsrl,vircpl,virsrl,nstep0,numlsts,engcp1,vircp1
+      save engsr1,virsr1,stresp,fpx,fpy,fpz,newjob
+      save vdw_sol_put,cou_sol_put,vdw_exc_put,cou_exc_put
+      
+      data newjob/.true./
+      data numlsts/-1/
+      
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+      lhke=(keyfce/2.eq.7)
+      lspme=(keyfce/2.eq.6)
+      lewald=(keyfce/2.eq.1)
+      lcshft=(keyfce/2.eq.4.or.keyfce/2.eq.5)
+      if(newlst)nstep0=nstep
+      newplst=(newlst).or.(mod(nstep-nstep0,multt).eq.0)
+      
+c     allocate working arrays
+      
+      if(newjob)then
+        
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate (fpx(mxatms),fpy(mxatms),fpz(mxatms),stat=fail(1))
+        if(lsolva)then
+          
+          allocate (vdw_sol_put(mxtmls_sol2),stat=fail(2))
+          allocate (cou_sol_put(mxtmls_sol2),stat=fail(3))
+          if(lghost)then
+            allocate (vdw_exc_put(mxtmls_exc2),stat=fail(4))
+            allocate (cou_exc_put(mxtmls_exc2),stat=fail(5))
+          endif
+          
+        endif
+        do i=1,nnn
+          if(fail(i).ne.0)call error(idnode,1840)
+        enddo
+        
+      endif
+      
+c     create ewald interpolation arrays
+      
+      if(newjob)then
+        
+        if(lspme.or.lewald.or.lcshft)then
+          
+          call erfcgen(alpha,drewd,rcut)
+          
+        endif
+        
+      endif
+      
+      newjob=.false.
+      
+c     divide neighbour list into primary and secondary neighbours
+      
+      if(newplst)then        
+        
+        numlsts=numlsts+1
+        call primlst(idnode,mxnode,natms,imcon,rprim)
+        
+      endif
+      
+c     flag for accumulating rdfs
+      
+      lgr=.false.
+      if(nstbgr.gt.0)lgr=(mod(numlsts,nstbgr).eq.0)
+      lgr=(lgr.and.(newplst.and.lgofr))
+      lgr=(lgr.and.((.not.lzeql).or.(nstep-nsteql.gt.0)))
+      
+c     zero force and stress arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=0.d0
+      enddo
+      
+c     ********************PROCESS SECONDARY NEIGHBOURS******************
+      
+      if(newplst.or.(mod(nstep-nstep0,multt).le.1))then
+        
+c     zero accumulators
+        
+        engcpl=0.d0
+        vircpl=0.d0
+        engsrl=0.d0
+        virsrl=0.d0
+        llsolva=lsolva
+        if(lsolva)then
+          
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+c     calculate fourier contribution to secondary coulombic forces
+        
+        if(lewald.or.lspme.or.lhke)then
+          
+          if(lewald)then
+            
+            call ewald1
+     x        (lsolva,llsolva,lfree,lghost,idnode,mxnode,natms,imcon,
+     x        kmax1,kmax2,kmax3,engac1,viracc,alpha,volm,epsq)
+            
+c     hautman-klein-ewald method
+            
+          elseif(lhke)then
+            
+            call hkewald1
+     x        (idnode,mxnode,natms,imcon,nhko,kmax1,kmax2,
+     x        engac1,viracc,alpha,epsq)
+            
+c     real space terms of hk-ewald
+            
+            call hkewald2
+     x        (idnode,mxnode,nhko,nlatt,imcon,natms,engac2,
+     x        virac2,drewd,rcut,epsq)
+            
+            engac1=engac1+engac2
+            viracc=viracc+virac2
+            
+          elseif(lspme)then
+            
+c     smoothed particle mesh ewald
+            
+            call ewald_spme
+     x        (idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3,nospl,
+     x        engac1,viracc,alpha,volm,epsq)
+            
+          endif
+          
+          engcpl=engcpl+engac1
+          vircpl=vircpl+viracc
+          
+c     calculate corrections for intramolecular coulomb terms in 
+c     Ewald sum
+c     note: if using link cells - have double counted excluded 
+c     interactions use temporary adjustment to relative dielectric
+c     constant
+          
+          eps=epsq
+          if(loglnk)eps=epsq*2.0d0
+          
+c     calculate self interaction corrections for fourier contributions
+          
+          ii=0
+          
+          do i=idnode+1,natms,mxnode
+            
+            ii=ii+1
+            
+c     calculate interatomic distances
+            
+            do k=1,nexatm(ii)
+              
+              j=lexatm(ii,k)
+              jlist(k)=j
+              
+              xdf(k)=xxx(i)-xxx(j)
+              ydf(k)=yyy(i)-yyy(j)
+              zdf(k)=zzz(i)-zzz(j)
+              
+            enddo
+            
+c     periodic boundary condition
+            
+            call images(imcon,0,1,nexatm(ii),cell,xdf,ydf,zdf)
+            
+c     calculate correction terms
+            
+            if(lhke)then
+              
+              call hkewald3(i,ii,engacc,viracc,eps)
+              
+            else
+              
+              call ewald3
+     x          (lsolva,lfree,lghost,i,ii,engacc,viracc,alpha,eps)
+              
+            endif
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          enddo
+          
+        endif
+        
+c     calculate pair contributions to secondary neighbour forces
+        
+        ii=0
+        
+        do i=idnode+1,natms,mxnode
+          
+          ii=ii+1
+          
+c     calculate interatomic distances
+          
+          ik=0
+          
+          do k=1,lentry(ii)
+            
+            j=list(ii,k)
+            
+            if(j.gt.0)then
+              
+              ik=ik+1
+              ilist(ik)=j
+              xdf(ik)=xxx(i)-xxx(j)
+              ydf(ik)=yyy(i)-yyy(j)
+              zdf(ik)=zzz(i)-zzz(j)
+              
+            endif
+            
+          enddo
+          
+c     periodic boundary conditions
+          
+          call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+          
+c     square of distance
+          
+          do k=1,ik
+            
+            rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+            
+          enddo
+          
+c     accumulate radial distribution functions
+          
+          if(lgr)call rdf0(i,ik,rcut)
+          
+c     calculate short range force and potential terms
+          
+          if(mod(keyfce,2).eq.1)then
+            
+            call srfrce
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+            
+            engsrl=engsrl+engacc
+            virsrl=virsrl+viracc
+            
+          endif
+          
+c     calculate coulombic force and potential terms
+c     (real space contributions to ewald sum)
+          
+          if(lewald.or.lspme)then
+            
+            call ewald2
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,drewd,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.2)then
+            
+            call coul2
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.3)then
+            
+            call coul0
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.4)then
+            
+            call coul4
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.5)then
+            
+            call coul3
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          endif
+          
+        enddo
+        
+c     store secondary forces and stress tensor
+        
+        do i=1,natms
+          
+          flx(i)=fxx(i)
+          fly(i)=fyy(i)
+          flz(i)=fzz(i)
+          fxx(i)=0.d0
+          fyy(i)=0.d0
+          fzz(i)=0.d0
+          
+        enddo
+        
+        do i=1,9
+          stresl(i)=stress(i)
+          stress(i)=0.d0
+        enddo
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol(:)
+          cou_sol_lng(:)=cou_sol(:)
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc(:)
+            cou_exc_lng(:)=cou_exc(:)
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     ****************END OF SECONDARY NEIGHBOUR PROCESSING*************
+      
+c     ********************PROCESS PRIMARY NEIGHBOURS********************
+      
+c     zero accumulators for total energies and virials
+      
+      engcpe=0.d0
+      engsrp=0.d0
+      vircpe=0.d0
+      virsrp=0.d0
+      
+c     calculate pair force contributions
+      
+      ii=0
+      
+      do i=idnode+1,natms,mxnode
+        
+        ii=ii+1
+        
+c     calculate interatomic distances
+        
+        ik=0
+        
+        do k=1,lentry(ii)
+          
+          j=-list(ii,k)
+          
+          if(j.gt.0)then
+            
+            ik=ik+1
+            ilist(ik)=j
+            xdf(ik)=xxx(i)-xxx(j)
+            ydf(ik)=yyy(i)-yyy(j)
+            zdf(ik)=zzz(i)-zzz(j)
+            
+          endif
+          
+        enddo
+        
+c     periodic boundary conditions
+        
+        call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+        
+c     square of distance
+        
+        do k=1,ik
+          
+          rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+          
+        enddo
+        
+c     accumulate radial distribution functions
+        
+        if(lgr)call rdf0(i,ik,rcut)
+        
+c     calculate short range force and potential terms
+        
+        if(mod(keyfce,2).eq.1)then
+          
+          call srfrce
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+c     (real space contributions to ewald sum)
+        
+        if(lewald.or.lspme.or.lhke)then
+          
+          if(newplst.or.
+     x      (mod(nstep-nstep0,multt).le.1))then
+            
+            if(lhke)then
+              
+              call hkewald4(i,ik,engacc,viracc,engacl,viracl,rcut,epsq)
+              
+            else
+              
+              call ewald4
+     x          (llsolva,lfree,lghost,i,ik,engacc,viracc,engacl,viracl,
+     x          drewd,rcut,epsq)
+              
+            endif
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            engcpl=engcpl+engacl
+            vircpl=vircpl+viracl
+            
+          else
+            
+            call coul0
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            
+          endif
+          
+        elseif(keyfce/2.eq.2)then
+          
+          call coul2
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call coul4
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+      enddo
+      
+c     **************END OF PRIMARY NEIGHBOUR PROCESSING*****************
+      
+c     counter for rdf statistics outside loop structure
+      
+      if(lgr)numrdf=numrdf+1
+      
+c     add in secondary neighbour contributions to force, energy etc
+      
+      if(newplst)then
+        
+        do i=1,natms
+          
+          fpx(i)=flx(i)
+          fpy(i)=fly(i)
+          fpz(i)=flz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresp(i)=stresl(i)
+        enddo
+        
+        engsr1=engsrl
+        virsr1=virsrl
+        engcp1=engcpl
+        vircp1=vircpl
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_put(:)=vdw_sol_lng(:)
+          cou_sol_put(:)=cou_sol_lng(:)
+          
+          if(lghost)then
+            
+            vdw_exc_put(:)=vdw_exc_lng(:)
+            cou_exc_put(:)=cou_exc_lng(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     calculate force increments etc
+      
+      if(mod(nstep-nstep0,multt).eq.1)then
+        
+        do i=1,natms
+          
+          flx(i)=flx(i)-fpx(i)
+          fly(i)=fly(i)-fpy(i)
+          flz(i)=flz(i)-fpz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresl(i)=stresl(i)-stresp(i)
+        enddo
+        
+        virsrl=virsrl-virsr1
+        engsrl=engsrl-engsr1
+        vircpl=vircpl-vircp1
+        engcpl=engcpl-engcp1
+        
+c     solvation and excitation increments
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol_lng(:)-vdw_sol_put(:)
+          cou_sol_lng(:)=cou_sol_lng(:)-cou_sol_put(:)
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc_lng(:)-vdw_exc_put(:)
+            cou_exc_lng(:)=cou_exc_lng(:)-cou_exc_put(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     extrapolate long range terms
+      
+      ann=dble(mod(nstep-nstep0,multt))
+      
+      do i=1,natms
+        
+        fxx(i)=fpx(i)+flx(i)*ann+fxx(i)
+        fyy(i)=fpy(i)+fly(i)*ann+fyy(i)
+        fzz(i)=fpz(i)+flz(i)*ann+fzz(i)
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=stress(i)+stresp(i)+stresl(i)*ann
+      enddo
+      
+      engsrp=engsr1+engsrl*ann+engsrp
+      virsrp=virsr1+virsrl*ann+virsrp
+      engcpe=engcp1+engcpl*ann+engcpe
+      vircpe=vircp1+vircpl*ann+vircpe
+      
+c     solvation and excitation extrapolation
+      
+      if(llsolva)then
+        
+        vdw_sol(:)=vdw_sol_put(:)+vdw_sol_lng(:)*ann+vdw_sol(:)
+        cou_sol(:)=cou_sol_put(:)+cou_sol_lng(:)*ann+cou_sol(:)
+        
+        if(lghost)then
+          
+          vdw_exc(:)=vdw_exc_put(:)+vdw_exc_lng(:)*ann+vdw_exc(:)
+          cou_exc(:)=cou_exc_put(:)+cou_exc_lng(:)*ann+cou_exc(:)
+          
+        endif
+        
+      endif
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=vdw_fre
+        buffer(6)=cou_fre
+        buffer(7)=vdw_vir
+        buffer(8)=cou_vir
+        call gdsum(buffer(1),8,buffer(9))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        vdw_fre=buffer(5)
+        cou_fre=buffer(6)
+        vdw_vir=buffer(7)
+        cou_vir=buffer(8)
+        
+      endif
+      
+      return
+      end subroutine multiple
+      
+      subroutine multiple_neu
+     x  (lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,imcon,
+     x  keyfce,multt,mxnode,natms,nneut,nstbgr,nstep,nsteql,
+     x  numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x  rprim,rcut,rvdw,alpha,vircpe,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating interatomic forces
+c     using the verlet neighbour list
+c     neutral group implemenation - no Ewald sum option
+c     multiple timestep option
+c     
+c     parallel replicated data version
+c     
+c     fpx,fpy,fpz : forces from electrostatics fron rprim < r <= rcut
+c     fxx,fyy,fzz : total force
+c     
+c     copyright daresbury laboratory april 1994
+c     author  - t. forester april 1993
+c     key:
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ invalid
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ invalid
+c     = 10,11 ----- reaction field                    : coul3
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=7
+
+      logical lgofr,lzeql,newlst,newplst,lgr,lchk,newjob,lsolva
+      logical lfree,lghost,llsolva
+      integer idnode,imcon,keyfce,multt,mxnode,natms,nneut,nstbgr
+      integer nstep,nsteql,numrdf,fail,i,numlsts,jneu,jj0,j
+      integer jj1,ineu,ia,isn,ibig,ik,nstep0,nsolva,isolva
+      real(8) delr,dlrpot,engcpe,engsrp,epsq,rprim,rcut,rvdw,vircpe
+      real(8) virsrp,engcpl,vircpl,engsrl,virsrl,anorm,ann,stresp
+      real(8) engacc,viracc,engsr1,virsr1,engcp1,vircp1,alpha
+      
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: fpx(:),fpy(:),fpz(:)
+      real(8), allocatable :: vdw_sol_put(:),cou_sol_put(:)
+      real(8), allocatable :: vdw_exc_put(:),cou_exc_put(:)
+      
+      dimension fail(nnn),stresp(9)
+      
+      save engcpl,engsrl,vircpl,virsrl,nstep0,numlsts,engcp1,vircp1
+      save engsr1,virsr1,stresp,fpx,fpy,fpz
+      save vdw_sol_put,cou_sol_put,vdw_exc_put,cou_exc_put
+      
+      data newjob/.true./
+      data numlsts/-1/
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(1))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(2))
+      if(newjob)then
+        
+        allocate (fpx(mxatms),fpy(mxatms),fpz(mxatms),stat=fail(3))
+        if(lsolva)then
+          
+          allocate (vdw_sol_put(mxtmls_sol2),stat=fail(4))
+          allocate (cou_sol_put(mxtmls_sol2),stat=fail(5))
+          
+          if(lghost)then
+            allocate (vdw_exc_put(mxtmls_exc2),stat=fail(6))
+            allocate (cou_exc_put(mxtmls_exc2),stat=fail(7))
+          endif
+          
+        endif
+        newjob=.false.
+        
+      endif
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1850)
+      enddo
+      
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+
+c     error if ewald sum requested
+      
+      if(keyfce/2.eq.1.or.keyfce/2.eq.6)call error(idnode,250)
+      
+c     create list of primary and secondary neighbours
+      
+      if(newlst)nstep0=nstep
+      newplst=(mod(nstep-nstep0,multt).eq.0)
+      
+      if(newplst)then        
+        
+        numlsts=numlsts+1
+        call prneulst(newlst,imcon,idnode,mxnode,nneut,rprim)
+        
+      endif
+      
+c     zero accumulators for total energies and virials
+      
+      engcpe=0.d0
+      engsrp=0.d0
+      vircpe=0.d0
+      virsrp=0.d0
+      
+c     zero force arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+c     zero stress arrays
+      
+      do i=1,9
+        stress(i)=0.d0
+      enddo
+      
+c     flag for accumulating rdfs
+      
+      lgr=.false.
+      if(nstbgr.gt.0)lgr=(mod(numlsts,nstbgr).eq.0)
+      lgr=(lgr.and.(newplst.and.lgofr))
+      lgr=(lgr.and.((.not.lzeql).or.(nstep-nsteql.gt.0)))
+      
+c     intra group vectors com
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-xxx(jj0)
+          tyy(j)=yyy(j)-yyy(jj0)
+          tzz(j)=zzz(j)-zzz(jj0)
+          
+        enddo
+        
+      enddo
+      
+      call images(imcon,0,1,natms,cell,txx,tyy,tzz)
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          xxx(j)=txx(j)+xxx(jj0)
+          yyy(j)=tyy(j)+yyy(jj0)
+          zzz(j)=tzz(j)+zzz(jj0)
+          
+        enddo
+        
+c     centre of molecule
+        
+        uxx(jneu)=0.d0
+        uyy(jneu)=0.d0
+        uzz(jneu)=0.d0
+        anorm=1.d0/dble(jj1-jj0+1)
+        
+        do j=jj0,jj1
+          
+          uxx(jneu)=uxx(jneu)+xxx(j)*anorm
+          uyy(jneu)=uyy(jneu)+yyy(j)*anorm
+          uzz(jneu)=uzz(jneu)+zzz(j)*anorm
+          
+        enddo
+        
+c     vector from site to geometric centre
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-uxx(jneu)
+          tyy(j)=yyy(j)-uyy(jneu)
+          tzz(j)=zzz(j)-uzz(jneu)
+          
+        enddo
+        
+      enddo
+      
+c     ********************PROCESS SECONDARY NEIGHBOURS********************
+        
+      lchk=.true.
+      ibig=0
+      ia=0
+      
+      if(newplst.or.(mod(nstep-nstep0,multt).le.1))then
+      
+c     zero accumulators for secondary neighbour energies and virial
+        
+        engcpl=0.d0
+        vircpl=0.d0
+        engsrl=0.d0
+        virsrl=0.d0
+        
+c     initialise solvation and excitation  arrays
+
+        if(lsolva)then
+          
+          cou_sol(:)=0.d0
+          vdw_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            cou_exc(:)=0.d0
+            vdw_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+c     outer loop over neutral groups
+        
+        do ineu=idnode+1,nneut,mxnode
+          
+          ia=ia+1
+          
+c     calculate interatomic distances
+          
+          isn=-1
+          call neutlst
+     x      (.true.,lchk,isn,imcon,idnode,ineu,ia,ik,
+     x      txx,tyy,tzz,uxx,uyy,uzz)
+          
+c     trap possible array bound exception 
+          
+          ibig=max(ibig,ik)
+          if(ik.gt.mxxdf)ik=0
+          
+c     calculate short range force and potential terms
+          
+          if(mod(keyfce,2).eq.1.and.(rvdw.gt.rprim-delr))then
+            
+            call srfrceneu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,dlrpot,rvdw)
+            
+            engsrl=engsrl+engacc
+            virsrl=virsrl+viracc
+            
+          endif
+          
+c     calculate coulombic force and potential terms
+          
+          if(keyfce/2.eq.2)then
+            
+            call coul2neu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.3)then
+            
+            call coul0neu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.4)then
+            
+            call error(idnode,250)
+            
+          elseif(keyfce/2.eq.5)then
+            
+            call coul3neu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,epsq,rcut,alpha)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          else
+            
+            call error(idnode,250)
+            
+          endif
+          
+c     accumulate radial distribution functions out to rcut
+          
+          if(lgr)then
+            call rdf0neu(ik,rcut)
+          endif
+          
+        enddo
+        
+c     store secondary forces and stress tensor
+        
+        do i=1,natms
+          
+          flx(i)=fxx(i)
+          fly(i)=fyy(i)
+          flz(i)=fzz(i)
+          fxx(i)=0.d0
+          fyy(i)=0.d0
+          fzz(i)=0.d0
+          
+        enddo
+        
+        do i=1,9
+          
+          stresl(i)=stress(i)
+          stress(i)=0.d0
+          
+        enddo
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol(:)
+          cou_sol_lng(:)=cou_sol(:)
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc(:)
+            cou_exc_lng(:)=cou_exc(:)
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     ****************END OF SECONDARY NEIGHBOUR PROCESSING*************
+      
+c     ********************PROCESS PRIMARY NEIGHBOURS********************
+      
+      ia=0
+      do ineu=idnode+1,nneut,mxnode
+        
+        ia=ia+1
+        
+c     calculate interatomic distances
+        
+        isn=1        
+        call neutlst
+     x    (.true.,lchk,isn,imcon,idnode,ineu,ia,ik,
+     x    txx,tyy,tzz,uxx,uyy,uzz)
+        
+c     trap possible array bound exception 
+        
+        ibig=max(ibig,ik)
+        if(ik.gt.mxxdf)ik=0
+        
+c     calculate short range force and potential terms
+        
+        if(mod(keyfce,2).eq.1)then
+          
+          call srfrceneu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,dlrpot,rvdw)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+        
+        if(keyfce/2.eq.2)then
+          
+          call coul2neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call error(idnode,250)
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq,rcut,alpha)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+c     accumulate radial distribution functions out to rcut
+        
+        if(lgr)then
+          call rdf0neu(ik,rcut)
+        endif
+        
+      enddo
+      
+c     ******************END OF PRIMARY NEIGHBOUR PROCESSING*************
+      
+c     check on validity of call to neutlst
+      
+      if(mxnode.gt.1)call gstate(lchk)
+      if(.not.lchk)then 
+        call gimax(ibig,1,i)
+        if(idnode.eq.0)write(nrite,*)'mxxdf must be at least ',ibig
+        if(idnode.eq.0)write(nrite,*)'mxxdf is currently ',mxxdf
+        call  error(idnode,479)
+      endif
+      
+c     counter for rdf statistics outside loop structure
+      
+      if(lgr)numrdf=numrdf+1
+      
+c     add in secondary neighbour contributions to force, energy etc
+      
+      if(newplst)then
+        
+        do i=1,natms
+          
+          fpx(i)=flx(i)
+          fpy(i)=fly(i)
+          fpz(i)=flz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresp(i)=stresl(i)
+        enddo
+        
+        engsr1=engsrl
+        virsr1=virsrl
+        engcp1=engcpl
+        vircp1=vircpl
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_put(:)=vdw_sol_lng(:)
+          cou_sol_put(:)=cou_sol_lng(:)
+          
+          if(lghost)then
+            
+            vdw_exc_put(:)=vdw_exc_lng(:)
+            cou_exc_put(:)=cou_exc_lng(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     calculate force increments etc
+      
+      if(mod(nstep-nstep0,multt).eq.1)then
+        
+        do i=1,natms
+          
+          flx(i)=flx(i)-fpx(i)
+          fly(i)=fly(i)-fpy(i)
+          flz(i)=flz(i)-fpz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresl(i)=stresl(i)-stresp(i)
+        enddo
+        
+        virsrl=virsrl-virsr1
+        engsrl=engsrl-engsr1
+        vircpl=vircpl-vircp1
+        engcpl=engcpl-engcp1
+        
+c     solvation and excitation increments
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol_lng(:)-vdw_sol_put(:)
+          cou_sol_lng(:)=cou_sol_lng(:)-cou_sol_put(:)
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc_lng(:)-vdw_exc_put(:)
+            cou_exc_lng(:)=cou_exc_lng(:)-cou_exc_put(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     extrapolate long range terms
+      
+      ann=dble(mod(nstep-nstep0,multt))
+      
+      do i=1,natms
+        
+        fxx(i)=fpx(i)+flx(i)*ann+fxx(i)
+        fyy(i)=fpy(i)+fly(i)*ann+fyy(i)
+        fzz(i)=fpz(i)+flz(i)*ann+fzz(i)
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=stress(i)+stresl(i)*ann+stresp(i)
+      enddo
+      
+      engsrp=engsr1+engsrl*ann+engsrp
+      virsrp=virsr1+virsrl*ann+virsrp
+      engcpe=engcp1+engcpl*ann+engcpe
+      vircpe=vircp1+vircpl*ann+vircpe
+      
+c     solvation and excitation extrapolation
+      
+      if(llsolva)then
+        
+        vdw_sol(:)=vdw_sol_put(:)+vdw_sol_lng(:)*ann+vdw_sol(:)
+        cou_sol(:)=cou_sol_put(:)+cou_sol_lng(:)*ann+cou_sol(:)
+        
+        if(lghost)then
+          
+          vdw_exc(:)=vdw_exc_put(:)+vdw_exc_lng(:)*ann+vdw_exc(:)
+          cou_exc(:)=cou_exc_put(:)+cou_exc_lng(:)*ann+cou_exc(:)
+          
+        endif
+        
+      endif
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=vdw_fre
+        buffer(6)=cou_fre
+        buffer(7)=vdw_vir
+        buffer(8)=cou_vir
+        call gdsum(buffer(1),8,buffer(9))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        vdw_fre=buffer(5)
+        cou_fre=buffer(6)
+        vdw_vir=buffer(7)
+        cou_vir=buffer(8)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (txx,tyy,tzz,uxx,uyy,uzz,stat=fail(1))
+      
+      return
+      end subroutine multiple_neu
+      
+      subroutine multiple_nsq
+     x  (lnsq,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x  imcon,keyfce,multt,mxnode,natms,nstep,nstbgr,nsteql,
+     x  numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x  rcut,rprim,rvdw,vircpe,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for multiple time step algorithm 
+c     to be used with all-pairs option
+c     
+c     flx,fly,flz : forces from electrostatics from r > rcut
+c     fpx,fpy,fpz : forces from electrostatics from rprim < r <= rcut
+c     fxx,fyy,fzz : total force
+c     
+c     copyright daresbury laboratory 1993
+c     
+c     author  t. forester,  may 1993
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     Ewald sum --- not used
+c     = 4,5  ------ Distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     truncated and shifted coulombic -- not used
+c     reaction field - not used
+c     
+c****************************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=5
+      logical newplst,newlst,lgofr,lzeql,lgr,lnsq,newjob,lsolva
+      logical lfree,lghost,llsolva
+      integer idnode,imcon,keyfce,multt,mxnode,natms,nstep,nstbgr
+      integer nsteql,numrdf,fail,nstep0,ii,ik,k,numlsts,nsolva
+      integer isolva,i,j
+      real(8) delr,dlrpot,engcpe,engsrp,engcp3,epsq,rcut
+      real(8) rprim,rvdw,vircpe,virsrp,vircp3,rcut1,engcp2,vircp2
+      real(8) engsr2,virsr2,stresp,engacc,viracc
+      
+      real(8), allocatable :: fpx(:),fpy(:),fpz(:)
+      real(8), allocatable :: vdw_sol_put(:),cou_sol_put(:)
+      real(8), allocatable :: vdw_exc_put(:),cou_exc_put(:)
+      
+      dimension stresp(9),fail(nnn)
+      
+      save engsr2,virsr2,engcp2,vircp2,nstep0,numlsts,stresp,fpx,fpy,fpz
+      save vdw_sol_put,cou_sol_put,vdw_exc_put,cou_exc_put
+
+      data numlsts/-1/
+      data newjob/.true./
+      
+c     allocate work arrays
+      
+      if(newjob)then
+        
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate (fpx(mxatms),fpy(mxatms),fpz(mxatms),stat=fail(1))
+        if(lsolva)then
+          
+          allocate (vdw_sol_put(mxtmls_sol2),stat=fail(2))
+          allocate (cou_sol_put(mxtmls_sol2),stat=fail(3))
+          if(lghost)then
+            allocate (vdw_exc_put(mxtmls_exc2),stat=fail(4))
+            allocate (cou_exc_put(mxtmls_exc2),stat=fail(5))
+          endif
+          
+        endif
+        do i=1,nnn
+          if(fail(i).ne.0)call error(idnode,1860)
+        enddo
+        newjob=.false.
+        
+      endif
+      
+      if(lnsq)then
+        
+        llsolva=.false.
+        if(lsolva)then
+          llsolva=(mod(nstep-nsolva,isolva).eq.0)
+        endif
+        
+c     divide neighbour list into primary and secondary neighbours
+        
+        if(newplst)then        
+          
+          numlsts=numlsts+1
+          call primlst(idnode,mxnode,natms,imcon,rprim)
+          
+        endif
+        
+c     flag for accumulating rdfs
+        
+        lgr=(lgofr.and.(.not.lzeql.or.(nstep-nsteql.gt.0)))
+        lgr=(lgr.and.newplst.and.(mod(numlsts,nstbgr).eq.0))
+        
+c     set extended cutoff for electrostatics - secondary shell
+        
+        rcut1=rcut+delr
+        
+        if(newlst)nstep0=nstep
+        newplst=(newlst.or.mod(nstep-nstep0,multt).eq.0)
+        
+c     ********************PROCESS TERTIARY NEIGHBOURS*********************
+        
+        if(newplst)then
+          
+          call coul_nsq
+     x      (lsolva,lfree,lghost,idnode,mxnode,natms,imcon,epsq,rcut,
+     x      engcp3,vircp3)
+          
+        endif
+        
+c     ****************END OF TERTIARY NEIGHBOUR PROCESSING**************
+        
+c     ********************PROCESS SECONDARY NEIGHBOURS********************
+        
+        if(newplst)then
+          
+c     zero accumulators for secondary neighbour energies and virial
+          
+          engcp2=0.d0
+          vircp2=0.d0
+          engsr2=0.d0
+          virsr2=0.d0
+          
+c     zero secondary forces
+          
+          do i=1,natms
+            
+            fxx(i)=0.d0
+            fyy(i)=0.d0
+            fzz(i)=0.d0
+            
+          enddo
+          
+c     zero solvation and excitation arrays
+        
+          if(lsolva)then
+            
+            vdw_sol(:)=0.d0
+            cou_sol(:)=0.d0
+            
+            if(lghost)then
+              
+              vdw_exc(:)=0.d0
+              cou_exc(:)=0.d0
+              
+            endif
+            
+          endif
+
+c     zero stress tensor
+          
+          do i=1,9
+            stress(i)=0.d0
+          enddo
+          
+          ii=0
+          do i=idnode+1,natms,mxnode
+            
+            ii=ii+1
+            
+c     calculate interatomic vectors
+            
+            ik=0
+            do k=1,lentry(ii)
+              
+              j=list(ii,k)
+              
+              if(j.gt.0)then
+                
+                ik=ik+1
+                ilist(ik)=j
+                xdf(ik)=xxx(i)-xxx(j)
+                ydf(ik)=yyy(i)-yyy(j)
+                zdf(ik)=zzz(i)-zzz(j)
+                
+              endif
+              
+            enddo
+            
+c     periodic boundary condition only for interactions > rprim
+            
+            call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+            
+c     square of interatomic distances
+            
+            do k=1,ik
+              
+              rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+              
+            enddo
+            
+c     short range forces for secondary shell
+            
+            if((mod(keyfce,2).eq.1).and.(rvdw.gt.rprim-delr))then
+              
+              call srfrce
+     x          (lsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+              
+              engsr2=engsr2+engacc
+              virsr2=virsr2+viracc
+              
+            endif
+            
+c     calculate coulombic force and potential terms
+            
+            if(keyfce/2.eq.1.or.keyfce/2.eq.6)then
+              
+              call error(idnode,424)
+              
+            elseif(keyfce/2.eq.2)then
+              
+c     distance dependent dielectric
+              
+              call coul2
+     x          (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut1,epsq)
+              
+              engcp2=engcp2+engacc
+              vircp2=vircp2+viracc
+              
+            elseif(keyfce/2.eq.3)then
+              
+c     coulombic potential
+              
+              call coul0
+     x          (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut1,epsq)
+              
+              engcp2=engcp2+engacc
+              vircp2=vircp2+viracc
+              
+            elseif(keyfce/2.eq.4)then
+              
+c     truncated shifted coulombic potential
+              
+              call error(idnode,424)
+              
+            endif
+            
+c     accumulate radial distribution functions : out to rcut
+            
+            if(lgr)call rdf0(i,ik,rcut)
+            
+          enddo
+          
+c     store secondary forces and stress tensor
+          
+          do i=1,natms
+            
+            fpx(i)=fxx(i)
+            fpy(i)=fyy(i)
+            fpz(i)=fzz(i)
+            
+          enddo
+          
+          do i=1,9
+            stresp(i)=stress(i)
+          enddo
+          
+c     store solvation and excitation arrays
+          
+          if(lsolva)then
+            
+            vdw_sol_put(:)=vdw_sol(:)
+            cou_sol_put(:)=cou_sol(:)
+            
+            if(lghost)then
+              
+              vdw_exc_put(:)=vdw_exc(:)
+              cou_exc_put(:)=cou_exc(:)
+              
+            endif
+            
+          endif
+          
+        endif
+        
+c     ****************END OF SECONDARY NEIGHBOUR PROCESSING*************
+        
+c     ********************PROCESS PRIMARY NEIGHBOURS********************
+        
+c     zero accumulators for total energies and virials
+        
+        engcpe=0.d0
+        engsrp=0.d0
+        vircpe=0.d0
+        virsrp=0.d0
+        
+c     zero primary forces
+        
+        do i=1,natms
+          
+          fxx(i)=0.d0
+          fyy(i)=0.d0
+          fzz(i)=0.d0
+          
+        enddo
+        
+c     zero stress tensor
+        
+        do i=1,9
+          stress(i)=0.d0
+        enddo
+        
+c     zero solvation and excitation arrays
+        
+        if(llsolva)then
+          
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+c     calculate primary pair force contributions
+        
+        ii=0
+        
+        do i=idnode+1,natms,mxnode
+          
+          ii=ii+1
+          
+c     calculate interatomic distances
+          
+          ik=0
+          
+          do k=1,lentry(ii)
+            
+            j=-list(ii,k)
+            
+            if(j.gt.0)then
+              
+              ik=ik+1
+              ilist(ik)=j
+              xdf(ik)=xxx(i)-xxx(j)
+              ydf(ik)=yyy(i)-yyy(j)
+              zdf(ik)=zzz(i)-zzz(j)
+              
+            endif
+            
+          enddo
+          
+c     periodic boundary conditions
+          
+          call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+          
+c     square of interatomic distances
+          
+          do k=1,ik
+            
+            rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+            
+          enddo
+          
+c     accumulate radial distribution functions : out to rcut
+          
+          if(lgr)call rdf0(i,ik,rcut)
+          
+c     calculate short range force and potential terms
+          
+          if(mod(keyfce,2).eq.1)then
+            
+            call srfrce
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+            
+            engsrp=engsrp+engacc
+            virsrp=virsrp+viracc
+            
+          endif
+          
+c     calculate coulombic force and potential terms
+          
+          if(keyfce/2.eq.1.or.keyfce/2.eq.6)then
+            
+            call error(idnode,424)
+            
+          elseif(keyfce/2.eq.2)then
+            
+c     distance dependent dielectric
+            
+            call coul2
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            
+          elseif(keyfce/2.eq.3)then
+            
+c     coulombic potential
+            
+            call coul0
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            
+          elseif(keyfce/2.eq.4)then
+            
+            call error(idnode,424)
+            
+          endif
+          
+        enddo
+        
+c     **************END OF PRIMARY NEIGHBOUR PROCESSING*****************
+        
+c     counter for rdf statistics outside loop structure
+        
+        if(lgr)numrdf=numrdf+1
+        
+c     add in secondary and tertiary neighbour contributions to 
+c     force, energy etc
+        
+        do i=1,natms
+          
+          fxx(i)=fxx(i)+fpx(i)+flx(i)
+          fyy(i)=fyy(i)+fpy(i)+fly(i)
+          fzz(i)=fzz(i)+fpz(i)+flz(i)
+          
+        enddo
+        
+        do i=1,9
+          stress(i)=stress(i)+stresp(i)
+        enddo
+        
+        engsrp=engsrp+engsr2
+        virsrp=virsrp+virsr2
+        
+        engcpe=engcpe+engcp2+engcp3 
+        vircpe=vircpe+vircp2+vircp3
+        
+c     calculate solvation and excitation arrays
+        
+        if(llsolva)then
+          
+          vdw_sol(:)=vdw_sol(:)+vdw_sol_put(:)+vdw_sol_lng(:)
+          cou_sol(:)=cou_sol(:)+cou_sol_put(:)+cou_sol_lng(:)
+          
+          if(lghost)then
+            
+            vdw_exc(:)=vdw_exc(:)+vdw_exc_put(:)+vdw_exc_lng(:)
+            cou_exc(:)=cou_exc(:)+cou_exc_put(:)+cou_exc_lng(:)
+            
+          endif
+          
+        endif
+        
+c     sum up contributions to short range and coulombic potential
+        
+        if(mxnode.gt.1)then 
+          
+          buffer(1)=engsrp
+          buffer(2)=virsrp
+          buffer(3)=engcpe
+          buffer(4)=vircpe
+          buffer(5)=vdw_fre
+          buffer(6)=cou_fre
+          buffer(7)=vdw_vir
+          buffer(8)=cou_vir
+          call gdsum(buffer(1),8,buffer(9))
+          engsrp=buffer(1)
+          virsrp=buffer(2)
+          engcpe=buffer(3)
+          vircpe=buffer(4)
+          vdw_fre=buffer(5)
+          cou_fre=buffer(6)
+          vdw_vir=buffer(7)
+          cou_vir=buffer(8)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine multiple_nsq
+      
+      subroutine neutlst
+     x  (newlst,lchk,isn,imcon,idnode,ineu,ia,ll,
+     x  txx,tyy,tzz,uxx,uyy,uzz)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to create pair lists for neutral group
+c     implementations.
+c     loops over group ineu
+c     
+c     replicated data version
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester march 1994
+c     
+c     isn = -1 => secondary neighbours
+c     isn =  1 => primary neighbours - must contain excld interactions
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newlst,lchk,lexc
+      integer isn,imcon,idnode,ineu,ia,ll,i,jj,jj0,jj1
+      integer fail,ibig,keyexc,lenia,j,jneu,in0,in1
+      real(8) txx,tyy,tzz,uxx,uyy,uzz
+      
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension uxx(mxatms),uyy(mxatms),uzz(mxatms)
+      
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      
+      data fail/0/
+      
+c     allocate work arrays
+      
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1830)
+      
+      if(newlst)then
+        
+        ibig=0
+        
+c     set cutoff radius
+        
+        ll=0
+        
+c     number of excludes found
+        
+        if(isn.lt.0)then
+          keyexc=nexatm(ia)+2
+        else
+          keyexc=1
+        endif
+        
+c     do centre - centre distances
+        
+        lenia=lentry(ia)
+        
+        do j=1,lenia
+          
+          jneu=abs(list(ia,j))
+          xxt(j)=uxx(ineu)-uxx(jneu)
+          yyt(j)=uyy(ineu)-uyy(jneu)
+          zzt(j)=uzz(ineu)-uzz(jneu)
+          
+        enddo
+        
+        call images(imcon,0,1,lenia,cell,xxt,yyt,zzt)
+        
+c     working intragroup vectors of central group 
+c     - for periodic boundaries
+        
+        in0=neulst(ineu)
+        in1=neulst(ineu+1)-1
+        
+c     loop over neutral groups sites of a  
+        
+        
+c     loop over groups in list
+        
+        do jj=1,lentry(ia)
+          
+          jneu=list(ia,jj)*isn
+          
+          if(jneu.gt.0)then
+            
+            do i=in0,in1
+              
+              jj0=neulst(jneu)
+              jj1=neulst(jneu+1)-1
+              
+              if(ineu.eq.jneu)jj0=i+1
+              
+c     loop over jneu sites
+              
+              do j=jj0,jj1
+                
+c     reject atoms in excluded pair list
+                
+                lexc=.false.     
+                
+                if(keyexc.lt.nexatm(ia))then
+                  
+                  if(lexatm(ia,keyexc).eq.i)then
+                    if(lexatm(ia,keyexc+1).eq.j)then
+                      lexc=.true.
+                      keyexc=keyexc+2
+                    endif
+                  endif   
+                  
+                endif
+                
+c     reject frozen atom pairs
+                
+                if(lstfrz(i).ne.0)then
+                  if(lstfrz(j).ne.0)lexc=.true.
+                endif
+                
+                if(.not.lexc)then
+                  
+                  ll=ll+1
+                  if(ll.le.mxxdf)then
+                    
+                    xdf(ll)=txx(i)+xxt(jj)-txx(j)
+                    ydf(ll)=tyy(i)+yyt(jj)-tyy(j)
+                    zdf(ll)=tzz(i)+zzt(jj)-tzz(j)
+                    rsqdf(ll)=xdf(ll)**2+ydf(ll)**2+zdf(ll)**2
+                    ilist(ll)=i
+                    jlist(ll)=j
+                    
+                  else
+                    
+                    lchk=.false.
+                    ibig=max(ibig,ll)
+                    
+                  endif
+                  
+                endif
+                
+              enddo
+              
+            enddo
+            
+          endif
+          
+        enddo
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (xxt,yyt,zzt,stat=fail)
+      
+      return
+      end subroutine neutlst
+      
+      end module forces_module
+      
diff -urN dl_class_1.9.orig/srcmod/forces_module.f.preplumed dl_class_1.9/srcmod/forces_module.f.preplumed
--- dl_class_1.9.orig/srcmod/forces_module.f.preplumed	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/forces_module.f.preplumed	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,2952 @@
+      module forces_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for calculation of atomic forces
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     adapted   - d. quigley : metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use coulomb_module
+      use error_module
+      use ewald_module
+      use exclude_module
+      use external_field_module
+      use four_body_module
+      use hkewald_module
+      use metafreeze_module
+      use metal_module
+      use neu_coul_module
+      use nlist_builders_module
+      use pair_module
+      use property_module
+      use setup_module
+      use solvation_module
+      use spme_module
+      use tersoff_module
+      use three_body_module
+      use utility_module
+      use vdw_module
+      
+      contains
+      
+      subroutine force_manager
+     x  (newlst,lneut,lnsq,lgofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x  lghost,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x  numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x  ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x  keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x  isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x  vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x  rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x  virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x  virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x  engcfg,fmax,temp,engord,virord)
+      
+c*********************************************************************
+c     
+c     dl_poly subroutine to manage the calculation of the atomic forces
+c     from all force field terms.
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      logical newlst,lneut,lnsq,lgofr,lzeql,loglnk,lfcap,lsolva
+      logical lfree,lghost,llsolva
+      
+      integer idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,numrdf
+      integer keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,ntpmet
+      integer i,nospl,multt,nneut,ntbond,ntangl,ntdihd,nsolva,isolva
+      integer ntinv,ntteth,ntshl,ntptbp,ntpfbp,ntpter,keyshl,keyfld
+      
+      real(8) delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw
+      real(8) vircpe,virsrp,alpha,drewd,volm,engmet,virmet
+      real(8) elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp
+      real(8) rctter,engter,virter,engbnd,virbnd,engang,virang,engdih
+      real(8) virdih,enginv,virinv,engtet,virtet,engshl,virshl,engfld
+      real(8) virfld,fmax,temp,shlke,engcfg,tmpeng,tmpvir,engord,virord
+      
+      llsolva=.false.
+      
+c     initialize energy and virial accumulators
+      
+      engbnd=0.d0
+      virbnd=0.d0
+      engang=0.d0
+      virang=0.d0
+      engdih=0.d0
+      virdih=0.d0
+      enginv=0.d0
+      virinv=0.d0
+      engtbp=0.d0
+      virtbp=0.d0
+      engter=0.d0
+      virter=0.d0
+      engfbp=0.d0
+      virfbp=0.d0
+      engsrp=0.d0
+      virsrp=0.d0
+      engcpe=0.d0
+      vircpe=0.d0
+      engfld=0.d0
+      virfld=0.d0
+      engshl=0.d0
+      virshl=0.d0
+      shlke =0.d0
+      engtet=0.d0
+      virtet=0.d0
+      engmet=0.d0
+      virmet=0.d0
+      virord=0.0d0
+      engord=0.0d0
+      
+      if(lmetadyn)then
+        
+        eng_loc=0.0d0
+        vir_loc=0.0d0
+        fxx_loc(:)=0.0d0
+        fyy_loc(:)=0.0d0
+        fzz_loc(:)=0.0d0
+        stress_loc(:)=0.0d0
+        
+      endif
+      
+c     initialise free energy accumulators
+      
+      if(lfree)then
+        
+        ang_fre=0.d0
+        bnd_fre=0.d0
+        dih_fre=0.d0
+        inv_fre=0.d0
+        tbp_fre=0.d0
+        fbp_fre=0.d0
+        cou_fre=0.d0
+        vdw_fre=0.d0
+        shl_fre=0.d0
+        ang_vir=0.d0
+        bnd_vir=0.d0
+        dih_vir=0.d0
+        inv_vir=0.d0
+        tbp_vir=0.d0
+        fbp_vir=0.d0
+        cou_vir=0.d0
+        vdw_vir=0.d0
+        shl_vir=0.d0
+        eng_cfg_fre=0.d0
+        vir_cfg_fre=0.d0
+        
+      endif
+      
+c     initialise solvation and excitation arrays
+      
+      if(lsolva)then
+        
+        if(keyfce/2.gt.0)lcomp(6)=.true.
+        if(mod(keyfce,2).eq.1)lcomp(7)=.true.
+        if(mod(nstep-nsolva,isolva).eq.0)then
+          
+          llsolva=.true.
+          cou_sol(:)=0.d0
+          vdw_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            cou_exc(:)=0.d0
+            vdw_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     initialise the force arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+c     zero stress tensor
+      
+      if(nstep.gt.0)then
+        
+        do i=1,9
+          stress(i)=0.d0
+        enddo
+        
+      endif
+      
+      if(keyfce.gt.0)then
+        
+c     calculate pair forces, including coulombic forces
+        
+        if(lnsq)then
+          
+c     multiple timestep - all-pairs
+          
+          call multiple_nsq
+     x      (lnsq,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x      imcon,keyfce,multt,mxnode,natms,nstep,nstbgr,nsteql,
+     x      numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x      rcut,rprim,rvdw,vircpe,virsrp)
+          
+        elseif(.not.lneut)then         
+          
+c     single timestep
+          
+          if(multt.eq.1)then
+            
+            call forces
+     x        (loglnk,lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,
+     x        keyfce,kmax1,kmax2,kmax3,nhko,nlatt,mxnode,ntpvdw,
+     x        ntpmet,natms,nstbgr,nstep,nsteql,numrdf,nospl,nsolva,
+     x        isolva,alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rvdw,
+     x        vircpe,virsrp,volm,engmet,virmet)
+            
+          else
+            
+            call multiple
+     x        (loglnk,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x        imcon,keyfce,nlatt,kmax1,kmax2,kmax3,nhko,multt,
+     x        mxnode,natms,nstep,nstbgr,nsteql,numrdf,nospl,nsolva,
+     x        isolva,alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rprim,
+     x        rvdw,vircpe,virsrp,volm)
+            
+          endif
+          
+        elseif(lneut)then
+          
+c     neutral groups
+          
+          if(multt.eq.1)then
+            
+            call forces_neu
+     x        (lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,keyfce,
+     x        mxnode,natms,nneut,nstbgr,nstep,nsteql,numrdf,nsolva,
+     x        isolva,dlrpot,engcpe,engsrp,epsq,rcut,rvdw,alpha,
+     x        vircpe,virsrp)
+            
+          else
+            
+            call multiple_neu
+     x        (lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,imcon,
+     x        keyfce,multt,mxnode,natms,nneut,nstbgr,nstep,nsteql,
+     x        numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x        rprim,rcut,rvdw,alpha,vircpe,virsrp)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     add in long range corrections to energy and pressure
+      
+      engsrp=engsrp+elrc
+      virsrp=virsrp+virlrc
+      engmet=engmet+elrcm(0)
+      virmet=virmet+vlrcm(0)
+      if(lfree)then
+        vdw_fre=vdw_fre+elrc_fre
+        vdw_vir=vdw_vir+vlrc_fre
+      endif
+      
+c     calculate three body forces
+      
+      if(ntptbp.gt.0)call thbfrc
+     x  (llsolva,lfree,lghost,idnode,mxnode,natms,imcon,rcuttb,
+     x  engtbp,virtbp)
+      
+c     calculate four body forces
+      
+      if(ntpfbp.gt.0)call fbpfrc
+     x  (llsolva,lfree,lghost,idnode,mxnode,natms,imcon,rcutfb,
+     x  engfbp,virfbp)
+      
+c     calculate tersoff potential forces
+      
+      if(ntpter.gt.0)call tersoff
+     x  (idnode,mxnode,natms,imcon,rctter,engter,virter)
+      
+c     calculate bond forces
+      
+      if(ntbond.gt.0)call bndfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntbond,epsq,
+     x  engbnd,virbnd)
+      
+c     calculate valence angle forces
+      
+      if(ntangl.gt.0)call angfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntangl,engang,virang)
+      
+c     calculate dihedral forces
+      
+      if(ntdihd.gt.0)call dihfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntdihd,keyfce,dlrpot,
+     x  epsq,engcpe,engdih,engsrp,rcut,rvdw,alpha,vircpe,virdih,virsrp)
+      
+c     calculate inversion forces
+      
+      if(ntinv.gt.0)call invfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntinv,enginv,virinv)
+      
+c     calculate tethered atom forces
+      
+      if(ntteth.gt.0)call tethfrc
+     x  (idnode,mxnode,imcon,natms,nstep,ntteth,engtet,virtet)
+      
+c     calculate shell model forces
+      
+      if(keyshl.gt.0)call shlfrc
+     x  (llsolva,lfree,lghost,idnode,imcon,mxnode,ntshl,engshl,virshl)
+      
+c     external field
+      
+      if(keyfld.gt.0)call extnfld
+     x  (idnode,imcon,keyfld,mxnode,natms,engfld,virfld)
+      
+c     metadynamics option : use potential energy as order parameter
+      
+      if(lmetadyn)then
+        
+        tmpeng=engsrp+engcpe+engbnd+engang+engdih+engfld+
+     x         engtbp+engfbp+engshl+enginv+engter+engmet
+        
+        tmpvir=vircpe+virsrp+virbnd+virtbp+virter+virfld+
+     x         virang+virshl+virtet+virmet
+        
+        call metafreeze_driver
+     x    (imcon,natms,temp,nstep,tmpeng,tmpvir,engord,virord)
+        
+      endif
+      
+c     global summation of force arrays (basic replicated data strategy)
+      
+      call global_sum_forces(natms,mxnode,fxx,fyy,fzz)
+      
+c     global sum of stress arrays
+      
+      if(mxnode.gt.1)call gdsum(stress,9,buffer)
+      
+c     add long range correction to diagonal terms of stress tensor
+      
+      stress(1)=stress(1)-(virlrc+vlrcm(0))/3.d0
+      stress(5)=stress(5)-(virlrc+vlrcm(0))/3.d0
+      stress(9)=stress(9)-(virlrc+vlrcm(0))/3.d0
+      
+c     cap forces in equilibration mode
+      
+      if(nstep.le.nsteql.and.lfcap)
+     x  call fcap(lfcap,natms,fmax,temp)
+      
+c     total configuration energy
+      
+      engcfg=engsrp+engcpe+engbnd+engang+engdih+engfld+engtbp+
+     x  engfbp+engshl+enginv+engter+engmet
+      
+c     total derivative of the configurational free energy
+      
+      if(lfree)then
+        
+        eng_cfg_fre=dlambda*(ang_fre+bnd_fre+dih_fre+inv_fre+
+     x    tbp_fre+fbp_fre+cou_fre+vdw_fre+shl_fre)
+        vir_cfg_fre=dlambda*(ang_vir+bnd_vir+dih_vir+inv_vir+
+     x    tbp_vir+fbp_vir+cou_vir+vdw_vir+shl_vir)
+        
+      endif
+      
+c     sum solvation and excitation energies for pair forces
+      
+      if(mxnode.gt.1)then
+        
+        if(llsolva)then
+          
+          call gdsum(vdw_sol,mxtmls_sol2,buffer)
+          call gdsum(cou_sol,mxtmls_sol2,buffer)
+          
+          if(lghost)then
+            
+            call gdsum(vdw_exc,mxtmls_exc2,buffer)
+            call gdsum(cou_exc,mxtmls_exc2,buffer)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     add long range corrections to solvation terms
+      
+      if(lsolva)then
+        
+        vdw_sol(:)=vdw_sol(:)+elrc_sol(:)
+        if(lghost)vdw_exc(:)=vdw_exc(:)+elrc_exc(:)
+        
+      endif
+      
+      return
+      end subroutine force_manager
+      
+      subroutine forces
+     x  (loglnk,lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,keyfce,
+     x  kmax1,kmax2,kmax3,nhko,nlatt,mxnode,ntpvdw,ntpmet,natms,
+     x  nstbgr,nstep,nsteql,numrdf,nospl,nsolva,isolva,alpha,dlrpot,
+     x  drewd,engcpe,engsrp,epsq,rcut,rvdw,vircpe,virsrp,volm,engmet,
+     x  virmet)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating interatomic forces
+c     using the verlet neighbour list
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     amended  - t. forester sept 1994
+c     amended  - w. smith june 1995 for metal potentials
+c     
+c     key:
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ Ewald sum                         : ewald1,2,3
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ truncated and shifted coulombic   : coul4
+c     = 10,11 ----- reaction field                    : coul3
+c     = 12,13 ----- Smoothed Particle Mesh Ewald      : ewald[_spme,2,3]
+c     = 14,15 ----- Hautman-Klein-Ewald               : hkewald1,2,3
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lgofr,lzeql,loglnk,lewald,lspme,lhke,newjob,lcshft,safe
+      logical lsolva,lfree,lghost,llsolva
+      
+      integer idnode,imcon,keyfce,kmax1,kmax2,kmax3,nhko,nlatt
+      integer mxnode,ntpvdw,natms,nstbgr,nstep,nsteql,numrdf
+      integer ntpmet,nospl,nsolva,isolva,i,j,k,ii
+      
+      real(8) alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rvdw,eps
+      real(8) vircpe,virsrp,volm,engacc,engac1,viracc,engmet,virmet
+      
+      save newjob
+      
+      data newjob/.true./
+      
+      safe=.true.
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+      lhke=(keyfce/2.eq.7)
+      lspme=(keyfce/2.eq.6)
+      lewald=(keyfce/2.eq.1)
+      lcshft=(keyfce/2.eq.4.or.keyfce/2.eq.5)
+      
+c     create ewald interpolation arrays
+      
+      if(newjob)then
+        
+        if(lhke)then
+          
+          call hkgen(idnode,nhko,nlatt,alpha,drewd,rcut)
+          
+        else if(lewald.or.lspme.or.lcshft)then
+          
+          call erfcgen(alpha,drewd,rcut)
+          
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+c     initialise force arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+c     calculate local density in metals
+      
+      if(ntpmet.gt.0)then
+        
+        call metdens
+     x    (idnode,imcon,mxnode,natms,engmet,virmet)
+        
+        stress(1)=stress(1)-virmet/3.d0
+        stress(5)=stress(5)-virmet/3.d0
+        stress(9)=stress(9)-virmet/3.d0
+        
+      endif
+      
+c     fourier contribution to coulombic forces in Ewald sum
+      
+      if(lewald)then
+        
+        call ewald1
+     x    (lsolva,llsolva,lfree,lghost,idnode,mxnode,natms,imcon,
+     x    kmax1,kmax2,kmax3,engac1,viracc,alpha,volm,epsq)
+        
+        engcpe=engcpe+engac1
+        vircpe=vircpe+viracc
+        
+      endif
+      
+c     hautman-klein-ewald method
+      
+      if(lhke)then
+        
+c     fourier terms of hk-ewald
+        
+        call hkewald1
+     x    (idnode,mxnode,natms,imcon,nhko,kmax1,kmax2,
+     x    engacc,viracc,alpha,epsq)
+        
+        engcpe=engcpe+engacc
+        vircpe=vircpe+viracc
+        
+c     real space terms of hk-ewald
+        
+        call hkewald2
+     x    (idnode,mxnode,nhko,nlatt,imcon,natms,engacc,viracc,
+     x    drewd,rcut,epsq)
+        
+        engcpe=engcpe+engacc
+        vircpe=vircpe+viracc
+        
+      endif
+      
+c     smoothed particle mesh ewald
+      
+      if(lspme)then
+        
+        call ewald_spme
+     x    (idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3,nospl,
+     x    engac1,viracc,alpha,volm,epsq)
+        
+        engcpe=engcpe+engac1
+        vircpe=vircpe+viracc
+        
+      endif
+      
+c     outer loop over atoms
+      
+      ii=0
+      
+      do i=idnode+1,natms,mxnode
+        
+        ii=ii+1
+        
+c     calculate interatomic distances
+        
+        do k=1,lentry(ii)
+          
+          j=list(ii,k)
+          ilist(k)=j
+          
+          xdf(k)=xxx(i)-xxx(j)
+          ydf(k)=yyy(i)-yyy(j)
+          zdf(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary conditions
+        
+        call images(imcon,0,1,lentry(ii),cell,xdf,ydf,zdf)
+        
+c     square of distances
+        
+        do k=1,lentry(ii)
+          
+          rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+          
+        enddo
+        
+c     calculate metal forces and potential
+        
+        if(ntpmet.gt.0)then
+          
+          call metfrc(safe,i,lentry(ii),engacc,viracc)
+          
+          engmet=engmet+engacc
+          virmet=virmet+viracc
+          
+        endif
+        
+c     calculate short range force and potential terms
+        
+        if(ntpvdw.gt.0.and.mod(keyfce,2).eq.1)then
+          
+          call srfrce
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,
+     x      rvdw,dlrpot)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+c     (real space contributions to ewald sum)
+        
+        if(lewald.or.lspme)then
+          
+          call ewald2(llsolva,lfree,lghost,i,lentry(ii),engacc,
+     x      viracc,drewd,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.2)then
+          
+          call coul2
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call coul4
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3
+     x      (llsolva,lfree,lghost,i,lentry(ii),engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+c     accumulate radial distribution functions
+        
+        if(lgofr.and.((.not.lzeql).or.(nstep.gt.nsteql)))then
+          
+          if(mod(nstep,nstbgr).eq.0)then
+            
+            call rdf0(i,lentry(ii),rcut)
+            
+          endif
+          
+        endif
+        
+      enddo      
+      
+c     check metal interpolation is safe
+      
+      if(ntpmet.gt.0)then
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)call error(idnode,142)
+        
+      endif
+      
+c     calculate corrections for intramolecular coulomb terms in
+c     Ewald sum
+      
+      if(lewald.or.lspme.or.lhke)then
+        
+        eps=epsq
+        if(loglnk)eps=eps*2.0d0
+        
+c     outer loop over atoms
+        
+        ii=0
+        
+        do i=idnode+1,natms,mxnode
+          
+          ii=ii+1
+          
+c     calculate interatomic distances
+          
+          do k=1,nexatm(ii)
+            
+            j=lexatm(ii,k)
+            jlist(k)=j
+            
+            xdf(k)=xxx(i)-xxx(j)
+            ydf(k)=yyy(i)-yyy(j)
+            zdf(k)=zzz(i)-zzz(j)
+            
+          enddo
+          
+c     periodic boundary condition
+          
+          call images(imcon,0,1,nexatm(ii),cell,xdf,ydf,zdf)
+          
+c     calculate correction terms
+          
+          if(lhke)then
+            
+            call hkewald3(i,ii,engacc,viracc,eps)
+            
+          else
+            
+            call ewald3
+     x        (llsolva,lfree,lghost,i,ii,engacc,viracc,alpha,eps)
+            
+          endif
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        enddo
+        
+      endif
+      
+c     counter for rdf statistics outside loop structure
+      
+      if(lgofr.and.((.not.lzeql).or.(nstep.gt.nsteql)))then
+        
+        if(mod(nstep,nstbgr).eq.0)then
+          
+          numrdf=numrdf+1
+          
+        endif
+        
+      endif
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=engmet
+        buffer(6)=virmet
+        buffer(7)=vdw_fre
+        buffer(8)=cou_fre
+        buffer(9)=vdw_vir
+        buffer(10)=cou_vir
+        call gdsum(buffer(1),10,buffer(11))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        engmet=buffer(5)
+        virmet=buffer(6)
+        vdw_fre=buffer(7)
+        cou_fre=buffer(8)
+        vdw_vir=buffer(9)
+        cou_vir=buffer(10)
+        
+      endif
+      
+      return
+      end subroutine forces
+      
+      subroutine forces_neu
+     x  (lgofr,lzeql,lsolva,lfree,lghost,idnode,imcon,keyfce,
+     x  mxnode,natms,nneut,nstbgr,nstep,nsteql,numrdf,nsolva,
+     x  isolva,dlrpot,engcpe,engsrp,epsq,rcut,rvdw,alpha,
+     x  vircpe,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating interatomic forces
+c     using the verlet neighbour list
+c     neutral group implemenation - no Ewald sum option
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     
+c     modified  - t. forester april 1993
+c     key:
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ invalid
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ invalid
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lgofr,lzeql,newlst,lchk,lsolva,lfree,lghost,llsolva
+      
+      integer idnode,imcon,keyfce,mxnode,natms,nneut,nstbgr
+      integer nstep,nsteql,numrdf,i,fail,jneu,jj0,jj1,j
+      integer ibig,ia,ineu,isn,ik,nsolva,isolva
+      real(8) dlrpot,engcpe,engsrp,epsq,rcut,rvdw,vircpe
+      real(8) virsrp,engacc,viracc,anorm,alpha
+      
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      
+      dimension fail(2)
+      
+      data fail/0,0/
+      
+c     allocate working arrays
+      
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(1))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(2))
+      do i=1,2
+        if(fail(i).ne.0)call error(idnode,1820)
+      enddo
+      
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+      
+c     initialise force and stress arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=0.d0
+      enddo
+      
+c     initialise energy and virial accumulators
+      
+      engcpe=0.d0
+      engsrp=0.d0
+      vircpe=0.d0
+      virsrp=0.d0
+      
+c     intra group vectors com
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-xxx(jj0)
+          tyy(j)=yyy(j)-yyy(jj0)
+          tzz(j)=zzz(j)-zzz(jj0)
+          
+        enddo
+        
+      enddo
+      
+      call images(imcon,0,1,natms,cell,txx,tyy,tzz)
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          xxx(j)=txx(j)+xxx(jj0)
+          yyy(j)=tyy(j)+yyy(jj0)
+          zzz(j)=tzz(j)+zzz(jj0)
+          
+        enddo
+        
+c     centre of molecule
+        
+        uxx(jneu)=0.d0
+        uyy(jneu)=0.d0
+        uzz(jneu)=0.d0
+        anorm=1.d0/dble(jj1-jj0+1)
+        
+        do j=jj0,jj1
+          
+          uxx(jneu)=uxx(jneu)+xxx(j)*anorm
+          uyy(jneu)=uyy(jneu)+yyy(j)*anorm
+          uzz(jneu)=uzz(jneu)+zzz(j)*anorm
+          
+        enddo
+        
+c     vector from site to geometric centre
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-uxx(jneu)
+          tyy(j)=yyy(j)-uyy(jneu)
+          tzz(j)=zzz(j)-uzz(jneu)
+          
+        enddo
+        
+      enddo
+      
+c     outer loop over neutral groups
+      
+      lchk=.true.
+      ibig=0
+      ia=0
+      
+      do ineu=idnode+1,nneut,mxnode
+        
+        ia=ia+1
+        
+c     calculate interatomic distances
+        
+        newlst=.true.
+        
+        isn=1
+        call neutlst
+     x    (newlst,lchk,isn,imcon,idnode,ineu,ia,ik,
+     x    txx,tyy,tzz,uxx,uyy,uzz)
+        
+c     trap possible array bound exception 
+        
+        ibig=max(ibig,ik)
+        if(ik.gt.mxxdf)ik=0
+        
+c     calculate short range force and potential terms
+        
+        if(mod(keyfce,2).eq.1)then
+          
+          call srfrceneu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,dlrpot,rvdw)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+        
+        if(keyfce/2.eq.2)then
+          
+          call coul2neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call error(idnode,250)
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq,rcut,alpha)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+c     accumulate radial distribution functions
+        
+        if( ((.not.lzeql).or.(nstep.gt.nsteql)).and.(lgofr).and.
+     x    mod(nstep,nstbgr).eq.0)then
+          
+          call rdf0neu(ik,rcut)
+          
+        endif
+        
+      enddo
+      
+c     check on validity of call to neutlst
+      
+      if(mxnode.gt.1)call gstate(lchk)
+      if(.not.lchk)then 
+        call gimax(ibig,1,i)
+        if(idnode.eq.0)write(nrite,*)'mxxdf must be at least ',ibig
+        if(idnode.eq.0)write(nrite,*)'mxxdf is currently ',mxxdf
+        call  error(idnode,478)
+      endif
+      
+      if(keyfce/2.eq.1.or.keyfce/2.eq.6)call error(idnode,250)
+      
+c     counter for rdf statistics outside loop structure
+      
+      if( ((.not.lzeql).or.(nstep.gt.nsteql)).and.(lgofr).and.
+     x  mod(nstep,nstbgr).eq.0)numrdf=numrdf+1
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=vdw_fre
+        buffer(6)=cou_fre
+        buffer(7)=vdw_vir
+        buffer(8)=cou_vir
+        call gdsum(buffer(1),8,buffer(9))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        vdw_fre=buffer(5)
+        cou_fre=buffer(6)
+        vdw_vir=buffer(7)
+        cou_vir=buffer(8)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,stat=fail(2))
+      
+      return
+      end subroutine forces_neu
+      
+      subroutine multiple
+     x  (loglnk,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x  imcon,keyfce,nlatt,kmax1,kmax2,kmax3,nhko,multt,
+     x  mxnode,natms,nstep,nstbgr,nsteql,numrdf,nospl,nsolva,
+     x  isolva,alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rprim,
+     x  rvdw,vircpe,virsrp,volm)
+c***************************************************************************
+c     
+c     dl_poly subroutine for multiple time step algorithm
+c     reciprocal space calculated on long time steps.
+c     
+c     copyright daresbury laboratory
+c     
+c     author  t. forester,  may 1993
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ Ewald sum                         : ewald1,2,3,4
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ truncated and shifted coulombic   : coul4
+c     = 10,11 ----- reaction field                    : coul3
+c     = 12,13 ----- Smoothed Particle Mesh Ewald      : ewald[_spme,2,3,4]
+c     = 14,15 ----- Hautman-Klein-Ewald               : hkewald1,2,3,4
+c     
+c****************************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=5
+
+      logical newplst,newlst,lgofr,lzeql,lgr,loglnk,lewald,lspme
+      logical lhke,newjob,lcshft,lsolva,lfree,lghost,llsolva
+      integer idnode,imcon,keyfce,nlatt,kmax1,kmax2,kmax3,nhko,multt
+      integer mxnode,natms,nstep,nstbgr,nsteql,numrdf,nospl,fail
+      integer numlsts,i,nstep0,nsolva,isolva,ii,k,j,ik
+      real(8) alpha,dlrpot,drewd,engcpe,engsrp,epsq,rcut,rprim,rvdw
+      real(8) vircpe,virsrp,volm,stresp,engcpl,engacc,viracc,engac1
+      real(8) vircpl,eps,ann,engsr1,viracl,engsrl,virsrl,virac2,engcp1
+      real(8) vircp1,engacl,engac2,virsr1
+      
+      real(8), allocatable :: fpx(:),fpy(:),fpz(:)
+      real(8), allocatable :: vdw_sol_put(:),cou_sol_put(:)
+      real(8), allocatable :: vdw_exc_put(:),cou_exc_put(:)
+      
+      dimension stresp(9),fail(nnn)
+      
+      save engcpl,engsrl,vircpl,virsrl,nstep0,numlsts,engcp1,vircp1
+      save engsr1,virsr1,stresp,fpx,fpy,fpz,newjob
+      save vdw_sol_put,cou_sol_put,vdw_exc_put,cou_exc_put
+      
+      data newjob/.true./
+      data numlsts/-1/
+      
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+      lhke=(keyfce/2.eq.7)
+      lspme=(keyfce/2.eq.6)
+      lewald=(keyfce/2.eq.1)
+      lcshft=(keyfce/2.eq.4.or.keyfce/2.eq.5)
+      if(newlst)nstep0=nstep
+      newplst=(newlst).or.(mod(nstep-nstep0,multt).eq.0)
+      
+c     allocate working arrays
+      
+      if(newjob)then
+        
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate (fpx(mxatms),fpy(mxatms),fpz(mxatms),stat=fail(1))
+        if(lsolva)then
+          
+          allocate (vdw_sol_put(mxtmls_sol2),stat=fail(2))
+          allocate (cou_sol_put(mxtmls_sol2),stat=fail(3))
+          if(lghost)then
+            allocate (vdw_exc_put(mxtmls_exc2),stat=fail(4))
+            allocate (cou_exc_put(mxtmls_exc2),stat=fail(5))
+          endif
+          
+        endif
+        do i=1,nnn
+          if(fail(i).ne.0)call error(idnode,1840)
+        enddo
+        
+      endif
+      
+c     create ewald interpolation arrays
+      
+      if(newjob)then
+        
+        if(lspme.or.lewald.or.lcshft)then
+          
+          call erfcgen(alpha,drewd,rcut)
+          
+        endif
+        
+      endif
+      
+      newjob=.false.
+      
+c     divide neighbour list into primary and secondary neighbours
+      
+      if(newplst)then        
+        
+        numlsts=numlsts+1
+        call primlst(idnode,mxnode,natms,imcon,rprim)
+        
+      endif
+      
+c     flag for accumulating rdfs
+      
+      lgr=.false.
+      if(nstbgr.gt.0)lgr=(mod(numlsts,nstbgr).eq.0)
+      lgr=(lgr.and.(newplst.and.lgofr))
+      lgr=(lgr.and.((.not.lzeql).or.(nstep-nsteql.gt.0)))
+      
+c     zero force and stress arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=0.d0
+      enddo
+      
+c     ********************PROCESS SECONDARY NEIGHBOURS******************
+      
+      if(newplst.or.(mod(nstep-nstep0,multt).le.1))then
+        
+c     zero accumulators
+        
+        engcpl=0.d0
+        vircpl=0.d0
+        engsrl=0.d0
+        virsrl=0.d0
+        llsolva=lsolva
+        if(lsolva)then
+          
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+c     calculate fourier contribution to secondary coulombic forces
+        
+        if(lewald.or.lspme.or.lhke)then
+          
+          if(lewald)then
+            
+            call ewald1
+     x        (lsolva,llsolva,lfree,lghost,idnode,mxnode,natms,imcon,
+     x        kmax1,kmax2,kmax3,engac1,viracc,alpha,volm,epsq)
+            
+c     hautman-klein-ewald method
+            
+          elseif(lhke)then
+            
+            call hkewald1
+     x        (idnode,mxnode,natms,imcon,nhko,kmax1,kmax2,
+     x        engac1,viracc,alpha,epsq)
+            
+c     real space terms of hk-ewald
+            
+            call hkewald2
+     x        (idnode,mxnode,nhko,nlatt,imcon,natms,engac2,
+     x        virac2,drewd,rcut,epsq)
+            
+            engac1=engac1+engac2
+            viracc=viracc+virac2
+            
+          elseif(lspme)then
+            
+c     smoothed particle mesh ewald
+            
+            call ewald_spme
+     x        (idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3,nospl,
+     x        engac1,viracc,alpha,volm,epsq)
+            
+          endif
+          
+          engcpl=engcpl+engac1
+          vircpl=vircpl+viracc
+          
+c     calculate corrections for intramolecular coulomb terms in 
+c     Ewald sum
+c     note: if using link cells - have double counted excluded 
+c     interactions use temporary adjustment to relative dielectric
+c     constant
+          
+          eps=epsq
+          if(loglnk)eps=epsq*2.0d0
+          
+c     calculate self interaction corrections for fourier contributions
+          
+          ii=0
+          
+          do i=idnode+1,natms,mxnode
+            
+            ii=ii+1
+            
+c     calculate interatomic distances
+            
+            do k=1,nexatm(ii)
+              
+              j=lexatm(ii,k)
+              jlist(k)=j
+              
+              xdf(k)=xxx(i)-xxx(j)
+              ydf(k)=yyy(i)-yyy(j)
+              zdf(k)=zzz(i)-zzz(j)
+              
+            enddo
+            
+c     periodic boundary condition
+            
+            call images(imcon,0,1,nexatm(ii),cell,xdf,ydf,zdf)
+            
+c     calculate correction terms
+            
+            if(lhke)then
+              
+              call hkewald3(i,ii,engacc,viracc,eps)
+              
+            else
+              
+              call ewald3
+     x          (lsolva,lfree,lghost,i,ii,engacc,viracc,alpha,eps)
+              
+            endif
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          enddo
+          
+        endif
+        
+c     calculate pair contributions to secondary neighbour forces
+        
+        ii=0
+        
+        do i=idnode+1,natms,mxnode
+          
+          ii=ii+1
+          
+c     calculate interatomic distances
+          
+          ik=0
+          
+          do k=1,lentry(ii)
+            
+            j=list(ii,k)
+            
+            if(j.gt.0)then
+              
+              ik=ik+1
+              ilist(ik)=j
+              xdf(ik)=xxx(i)-xxx(j)
+              ydf(ik)=yyy(i)-yyy(j)
+              zdf(ik)=zzz(i)-zzz(j)
+              
+            endif
+            
+          enddo
+          
+c     periodic boundary conditions
+          
+          call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+          
+c     square of distance
+          
+          do k=1,ik
+            
+            rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+            
+          enddo
+          
+c     accumulate radial distribution functions
+          
+          if(lgr)call rdf0(i,ik,rcut)
+          
+c     calculate short range force and potential terms
+          
+          if(mod(keyfce,2).eq.1)then
+            
+            call srfrce
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+            
+            engsrl=engsrl+engacc
+            virsrl=virsrl+viracc
+            
+          endif
+          
+c     calculate coulombic force and potential terms
+c     (real space contributions to ewald sum)
+          
+          if(lewald.or.lspme)then
+            
+            call ewald2
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,drewd,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.2)then
+            
+            call coul2
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.3)then
+            
+            call coul0
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.4)then
+            
+            call coul4
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.5)then
+            
+            call coul3
+     x        (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          endif
+          
+        enddo
+        
+c     store secondary forces and stress tensor
+        
+        do i=1,natms
+          
+          flx(i)=fxx(i)
+          fly(i)=fyy(i)
+          flz(i)=fzz(i)
+          fxx(i)=0.d0
+          fyy(i)=0.d0
+          fzz(i)=0.d0
+          
+        enddo
+        
+        do i=1,9
+          stresl(i)=stress(i)
+          stress(i)=0.d0
+        enddo
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol(:)
+          cou_sol_lng(:)=cou_sol(:)
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc(:)
+            cou_exc_lng(:)=cou_exc(:)
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     ****************END OF SECONDARY NEIGHBOUR PROCESSING*************
+      
+c     ********************PROCESS PRIMARY NEIGHBOURS********************
+      
+c     zero accumulators for total energies and virials
+      
+      engcpe=0.d0
+      engsrp=0.d0
+      vircpe=0.d0
+      virsrp=0.d0
+      
+c     calculate pair force contributions
+      
+      ii=0
+      
+      do i=idnode+1,natms,mxnode
+        
+        ii=ii+1
+        
+c     calculate interatomic distances
+        
+        ik=0
+        
+        do k=1,lentry(ii)
+          
+          j=-list(ii,k)
+          
+          if(j.gt.0)then
+            
+            ik=ik+1
+            ilist(ik)=j
+            xdf(ik)=xxx(i)-xxx(j)
+            ydf(ik)=yyy(i)-yyy(j)
+            zdf(ik)=zzz(i)-zzz(j)
+            
+          endif
+          
+        enddo
+        
+c     periodic boundary conditions
+        
+        call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+        
+c     square of distance
+        
+        do k=1,ik
+          
+          rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+          
+        enddo
+        
+c     accumulate radial distribution functions
+        
+        if(lgr)call rdf0(i,ik,rcut)
+        
+c     calculate short range force and potential terms
+        
+        if(mod(keyfce,2).eq.1)then
+          
+          call srfrce
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+c     (real space contributions to ewald sum)
+        
+        if(lewald.or.lspme.or.lhke)then
+          
+          if(newplst.or.
+     x      (mod(nstep-nstep0,multt).le.1))then
+            
+            if(lhke)then
+              
+              call hkewald4(i,ik,engacc,viracc,engacl,viracl,rcut,epsq)
+              
+            else
+              
+              call ewald4
+     x          (llsolva,lfree,lghost,i,ik,engacc,viracc,engacl,viracl,
+     x          drewd,rcut,epsq)
+              
+            endif
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            engcpl=engcpl+engacl
+            vircpl=vircpl+viracl
+            
+          else
+            
+            call coul0
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            
+          endif
+          
+        elseif(keyfce/2.eq.2)then
+          
+          call coul2
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call coul4
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3
+     x      (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+      enddo
+      
+c     **************END OF PRIMARY NEIGHBOUR PROCESSING*****************
+      
+c     counter for rdf statistics outside loop structure
+      
+      if(lgr)numrdf=numrdf+1
+      
+c     add in secondary neighbour contributions to force, energy etc
+      
+      if(newplst)then
+        
+        do i=1,natms
+          
+          fpx(i)=flx(i)
+          fpy(i)=fly(i)
+          fpz(i)=flz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresp(i)=stresl(i)
+        enddo
+        
+        engsr1=engsrl
+        virsr1=virsrl
+        engcp1=engcpl
+        vircp1=vircpl
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_put(:)=vdw_sol_lng(:)
+          cou_sol_put(:)=cou_sol_lng(:)
+          
+          if(lghost)then
+            
+            vdw_exc_put(:)=vdw_exc_lng(:)
+            cou_exc_put(:)=cou_exc_lng(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     calculate force increments etc
+      
+      if(mod(nstep-nstep0,multt).eq.1)then
+        
+        do i=1,natms
+          
+          flx(i)=flx(i)-fpx(i)
+          fly(i)=fly(i)-fpy(i)
+          flz(i)=flz(i)-fpz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresl(i)=stresl(i)-stresp(i)
+        enddo
+        
+        virsrl=virsrl-virsr1
+        engsrl=engsrl-engsr1
+        vircpl=vircpl-vircp1
+        engcpl=engcpl-engcp1
+        
+c     solvation and excitation increments
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol_lng(:)-vdw_sol_put(:)
+          cou_sol_lng(:)=cou_sol_lng(:)-cou_sol_put(:)
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc_lng(:)-vdw_exc_put(:)
+            cou_exc_lng(:)=cou_exc_lng(:)-cou_exc_put(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     extrapolate long range terms
+      
+      ann=dble(mod(nstep-nstep0,multt))
+      
+      do i=1,natms
+        
+        fxx(i)=fpx(i)+flx(i)*ann+fxx(i)
+        fyy(i)=fpy(i)+fly(i)*ann+fyy(i)
+        fzz(i)=fpz(i)+flz(i)*ann+fzz(i)
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=stress(i)+stresp(i)+stresl(i)*ann
+      enddo
+      
+      engsrp=engsr1+engsrl*ann+engsrp
+      virsrp=virsr1+virsrl*ann+virsrp
+      engcpe=engcp1+engcpl*ann+engcpe
+      vircpe=vircp1+vircpl*ann+vircpe
+      
+c     solvation and excitation extrapolation
+      
+      if(llsolva)then
+        
+        vdw_sol(:)=vdw_sol_put(:)+vdw_sol_lng(:)*ann+vdw_sol(:)
+        cou_sol(:)=cou_sol_put(:)+cou_sol_lng(:)*ann+cou_sol(:)
+        
+        if(lghost)then
+          
+          vdw_exc(:)=vdw_exc_put(:)+vdw_exc_lng(:)*ann+vdw_exc(:)
+          cou_exc(:)=cou_exc_put(:)+cou_exc_lng(:)*ann+cou_exc(:)
+          
+        endif
+        
+      endif
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=vdw_fre
+        buffer(6)=cou_fre
+        buffer(7)=vdw_vir
+        buffer(8)=cou_vir
+        call gdsum(buffer(1),8,buffer(9))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        vdw_fre=buffer(5)
+        cou_fre=buffer(6)
+        vdw_vir=buffer(7)
+        cou_vir=buffer(8)
+        
+      endif
+      
+      return
+      end subroutine multiple
+      
+      subroutine multiple_neu
+     x  (lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,imcon,
+     x  keyfce,multt,mxnode,natms,nneut,nstbgr,nstep,nsteql,
+     x  numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x  rprim,rcut,rvdw,alpha,vircpe,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating interatomic forces
+c     using the verlet neighbour list
+c     neutral group implemenation - no Ewald sum option
+c     multiple timestep option
+c     
+c     parallel replicated data version
+c     
+c     fpx,fpy,fpz : forces from electrostatics fron rprim < r <= rcut
+c     fxx,fyy,fzz : total force
+c     
+c     copyright daresbury laboratory april 1994
+c     author  - t. forester april 1993
+c     key:
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     = 2,3  ------ invalid
+c     = 4,5  ------ distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     = 8,9  ------ invalid
+c     = 10,11 ----- reaction field                    : coul3
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=7
+
+      logical lgofr,lzeql,newlst,newplst,lgr,lchk,newjob,lsolva
+      logical lfree,lghost,llsolva
+      integer idnode,imcon,keyfce,multt,mxnode,natms,nneut,nstbgr
+      integer nstep,nsteql,numrdf,fail,i,numlsts,jneu,jj0,j
+      integer jj1,ineu,ia,isn,ibig,ik,nstep0,nsolva,isolva
+      real(8) delr,dlrpot,engcpe,engsrp,epsq,rprim,rcut,rvdw,vircpe
+      real(8) virsrp,engcpl,vircpl,engsrl,virsrl,anorm,ann,stresp
+      real(8) engacc,viracc,engsr1,virsr1,engcp1,vircp1,alpha
+      
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: fpx(:),fpy(:),fpz(:)
+      real(8), allocatable :: vdw_sol_put(:),cou_sol_put(:)
+      real(8), allocatable :: vdw_exc_put(:),cou_exc_put(:)
+      
+      dimension fail(nnn),stresp(9)
+      
+      save engcpl,engsrl,vircpl,virsrl,nstep0,numlsts,engcp1,vircp1
+      save engsr1,virsr1,stresp,fpx,fpy,fpz
+      save vdw_sol_put,cou_sol_put,vdw_exc_put,cou_exc_put
+      
+      data newjob/.true./
+      data numlsts/-1/
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(1))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(2))
+      if(newjob)then
+        
+        allocate (fpx(mxatms),fpy(mxatms),fpz(mxatms),stat=fail(3))
+        if(lsolva)then
+          
+          allocate (vdw_sol_put(mxtmls_sol2),stat=fail(4))
+          allocate (cou_sol_put(mxtmls_sol2),stat=fail(5))
+          
+          if(lghost)then
+            allocate (vdw_exc_put(mxtmls_exc2),stat=fail(6))
+            allocate (cou_exc_put(mxtmls_exc2),stat=fail(7))
+          endif
+          
+        endif
+        newjob=.false.
+        
+      endif
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1850)
+      enddo
+      
+      llsolva=.false.
+      if(lsolva)then
+        llsolva=(mod(nstep-nsolva,isolva).eq.0)
+      endif
+
+c     error if ewald sum requested
+      
+      if(keyfce/2.eq.1.or.keyfce/2.eq.6)call error(idnode,250)
+      
+c     create list of primary and secondary neighbours
+      
+      if(newlst)nstep0=nstep
+      newplst=(mod(nstep-nstep0,multt).eq.0)
+      
+      if(newplst)then        
+        
+        numlsts=numlsts+1
+        call prneulst(newlst,imcon,idnode,mxnode,nneut,rprim)
+        
+      endif
+      
+c     zero accumulators for total energies and virials
+      
+      engcpe=0.d0
+      engsrp=0.d0
+      vircpe=0.d0
+      virsrp=0.d0
+      
+c     zero force arrays
+      
+      do i=1,natms
+        
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+        
+      enddo
+      
+c     zero stress arrays
+      
+      do i=1,9
+        stress(i)=0.d0
+      enddo
+      
+c     flag for accumulating rdfs
+      
+      lgr=.false.
+      if(nstbgr.gt.0)lgr=(mod(numlsts,nstbgr).eq.0)
+      lgr=(lgr.and.(newplst.and.lgofr))
+      lgr=(lgr.and.((.not.lzeql).or.(nstep-nsteql.gt.0)))
+      
+c     intra group vectors com
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-xxx(jj0)
+          tyy(j)=yyy(j)-yyy(jj0)
+          tzz(j)=zzz(j)-zzz(jj0)
+          
+        enddo
+        
+      enddo
+      
+      call images(imcon,0,1,natms,cell,txx,tyy,tzz)
+      
+      do jneu=1,nneut
+        
+        jj0=neulst(jneu)
+        jj1=neulst(jneu+1)-1
+        
+c     loop over jneu sites
+        
+        do j=jj0,jj1
+          
+          xxx(j)=txx(j)+xxx(jj0)
+          yyy(j)=tyy(j)+yyy(jj0)
+          zzz(j)=tzz(j)+zzz(jj0)
+          
+        enddo
+        
+c     centre of molecule
+        
+        uxx(jneu)=0.d0
+        uyy(jneu)=0.d0
+        uzz(jneu)=0.d0
+        anorm=1.d0/dble(jj1-jj0+1)
+        
+        do j=jj0,jj1
+          
+          uxx(jneu)=uxx(jneu)+xxx(j)*anorm
+          uyy(jneu)=uyy(jneu)+yyy(j)*anorm
+          uzz(jneu)=uzz(jneu)+zzz(j)*anorm
+          
+        enddo
+        
+c     vector from site to geometric centre
+        
+        do j=jj0,jj1
+          
+          txx(j)=xxx(j)-uxx(jneu)
+          tyy(j)=yyy(j)-uyy(jneu)
+          tzz(j)=zzz(j)-uzz(jneu)
+          
+        enddo
+        
+      enddo
+      
+c     ********************PROCESS SECONDARY NEIGHBOURS********************
+        
+      lchk=.true.
+      ibig=0
+      ia=0
+      
+      if(newplst.or.(mod(nstep-nstep0,multt).le.1))then
+      
+c     zero accumulators for secondary neighbour energies and virial
+        
+        engcpl=0.d0
+        vircpl=0.d0
+        engsrl=0.d0
+        virsrl=0.d0
+        
+c     initialise solvation and excitation  arrays
+
+        if(lsolva)then
+          
+          cou_sol(:)=0.d0
+          vdw_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            cou_exc(:)=0.d0
+            vdw_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+c     outer loop over neutral groups
+        
+        do ineu=idnode+1,nneut,mxnode
+          
+          ia=ia+1
+          
+c     calculate interatomic distances
+          
+          isn=-1
+          call neutlst
+     x      (.true.,lchk,isn,imcon,idnode,ineu,ia,ik,
+     x      txx,tyy,tzz,uxx,uyy,uzz)
+          
+c     trap possible array bound exception 
+          
+          ibig=max(ibig,ik)
+          if(ik.gt.mxxdf)ik=0
+          
+c     calculate short range force and potential terms
+          
+          if(mod(keyfce,2).eq.1.and.(rvdw.gt.rprim-delr))then
+            
+            call srfrceneu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,dlrpot,rvdw)
+            
+            engsrl=engsrl+engacc
+            virsrl=virsrl+viracc
+            
+          endif
+          
+c     calculate coulombic force and potential terms
+          
+          if(keyfce/2.eq.2)then
+            
+            call coul2neu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.3)then
+            
+            call coul0neu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,epsq)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          elseif(keyfce/2.eq.4)then
+            
+            call error(idnode,250)
+            
+          elseif(keyfce/2.eq.5)then
+            
+            call coul3neu
+     x        (lsolva,lfree,lghost,ik,engacc,viracc,epsq,rcut,alpha)
+            
+            engcpl=engcpl+engacc
+            vircpl=vircpl+viracc
+            
+          else
+            
+            call error(idnode,250)
+            
+          endif
+          
+c     accumulate radial distribution functions out to rcut
+          
+          if(lgr)then
+            call rdf0neu(ik,rcut)
+          endif
+          
+        enddo
+        
+c     store secondary forces and stress tensor
+        
+        do i=1,natms
+          
+          flx(i)=fxx(i)
+          fly(i)=fyy(i)
+          flz(i)=fzz(i)
+          fxx(i)=0.d0
+          fyy(i)=0.d0
+          fzz(i)=0.d0
+          
+        enddo
+        
+        do i=1,9
+          
+          stresl(i)=stress(i)
+          stress(i)=0.d0
+          
+        enddo
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol(:)
+          cou_sol_lng(:)=cou_sol(:)
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc(:)
+            cou_exc_lng(:)=cou_exc(:)
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     ****************END OF SECONDARY NEIGHBOUR PROCESSING*************
+      
+c     ********************PROCESS PRIMARY NEIGHBOURS********************
+      
+      ia=0
+      do ineu=idnode+1,nneut,mxnode
+        
+        ia=ia+1
+        
+c     calculate interatomic distances
+        
+        isn=1        
+        call neutlst
+     x    (.true.,lchk,isn,imcon,idnode,ineu,ia,ik,
+     x    txx,tyy,tzz,uxx,uyy,uzz)
+        
+c     trap possible array bound exception 
+        
+        ibig=max(ibig,ik)
+        if(ik.gt.mxxdf)ik=0
+        
+c     calculate short range force and potential terms
+        
+        if(mod(keyfce,2).eq.1)then
+          
+          call srfrceneu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,dlrpot,rvdw)
+          
+          engsrp=engsrp+engacc
+          virsrp=virsrp+viracc
+          
+        endif
+        
+c     calculate coulombic force and potential terms
+        
+        if(keyfce/2.eq.2)then
+          
+          call coul2neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.3)then
+          
+          call coul0neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        elseif(keyfce/2.eq.4)then
+          
+          call error(idnode,250)
+          
+        elseif(keyfce/2.eq.5)then
+          
+          call coul3neu
+     x      (llsolva,lfree,lghost,ik,engacc,viracc,epsq,rcut,alpha)
+          
+          engcpe=engcpe+engacc
+          vircpe=vircpe+viracc
+          
+        endif
+        
+c     accumulate radial distribution functions out to rcut
+        
+        if(lgr)then
+          call rdf0neu(ik,rcut)
+        endif
+        
+      enddo
+      
+c     ******************END OF PRIMARY NEIGHBOUR PROCESSING*************
+      
+c     check on validity of call to neutlst
+      
+      if(mxnode.gt.1)call gstate(lchk)
+      if(.not.lchk)then 
+        call gimax(ibig,1,i)
+        if(idnode.eq.0)write(nrite,*)'mxxdf must be at least ',ibig
+        if(idnode.eq.0)write(nrite,*)'mxxdf is currently ',mxxdf
+        call  error(idnode,479)
+      endif
+      
+c     counter for rdf statistics outside loop structure
+      
+      if(lgr)numrdf=numrdf+1
+      
+c     add in secondary neighbour contributions to force, energy etc
+      
+      if(newplst)then
+        
+        do i=1,natms
+          
+          fpx(i)=flx(i)
+          fpy(i)=fly(i)
+          fpz(i)=flz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresp(i)=stresl(i)
+        enddo
+        
+        engsr1=engsrl
+        virsr1=virsrl
+        engcp1=engcpl
+        vircp1=vircpl
+        
+c     store solvation and excitation arrays
+        
+        if(lsolva)then
+          
+          vdw_sol_put(:)=vdw_sol_lng(:)
+          cou_sol_put(:)=cou_sol_lng(:)
+          
+          if(lghost)then
+            
+            vdw_exc_put(:)=vdw_exc_lng(:)
+            cou_exc_put(:)=cou_exc_lng(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     calculate force increments etc
+      
+      if(mod(nstep-nstep0,multt).eq.1)then
+        
+        do i=1,natms
+          
+          flx(i)=flx(i)-fpx(i)
+          fly(i)=fly(i)-fpy(i)
+          flz(i)=flz(i)-fpz(i)
+          
+        enddo
+        
+        do i=1,9
+          stresl(i)=stresl(i)-stresp(i)
+        enddo
+        
+        virsrl=virsrl-virsr1
+        engsrl=engsrl-engsr1
+        vircpl=vircpl-vircp1
+        engcpl=engcpl-engcp1
+        
+c     solvation and excitation increments
+        
+        if(lsolva)then
+          
+          vdw_sol_lng(:)=vdw_sol_lng(:)-vdw_sol_put(:)
+          cou_sol_lng(:)=cou_sol_lng(:)-cou_sol_put(:)
+          
+          if(lghost)then
+            
+            vdw_exc_lng(:)=vdw_exc_lng(:)-vdw_exc_put(:)
+            cou_exc_lng(:)=cou_exc_lng(:)-cou_exc_put(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     extrapolate long range terms
+      
+      ann=dble(mod(nstep-nstep0,multt))
+      
+      do i=1,natms
+        
+        fxx(i)=fpx(i)+flx(i)*ann+fxx(i)
+        fyy(i)=fpy(i)+fly(i)*ann+fyy(i)
+        fzz(i)=fpz(i)+flz(i)*ann+fzz(i)
+        
+      enddo
+      
+      do i=1,9
+        stress(i)=stress(i)+stresl(i)*ann+stresp(i)
+      enddo
+      
+      engsrp=engsr1+engsrl*ann+engsrp
+      virsrp=virsr1+virsrl*ann+virsrp
+      engcpe=engcp1+engcpl*ann+engcpe
+      vircpe=vircp1+vircpl*ann+vircpe
+      
+c     solvation and excitation extrapolation
+      
+      if(llsolva)then
+        
+        vdw_sol(:)=vdw_sol_put(:)+vdw_sol_lng(:)*ann+vdw_sol(:)
+        cou_sol(:)=cou_sol_put(:)+cou_sol_lng(:)*ann+cou_sol(:)
+        
+        if(lghost)then
+          
+          vdw_exc(:)=vdw_exc_put(:)+vdw_exc_lng(:)*ann+vdw_exc(:)
+          cou_exc(:)=cou_exc_put(:)+cou_exc_lng(:)*ann+cou_exc(:)
+          
+        endif
+        
+      endif
+      
+c     sum up contributions to short range and coulombic potential
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=engsrp
+        buffer(2)=virsrp
+        buffer(3)=engcpe
+        buffer(4)=vircpe
+        buffer(5)=vdw_fre
+        buffer(6)=cou_fre
+        buffer(7)=vdw_vir
+        buffer(8)=cou_vir
+        call gdsum(buffer(1),8,buffer(9))
+        engsrp=buffer(1)
+        virsrp=buffer(2)
+        engcpe=buffer(3)
+        vircpe=buffer(4)
+        vdw_fre=buffer(5)
+        cou_fre=buffer(6)
+        vdw_vir=buffer(7)
+        cou_vir=buffer(8)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (txx,tyy,tzz,uxx,uyy,uzz,stat=fail(1))
+      
+      return
+      end subroutine multiple_neu
+      
+      subroutine multiple_nsq
+     x  (lnsq,lgofr,lzeql,newlst,lsolva,lfree,lghost,idnode,
+     x  imcon,keyfce,multt,mxnode,natms,nstep,nstbgr,nsteql,
+     x  numrdf,nsolva,isolva,delr,dlrpot,engcpe,engsrp,epsq,
+     x  rcut,rprim,rvdw,vircpe,virsrp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for multiple time step algorithm 
+c     to be used with all-pairs option
+c     
+c     flx,fly,flz : forces from electrostatics from r > rcut
+c     fpx,fpy,fpz : forces from electrostatics from rprim < r <= rcut
+c     fxx,fyy,fzz : total force
+c     
+c     copyright daresbury laboratory 1993
+c     
+c     author  t. forester,  may 1993
+c     
+c     keyfce = odd  ------ short range potentials calculated : srfrce
+c     = 0,1  ------ no electrostatics
+c     Ewald sum --- not used
+c     = 4,5  ------ Distance dependent dielectric     : coul2
+c     = 6,7  ------ coulombic                         : coul0
+c     truncated and shifted coulombic -- not used
+c     reaction field - not used
+c     
+c****************************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=5
+      logical newplst,newlst,lgofr,lzeql,lgr,lnsq,newjob,lsolva
+      logical lfree,lghost,llsolva
+      integer idnode,imcon,keyfce,multt,mxnode,natms,nstep,nstbgr
+      integer nsteql,numrdf,fail,nstep0,ii,ik,k,numlsts,nsolva
+      integer isolva,i,j
+      real(8) delr,dlrpot,engcpe,engsrp,engcp3,epsq,rcut
+      real(8) rprim,rvdw,vircpe,virsrp,vircp3,rcut1,engcp2,vircp2
+      real(8) engsr2,virsr2,stresp,engacc,viracc
+      
+      real(8), allocatable :: fpx(:),fpy(:),fpz(:)
+      real(8), allocatable :: vdw_sol_put(:),cou_sol_put(:)
+      real(8), allocatable :: vdw_exc_put(:),cou_exc_put(:)
+      
+      dimension stresp(9),fail(nnn)
+      
+      save engsr2,virsr2,engcp2,vircp2,nstep0,numlsts,stresp,fpx,fpy,fpz
+      save vdw_sol_put,cou_sol_put,vdw_exc_put,cou_exc_put
+
+      data numlsts/-1/
+      data newjob/.true./
+      
+c     allocate work arrays
+      
+      if(newjob)then
+        
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate (fpx(mxatms),fpy(mxatms),fpz(mxatms),stat=fail(1))
+        if(lsolva)then
+          
+          allocate (vdw_sol_put(mxtmls_sol2),stat=fail(2))
+          allocate (cou_sol_put(mxtmls_sol2),stat=fail(3))
+          if(lghost)then
+            allocate (vdw_exc_put(mxtmls_exc2),stat=fail(4))
+            allocate (cou_exc_put(mxtmls_exc2),stat=fail(5))
+          endif
+          
+        endif
+        do i=1,nnn
+          if(fail(i).ne.0)call error(idnode,1860)
+        enddo
+        newjob=.false.
+        
+      endif
+      
+      if(lnsq)then
+        
+        llsolva=.false.
+        if(lsolva)then
+          llsolva=(mod(nstep-nsolva,isolva).eq.0)
+        endif
+        
+c     divide neighbour list into primary and secondary neighbours
+        
+        if(newplst)then        
+          
+          numlsts=numlsts+1
+          call primlst(idnode,mxnode,natms,imcon,rprim)
+          
+        endif
+        
+c     flag for accumulating rdfs
+        
+        lgr=(lgofr.and.(.not.lzeql.or.(nstep-nsteql.gt.0)))
+        lgr=(lgr.and.newplst.and.(mod(numlsts,nstbgr).eq.0))
+        
+c     set extended cutoff for electrostatics - secondary shell
+        
+        rcut1=rcut+delr
+        
+        if(newlst)nstep0=nstep
+        newplst=(newlst.or.mod(nstep-nstep0,multt).eq.0)
+        
+c     ********************PROCESS TERTIARY NEIGHBOURS*********************
+        
+        if(newplst)then
+          
+          call coul_nsq
+     x      (lsolva,lfree,lghost,idnode,mxnode,natms,imcon,epsq,rcut,
+     x      engcp3,vircp3)
+          
+        endif
+        
+c     ****************END OF TERTIARY NEIGHBOUR PROCESSING**************
+        
+c     ********************PROCESS SECONDARY NEIGHBOURS********************
+        
+        if(newplst)then
+          
+c     zero accumulators for secondary neighbour energies and virial
+          
+          engcp2=0.d0
+          vircp2=0.d0
+          engsr2=0.d0
+          virsr2=0.d0
+          
+c     zero secondary forces
+          
+          do i=1,natms
+            
+            fxx(i)=0.d0
+            fyy(i)=0.d0
+            fzz(i)=0.d0
+            
+          enddo
+          
+c     zero solvation and excitation arrays
+        
+          if(lsolva)then
+            
+            vdw_sol(:)=0.d0
+            cou_sol(:)=0.d0
+            
+            if(lghost)then
+              
+              vdw_exc(:)=0.d0
+              cou_exc(:)=0.d0
+              
+            endif
+            
+          endif
+
+c     zero stress tensor
+          
+          do i=1,9
+            stress(i)=0.d0
+          enddo
+          
+          ii=0
+          do i=idnode+1,natms,mxnode
+            
+            ii=ii+1
+            
+c     calculate interatomic vectors
+            
+            ik=0
+            do k=1,lentry(ii)
+              
+              j=list(ii,k)
+              
+              if(j.gt.0)then
+                
+                ik=ik+1
+                ilist(ik)=j
+                xdf(ik)=xxx(i)-xxx(j)
+                ydf(ik)=yyy(i)-yyy(j)
+                zdf(ik)=zzz(i)-zzz(j)
+                
+              endif
+              
+            enddo
+            
+c     periodic boundary condition only for interactions > rprim
+            
+            call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+            
+c     square of interatomic distances
+            
+            do k=1,ik
+              
+              rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+              
+            enddo
+            
+c     short range forces for secondary shell
+            
+            if((mod(keyfce,2).eq.1).and.(rvdw.gt.rprim-delr))then
+              
+              call srfrce
+     x          (lsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+              
+              engsr2=engsr2+engacc
+              virsr2=virsr2+viracc
+              
+            endif
+            
+c     calculate coulombic force and potential terms
+            
+            if(keyfce/2.eq.1.or.keyfce/2.eq.6)then
+              
+              call error(idnode,424)
+              
+            elseif(keyfce/2.eq.2)then
+              
+c     distance dependent dielectric
+              
+              call coul2
+     x          (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut1,epsq)
+              
+              engcp2=engcp2+engacc
+              vircp2=vircp2+viracc
+              
+            elseif(keyfce/2.eq.3)then
+              
+c     coulombic potential
+              
+              call coul0
+     x          (lsolva,lfree,lghost,i,ik,engacc,viracc,rcut1,epsq)
+              
+              engcp2=engcp2+engacc
+              vircp2=vircp2+viracc
+              
+            elseif(keyfce/2.eq.4)then
+              
+c     truncated shifted coulombic potential
+              
+              call error(idnode,424)
+              
+            endif
+            
+c     accumulate radial distribution functions : out to rcut
+            
+            if(lgr)call rdf0(i,ik,rcut)
+            
+          enddo
+          
+c     store secondary forces and stress tensor
+          
+          do i=1,natms
+            
+            fpx(i)=fxx(i)
+            fpy(i)=fyy(i)
+            fpz(i)=fzz(i)
+            
+          enddo
+          
+          do i=1,9
+            stresp(i)=stress(i)
+          enddo
+          
+c     store solvation and excitation arrays
+          
+          if(lsolva)then
+            
+            vdw_sol_put(:)=vdw_sol(:)
+            cou_sol_put(:)=cou_sol(:)
+            
+            if(lghost)then
+              
+              vdw_exc_put(:)=vdw_exc(:)
+              cou_exc_put(:)=cou_exc(:)
+              
+            endif
+            
+          endif
+          
+        endif
+        
+c     ****************END OF SECONDARY NEIGHBOUR PROCESSING*************
+        
+c     ********************PROCESS PRIMARY NEIGHBOURS********************
+        
+c     zero accumulators for total energies and virials
+        
+        engcpe=0.d0
+        engsrp=0.d0
+        vircpe=0.d0
+        virsrp=0.d0
+        
+c     zero primary forces
+        
+        do i=1,natms
+          
+          fxx(i)=0.d0
+          fyy(i)=0.d0
+          fzz(i)=0.d0
+          
+        enddo
+        
+c     zero stress tensor
+        
+        do i=1,9
+          stress(i)=0.d0
+        enddo
+        
+c     zero solvation and excitation arrays
+        
+        if(llsolva)then
+          
+          vdw_sol(:)=0.d0
+          cou_sol(:)=0.d0
+          
+          if(lghost)then
+            
+            vdw_exc(:)=0.d0
+            cou_exc(:)=0.d0
+            
+          endif
+          
+        endif
+        
+c     calculate primary pair force contributions
+        
+        ii=0
+        
+        do i=idnode+1,natms,mxnode
+          
+          ii=ii+1
+          
+c     calculate interatomic distances
+          
+          ik=0
+          
+          do k=1,lentry(ii)
+            
+            j=-list(ii,k)
+            
+            if(j.gt.0)then
+              
+              ik=ik+1
+              ilist(ik)=j
+              xdf(ik)=xxx(i)-xxx(j)
+              ydf(ik)=yyy(i)-yyy(j)
+              zdf(ik)=zzz(i)-zzz(j)
+              
+            endif
+            
+          enddo
+          
+c     periodic boundary conditions
+          
+          call images(imcon,0,1,ik,cell,xdf,ydf,zdf)
+          
+c     square of interatomic distances
+          
+          do k=1,ik
+            
+            rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+            
+          enddo
+          
+c     accumulate radial distribution functions : out to rcut
+          
+          if(lgr)call rdf0(i,ik,rcut)
+          
+c     calculate short range force and potential terms
+          
+          if(mod(keyfce,2).eq.1)then
+            
+            call srfrce
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rvdw,dlrpot)
+            
+            engsrp=engsrp+engacc
+            virsrp=virsrp+viracc
+            
+          endif
+          
+c     calculate coulombic force and potential terms
+          
+          if(keyfce/2.eq.1.or.keyfce/2.eq.6)then
+            
+            call error(idnode,424)
+            
+          elseif(keyfce/2.eq.2)then
+            
+c     distance dependent dielectric
+            
+            call coul2
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            
+          elseif(keyfce/2.eq.3)then
+            
+c     coulombic potential
+            
+            call coul0
+     x        (llsolva,lfree,lghost,i,ik,engacc,viracc,rcut,epsq)
+            
+            engcpe=engcpe+engacc
+            vircpe=vircpe+viracc
+            
+          elseif(keyfce/2.eq.4)then
+            
+            call error(idnode,424)
+            
+          endif
+          
+        enddo
+        
+c     **************END OF PRIMARY NEIGHBOUR PROCESSING*****************
+        
+c     counter for rdf statistics outside loop structure
+        
+        if(lgr)numrdf=numrdf+1
+        
+c     add in secondary and tertiary neighbour contributions to 
+c     force, energy etc
+        
+        do i=1,natms
+          
+          fxx(i)=fxx(i)+fpx(i)+flx(i)
+          fyy(i)=fyy(i)+fpy(i)+fly(i)
+          fzz(i)=fzz(i)+fpz(i)+flz(i)
+          
+        enddo
+        
+        do i=1,9
+          stress(i)=stress(i)+stresp(i)
+        enddo
+        
+        engsrp=engsrp+engsr2
+        virsrp=virsrp+virsr2
+        
+        engcpe=engcpe+engcp2+engcp3 
+        vircpe=vircpe+vircp2+vircp3
+        
+c     calculate solvation and excitation arrays
+        
+        if(llsolva)then
+          
+          vdw_sol(:)=vdw_sol(:)+vdw_sol_put(:)+vdw_sol_lng(:)
+          cou_sol(:)=cou_sol(:)+cou_sol_put(:)+cou_sol_lng(:)
+          
+          if(lghost)then
+            
+            vdw_exc(:)=vdw_exc(:)+vdw_exc_put(:)+vdw_exc_lng(:)
+            cou_exc(:)=cou_exc(:)+cou_exc_put(:)+cou_exc_lng(:)
+            
+          endif
+          
+        endif
+        
+c     sum up contributions to short range and coulombic potential
+        
+        if(mxnode.gt.1)then 
+          
+          buffer(1)=engsrp
+          buffer(2)=virsrp
+          buffer(3)=engcpe
+          buffer(4)=vircpe
+          buffer(5)=vdw_fre
+          buffer(6)=cou_fre
+          buffer(7)=vdw_vir
+          buffer(8)=cou_vir
+          call gdsum(buffer(1),8,buffer(9))
+          engsrp=buffer(1)
+          virsrp=buffer(2)
+          engcpe=buffer(3)
+          vircpe=buffer(4)
+          vdw_fre=buffer(5)
+          cou_fre=buffer(6)
+          vdw_vir=buffer(7)
+          cou_vir=buffer(8)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine multiple_nsq
+      
+      subroutine neutlst
+     x  (newlst,lchk,isn,imcon,idnode,ineu,ia,ll,
+     x  txx,tyy,tzz,uxx,uyy,uzz)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to create pair lists for neutral group
+c     implementations.
+c     loops over group ineu
+c     
+c     replicated data version
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester march 1994
+c     
+c     isn = -1 => secondary neighbours
+c     isn =  1 => primary neighbours - must contain excld interactions
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newlst,lchk,lexc
+      integer isn,imcon,idnode,ineu,ia,ll,i,jj,jj0,jj1
+      integer fail,ibig,keyexc,lenia,j,jneu,in0,in1
+      real(8) txx,tyy,tzz,uxx,uyy,uzz
+      
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension uxx(mxatms),uyy(mxatms),uzz(mxatms)
+      
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      
+      data fail/0/
+      
+c     allocate work arrays
+      
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1830)
+      
+      if(newlst)then
+        
+        ibig=0
+        
+c     set cutoff radius
+        
+        ll=0
+        
+c     number of excludes found
+        
+        if(isn.lt.0)then
+          keyexc=nexatm(ia)+2
+        else
+          keyexc=1
+        endif
+        
+c     do centre - centre distances
+        
+        lenia=lentry(ia)
+        
+        do j=1,lenia
+          
+          jneu=abs(list(ia,j))
+          xxt(j)=uxx(ineu)-uxx(jneu)
+          yyt(j)=uyy(ineu)-uyy(jneu)
+          zzt(j)=uzz(ineu)-uzz(jneu)
+          
+        enddo
+        
+        call images(imcon,0,1,lenia,cell,xxt,yyt,zzt)
+        
+c     working intragroup vectors of central group 
+c     - for periodic boundaries
+        
+        in0=neulst(ineu)
+        in1=neulst(ineu+1)-1
+        
+c     loop over neutral groups sites of a  
+        
+        
+c     loop over groups in list
+        
+        do jj=1,lentry(ia)
+          
+          jneu=list(ia,jj)*isn
+          
+          if(jneu.gt.0)then
+            
+            do i=in0,in1
+              
+              jj0=neulst(jneu)
+              jj1=neulst(jneu+1)-1
+              
+              if(ineu.eq.jneu)jj0=i+1
+              
+c     loop over jneu sites
+              
+              do j=jj0,jj1
+                
+c     reject atoms in excluded pair list
+                
+                lexc=.false.     
+                
+                if(keyexc.lt.nexatm(ia))then
+                  
+                  if(lexatm(ia,keyexc).eq.i)then
+                    if(lexatm(ia,keyexc+1).eq.j)then
+                      lexc=.true.
+                      keyexc=keyexc+2
+                    endif
+                  endif   
+                  
+                endif
+                
+c     reject frozen atom pairs
+                
+                if(lstfrz(i).ne.0)then
+                  if(lstfrz(j).ne.0)lexc=.true.
+                endif
+                
+                if(.not.lexc)then
+                  
+                  ll=ll+1
+                  if(ll.le.mxxdf)then
+                    
+                    xdf(ll)=txx(i)+xxt(jj)-txx(j)
+                    ydf(ll)=tyy(i)+yyt(jj)-tyy(j)
+                    zdf(ll)=tzz(i)+zzt(jj)-tzz(j)
+                    rsqdf(ll)=xdf(ll)**2+ydf(ll)**2+zdf(ll)**2
+                    ilist(ll)=i
+                    jlist(ll)=j
+                    
+                  else
+                    
+                    lchk=.false.
+                    ibig=max(ibig,ll)
+                    
+                  endif
+                  
+                endif
+                
+              enddo
+              
+            enddo
+            
+          endif
+          
+        enddo
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (xxt,yyt,zzt,stat=fail)
+      
+      return
+      end subroutine neutlst
+      
+      end module forces_module
+      
diff -urN dl_class_1.9.orig/srcmod/four_body_module.f dl_class_1.9/srcmod/four_body_module.f
--- dl_class_1.9.orig/srcmod/four_body_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/four_body_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,979 @@
+      module four_body_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining four-body potential arrays
+c     copyright - daresbury laboratory
+c     author  - w. smith  sep 2003
+c     adapted - w. smith  aug 2008 : solvation, free energy, excitation 
+c     adapted - w. smith  jan 2011 : metadynamics
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use metafreeze_module
+      use parse_module
+      use property_module
+      use setup_module
+      use site_module
+      use solvation_module
+      use utility_module
+
+      implicit none
+
+      logical, allocatable :: filter(:)
+      real(8), allocatable :: prmfbp(:,:),rcut4b(:)
+      integer, allocatable :: lstfbp(:),ltpfbp(:),latfbp(:)
+
+      save prmfbp,rcut4b,lstfbp,ltpfbp,latfbp,filter
+
+      contains
+      
+      subroutine alloc_fbp_arrays(idnode)
+
+      implicit none
+
+      integer i,fail,idnode
+      dimension fail(6)
+
+      do i=1,6
+        fail(i)=0
+      enddo
+
+      allocate (prmfbp(mxfbp,mxpfbp),stat=fail(1))
+      allocate (rcut4b(mxfbp),stat=fail(2))
+      allocate (lstfbp(mxfbp),stat=fail(3))
+      allocate (ltpfbp(mxfbp),stat=fail(4))
+      allocate (latfbp(mxatms),stat=fail(5))
+      allocate (filter(mxsite),stat=fail(6))
+
+      do i=1,6
+        if(fail(i).gt.0)call error(idnode,1140)
+      enddo
+
+      end subroutine alloc_fbp_arrays
+
+      subroutine define_four_body
+     x  (safe,lunits,lmols,idnode,ntpfbp,ntpatm,
+     x  rcutfb,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining four body potentials
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lunits,lmols
+      character*8 keyword
+      character*8 atom0,atom1,atom2,atom3
+      character*1 message(80)
+      integer idnode,ntpfbp,ntpatm,ifbp,itpfbp,keypot,katm0
+      integer i,katm1,katm2,katm3,jtpatm,ka1,ka2,ka3,keyfbp,kfbp
+      integer j,fail,idum
+      real(8) rcutfb,engunit
+      real(8), allocatable :: parpot(:)
+
+      data fail/0/
+
+      allocate (parpot(mxpfbp),stat=fail)
+      if(fail.ne.0)call error(idnode,1150)
+
+      ntpfbp=intstr(record,lenrec,idum)
+      
+      if(idnode.eq.0) then
+        
+        write(nrite,"(/,/,1x,'number of specified four ',
+     x    'body potentials',i10)") ntpfbp
+        write(nrite,"(/,/,16x,'atom 1  ','atom 2  ','atom 3  ',
+     x    'atom 4  ',3x,' key',30x,'parameters'/,/)")
+        
+      endif      
+      if(ntpfbp.gt.mxfbp) call error(idnode,89)
+      if(.not.lunits) call error(idnode,6)
+      if(.not.lmols) call error(idnode,13)
+      
+      do i=1,mxsite
+        filter(i)=.false.
+      enddo
+
+      do ifbp=1,mxfbp
+        lstfbp(ifbp)=0
+      enddo
+      
+      do ifbp=1,mxfbp,mx3fbp
+        lstfbp(ifbp)=-1
+      enddo
+      
+      rcutfb=0.d0
+      
+      do itpfbp=1,ntpfbp
+        
+        do i=1,mxpfbp
+          parpot(i)=0.d0
+        enddo
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+c     Note the order!! atom0 is the central atom
+
+        call copystring(record,message,80)
+        call getword(atom0,record,8,lenrec)
+        call getword(atom1,record,8,lenrec)
+        call getword(atom2,record,8,lenrec)
+        call getword(atom3,record,8,lenrec)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+
+        if(keyword(1:4).eq.'harm') then
+          keypot=1
+        elseif(keyword(1:4).eq.'hcos') then
+          keypot=2
+        elseif(keyword(1:4).eq.'plan') then
+          keypot=3
+        else
+          if(idnode.eq.0) write(nrite,*) message
+          call error(idnode,443)
+        endif
+
+        parpot(1)=dblstr(record,lenrec,idum)
+        parpot(2)=dblstr(record,lenrec,idum)
+        parpot(3)=dblstr(record,lenrec,idum)
+        
+        if(idnode.eq.0) 
+     x    write(nrite,"(16x,4a8,4x,a4,1x,1p,9e13.5)") 
+     x    atom0,atom1,atom2,atom3,keyword(1:4),(parpot(j),j=1,mxpfbp)
+        
+        katm0=0
+        katm1=0
+        katm2=0
+        katm3=0
+        
+        do jtpatm=1,ntpatm
+          
+          if(atom0.eq.unqatm(jtpatm))katm0=jtpatm
+          if(atom1.eq.unqatm(jtpatm))katm1=jtpatm
+          if(atom2.eq.unqatm(jtpatm))katm2=jtpatm
+          if(atom3.eq.unqatm(jtpatm))katm3=jtpatm
+          
+        enddo
+        
+        if(katm0.eq.0.or.katm1.eq.0.or.katm2.eq.0.or.
+     x    katm3.eq.0) call error(idnode,91)
+        
+        filter(katm0)=.true.
+        filter(katm1)=.true.
+        filter(katm2)=.true.
+        filter(katm3)=.true.
+        
+        ka1=max(katm1,katm2,katm3)
+        ka3=min(katm1,katm2,katm3)
+        ka2=katm1+katm2+katm3-ka1-ka3
+        keyfbp=ka3+(ka2*(ka2-1))/2+(ka1*(ka1**2-1))/6+
+     x    (katm0-1)*mx3fbp
+
+        if(keyfbp.gt.mxfbp) call error(idnode,101)
+
+c     convert parameters to internal units
+        
+        parpot(1)=parpot(1)*engunit
+        parpot(2)=parpot(2)*(pi/180.d0)
+
+        if(keypot.eq.2)then
+
+          parpot(2)=cos(parpot(2))
+
+        endif
+
+        if(lstfbp(keyfbp).gt.0) call error(idnode,19)
+        lstfbp(keyfbp)=itpfbp
+        ltpfbp(itpfbp)=keypot
+        kfbp=mx3fbp*((keyfbp-1)/mx3fbp)+1
+        if(lstfbp(kfbp).lt.0)lstfbp(kfbp)=0
+
+c     calculate max four body cutoff
+        
+        rcutfb=max(rcutfb,parpot(3))
+        rcut4b(itpfbp)=parpot(3)
+
+c     store four body potential parameters
+        
+        do i=1,mxpfbp
+          prmfbp(itpfbp,i)=parpot(i)
+        enddo
+
+      enddo
+
+      if(rcutfb.lt.1.d-6)call error(idnode,453)
+      
+      deallocate (parpot,stat=fail)
+
+      return
+      end subroutine define_four_body
+
+      subroutine fbpfrc
+     x  (lsolva,lfree,lexcite,idnode,mxnode,natms,imcon,rcutfb,
+     x  engfbp,virfbp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating four body inversion forces
+c     arising from the inversion angle between three atoms around a
+c     nominated central atom
+c     
+c     Note: the subroutine converts coordinates to reduced units
+c     to avoid a call to images.f. The link cell algorithm used
+c     here necessitates a parallelepiped cell geometry
+c     
+c     copyright - daresbury laboratory 1996
+c     author   - w.smith july 1996
+c     adapted   - w.smith aug 2008 solvation, free energy etc
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lsolva,lfree,lexcite,lselect,lskip
+      logical idrive,jdrive,kdrive,ldrive
+      integer idnode,mxnode,natms,imcon,nix,niy,niz
+      integer i,j,k,nbx,nby,nbz,ncells,ix,iy,iz,icell,jx,jy
+      integer jz,jj,kk,ia,ib,ifbp,jfbp,kfbp,jklbd,kkfbp,ktyp,ii
+      integer ic,ll,id,lfbp,l,limit,jcell,kkk
+      real(8) rcutfb,engfbp,virfbp,vbn,vcn,pterm,xm,ym,zm
+      real(8) strs,cprp,det,xdc,ydc,zdc,sxx,syy,szz,sxab,strs_loc
+      real(8) syab,szab,xab,yab,zab,rab2,sxac,syac,szac,xac,yac
+      real(8) zac,rac2,sxad,syad,szad,xad,yad,zad,rad2,rrab,rrac
+      real(8) rrad,rbc,rcd,rdb,ubx,uby,ubz,ubn,rub,vbx,vby,vbz
+      real(8) rvb,wwb,ucx,ucy,ucz,ucn,ruc,vcx,vcy,vcz,rvc,wwc
+      real(8) udx,udy,udz,udn,rud,vdx,vdy,vdz,vdn,rvd,wwd,cosb
+      real(8) cosc,cosd,thb,thc,thd,gamb,gamc,gamd,rubc,rubd
+      real(8) rucd,rucb,rudb,rudc,rvbc,rvbd,rvcd,rvcb,rvdb,rvdc
+      real(8) fax,fay,faz,fbx,fby,fbz,fcx,fcy,fcz,fdx,fdy,fdz
+      dimension cprp(10),strs(6),nix(27),niy(27),niz(27),strs_loc(6)
+      
+      data nix/ 0,-1,-1,-1, 0, 0,-1, 1,-1, 0, 1,-1, 0, 1,
+     x  1, 1, 1, 0, 0, 1,-1, 1, 0,-1, 1, 0,-1/
+      data niy/ 0, 0,-1, 1, 1, 0, 0, 0,-1,-1,-1, 1, 1, 1,
+     x  0, 1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1/
+      data niz/ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+     x  0, 0, 0, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1/
+      
+      lskip=(lfree.or.lexcite)
+      
+c     flag for undefined potentials
+      
+      safe=.true.
+      
+c     initialise accumulators
+      
+      engfbp=0.d0
+      virfbp=0.d0
+      fbp_fre=0.d0
+      fbp_vir=0.d0
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+      if(lsolva)then
+        
+        lcomp(9)=.true.
+        en4_sol(:)=0.d0
+        if(lexcite)en4_exc(:)=0.d0
+        
+      endif
+      
+c     create mock cell vectors for non-periodic system
+      
+      if(imcon.eq.0) then
+        
+        xm=0.d0
+        ym=0.d0
+        zm=0.d0
+        do i=1,natms
+          xm=max(xm,abs(xxx(i)))
+          ym=max(ym,abs(yyy(i)))
+          zm=max(zm,abs(zzz(i)))
+        enddo
+        
+        cell(1)=2.d0*xm+rcutfb
+        cell(2)=0.d0
+        cell(3)=0.d0
+        cell(4)=0.d0
+        cell(5)=2.d0*ym+rcutfb
+        cell(6)=0.d0
+        cell(7)=0.d0
+        cell(8)=0.d0
+        cell(9)=2.d0*zm+rcutfb
+      
+      endif
+      
+c     check for appropriate boundary conditions
+      
+      if(imcon.gt.3)call error(idnode,79)
+      call invert(cell,rcell,det)
+      call dcell(cell,cprp)
+      
+c     calculate link cell numbers
+      
+      nbx=int(cprp(7)/(rcutfb+1.d-6))
+      nby=int(cprp(8)/(rcutfb+1.d-6))
+      nbz=int(cprp(9)/(rcutfb+1.d-6))
+      ncells=nbx*nby*nbz
+      if(ncells.gt.mxcell) then
+        
+        if(idnode.eq.0) write(nrite,'(a,i6)')
+     x    'number of required link cells in routine fbpfrc is ',ncells
+        write(nrite,'(a,i6)')
+     x    'number of default link cells in routine fbpfrc is ',mxcell
+        call error(idnode,87)
+        
+      endif
+      
+c     transform atomic coordinates and construct link cells
+      
+      do l=1,ncells
+        
+        lct(l)=0
+        lst(l)=0
+        
+      enddo
+      
+      xdc=dble(nbx)
+      ydc=dble(nby)
+      zdc=dble(nbz)
+      
+      do i=1,natms
+        
+        if(filter(ltype(i)))then
+          
+          sxx=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          syy=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          szz=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+          xxx(i)=sxx
+          yyy(i)=syy
+          zzz(i)=szz
+          
+          ix=min(int(xdc*(sxx+0.5d0)),nbx-1)
+          iy=min(int(ydc*(syy+0.5d0)),nby-1)
+          iz=min(int(zdc*(szz+0.5d0)),nbz-1)
+          k=1+ix+nbx*(iy+nby*iz)
+          lst(k)=lst(k)+1
+          link(i)=lct(k)
+          lct(k)=i
+          
+        endif
+        
+      enddo
+      
+c     loop over central atoms of inversion
+      
+      ix=0
+      iy=1
+      iz=1
+      do icell=1,ncells
+        
+        ix=ix+1
+        if(ix.gt.nbx)then
+          ix=1
+          iy=iy+1
+          if(iy.gt.nby)then
+            iy=1
+            iz=iz+1
+          endif
+        endif
+        
+        k=0
+        do kk=1,27
+          
+          jx=ix+nix(kk)
+          jy=iy+niy(kk)
+          jz=iz+niz(kk)
+          
+          if(jx.gt.nbx)jx=1
+          if(jy.gt.nby)jy=1
+          if(jz.gt.nbz)jz=1
+          if(jx.lt.1)jx=jx+nbx
+          if(jy.lt.1)jy=jy+nby
+          if(jz.lt.1)jz=jz+nbz
+          
+          jcell=jx+nbx*(jy-1+nby*(jz-1))
+          j=lct(jcell)
+          
+          do ii=1,lst(jcell)
+            
+            k=k+1
+            latfbp(k)=j
+            j=link(j)
+            
+          enddo
+          
+        enddo
+        
+        limit=k
+        
+        do ii=1,lst(icell)
+          
+          ia=latfbp(ii)
+          if(lmetadyn)idrive=driven(ltype(ia))
+          ifbp=mx3fbp*(ltype(ia)-1)
+          if(mod(ia,mxnode).eq.idnode.and.lstfbp(ifbp+1).ge.0)then
+            
+          do jj=1,limit-2
+          
+          ib=latfbp(jj)
+          if(lmetadyn)jdrive=driven(ltype(ib))
+          
+          do kk=jj+1,limit-1
+          
+          ic=latfbp(kk)
+          if(lmetadyn)kdrive=driven(ltype(ic))
+                
+          do ll=kk+1,limit
+          
+          id=latfbp(ll)
+          if(lmetadyn)ldrive=driven(ltype(id))
+                  
+          if(lskip)then
+            
+            if((atm_fre(ia).eq.1.or.atm_fre(ib).eq.1.or.
+     x        atm_fre(ic).eq.1.or.atm_fre(id).eq.1).and.
+     x        (atm_fre(ia).eq.2.or.atm_fre(ib).eq.2.or.
+     x        atm_fre(ic).eq.2.or.atm_fre(id).eq.2))cycle
+            
+          endif
+          
+          jfbp=max(ltype(ib),ltype(ic),ltype(id))
+          lfbp=min(ltype(ib),ltype(ic),ltype(id))
+          kfbp=ltype(ib)+ltype(ic)+ltype(id)-jfbp-lfbp
+          jklbd=ifbp+lfbp+(kfbp*(kfbp-1))/2+(jfbp*(jfbp**2-1))/6
+          kkfbp=lstfbp(jklbd)
+          if(kkfbp.gt.0)then
+                    
+          sxab=xxx(ib)-xxx(ia)
+          sxab=sxab-nint(sxab)
+          syab=yyy(ib)-yyy(ia)
+          syab=syab-nint(syab)
+          szab=zzz(ib)-zzz(ia)
+          szab=szab-nint(szab)
+          
+          xab=cell(1)*sxab+cell(4)*syab+cell(7)*szab
+          if(abs(xab).lt.rcutfb)then
+          
+          yab=cell(2)*sxab+cell(5)*syab+cell(8)*szab
+          if(abs(yab).lt.rcutfb)then
+          
+          zab=cell(3)*sxab+cell(6)*syab+cell(9)*szab
+          if(abs(zab).lt.rcutfb)then
+          
+          rab2=xab*xab+yab*yab+zab*zab
+          
+          sxac=xxx(ic)-xxx(ia)
+          sxac=sxac-nint(sxac)
+          syac=yyy(ic)-yyy(ia)
+          syac=syac-nint(syac)
+          szac=zzz(ic)-zzz(ia)
+          szac=szac-nint(szac)
+          
+          xac=cell(1)*sxac+cell(4)*syac+cell(7)*szac
+          if(abs(xac).lt.rcutfb)then
+                            
+          yac=cell(2)*sxac+cell(5)*syac+cell(8)*szac
+          if(abs(yac).lt.rcutfb)then
+          
+          zac=cell(3)*sxac+cell(6)*syac+cell(9)*szac
+          if(abs(zac).lt.rcutfb)then
+          
+          rac2=xac*xac+yac*yac+zac*zac
+          
+          sxad=xxx(id)-xxx(ia)
+          sxad=sxad-nint(sxad)
+          syad=yyy(id)-yyy(ia)
+          syad=syad-nint(syad)
+          szad=zzz(id)-zzz(ia)
+          szad=szad-nint(szad)
+          
+          xad=cell(1)*sxad+cell(4)*syad+cell(7)*szad
+          if(abs(xad).lt.rcutfb)then
+          
+          yad=cell(2)*sxad+cell(5)*syad+cell(8)*szad
+          if(abs(yad).lt.rcutfb)then
+          
+          zad=cell(3)*sxad+cell(6)*syad+cell(9)*szad
+          if(abs(zad).lt.rcutfb)then
+          
+          rad2=xad*xad+yad*yad+zad*zad
+          
+          if(rcut4b(kkfbp)**2.ge.max(rab2,rac2,rad2))then
+          
+          rrab=1.d0/sqrt(rab2)
+          rrac=1.d0/sqrt(rac2)
+          rrad=1.d0/sqrt(rad2)
+          
+          rbc=xab*xac+yab*yac+zab*zac
+          rcd=xac*xad+yac*yad+zac*zad
+          rdb=xad*xab+yad*yab+zad*zab
+          
+c     calculate bond-angle-plane vectors
+          
+          ubx=xac*rrac+xad*rrad
+          uby=yac*rrac+yad*rrad
+          ubz=zac*rrac+zad*rrad
+          ubn=1.d0/sqrt(ubx**2+uby**2+ubz**2)
+          ubx=ubn*ubx
+          uby=ubn*uby
+          ubz=ubn*ubz
+          rub=xab*ubx+yab*uby+zab*ubz
+          
+          vbx=xac*rrac-xad*rrad
+          vby=yac*rrac-yad*rrad
+          vbz=zac*rrac-zad*rrad
+          vbn=1.d0/sqrt(vbx**2+vby**2+vbz**2)
+          vbx=vbn*vbx
+          vby=vbn*vby
+          vbz=vbn*vbz
+          rvb=xab*vbx+yab*vby+zab*vbz
+          wwb=sqrt(rub**2+rvb**2)
+          
+          ucx=xad*rrad+xab*rrab
+          ucy=yad*rrad+yab*rrab
+          ucz=zad*rrad+zab*rrab
+          ucn=1.d0/sqrt(ucx**2+ucy**2+ucz**2)
+          ucx=ucn*ucx
+          ucy=ucn*ucy
+          ucz=ucn*ucz
+          ruc=xac*ucx+yac*ucy+zac*ucz
+          
+          vcx=xad*rrad-xab*rrab
+          vcy=yad*rrad-yab*rrab
+          vcz=zad*rrad-zab*rrab
+          vcn=1.d0/sqrt(vcx**2+vcy**2+vcz**2)
+          vcx=vcn*vcx
+          vcy=vcn*vcy
+          vcz=vcn*vcz
+          rvc=xac*vcx+yac*vcy+zac*vcz
+          wwc=sqrt(ruc**2+rvc**2)
+          
+          udx=xab*rrab+xac*rrac
+          udy=yab*rrab+yac*rrac
+          udz=zab*rrab+zac*rrac
+          udn=1.d0/sqrt(udx**2+udy**2+udz**2)
+          udx=udn*udx
+          udy=udn*udy
+          udz=udn*udz
+          rud=xad*udx+yad*udy+zad*udz
+          
+          vdx=xab*rrab-xac*rrac
+          vdy=yab*rrab-yac*rrac
+          vdz=zab*rrab-zac*rrac
+          vdn=1.d0/sqrt(vdx**2+vdy**2+vdz**2)
+          vdx=vdn*vdx
+          vdy=vdn*vdy
+          vdz=vdn*vdz
+          rvd=xad*vdx+yad*vdy+zad*vdz
+          wwd=sqrt(rud**2+rvd**2)
+          
+c     calculate inversion angle cosines
+          
+          cosb=wwb*rrab
+          cosc=wwc*rrac
+          cosd=wwd*rrad
+          if(abs(cosb).gt.1.d0)cosb=sign(1.d0,cosb)
+          if(abs(cosc).gt.1.d0)cosc=sign(1.d0,cosc)
+          if(abs(cosd).gt.1.d0)cosd=sign(1.d0,cosd)
+          
+c     select potential energy function type
+          
+          ktyp=ltpfbp(kkfbp)
+          
+c     calculate potential energy and scalar force term
+          
+          if(ktyp.eq.1)then
+            
+c     key=1 for harmonic potential
+            
+            thb=acos(cosb)
+            thc=acos(cosc)
+            thd=acos(cosd)
+            
+            pterm=0.5d0*prmfbp(kkfbp,1)*
+     x        ((thb-prmfbp(kkfbp,2))**2+
+     x        (thc-prmfbp(kkfbp,2))**2+
+     x        (thd-prmfbp(kkfbp,2))**2)/3.d0
+            
+            gamb=0.d0
+            if(abs(thb).gt.1.d-12)gamb=prmfbp(kkfbp,1)*
+     x        (thb-prmfbp(kkfbp,2))/(3.d0*sin(thb))
+            gamc=0.d0
+            if(abs(thc).gt.1.d-12)gamc=prmfbp(kkfbp,1)*
+     x        (thc-prmfbp(kkfbp,2))/(3.d0*sin(thc))
+            gamd=0.d0
+            if(abs(thd).gt.1.d-12)gamd=prmfbp(kkfbp,1)*
+     x        (thd-prmfbp(kkfbp,2))/(3.d0*sin(thd))
+            
+          else if(ktyp.eq.2)then
+            
+c     key=2 for harmonic cosine inversion potential
+            
+            pterm=0.5d0*prmfbp(kkfbp,1)*
+     x        ((cosb-prmfbp(kkfbp,2))**2+
+     x        (cosc-prmfbp(kkfbp,2))**2+
+     x        (cosd-prmfbp(kkfbp,2))**2)/3.d0
+            
+            gamb=-prmfbp(kkfbp,1)*(cosb-prmfbp(kkfbp,2))/3.d0
+            gamc=-prmfbp(kkfbp,1)*(cosc-prmfbp(kkfbp,2))/3.d0
+            gamd=-prmfbp(kkfbp,1)*(cosd-prmfbp(kkfbp,2))/3.d0
+            
+          else if(ktyp.eq.3)then
+            
+c     key=3 for planar inversion potentials
+            
+            pterm=prmfbp(kkfbp,1)*
+     x        (3.d0-cosb-cosc-cosd)/3.d0
+            
+            gamb=-prmfbp(kkfbp,1)/3.d0
+            gamc=-prmfbp(kkfbp,1)/3.d0
+            gamd=-prmfbp(kkfbp,1)/3.d0
+            
+          else
+            
+c     undefined potential
+            
+            safe=.false.
+            pterm=0.d0
+            gamb=0.d0
+            gamc=0.d0
+            gamd=0.d0
+            
+          endif
+          
+c     set selection control
+          
+          lselect=.true.
+          
+c     set quadruple index
+          
+          if(lsolva)
+     x      kkk=loc4(atmolt(ia),atmolt(ib),atmolt(ic),atmolt(id))
+          
+          if(lexcite)then
+            
+c     selected excitation option
+            
+            if((atm_fre(ia).ne.1).and.(atm_fre(ib).ne.1).and.
+     x        (atm_fre(ic).ne.1).and.(atm_fre(id).ne.1))then
+              
+c     reset selection control
+              
+              lselect=(atm_fre(ia)+atm_fre(ib)+atm_fre(ic)+
+     x          atm_fre(id).eq.0)
+              
+              if(lsolva)en4_exc(kkk)=en4_exc(kkk)+pterm
+              
+            endif
+            
+          elseif(lfree)then
+            
+c     selected free energy option
+            
+            if((atm_fre(ia).eq.1).or.(atm_fre(ib).eq.1).or.
+     x        (atm_fre(ic).eq.1).or.(atm_fre(id).eq.1))then
+              
+c     set hamiltonian mixing parameter
+              
+              fbp_fre=fbp_fre-pterm
+              pterm=lambda1*pterm
+              gamb=lambda1*gamb
+              gamc=lambda1*gamc
+              gamd=lambda1*gamd
+              
+            elseif((atm_fre(ia).eq.2).or.(atm_fre(ib).eq.2).or.
+     x          (atm_fre(ic).eq.2).or.(atm_fre(id).eq.2))then
+              
+c     set hamiltonian mixing parameter
+              
+              fbp_fre=fbp_fre+pterm
+              pterm=lambda2*pterm
+              gamb=lambda2*gamb
+              gamc=lambda2*gamc
+              gamd=lambda2*gamd
+              
+            endif
+            
+          endif
+          
+          if(lselect)then
+            
+c     calculate potential
+            
+            engfbp=engfbp+pterm
+            
+            if(lsolva)en4_sol(kkk)=en4_sol(kkk)+pterm
+            
+c     calculate bond and u,v scalar products
+            
+            rubc=xab*ucx+yab*ucy+zab*ucz
+            rubd=xab*udx+yab*udy+zab*udz
+            rucd=xac*udx+yac*udy+zac*udz
+            rucb=xac*ubx+yac*uby+zac*ubz
+            rudb=xad*ubx+yad*uby+zad*ubz
+            rudc=xad*ucx+yad*ucy+zad*ucz
+            
+            rvbc=xab*vcx+yab*vcy+zab*vcz
+            rvbd=xab*vdx+yab*vdy+zab*vdz
+            rvcd=xac*vdx+yac*vdy+zac*vdz
+            rvcb=xac*vbx+yac*vby+zac*vbz
+            rvdb=xad*vbx+yad*vby+zad*vbz
+            rvdc=xad*vcx+yad*vcy+zad*vcz
+            
+c     calculate atomic forces
+            
+            fbx=gamb*(-cosb*xab*rrab**2+rrab*(rub*ubx+rvb*vbx)/wwb)
+     x        +(ruc*ucn*rrab*(xac-ruc*ucx-(rbc-ruc*rubc)*xab*rrab**2)
+     x        - rvc*vcn*rrab*(xac-rvc*vcx-(rbc-rvc*rvbc)*xab*rrab**2))
+     x        * gamc*rrac/wwc
+     x        +(rud*udn*rrab*(xad-rud*udx-(rdb-rud*rubd)*xab*rrab**2)
+     x        + rvd*vdn*rrab*(xad-rvd*vdx-(rdb-rvd*rvbd)*xab*rrab**2))
+     x        * gamd*rrad/wwd
+            
+            fby=gamb*(-cosb*yab*rrab**2+rrab*(rub*uby+rvb*vby)/wwb)
+     x        +(ruc*ucn*rrab*(yac-ruc*ucy-(rbc-ruc*rubc)*yab*rrab**2)
+     x        - rvc*vcn*rrab*(yac-rvc*vcy-(rbc-rvc*rvbc)*yab*rrab**2))
+     x        * gamc*rrac/wwc
+     x        +(rud*udn*rrab*(yad-rud*udy-(rdb-rud*rubd)*yab*rrab**2)
+     x        + rvd*vdn*rrab*(yad-rvd*vdy-(rdb-rvd*rvbd)*yab*rrab**2))
+     x        * gamd*rrad/wwd
+            
+            fbz=gamb*(-cosb*zab*rrab**2+rrab*(rub*ubz+rvb*vbz)/wwb)
+     x        +(ruc*ucn*rrab*(zac-ruc*ucz-(rbc-ruc*rubc)*zab*rrab**2)
+     x        - rvc*vcn*rrab*(zac-rvc*vcz-(rbc-rvc*rvbc)*zab*rrab**2))
+     x        * gamc*rrac/wwc
+     x        +(rud*udn*rrab*(zad-rud*udz-(rdb-rud*rubd)*zab*rrab**2)
+     x        + rvd*vdn*rrab*(zad-rvd*vdz-(rdb-rvd*rvbd)*zab*rrab**2))
+     x        * gamd*rrad/wwd
+            
+            fcx=gamc*(-cosc*xac*rrac**2+rrac*(ruc*ucx+rvc*vcx)/wwc)
+     x        +(rud*udn*rrac*(xad-rud*udx-(rcd-rud*rucd)*xac*rrac**2)
+     x        - rvd*vdn*rrac*(xad-rvd*vdx-(rcd-rvd*rvcd)*xac*rrac**2))
+     x        * gamd*rrad/wwd
+     x        +(rub*ubn*rrac*(xab-rub*ubx-(rbc-rub*rucb)*xac*rrac**2)
+     x        + rvb*vbn*rrac*(xab-rvb*vbx-(rbc-rvb*rvcb)*xac*rrac**2))
+     x        * gamb*rrab/wwb
+            
+            fcy=gamc*(-cosc*yac*rrac**2+rrac*(ruc*ucy+rvc*vcy)/wwc)
+     x        +(rud*udn*rrac*(yad-rud*udy-(rcd-rud*rucd)*yac*rrac**2)
+     x        - rvd*vdn*rrac*(yad-rvd*vdy-(rcd-rvd*rvcd)*yac*rrac**2))
+     x        * gamd*rrad/wwd
+     x        +(rub*ubn*rrac*(yab-rub*uby-(rbc-rub*rucb)*yac*rrac**2)
+     x        + rvb*vbn*rrac*(yab-rvb*vby-(rbc-rvb*rvcb)*yac*rrac**2))
+     x        * gamb*rrab/wwb
+            
+            fcz=gamc*(-cosc*zac*rrac**2+rrac*(ruc*ucz+rvc*vcz)/wwc)
+     x        +(rud*udn*rrac*(zad-rud*udz-(rcd-rud*rucd)*zac*rrac**2)
+     x        - rvd*vdn*rrac*(zad-rvd*vdz-(rcd-rvd*rvcd)*zac*rrac**2))
+     x        * gamd*rrad/wwd
+     x        +(rub*ubn*rrac*(zab-rub*ubz-(rbc-rub*rucb)*zac*rrac**2)
+     x        + rvb*vbn*rrac*(zab-rvb*vbz-(rbc-rvb*rvcb)*zac*rrac**2))
+     x        * gamb*rrab/wwb
+            
+            fdx=gamd*(-cosd*xad*rrad**2+rrad*(rud*udx+rvd*vdx)/wwd)
+     x        +(rub*ubn*rrad*(xab-rub*ubx-(rdb-rub*rudb)*xad*rrad**2)
+     x        - rvb*vbn*rrad*(xab-rvb*vbx-(rdb-rvb*rvdb)*xad*rrad**2))
+     x        * gamb*rrab/wwb
+     x        +(ruc*ucn*rrad*(xac-ruc*ucx-(rcd-ruc*rudc)*xad*rrad**2)
+     x        + rvc*vcn*rrad*(xac-rvc*vcx-(rcd-rvc*rvdc)*xad*rrad**2))
+     x        * gamc*rrac/wwc
+            
+            fdy=gamd*(-cosd*yad*rrad**2+rrad*(rud*udy+rvd*vdy)/wwd)
+     x        +(rub*ubn*rrad*(yab-rub*uby-(rdb-rub*rudb)*yad*rrad**2)
+     x        - rvb*vbn*rrad*(yab-rvb*vby-(rdb-rvb*rvdb)*yad*rrad**2))
+     x        * gamb*rrab/wwb
+     x        +(ruc*ucn*rrad*(yac-ruc*ucy-(rcd-ruc*rudc)*yad*rrad**2)
+     x        + rvc*vcn*rrad*(yac-rvc*vcy-(rcd-rvc*rvdc)*yad*rrad**2))
+     x        * gamc*rrac/wwc
+            
+            fdz=gamd*(-cosd*zad*rrad**2+rrad*(rud*udz+rvd*vdz)/wwd)
+     x        +(rub*ubn*rrad*(zab-rub*ubz-(rdb-rub*rudb)*zad*rrad**2)
+     x        - rvb*vbn*rrad*(zab-rvb*vbz-(rdb-rvb*rvdb)*zad*rrad**2))
+     x        * gamb*rrab/wwb
+     x        +(ruc*ucn*rrad*(zac-ruc*ucz-(rcd-ruc*rudc)*zad*rrad**2)
+     x        + rvc*vcn*rrad*(zac-rvc*vcz-(rcd-rvc*rvdc)*zad*rrad**2))
+     x        * gamc*rrac/wwc
+            
+            fax=-(fbx+fcx+fdx)
+            fay=-(fby+fcy+fdy)
+            faz=-(fbz+fcz+fdz)
+            
+            fxx(ia)=fxx(ia)+fax
+            fyy(ia)=fyy(ia)+fay
+            fzz(ia)=fzz(ia)+faz
+            
+            fxx(ib)=fxx(ib)+fbx
+            fyy(ib)=fyy(ib)+fby
+            fzz(ib)=fzz(ib)+fbz
+            
+            fxx(ic)=fxx(ic)+fcx
+            fyy(ic)=fyy(ic)+fcy
+            fzz(ic)=fzz(ic)+fcz
+            
+            fxx(id)=fxx(id)+fdx
+            fyy(id)=fyy(id)+fdy
+            fzz(id)=fzz(id)+fdz
+            
+c     stress tensor calculation for inversion terms
+            
+            strs(1)=strs(1)+xab*fbx+xac*fcx+xad*fdx 
+            strs(2)=strs(2)+yab*fbx+yac*fcx+yad*fdx 
+            strs(3)=strs(3)+zab*fbx+zac*fcx+zad*fdx 
+            strs(4)=strs(4)+yab*fby+yac*fcy+yad*fdy 
+            strs(5)=strs(5)+yab*fbz+yac*fcz+yad*fdz 
+            strs(6)=strs(6)+zab*fbz+zac*fcz+zad*fdz 
+          
+          endif
+          
+c     metadynamics local parameters
+          
+          if(lmetadyn.and.(idrive.or.jdrive.or.kdrive.or.ldrive))then
+            
+c     local energy (no virial)
+
+            eng_loc=eng_loc+pterm
+
+c     local forces
+            
+            fxx_loc(ia)=fxx_loc(ia)+fax
+            fyy_loc(ia)=fyy_loc(ia)+fay
+            fzz_loc(ia)=fzz_loc(ia)+faz
+            
+            fxx_loc(ib)=fxx_loc(ib)+fbx
+            fyy_loc(ib)=fyy_loc(ib)+fby
+            fzz_loc(ib)=fzz_loc(ib)+fbz
+            
+            fxx_loc(ic)=fxx_loc(ic)+fcx
+            fyy_loc(ic)=fyy_loc(ic)+fcy
+            fzz_loc(ic)=fzz_loc(ic)+fcz
+            
+            fxx_loc(id)=fxx_loc(id)+fdx
+            fyy_loc(id)=fyy_loc(id)+fdy
+            fzz_loc(id)=fzz_loc(id)+fdz
+            
+c     local stress tensor
+            
+            strs_loc(1)=strs_loc(1)+xab*fbx+xac*fcx+xad*fdx 
+            strs_loc(2)=strs_loc(2)+yab*fbx+yac*fcx+yad*fdx 
+            strs_loc(3)=strs_loc(3)+zab*fbx+zac*fcx+zad*fdx 
+            strs_loc(4)=strs_loc(4)+yab*fby+yac*fcy+yad*fdy 
+            strs_loc(5)=strs_loc(5)+yab*fbz+yac*fcz+yad*fdz 
+            strs_loc(6)=strs_loc(6)+zab*fbz+zac*fcz+zad*fdz 
+
+          endif
+          
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+
+          enddo
+          enddo
+          enddo
+          
+          endif
+
+        enddo
+
+      enddo
+
+c     check for undefined potentials
+
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe) call error(idnode,443)
+
+c     global sum of four body potential and virial
+
+      buffer(1)=engfbp
+      buffer(2)=virfbp
+      buffer(3)=fbp_fre
+      buffer(4)=fbp_vir
+      call gdsum(buffer(1),4,buffer(5))
+      engfbp=buffer(1)
+      virfbp=buffer(2)
+      fbp_fre=buffer(3)
+      fbp_vir=buffer(4)
+
+c     sum up solvation energies
+        
+        if(lsolva)then
+
+          call gdsum(en4_sol,mxtmls_sol4,buffer(1))
+          if(lexcite)call gdsum(en4_exc,mxtmls_exc4,buffer(1))
+          
+        endif
+        
+c     restore coordinate array to original representation
+
+      do i=1,natms
+
+        if(filter(ltype(i)))then
+          
+          sxx=xxx(i)
+          syy=yyy(i)
+          szz=zzz(i)
+          
+          xxx(i)=cell(1)*sxx+cell(4)*syy+cell(7)*szz
+          yyy(i)=cell(2)*sxx+cell(5)*syy+cell(8)*szz
+          zzz(i)=cell(3)*sxx+cell(6)*syy+cell(9)*szz
+          
+        endif
+        
+      enddo
+
+c     restore cell vector
+
+      if(imcon.eq.0) then
+        cell(1)=0.d0
+        cell(5)=0.d0
+        cell(9)=0.d0
+      endif
+
+c     complete stress tensor
+        
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+      
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+      return
+      end subroutine fbpfrc
+      
+      end module four_body_module
diff -urN dl_class_1.9.orig/srcmod/hkewald_module.f dl_class_1.9/srcmod/hkewald_module.f
--- dl_class_1.9.orig/srcmod/hkewald_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/hkewald_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,1292 @@
+      module hkewald_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining hautman-klein ewald sum arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    nov 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use exclude_module
+      use error_module
+      use pair_module
+      use property_module
+      use setup_module
+
+      implicit none
+
+      real(8), allocatable :: ahk(:),crn(:,:)
+      real(8), allocatable :: elc(:,:),els(:,:)
+      real(8), allocatable :: emc(:,:),ems(:,:)
+      real(8), allocatable :: zzn(:),zzd(:)
+      real(8), allocatable :: hon(:,:),znp(:,:)
+      real(8), allocatable :: dhn(:,:),zgs(:)
+      real(8), allocatable :: fon(:,:),zgc(:)
+      real(8), allocatable :: ckc(:),cks(:)
+      real(8), allocatable :: pp(:),sss(:)
+
+      save ahk,crn,elc,els,emc,ems,zzn,zzd,hon,znp,dhn,zgs
+      save fon,zgc,ckc,cks,pp,sss
+
+      contains
+      
+      subroutine alloc_hke_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=9
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (ahk(0:mxhko),crn(0:mxhko,0:mxhko),stat=fail(1))
+      allocate (elc(mxewld,0:1),els(mxewld,0:1),stat=fail(2))
+      allocate (emc(mxewld,0:kmaxb),ems(mxewld,0:kmaxb),stat=fail(3))
+      allocate (zzn(mxxdf),zzd(mxxdf),stat=fail(4))
+      allocate (hon(mxgrid,0:mxhko),znp(mxhke,0:2*mxhko),stat=fail(5))
+      allocate (dhn(mxgrid,0:mxhko),zgs(0:2*mxhko),stat=fail(6))
+      allocate (fon(mxegrd,0:7),zgc(0:2*mxhko),stat=fail(7))
+      allocate (ckc(mxewld),cks(mxewld),stat=fail(8))
+      allocate (pp(2*mxhko),sss(mxxdf),stat=fail(9))
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1730)
+      enddo
+
+      end subroutine alloc_hke_arrays
+
+      subroutine hkgen(idnode,nhko,nlatt,alpha,drewd,rcut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for generating convergence function
+c     arrays for hautman klein ewald method (up to order 3 only)
+c     
+c     copyright - daresbury laboratory 2000
+c     author    - w. smith february 2000
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer i,idnode,nhko,nlatt,k
+      real(8) alpha,drewd,rcut,ecut,den,fac,ss1,aaa,ss2
+
+      if(nhko.gt.mxhko)call error(idnode,332)
+
+c     define effective cutoff
+
+      ecut=rcut*dble(2*nlatt+1)
+
+c     define grid resolution for potential arrays
+      
+      drewd=ecut/dble(mxegrd-4)
+
+c     calculate HKE coefficients
+
+      ahk(0)=1.d0
+
+      do i=1,nhko
+
+        ahk(i)=-0.25d0*ahk(i-1)*dble(2*i*(2*i-1))/dble(i*i)
+
+      enddo
+
+c     generate convergence function arrays
+
+      do i=1,mxegrd
+
+        hon(i,0)=0.d0
+        hon(i,1)=dble(i-1)*drewd
+        hon(i,2)=(2.d0*alpha/sqrpi)*exp(-(alpha*hon(i,1))**2)
+
+      enddo
+
+c     generate error function and derivatives by recursion
+
+      do k=100,1,-1
+
+        den=1.d0/dble(2*k-1)
+        fac=(2.d0*alpha**2)**(k-1)
+
+        do i=1,mxegrd
+
+          hon(i,0)=den*(hon(i,0)*hon(i,1)**2+fac*hon(i,2))
+
+        enddo
+
+        if(k.le.2*nhko+2)then
+
+          do i=1,mxegrd
+
+            fon(i,k-1)=hon(i,0)
+
+          enddo
+
+        endif
+
+      enddo
+        
+c     zeroth order function
+c     note: hon(1,0)=2.d0*alpha/sqrpi
+
+      do i=1,mxegrd
+
+        hon(i,0)= fon(i,0)
+        dhn(i,0)=-fon(i,1)
+
+      enddo
+
+      if(nhko.eq.0)then
+
+        ss1=dble(mxegrd-1)*drewd
+        aaa=abs(1.d0-hon(mxegrd,nhko)*ss1)
+        if(aaa.gt.1.d-4)then
+
+          call warning(idnode,100,aaa,0.d0,0.d0)
+
+        endif
+        
+        return
+
+      endif
+
+c     first order function
+c     note: hon(1,1)=8.d0*alpha**3/(3.d0*sqrpi)
+
+      do i=1,mxegrd
+        
+        ss2=(dble(i-1)*drewd)**2
+        
+        hon(i,1)=-(2.d0*fon(i,1)-fon(i,2)*ss2)
+        dhn(i,1)= (4.d0*fon(i,2)-fon(i,3)*ss2)
+          
+      enddo
+        
+      if(nhko.eq.1)then
+
+        aaa=abs(1.d0-hon(mxegrd,nhko)*sqrt(ss2)**(2*nhko+1))
+        if(aaa.gt.1.d-4)then
+
+          call warning(idnode,100,aaa,0.d0,0.d0)
+
+        endif
+        
+        return
+
+      endif
+
+c     second order function
+c     note: hon(1,2)=64.d0*alpha**5/(45.d0*sqrpi)
+
+      do i=1,mxegrd
+        
+        ss2=(dble(i-1)*drewd)**2
+        
+        hon(i,2)=(8.d0*fon(i,2)+ss2*(-8.d0*fon(i,3)+ss2*fon(i,4)))/9.d0
+        dhn(i,2)=(-24.d0*fon(i,3)+ss2*(12.d0*fon(i,4)-ss2*fon(i,5)))
+     x          /9.d0
+
+      enddo
+
+      if(nhko.eq.2)then
+
+        aaa=abs(1.d0-hon(mxegrd,nhko)*sqrt(ss2)**(2*nhko+1))
+        if(aaa.gt.1.d-4)then
+
+          call warning(idnode,100,aaa,0.d0,0.d0)
+
+        endif
+        
+        return
+        
+      endif
+
+c     third order function (enough for anyone!)
+c     note: hon(1,3)=768.d0*alpha**7/(14175.d0*sqrpi)
+
+      do i=1,mxegrd
+        
+        ss2=(dble(i-1)*drewd)**2
+        
+        hon(i,3)=-(48.d0*fon(i,3)+ss2*(-72.d0*fon(i,4)+ss2*(
+     x    18.d0*fon(i,5)-ss2*fon(i,6))))/225.d0
+        dhn(i,3)= (192.d0*fon(i,4)+ss2*(-144.d0*fon(i,5)+ss2*(
+     x    24.d0*fon(i,6)-ss2*fon(i,7))))/225.d0
+        
+      enddo
+
+      if(nhko.eq.3)then
+
+        aaa=abs(1.d0-hon(mxegrd,nhko)*sqrt(ss2)**(2*nhko+1))
+        if(aaa.gt.1.d-4)then
+
+          call warning(idnode,100,aaa,0.d0,0.d0)
+
+        endif
+        
+        return
+        
+      endif
+
+      return
+      end subroutine hkgen
+
+      subroutine hkewald1
+     x  (idnode,mxnode,natms,imcon,nhko,kmax1,kmax2,
+     x  engcpe,vircpe,alpha,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using Hautman Klein Ewald method
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 2000
+c     author    - w. smith february 2000
+c     
+c     part 1 - reciprocal space terms (fourier part)
+c     
+c     note - in loop over all k vectors k=2pi(ll/cl,mm/cl)
+c     the values of ll and mm are selected so that the symmetry of
+c     reciprocal lattice is taken into account i.e. the following
+c     rules apply.
+c     
+c     ll ranges over the values 0 to kmax1 only.
+c     
+c     mm ranges over 1 to kmax2 when ll=0 and over
+c     -kmax2 to kmax2 otherwise.
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical newjob
+      integer idnode,mxnode,natms,imcon,nhko,kmax1,kmax2,i
+      integer iatm0,iatm1,j,k,limit,mmin,l,ll,m,mm,n
+      real(8) engcpe,vircpe,alpha,epsq,twopi,ralph,area,rarea
+      real(8) det,rcpcut,rcpct2,aaa,engsic,pm1,pm2,term,ssx,ssy
+      real(8) tmp,rkx1,rky1,rkx2,rky2,rksq,rkk,fac,eterm,fng,fn0,gaus
+      real(8) bkk,force0,forcez,pterm,scale,cprop,omg,cs
+c$$$      real(8) erfc
+
+      dimension cprop(10),omg(9)
+
+      save newjob,engsic
+
+      data newjob/.true./
+
+c     initialise coulombic potential energy
+
+      engcpe=0.d0
+      vircpe=0.d0
+      if(alpha.lt.1.d-8)return
+
+c     set working parameters
+
+      twopi=2.d0*pi
+      ralph=0.5d0/alpha
+      call dcell(cell,cprop)
+      area=cprop(1)*cprop(2)*sqrt(1.d0-cprop(4)**2)
+      rarea=pi/area
+
+c     set up atoms numbers for nodes
+
+      iatm0 = (idnode*natms)/mxnode + 1
+      iatm1 = ((idnode+1)*natms)/mxnode
+
+c     initalize stress tensor working arrays
+
+      do i = 1,9
+
+        omg(i) = 0.d0
+
+      enddo
+
+c     construct reciprocal lattice vectors and set k vector range
+
+      call invert(cell,rcell,det)
+      if(abs(det).lt.1.d-6)call error(idnode,120)
+      call dcell(rcell,cprop)
+      rcpcut=min(dble(kmax1)*cprop(7),dble(kmax2)*cprop(8))*
+     x  1.05d0*twopi
+      rcpct2=rcpcut**2
+
+c     compute quantities for first entry
+
+      if(newjob)then
+
+        newjob=.false.
+
+c     pbc check and array bound checks
+
+        if(imcon.ne.6)call error(idnode,66)
+        if(mxhke.ne.msatms) call error(idnode,331)
+        if(mxewld.ne.msatms) call error(idnode,330)
+
+c     check hk screening function at cutoff
+
+        aaa=cerfr(ralph,rcpcut)
+c$$$        aaa=erfc(ralph*rcpcut)/rcpcut
+
+        if(aaa.gt.1.d-4)then
+
+          call warning(idnode,105,aaa,0.d0,0.d0)
+c          call error(idnode,487)
+          
+        endif
+
+c     calculate self interaction correction
+        
+        engsic=0.d0
+        
+        do i=iatm0,iatm1
+          
+          engsic=engsic+chge(i)**2
+          
+        enddo
+
+        engsic=-r4pie0*alpha*engsic/(sqrpi*epsq)
+
+c     binomial coefficients
+
+        k=0
+        crn(0,0)=0.5d0
+        do i=1,2*nhko
+
+          pp(i)=1.d0
+          pm1=pp(1)
+
+          do j=2,i
+
+            pm2=pp(j)
+            pp(j)=pm2+pm1
+            pm1=pm2
+
+          enddo
+
+          if(mod(i,2).eq.0)then
+
+            k=k+1
+            do j=0,k
+
+              term=pp(j+1)*(-1.d0)**j
+              crn(j,k)=term
+              crn(k,j)=term
+
+            enddo
+
+            crn(k,k)=0.5d0*crn(k,k)
+
+          endif
+
+        enddo
+
+      endif
+
+c     calculate and store powers of z_i
+      
+      i=0
+
+      do j=iatm0,iatm1
+
+        i=i+1
+        znp(i,0)=1.d0
+        znp(i,1)=zzz(j)
+
+      enddo
+
+      limit=i
+
+      do k=2,2*nhko
+
+        do i=1,limit
+
+          znp(i,k)=znp(i,k-1)*znp(i,1)
+
+        enddo
+
+      enddo
+
+c     calculate and store exponential factors
+
+      i=0
+
+      do j=iatm0,iatm1
+        
+        i=i+1
+        elc(i,0)=1.d0
+        emc(i,0)=1.d0
+        els(i,0)=0.d0
+        ems(i,0)=0.d0
+        ssx=rcell(1)*xxx(j)+rcell(4)*yyy(j)
+        ssy=rcell(2)*xxx(j)+rcell(5)*yyy(j)
+        elc(i,1)=cos(twopi*ssx)
+        emc(i,1)=cos(twopi*ssy)
+        els(i,1)=sin(twopi*ssx)
+        ems(i,1)=sin(twopi*ssy)
+        
+      enddo
+
+      do l=2,kmax2
+        
+        do i=1,limit
+          
+          emc(i,l)=emc(i,l-1)*emc(i,1)-ems(i,l-1)*ems(i,1)
+          ems(i,l)=ems(i,l-1)*emc(i,1)+emc(i,l-1)*ems(i,1)
+          
+        enddo
+        
+      enddo
+
+c     start of main loop over k vectors
+
+      mmin=1
+      
+      do ll=0,kmax1
+        
+        l=ll
+        tmp = twopi*dble(ll)
+        rkx1=tmp*rcell(1)
+        rky1=tmp*rcell(4)
+
+c     put cos(i,L) terms into cos(i,0) array
+
+        if(l.eq.1) then
+          
+          do i=1,limit
+
+            elc(i,0)=elc(i,1)
+            els(i,0)=els(i,1)
+            
+          enddo
+
+        elseif(l.gt.1) then
+
+          do i=1,limit
+
+            cs=elc(i,0)
+            elc(i,0)=cs*elc(i,1)-els(i,0)*els(i,1)
+            els(i,0)=els(i,0)*elc(i,1)+cs*els(i,1)
+            
+          enddo
+          
+        endif
+
+        do mm=mmin,kmax2
+          
+          m=iabs(mm)
+          tmp = twopi*dble(mm)
+          rkx2=rkx1+tmp*rcell(2)
+          rky2=rky1+tmp*rcell(5)
+
+c     test on magnitude of k vector
+          
+          rksq=rkx2*rkx2+rky2*rky2
+
+          if(rksq.le.rcpct2)then
+
+c     calculate exp(ikr) terms and product with charges
+            
+            i=0
+
+            if(mm.ge.0)then
+              
+              do j=iatm0,iatm1
+                
+                i=i+1
+                ckc(i)=chge(j)*(elc(i,0)*emc(i,m)-els(i,0)*ems(i,m))
+                cks(i)=chge(j)*(els(i,0)*emc(i,m)+ems(i,m)*elc(i,0))
+                
+              enddo
+              
+            else
+              
+              do j=iatm0,iatm1
+                
+                i=i+1
+                
+                ckc(i)=chge(j)*(elc(i,0)*emc(i,m)+els(i,0)*ems(i,m))
+                cks(i)=chge(j)*(els(i,0)*emc(i,m)-ems(i,m)*elc(i,0))
+                
+              enddo
+              
+            endif
+
+c     calculate sum of products of powers of z_i and q_i exp(ik.s_i)
+            
+            do k=0,2*nhko
+              
+              zgc(k)=0.d0
+              zgs(k)=0.d0
+
+              do i=1,limit
+
+                zgc(k)=zgc(k)+ckc(i)*znp(i,k)
+                zgs(k)=zgs(k)+cks(i)*znp(i,k)
+
+              enddo
+
+            enddo
+
+c     perform global summation of zgc and zgs arrays
+            
+            if(mxnode.gt.1)then
+              
+              call gdsum(zgc(0),2*nhko+1,buffer)
+              call gdsum(zgs(0),2*nhko+1,buffer)
+              
+            endif
+
+c     calculate 0th order screening function
+
+            rkk=sqrt(rksq)
+            fn0=cerfr(ralph,rkk)
+c$$$            fn0=erfc(ralph*rkk)/rkk
+            gaus=exp(-(ralph*rkk)**2)/(alpha*sqrpi)
+
+c     sum terms for orders of the screening function
+
+            fac=1.d0
+
+            do k=0,nhko
+
+c     sum over z_i binomial contributions
+
+              eterm=0.d0
+              fng=fac*fn0
+              do m=0,k
+
+                n=2*k-m
+
+c     sum energy terms
+
+                eterm=eterm+crn(m,k)*(zgc(m)*zgc(n)+zgs(m)*zgs(n))
+
+c     calculate force contribution to each site
+                
+                i=0
+                bkk=-fng*crn(m,k)
+
+                do j=iatm0,iatm1
+                  
+                  i=i+1
+                  force0=bkk*(znp(i,n)*(zgs(m)*ckc(i)-zgc(m)*cks(i))+
+     x              znp(i,m)*(zgs(n)*ckc(i)-zgc(n)*cks(i)))
+                  fxx(j)=fxx(j)+rkx2*force0
+                  fyy(j)=fyy(j)+rky2*force0
+
+                  omg(3)=omg(3)+rkx2*force0*zzz(j)
+                  omg(6)=omg(6)+rky2*force0*zzz(j)
+
+                  if(k.gt.0)then
+
+                    if(m.eq.0)then
+                      
+                      forcez=bkk*dble(n)*znp(i,n-1)*(zgc(m)*ckc(i)+
+     x                  zgs(m)*cks(i))
+                      
+                    else
+                      
+                      forcez=bkk*(dble(m)*znp(i,m-1)*(zgc(n)*ckc(i)+
+     x                  zgs(n)*cks(i))+dble(n)*znp(i,n-1)*(zgc(m)*
+     x                  ckc(i)+zgs(m)*cks(i)))
+                    
+                    endif
+                    
+                    omg(9)=omg(9)+forcez*zzz(j)
+                    fzz(j)=fzz(j)+forcez
+
+                  endif
+
+                enddo
+
+              enddo
+
+c     accumulate potential energy and stress tensor
+              
+              engcpe=engcpe+fng*eterm
+              pterm=(dble(2*k-1)*fng-fac*gaus)/rksq
+              omg(1)=omg(1)+eterm*(fng+pterm*rkx2*rkx2)
+              omg(5)=omg(5)+eterm*(fng+pterm*rky2*rky2)
+              omg(2)=omg(2)+eterm*pterm*rky2*rkx2
+              fac=fac*rksq/(dble(2*(k+1))*dble(2*k+1))
+
+c     end of loop over orders of screening function
+
+            enddo
+
+c     end of if-block for  rksq <  rcpct2
+
+          endif
+
+c     end of inner loop over reciprocal lattice vectors
+
+        enddo
+        
+        mmin=-kmax2
+
+c     end of outer loop over reciprocal lattice vectors
+
+      enddo
+      
+      engcpe=engcpe/dble(mxnode)
+      do i = 1,9
+
+        omg(i) = omg(i)/dble(mxnode)
+
+      enddo
+
+c     add self interaction correction to potential
+
+      scale=4.d0*rarea*r4pie0/epsq
+      engcpe=scale*engcpe+engsic
+
+c     virial term
+
+      vircpe=vircpe-scale*(omg(1)+omg(5)+omg(9))
+
+c     calculate final forces
+
+      do i=iatm0,iatm1
+
+        fxx(i)=scale*fxx(i)
+        fyy(i)=scale*fyy(i)
+        fzz(i)=scale*fzz(i)
+
+      enddo
+
+c     calculate stress tensor (symmetrical)
+
+      stress(1) = stress(1)+scale*omg(1)
+      stress(2) = stress(2)+scale*omg(2)
+      stress(3) = stress(3)+scale*omg(3)
+      stress(4) = stress(4)+scale*omg(2)
+      stress(5) = stress(5)+scale*omg(5)
+      stress(6) = stress(6)+scale*omg(6)
+      stress(7) = stress(7)+scale*omg(3)
+      stress(8) = stress(8)+scale*omg(6)
+      stress(9) = stress(9)+scale*omg(9)
+      
+      return
+      end subroutine hkewald1
+
+      subroutine hkewald2
+     x  (idnode,mxnode,nhko,nlatt,imcon,natms,engcpe,
+     x  vircpe,drewd,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating real-space contributions to
+c     the hautman-klein-ewald electrostatic method
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 2000
+c     author    - w. smith  may 2000
+c     
+c***********************************************************************
+            
+      implicit none
+
+      integer idnode,mxnode,nhko,nlatt,imcon,natms,nix,niy
+      integer nboxes,i,j,k,n,m,ma,mpm2,npm2,ii,l0,l1,l2,last
+      real(8) engcpe,vircpe,drewd,rcut,epsq
+      real(8) step,rcsq,rdrewd,strs1,strs2,strs3
+      real(8) strs5,strs6,strs9,dcx,dcy,udx,udy,fac,chgea,chgprd
+      real(8) ddx,ddy,ssx,ssy,ssq,coul,fcoul,rrr,ppp,vk0,vk1,vk2
+      real(8) eterm,t1,t2,egamma,fx,fy,fz,det
+
+      dimension nix(25),niy(25)
+
+      data nix/ 0, 1, 1, 0,-1,-1,-1, 0, 1, 2, 2,
+     x  2, 1, 0,-1,-2,-2,-2,-2,-2,-1, 0, 1, 2, 2/
+      data niy/ 0, 0, 1, 1, 1, 0,-1,-1,-1, 0, 1,
+     x  2, 2, 2, 2, 2, 1, 0,-1,-2,-2,-2,-2,-2,-1/
+
+CDIR$ CACHE_ALIGN fi
+      
+c     check boundary condition
+
+      if(imcon.ne.6)call error(idnode,66)
+
+c     number of neighbouring real space cells
+
+      if(nlatt.gt.2)call error(idnode,488)
+      step=dble(2*nlatt+1)
+      nboxes=(2*nlatt+1)**2
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+
+c     set cutoff condition for pair forces
+      
+      rcsq=(step*rcut)**2
+
+c     reciprocal of interpolation interval
+      
+      rdrewd = 1.d0/drewd
+
+c     reciprocal cell
+
+      call invert(cell,rcell,det)
+      do i=1,9
+
+        rcell(i)=rcell(i)/step
+
+      enddo
+
+c     initialise stress tensor accumulators
+      strs3 = 0.d0
+      strs6 = 0.d0
+      strs9 = 0.d0
+      strs1 = 0.d0
+      strs2 = 0.d0
+      strs5 = 0.d0
+
+c     loop over image cells, starting with central cell
+
+      ma=1
+      mpm2=natms/2
+      npm2=(natms-1)/2
+
+      do k=1,nboxes
+
+        last=natms
+        dcx=dble(nix(k))
+        dcy=dble(niy(k))
+        udx=cell(1)*dcx+cell(4)*dcy
+        udy=cell(2)*dcx+cell(5)*dcy
+
+c     outer loop over atoms
+
+        do m=ma,mpm2
+
+          fac=r4pie0/epsq
+          if(m.eq.0)fac=fac*0.5d0
+          if(m.gt.npm2)last=mpm2
+
+c     set initial array values
+
+          ii=0
+          do i=idnode+1,last,mxnode
+            
+            ii=ii+1
+            chgea=fac*chge(i)
+            
+            if(abs(chgea).gt.1.d-10)then
+              
+              j=i+m
+              if(j.gt.natms)j=j-natms
+              
+              chgprd=chgea*chge(j)
+              
+              if(abs(chgprd).gt.1.d-10)then
+
+                zzn(ii)=1.d0
+                zzd(ii)=0.d0
+
+c     calculate interatomic separation
+                
+                ddx=xxx(i)-xxx(j)+udx
+                ddy=yyy(i)-yyy(j)+udy
+                ssx=rcell(1)*ddx+rcell(4)*ddy
+                ssy=rcell(2)*ddx+rcell(5)*ddy
+                ssx=ssx-nint(ssx)
+                ssy=ssy-nint(ssy)
+                xdf(ii)=step*(ssx*cell(1)+ssy*cell(4))
+                ydf(ii)=step*(ssx*cell(2)+ssy*cell(5))
+                zdf(ii)=zzz(i)-zzz(j)
+                rsqdf(ii)=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+                
+              endif
+
+            endif
+
+          enddo
+
+c     loop over HK orders
+
+          do n=0,nhko
+
+c     inner loop over atoms
+
+            ii=0
+            do i=idnode+1,last,mxnode
+
+              ii=ii+1
+              chgea = fac*chge(i)
+
+              if(abs(chgea).gt.1.d-10)then
+                
+                j=i+m
+                if(j.gt.natms)j=j-natms
+
+                chgprd=chgea*chge(j)
+                
+                if(abs(chgprd).gt.1.d-10)then
+
+c     apply truncation of potential
+                  
+                  ssq=rsqdf(ii)-zdf(ii)*zdf(ii)
+
+                  if(rcsq.gt.ssq)then
+
+c     calculate potential energy and virial
+                    
+                    coul=0.d0
+                    fcoul=0.d0
+                    rrr = sqrt(rsqdf(ii))
+                    sss(ii)=sqrt(ssq)
+
+                    if(n.eq.0)then
+
+                      coul = chgprd/rrr
+                      fcoul = coul/rsqdf(ii)
+
+                    endif
+
+c     interpolation parameters
+
+                    l0=int(sss(ii)*rdrewd)
+                    ppp=sss(ii)*rdrewd-dble(l0)
+                    l0=l0+1
+                    l1=l0+1
+                    l2=l0+2
+
+c     calculate interaction energy using 3-point interpolation
+                    
+                    vk0 = hon(l0,n)
+                    vk1 = hon(l1,n)
+                    vk2 = hon(l2,n)
+                    t1 = vk0 + (vk1 - vk0)*ppp
+                    t2 = vk1 + (vk2 - vk1)*(ppp - 1.0d0)
+                    
+                    eterm=(t1+(t2-t1)*ppp*0.5d0)*ahk(n)*chgprd
+                    engcpe=engcpe+coul-eterm*zzn(ii)
+
+c     calculate forces using 3pt interpolation
+                    
+                    vk0 = dhn(l0,n)
+                    vk1 = dhn(l1,n)
+                    vk2 = dhn(l2,n)
+                    
+                    t1 = vk0 + (vk1 - vk0)*ppp
+                    t2 = vk1 + (vk2 - vk1)*(ppp - 1.0d0)
+
+c     calculate in-plane forces
+                    
+                    egamma=fcoul+
+     x                (t1+(t2-t1)*ppp*0.5d0)*chgprd*zzn(ii)*ahk(n)
+                    fx=egamma*xdf(ii)
+                    fy=egamma*ydf(ii)
+
+c     calculate perpendicular forces
+                    
+                    fz=fcoul*zdf(ii)+2.d0*dble(n)*eterm*zzd(ii)
+
+c     add to force accumulators
+
+                    fxx(i)=fxx(i)+fx
+                    fyy(i)=fyy(i)+fy
+                    fzz(i)=fzz(i)+fz
+
+                    fxx(j)=fxx(j)-fx
+                    fyy(j)=fyy(j)-fy
+                    fzz(j)=fzz(j)-fz
+
+c     reset zzn array for next order of convergence function
+              
+                    zzd(ii)=zzn(ii)*zdf(ii)
+                    zzn(ii)=zzd(ii)*zdf(ii)
+              
+c     calculate stress tensor
+                    
+                    strs1 = strs1 + xdf(ii)*fx
+                    strs2 = strs2 + xdf(ii)*fy
+                    strs3 = strs3 + xdf(ii)*fz
+                    strs5 = strs5 + ydf(ii)*fy
+                    strs6 = strs6 + ydf(ii)*fz
+                    strs9 = strs9 + zdf(ii)*fz
+
+                  endif
+                  
+                endif
+                
+              endif
+
+            enddo
+
+          enddo
+
+        enddo
+
+        ma=0
+
+      enddo
+
+c     calculate virial
+
+      vircpe=vircpe-(strs1+strs5+strs9)
+
+c     complete stress tensor
+      
+      stress(1) = stress(1) + strs1
+      stress(2) = stress(2) + strs2
+      stress(3) = stress(3) + strs3
+      stress(4) = stress(4) + strs2
+      stress(5) = stress(5) + strs5
+      stress(6) = stress(6) + strs6
+      stress(7) = stress(7) + strs3
+      stress(8) = stress(8) + strs6
+      stress(9) = stress(9) + strs9
+      
+      return
+      end subroutine hkewald2
+
+      subroutine hkewald3(iatm,ik,engcpe,vircpe,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating exclusion corrections to
+c     the hautman-klein-ewald electrostatic method
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 2000
+c     author    - w. smith  may 2000
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer iatm,ik,m,jatm
+      real(8) engcpe,vircpe,epsq,fx,fy,fz,strs1,strs2,strs3
+      real(8) strs5,strs6,strs9,chgea,chgprd,rrr,rsq,coul,fcoul
+
+CDIR$ CACHE_ALIGN fi
+      
+c     initialise stress tensor accumulators
+
+      strs1 = 0.d0
+      strs2 = 0.d0
+      strs3 = 0.d0
+      strs5 = 0.d0
+      strs6 = 0.d0
+      strs9 = 0.d0
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0     
+
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      
+      if(abs(chgea).gt.1.d-10)then
+        
+        do m=1,nexatm(ik)
+
+c     atomic index and charge product
+          
+          jatm=lexatm(ik,m)
+          chgprd=chgea*chge(jatm)
+          
+          if(abs(chgprd).gt.1.d-10)then
+
+c     calculate interatomic distance
+            
+            rsq=xdf(m)**2+ydf(m)**2+zdf(m)**2
+            rrr = sqrt(rsq)
+
+c     calculate potential energy and virial
+            
+            coul = chgprd/rrr
+            engcpe = engcpe - coul
+            
+c     calculate forces
+            
+            fcoul = coul/rsq
+            fx = fcoul*xdf(m)
+            fy = fcoul*ydf(m)
+            fz = fcoul*zdf(m)
+            
+            fxx(iatm) = fxx(iatm) - fx
+            fyy(iatm) = fyy(iatm) - fy
+            fzz(iatm) = fzz(iatm) - fz
+
+            fxx(jatm) = fxx(jatm) + fx
+            fyy(jatm) = fyy(jatm) + fy
+            fzz(jatm) = fzz(jatm) + fz
+
+c     calculate stress tensor
+            
+            strs1 = strs1 - xdf(m)*fx
+            strs2 = strs2 - xdf(m)*fy
+            strs3 = strs3 - xdf(m)*fz
+            strs5 = strs5 - ydf(m)*fy
+            strs6 = strs6 - ydf(m)*fz
+            strs9 = strs9 - zdf(m)*fz
+            
+          endif
+          
+        enddo
+
+c     virial
+        
+        vircpe=vircpe-engcpe
+
+c     complete stress tensor
+        
+        stress(1) = stress(1) + strs1
+        stress(2) = stress(2) + strs2
+        stress(3) = stress(3) + strs3
+        stress(4) = stress(4) + strs2
+        stress(5) = stress(5) + strs5
+        stress(6) = stress(6) + strs6
+        stress(7) = stress(7) + strs3
+        stress(8) = stress(8) + strs6
+        stress(9) = stress(9) + strs9
+
+      endif
+      
+      return
+      end subroutine hkewald3
+
+      subroutine hkewald4(iatm,ik,engcpe,vircpe,engcpl,vircpl,rcut,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using the hautman-klein-ewald method
+c     
+c     modified to allow direct calculation of primary (short-range)
+c     interactions for multiple-time step corrections
+      
+c     primary neighbours are taken out of the Ewald sum
+c     electrostatics are evaluated directly instead
+c     
+c     parallel replicated data version - real space terms
+c     
+c     copyright - daresbury laboratory 2000
+c     author    - w. smith july 2000
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer iatm,ik,m,jatm
+      real(8) engcpe,vircpe,engcpl,vircpl,rcut,epsq
+      real(8) fi,fli,rcsq,strs1,strs2,strs3,strs5,strs6
+      real(8) strs9,strl1,strl2,strl3,strl5,strl6,strl9,chgea,chgprd
+      real(8) rsq,rrr,coul,egamma,fx,fy,fz
+
+      dimension fi(3),fli(3)
+
+CDIR$ CACHE_ALIGN fi
+CDIR$ CACHE_ALIGN fli
+
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+      engcpl=0.d0
+      vircpl=0.d0
+
+c     initialise stress tensor accumulators
+
+      strs1 = 0.d0
+      strs2 = 0.d0
+      strs3 = 0.d0
+      strs5 = 0.d0
+      strs6 = 0.d0
+      strs9 = 0.d0
+      strl1 = 0.d0
+      strl2 = 0.d0
+      strl3 = 0.d0
+      strl5 = 0.d0
+      strl6 = 0.d0
+      strl9 = 0.d0
+
+c     start of primary loop for forces evaluation
+      
+      chgea=chge(iatm)/epsq*r4pie0
+      if(abs(chgea).gt.1.d-10)then
+
+c     temporary arrays for cache aligning
+        
+        fi(1) = fxx(iatm)
+        fi(2) = fyy(iatm)
+        fi(3) = fzz(iatm)
+        
+        fli(1) = flx(iatm)
+        fli(2) = fly(iatm)
+        fli(3) = flz(iatm)
+
+        do m=1,ik
+
+c     atomic index and charge product
+          
+          jatm=ilist(m)
+          chgprd=chgea*chge(jatm)
+          
+          if(abs(chgprd).gt.1.d-10)then
+
+c     calculate interatomic distance
+            
+            rsq=rsqdf(m)
+            
+            if(rcsq.gt.rsq)then
+
+c     coulombic energy
+              
+              rrr = sqrt(rsq)
+              coul = chgprd/rrr
+
+c     sum contributions to the totals 
+              
+              engcpe = engcpe + coul
+              engcpl = engcpl - coul
+              vircpe = vircpe - coul
+              vircpl = vircpl + coul
+
+c     calculate coulombic forces
+              
+              egamma = coul/rsq
+
+              fx = egamma*xdf(m)
+              fy = egamma*ydf(m)
+              fz = egamma*zdf(m)
+
+c     add in contributions to instantaneous force
+              
+              fi(1) = fi(1) + fx
+              fi(2) = fi(2) + fy
+              fi(3) = fi(3) + fz
+              
+              fxx(jatm) = fxx(jatm) - fx
+              fyy(jatm) = fyy(jatm) - fy
+              fzz(jatm) = fzz(jatm) - fz
+
+c     add in contributions to the long-range force
+
+              fli(1) = fli(1) - fx
+              fli(2) = fli(2) - fy
+              fli(3) = fli(3) - fz
+              
+              flx(jatm) = flx(jatm) + fx
+              fly(jatm) = fly(jatm) + fy
+              flz(jatm) = flz(jatm) + fz
+
+c     calculate long and short range stress tensors
+              
+              strs1 = strs1 + xdf(m)*fx
+              strl1 = strl1 - xdf(m)*fx
+              strs2 = strs2 + xdf(m)*fy
+              strl2 = strl2 - xdf(m)*fy
+              strs3 = strs3 + xdf(m)*fz
+              strl3 = strl3 - xdf(m)*fz
+              strs5 = strs5 + ydf(m)*fy
+              strl5 = strl5 - ydf(m)*fy
+              strs6 = strs6 + ydf(m)*fz
+              strl6 = strl6 - ydf(m)*fz
+              strs9 = strs9 + zdf(m)*fz
+              strl9 = strl9 - zdf(m)*fz
+
+            endif
+
+          endif
+          
+        enddo
+
+c     copy back temporaries
+
+        fxx(iatm) = fi(1)
+        fyy(iatm) = fi(2)
+        fzz(iatm) = fi(3)
+
+        flx(iatm) = fli(1)
+        fly(iatm) = fli(2)
+        flz(iatm) = fli(3)
+
+c     complete stress tensor
+        
+        stresl(1) = stresl(1) + strl1
+        stresl(2) = stresl(2) + strl2
+        stresl(3) = stresl(3) + strl3
+        stresl(4) = stresl(4) + strl2
+        stresl(5) = stresl(5) + strl5
+        stresl(6) = stresl(6) + strl6
+        stresl(7) = stresl(7) + strl3
+        stresl(8) = stresl(8) + strl6
+        stresl(9) = stresl(9) + strl9
+        
+        stress(1) = stress(1) + strs1
+        stress(2) = stress(2) + strs2
+        stress(3) = stress(3) + strs3
+        stress(4) = stress(4) + strs2
+        stress(5) = stress(5) + strs5
+        stress(6) = stress(6) + strs6
+        stress(7) = stress(7) + strs3
+        stress(8) = stress(8) + strs6
+        stress(9) = stress(9) + strs9
+
+      endif
+      
+      return
+      end subroutine hkewald4
+
+      function cerfr(alpha,rrr)
+
+c***********************************************************************
+c     
+c     dl_poly function for generating complementary error function
+c     divided by r
+c     
+c     copyright - daresbury laboratory 2001
+c     author    - w. smith february 2001
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer k
+      real(8) cerfr,sqrpi,h0,h1,alpha,rrr,rr2,fac
+
+      sqrpi=1.7724538509055159d0
+
+c     starting values
+
+      h0=0.d0
+      h1=(2.d0*alpha/sqrpi)*exp(-(alpha*rrr)**2)
+
+c     generate function by recursion
+
+      rr2=rrr*rrr
+      do k=100,1,-1
+
+        fac=(2.d0*alpha**2)**(k-1)
+        h0=(h0*rr2+fac*h1)/dble(2*k-1)
+
+      enddo
+        
+      cerfr=1.d0/rrr-h0
+
+      return
+      end function cerfr
+      
+      end module hkewald_module
+
diff -urN dl_class_1.9.orig/srcmod/hyper_dynamics_module.f dl_class_1.9/srcmod/hyper_dynamics_module.f
--- dl_class_1.9.orig/srcmod/hyper_dynamics_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/hyper_dynamics_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,2821 @@
+      module hyper_dynamics_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining hyperdynamics routines
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use forces_module
+      use nlist_builders_module
+      use optimiser_module
+      use property_module
+      use setup_module
+      use shake_module
+      use temp_scalers_module
+      use vv_motion_module
+      
+      implicit none
+      
+      integer, parameter :: mxtrn=10
+      integer, parameter :: mxbsn=1000
+      integer, parameter :: mxneb=8
+      integer, parameter :: mxdiffs=300
+      integer, parameter :: hyper_tag=35000      
+      
+      integer numbsn,numpro,numtrk,ndiff,maxtrk,numdark,home_bsn,numbpd
+      integer nbsa(mxbsn),nbsb(mxbsn),ktrn(mxtrn)
+      real(8) xtrn(mxtrn),ytrn(mxtrn)
+      real(8) tstop,tkeres,timhyp,timres,tboost,boost,vbase
+      
+      integer, allocatable :: idabsn(:),keymin(:)
+      real(8), allocatable :: xbas(:),ybas(:),zbas(:)
+      real(8), allocatable :: xchk(:),ychk(:),zchk(:)
+      real(8), allocatable :: xres(:),yres(:),zres(:)
+      real(8), allocatable :: vxrs(:),vyrs(:),vzrs(:)
+      real(8), allocatable :: fxrs(:),fyrs(:),fzrs(:)
+      real(8), allocatable :: xhyp(:),yhyp(:),zhyp(:)
+      real(8), allocatable :: vxhp(:),vyhp(:),vzhp(:)
+      real(8), allocatable :: fxhp(:),fyhp(:),fzhp(:)
+      real(8), allocatable :: xdiffs(:),ydiffs(:),zdiffs(:)
+      real(8), allocatable :: celneb(:,:),path(:),optk(:,:)
+      real(8), allocatable :: xneb(:),yneb(:),zneb(:),engneb(:)
+      real(8), allocatable :: fxneb(:),fyneb(:),fzneb(:)
+      real(8), allocatable :: hxneb(:),hyneb(:),hzneb(:)
+      real(8), allocatable :: taux(:),tauy(:),tauz(:)
+      real(8), allocatable :: track(:)
+
+      integer bsn_1(maxneb),bsn_2(maxneb)
+      real(8) strhyp(9),strres(9),engbsn(2)
+      real(8) celbas(9),celhyp(9),celchk(9),celres(9)
+
+      save numbsn,numtrk,numpro,ndiff,numdark,timres
+      save xbas,ybas,zbas,xchk,ychk,zchk,timhyp,vbase
+      save xres,yres,zres,vxrs,vyrs,vzrs,fxrs,fyrs,fzrs
+      save xhyp,yhyp,zhyp,vxhp,vyhp,vzhp,fxhp,fyhp,fzhp
+      save celbas,celhyp,celres,celchk,strhyp,strres
+      save idabsn,nbsa,nbsb,xdiffs,ydiffs,zdiffs,tkeres
+      save xneb,yneb,zneb,engneb,taux,tauy,tauz,keymin
+      save fxneb,fyneb,fzneb,hxneb,hyneb,hzneb,path
+      save optk,tstop,tboost,boost,numbpd
+      
+      contains
+      
+      subroutine alloc_hyper_arrays(idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining hyperdynamics arrays and
+c     initialising control variables
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      
+      integer i,fail,idnode,nebmax
+      dimension fail(nnn)
+      
+      nebmax=msatms*(mxneb+1)
+      
+c     initialise control variables
+      
+      numbpd=0
+      numtrk=0
+      numbsn=0
+      numpro=0
+      ndiff=0
+      numdark=0
+      home_bsn=0
+      tkeres=0.d0
+      tstop=1.d30
+      timhyp=0.d0
+      timres=0.d0
+      boost=1.d0
+      tboost=0.d0
+      vbase=-huge(1.d0)
+      do i=1,maxneb
+        bsn_1(i)=0
+        bsn_2(i)=0
+      enddo
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (xbas(msatms),ybas(msatms),zbas(msatms),stat=fail(1))
+      allocate (xchk(msatms),ychk(msatms),zchk(msatms),stat=fail(2))
+      allocate (xres(msatms),yres(msatms),zres(msatms),stat=fail(3))
+      allocate (vxrs(msatms),vyrs(msatms),vzrs(msatms),stat=fail(4))
+      allocate (fxrs(msatms),fyrs(msatms),fzrs(msatms),stat=fail(5))
+      allocate (xhyp(msatms),yhyp(msatms),zhyp(msatms),stat=fail(6))
+      allocate (vxhp(msatms),vyhp(msatms),vzhp(msatms),stat=fail(7))
+      allocate (fxhp(msatms),fyhp(msatms),fzhp(msatms),stat=fail(8))
+      allocate (xdiffs(mxdiffs),ydiffs(mxdiffs),zdiffs(mxdiffs),
+     x  stat=fail(9))
+      allocate (idabsn(mxdiffs),keymin(0:mxneb),stat=fail(10))
+      allocate (xneb(nebmax),yneb(nebmax),zneb(nebmax),stat=fail(11))
+      allocate (fxneb(nebmax),fyneb(nebmax),fzneb(nebmax),stat=fail(12))
+      allocate (taux(msatms),tauy(msatms),tauz(msatms),stat=fail(13))
+      allocate (engneb(0:mxneb),celneb(9,0:mxneb),path(0:mxneb),
+     x  stat=fail(14))
+      allocate (hxneb(nebmax),hyneb(nebmax),hzneb(nebmax),stat=fail(15))
+      allocate (optk(5,0:mxneb),stat=fail(16))
+      
+      do i=1,nnn
+        if(fail(i).gt.0)then
+          if(idnode.eq.0)write(nrite,'(10i5)')fail
+          call error(idnode,1115)
+        endif
+      enddo
+      
+      end subroutine alloc_hyper_arrays
+      
+      subroutine hyper_start
+     x  (ltad,lbpd,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,idnode,
+     x  imcon,keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,
+     x  mxnode,natms,ngrp,nhko,nlatt,nneut,nospl,nscons,nstbgr,
+     x  nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,
+     x  ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,ntcons,ntrack,alpha,
+     x  delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,opttol,rctter,
+     x  rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep,volm,sigma,
+     x  hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for starting a hyperdynamics simulation
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical ltad,lbpd,lfcap,lneut,lnsq,loglnk,lzeql,newlst,savflg
+      integer nblock,idnode,imcon,keyfce,keyfld,keyshl,keytol
+      integer kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt
+      integer nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond
+      integer ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,i,j
+      integer ntpvdw,ntshl,ntteth,numblock,iatm0,iatm1,ntcons
+      integer ktol,pass,fail,ntrack
+      real(8) alpha,delr,dlrpot,drewd,elrc,epsq,fmax,opttol,rctter
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep,volm,engcfg
+      real(8) virlrc,cvgerr,dum,otol,cgerr,sigma,hyp_units
+      
+c     allocate track array for BPD
+
+      if(lbpd)then
+        allocate (track(0:nblock/ntrack),stat=fail)
+      endif
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     current block number
+      
+      numblock=nstep/nblock
+      
+c     open hyperdynamics journal file
+      
+      if(idnode.eq.0)
+     x  open(nevnt,file="EVENTS",form='formatted',position='append')
+      
+c     set up hyperdynamics for simulation start
+      
+      if(nstep.eq.0)then
+        
+c     initialise bias potential boost factor
+      
+        numbpd=0
+        boost=1.d0
+        tboost=0.d0
+      
+c     set basin difference markers
+        
+        do i=1,mxbsn
+          
+          nbsa(i)=0
+          nbsb(i)=0
+          
+        enddo
+         
+c     store the starting configuration
+        
+        savflg=.true.
+        tkeres=sigma
+        call store_config(savflg,idnode,mxnode,natms,strres,celres,
+     x    xres,yres,zres,vxrs,vyrs,vzrs,fxrs,fyrs,fzrs)
+        
+c     minimise starting structure
+        
+        call define_minimum_state
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,pass,
+     x    idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,
+     x    kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x    nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,
+     x    ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,
+     x    ntpvdw,ntshl,ntteth,alpha,delr,dlrpot,drewd,
+     x    elrc,virlrc,epsq,fmax,opttol,rctter,rcut,rcutfb,
+     x    rcuttb,rprim,rvdw,temp,tstep,volm,engcfg,cvgerr)
+        
+c     define zero energy for BPD dynamics mode
+        
+        vbase=engcfg
+        
+c     write events entry for minimisation
+        
+        if(idnode.eq.0)then
+          
+          write(nevnt,'("MIN",i10,3i6,1p,3e14.5)')
+     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+     x      engcfg/hyp_units,cvgerr/hyp_units
+          write(nrite,'(1x,"MIN",i10,3i6,1p,3e14.5)')
+     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+     x      engcfg/hyp_units,cvgerr/hyp_units
+          write(nrite,"(1x,120('-'))")
+          
+        endif
+      
+c     save minimised starting structure as basin file
+        
+        call write_reference_config
+     x    ('CFGBSN','BASINS',nbsn,numbsn,natms,imcon,idnode,engcfg)
+        
+c     save details of starting home basin
+        
+        engbsn(1)=engcfg
+        
+        do i=1,9
+          celbas(i)=cell(i)
+        enddo
+        
+        call invert(cell,rcell,dum)
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          xbas(j)=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          ybas(j)=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          zbas(j)=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+        enddo
+        
+c     restore the starting configuration
+        
+        savflg=.false.
+        call store_config(savflg,idnode,mxnode,natms,strres,celres,
+     x    xres,yres,zres,vxrs,vyrs,vzrs,fxrs,fyrs,fzrs)
+        
+      else
+        
+c     restore previous data from hyperdynamics backup file
+      
+        call hyper_open(ltad,idnode,mxnode,natms,nsteql)
+                
+c     reset home basin for hyperdynamics (home basin is 0 for TAD)
+        
+        if(lbpd)home_bsn=numbsn-1
+        
+c     store the current configuration
+        
+        savflg=.true.
+        call store_config(savflg,idnode,mxnode,natms,strhyp,celhyp,
+     x    xhyp,yhyp,zhyp,vxhp,vyhp,vzhp,fxhp,fyhp,fzhp)
+        
+c     read minimised starting structure from home basin file
+      
+        call read_reference_config
+     x    ('CFGBSN','BASINS',nbsn,home_bsn,natms,imcon,idnode,engcfg)
+        
+c     save details of current home basin
+        
+        engbsn(1)=engcfg
+        
+        do i=1,9
+          celbas(i)=cell(i)
+        enddo
+        
+        call invert(cell,rcell,dum)
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          xbas(j)=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          ybas(j)=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          zbas(j)=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+        enddo
+        
+c     restore the current configuration
+        
+        savflg=.false.
+        call store_config(savflg,idnode,mxnode,natms,strhyp,celhyp,
+     x    xhyp,yhyp,zhyp,vxhp,vyhp,vzhp,fxhp,fyhp,fzhp)
+        
+      endif
+      
+      return
+      end subroutine hyper_start
+      
+      subroutine hyper_driver
+     x  (seek,ltad,lbpd,recycle,lfcap,lneut,lnsq,loglnk,lzeql,
+     x  newlst,prechk,tadall,nebgo,nblock,ntrack,idnode,imcon,
+     x  keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,multt,
+     x  mxnode,natms,ngrp,ntcons,nhko,nlatt,nneut,nospl,nscons,
+     x  nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,
+     x  ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,blkout,
+     x  alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,
+     x  opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,
+     x  tstep,volm,engcfg,catchrad,sprneb,deltad,tlow,engtke,
+     x  tolnce,hyp_units,ebias,vmin)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for implementing a hyperdynamics simulation
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+      
+      implicit none
+
+      character*8 seek
+      logical lbpd,ltad,lfcap,lneut,lnsq,loglnk,lzeql,newlst,lneb
+      logical lrefmin,same,savflg,recycle,scan,prechk,tadall,nebgo
+      integer nblock,idnode,imcon,keyfce,keyfld,keyshl,keytol,ntrack
+      integer kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt
+      integer nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond
+      integer ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw
+      integer ntshl,ntteth,blkout,numblock,bsn1,bsn2,itrack
+      integer nturn,ntcons,mdiff,newbsn,iatm0,iatm1,pass,i,j,itrk
+      real(8) alpha,delr,dlrpot,drewd,elrc,epsq,fmax,opttol,rctter
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep,volm,catchrad
+      real(8) cvgerr,estar,engcfg,cfgtmp,engcpe,engsrp,catch
+      real(8) vircpe,engmet,virmet,virlrc,engtbp,virtbp,dum
+      real(8) engfbp,virfbp,engter,virter,engbnd,virbnd,engang
+      real(8) virang,engdih,virdih,enginv,virinv,engtet,virtet
+      real(8) engshl,shlke,virshl,engfld,virfld,virsrp,sprneb
+      real(8) deltad,deltal,tlow,timhop,timlow,engtke,tolnce,hyp_units
+      real(8) ebias,vmin
+      
+      data bsn1,bsn2/0,0/
+      
+c     control variables
+      
+      lneb=.false.
+      numblock=nstep/nblock
+      maxtrk=nblock/ntrack
+      if(numdark.eq.0)numdark=nsteql
+      lrefmin=(mod(nstep,nblock).eq.0)
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     BPD/TAD simulation time
+      
+      timhyp=timhyp+tstep
+      
+c     track the tboost value
+      
+      if(mod(nstep,ntrack).eq.0)track(mod(numtrk,maxtrk))=tboost
+      
+c     provisional check for transition - compare current config with 
+c     the reference state (not in dark period)
+      
+      same=.true.
+      scan=.false.
+      if(prechk.and.(mod(nstep,ntrack).eq.0).and.
+     x  (lbpd.or.(ltad.and.(nstep.gt.numdark))))then
+        
+        catch=0.65d0*catchrad
+        call check_for_transition
+     x    (seek,same,scan,idnode,mxnode,natms,imcon,mdiff,nblock,
+     x    catch)
+        
+        if(.not.same.and.idnode.eq.0)then
+          
+          write(nevnt,'("PRE",i10)')nstep
+          write(nrite,'(1x,"PRE",i10)')nstep
+          write(nrite,"(1x,120('-'))")
+        
+        endif
+        
+      endif
+      
+      if(.not.same.or.lrefmin)then
+        
+c     store the current configuration
+        
+        savflg=.true.
+        call store_config(savflg,idnode,mxnode,natms,strhyp,celhyp,
+     x    xhyp,yhyp,zhyp,vxhp,vyhp,vzhp,fxhp,fyhp,fzhp)
+        
+c     minimise current structure
+        
+        call define_minimum_state
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,pass,
+     x    idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,
+     x    kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x    nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,
+     x    ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,
+     x    ntpvdw,ntshl,ntteth,alpha,delr,dlrpot,drewd,
+     x    elrc,virlrc,epsq,fmax,opttol,rctter,rcut,rcutfb,
+     x    rcuttb,rprim,rvdw,temp,tstep,volm,cfgtmp,cvgerr)
+        
+c     write events entry for minimisation
+      
+        if(idnode.eq.0)then
+          
+          write(nevnt,'("MIN",i10,3i6,1p,3e14.5)')
+     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+     x      cfgtmp/hyp_units,cvgerr/hyp_units
+          write(nrite,'(1x,"MIN",i10,3i6,1p,3e14.5)')
+     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+     x      cfgtmp/hyp_units,cvgerr/hyp_units
+          write(nrite,"(1x,120('-'))")
+          
+        endif
+        
+c     confirm any transition
+        
+        if(ltad)scan=.true.
+        call check_for_transition
+     x    (seek,same,scan,idnode,mxnode,natms,imcon,mdiff,nblock,
+     x    catchrad)
+        
+c     transition detected - proceed with transition analysis
+        
+        if(.not.same)then
+          
+c     store new basin energy
+          
+          engbsn(2)=cfgtmp
+          
+c     save new minimised state (bias potential dynamics only)
+          
+          if(lbpd)then
+            
+            do i=1,9
+              celres(i)=cell(i)
+            enddo
+            
+            j=0
+            do i=iatm0,iatm1
+              
+              j=j+1
+              xres(j)=xxx(i)
+              yres(j)=yyy(i)
+              zres(j)=zzz(i)
+              
+            enddo
+
+          endif
+          
+c     record transition (for TAD only if outside blackout period)
+          
+          if(lbpd.or.nstep.gt.numdark)then
+            
+c     check if transition results in unique new basin (TAD only)
+            
+            if(ltad)call check_basins(newbsn,mdiff,mxnode)
+            
+c     analysis of new basin
+            
+            if(lbpd.or.tadall.or.newbsn.eq.numbsn)then
+              
+c     set difference counters and pointers (TAD only)
+              
+              if(ltad)then
+                
+                if(numbsn.gt.mxbsn)call error(idnode,2330)
+              
+                ndiff=mdiff
+                
+                if(numbsn.gt.1)then
+                  nbsa(numbsn)=nbsb(numbsn-1)+1
+                else
+                  nbsa(numbsn)=1
+                endif
+                
+                nbsb(numbsn)=mdiff
+                
+              endif
+              
+c     save the basin file and store basin energy
+              
+              call write_reference_config
+     x          ('CFGBSN','BASINS',nbsn,numbsn,natms,imcon,idnode,
+     x          cfgtmp)
+              
+c     determine minimum (reaction) path and activation energy
+              
+              if(nebgo)call neb_driver
+     x          (lfcap,lneut,lnsq,loglnk,lzeql,newlst,lneb,bsn1,
+     x          bsn2,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x          keytol,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,ngrp,
+     x          ntcons,ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,
+     x          keyshl,ntfree,keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,
+     x          ntshl,nscons,delr,dlrpot,engcpe,engsrp,epsq,rcut,
+     x          rprim,rvdw,vircpe,virsrp,alpha,drewd,volm,
+     x          engmet,virmet,elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,
+     x          engfbp,virfbp,rctter,engter,virter,engbnd,virbnd,
+     x          engang,virang,engdih,virdih,enginv,virinv,engtet,
+     x          virtet,engshl,shlke,virshl,engfld,virfld,cfgtmp,fmax,
+     x          temp,tstep,opttol,sprneb,hyp_units)
+              
+c     analyse the transition - determine e-star and destination state
+              
+              if(nebgo)call transition_properties
+     x          (seek,ltad,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,
+     x          idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,
+     x          kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x          nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,
+     x          ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,
+     x          ntpvdw,ntshl,ntteth,nturn,numbsn,alpha,delr,dlrpot,
+     x          drewd,elrc,virlrc,epsq,fmax,opttol,rctter,rcut,rcutfb,
+     x          rcuttb,rprim,rvdw,temp,tstep,volm,cfgtmp,cvgerr,estar,
+     x          catchrad,hyp_units)
+              
+c     estimate time of transition from past trajectory
+              
+              call transition_time
+     x          (seek,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,
+     x          idnode,imcon,keyfce,keyfld,keyshl,keytol,kmax1,
+     x          kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x          nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,
+     x          ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,
+     x          ntpter,ntrack,ntpvdw,ntshl,ntteth,ntcons,itrk,
+     x          alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,
+     x          opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,
+     x          tstep,volm,cfgtmp,cvgerr,catchrad,timhop,hyp_units)
+              
+c     update TAD control variables
+              
+              if(ltad)then
+                
+c     update blackout period
+                
+                numdark=nblock*((nstep+blkout)/nblock+1)
+                
+c     calculate stopping time
+                
+                timlow=timhop*exp(-(estar/temp-estar/tlow)/boltz)
+                tstop=min(tstop,deltad*(timlow/deltad)**(tlow/temp))
+                
+c     write transition data for TAD only
+                
+                if(idnode.eq.0)then
+                  
+                  write(nevnt,'("TRA",i10,3i6,1p,4e14.5)')
+     x              nstep,home_bsn,numbsn-1,nturn,estar/hyp_units,
+     x              timhop,timlow,tstop
+                  write(nevnt,'("BLK",2i10)')nstep,numdark
+                  write(nrite,'(1x,"TRA",i10,3i6,1p,4e14.5)')
+     x              nstep,home_bsn,numbsn-1,nturn,estar/hyp_units,
+     x              timhop,timlow,tstop
+                  write(nrite,'(1x,"BLK",2i10)')nstep,numdark
+                  write(nrite,"(1x,120('-'))")
+                  
+                endif
+                
+              elseif(nebgo.and.idnode.eq.0)then
+                
+c     write transition data for bias potential dynamics with NEB
+                
+                write(nevnt,'("TRA",i10,3i6,1p,3e14.5)')
+     x            nstep,home_bsn,numbsn-1,nturn,estar/hyp_units,
+     x            timhop,timhop*tboost
+                write(nrite,'(1x,"TRA",i10,3i6,1p,3e14.5)')
+     x            nstep,home_bsn,numbsn-1,nturn,estar/hyp_units,
+     x            timhop,timhop*tboost
+                write(nrite,"(1x,120('-'))")
+                
+                numbpd=0
+                tboost=0.0
+                
+              elseif(idnode.eq.0)then
+                
+c     write transition data for bias potential dynamics without NEB
+                
+                write(nevnt,'("TRA",i10,2i6,1p,3e14.5)')
+     x            nstep,home_bsn,numbsn-1,ebias/hyp_units,
+     x            timhop,timhop*tboost
+                write(nrite,'(1x,"TRA",i10,2i6,1p,3e14.5)')
+     x            nstep,home_bsn,numbsn-1,ebias/hyp_units,
+     x            timhop,timhop*tboost
+                write(nrite,"(1x,120('-'))")
+                
+                numbpd=0
+                tboost=0.0
+                
+              endif
+              
+            else
+              
+c     update blackout period when transition not unique (TAD only)
+              
+              numdark=nblock*((nstep+blkout)/nblock+1)
+              
+              if(idnode.eq.0)then
+                
+                write(nevnt,'("TRR",i10,3i6)')nstep,home_bsn,newbsn
+                write(nevnt,'("BLK",2i10)')nstep,numdark
+                write(nrite,'(1x,"TRR",i10,3i6)')nstep,home_bsn,newbsn
+                write(nrite,'(1x,"BLK",2i10)')nstep,numdark
+                write(nrite,"(1x,120('-'))")
+                
+              endif
+              
+            endif
+            
+c     actions when new basin has been visited before (TAD only)
+            
+          elseif(ltad)then
+            
+c     ignore dark transition and extend blackout period (TAD only)
+            
+            if(idnode.eq.0)then
+              
+              write(nevnt,'("TRI",i10)')nstep
+              write(nrite,'(1x,"TRI",i10)')nstep
+              write(nrite,"(1x,120('-'))")
+              
+            endif
+            
+            if(nstep.le.nsteql)then
+              
+              nsteql=nsteql+blkout
+              numdark=nsteql+blkout
+              if(idnode.eq.0)then
+                
+                write(nevnt,'("EQL",2i10)')nstep,nsteql
+                write(nrite,'(1x,"EQL",2i10)')nstep,nsteql
+                write(nrite,"(1x,120('-'))")
+                
+              endif
+              
+            else
+              
+              numdark=nblock*((nstep+blkout)/nblock+1)
+              if(idnode.eq.0)then
+                
+                write(nevnt,'("BLK",3i10)')nstep,numdark
+                write(nrite,'(1x,"BLK",3i10)')nstep,numdark
+                write(nrite,"(1x,120('-'))")
+                
+              endif
+              
+            endif
+            
+          endif
+          
+          if(ltad)then
+            
+c     return to the block starting state after transition (TAD only)
+            
+            timhyp=timres
+            savflg=.false.
+            call store_config(savflg,idnode,mxnode,natms,strres,celres,
+     x        xres,yres,zres,vxrs,vyrs,vzrs,fxrs,fyrs,fzrs)
+            
+c     scramble the velocities (and conserve system energy)
+            
+            call regauss(idnode,imcon,mxnode,natms,ngrp,nscons,ntcons,
+     x        ntshl,keyshl,tkeres,temp,tolnce)
+          
+          elseif(lbpd)then
+            
+c     reset reference state to new basin (bias potential dynamics only)
+            
+            home_bsn=home_bsn+1
+            engbsn(1)=engbsn(2)
+      
+            do i=1,9
+              celbas(i)=celres(i)
+            enddo
+            
+            call invert(celbas,rcell,dum)
+            
+            do i=1,iatm1-iatm0+1
+              
+              xbas(i)=rcell(1)*xres(i)+rcell(4)*yres(i)+rcell(7)*zres(i)
+              ybas(i)=rcell(2)*xres(i)+rcell(5)*yres(i)+rcell(8)*zres(i)
+              zbas(i)=rcell(3)*xres(i)+rcell(6)*yres(i)+rcell(9)*zres(i)
+              
+            enddo
+            
+c     restore current hyperdynamics configuration
+            
+            savflg=.false.
+            call store_config(savflg,idnode,mxnode,natms,strhyp,celhyp,
+     x        xhyp,yhyp,zhyp,vxhp,vyhp,vzhp,fxhp,fyhp,fzhp)
+            
+c     reset boost factor
+            
+            numbpd=0
+            tboost=0.d0
+            
+          endif
+          
+c     no transition detected so restore current trajectory
+          
+        else
+          
+c     restore the current configuration
+          
+          savflg=.false.
+          call store_config(savflg,idnode,mxnode,natms,strhyp,celhyp,
+     x      xhyp,yhyp,zhyp,vxhp,vyhp,vzhp,fxhp,fyhp,fzhp)
+          
+c     save the block configuration as reset state (TAD only)
+          
+          if(ltad.and.lrefmin)then
+            
+            savflg=.true.
+            tkeres=engtke
+            timres=timhyp
+            call store_config(savflg,idnode,mxnode,natms,strres,celres,
+     x        xres,yres,zres,vxrs,vyrs,vzrs,fxrs,fyrs,fzrs)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+c     close down if TAD stopping time reached
+      
+      if(ltad.and.tstop.lt.timhyp)recycle=.false.
+            
+c     write a tracking file
+      
+      if(mod(nstep,ntrack).eq.0)then
+        
+        itrack=mod(numtrk,maxtrk)
+        call write_reference_config
+     x    ('CFGTRK','TRACKS',ntrk,itrack,natms,imcon,idnode,engcfg)
+
+        numtrk=numtrk+1
+        
+      endif
+      
+      return
+      end subroutine hyper_driver
+      
+      subroutine define_minimum_state
+     x  (lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,pass,
+     x  idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,
+     x  kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x  nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,
+     x  ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,
+     x  ntpvdw,ntshl,ntteth,alpha,delr,dlrpot,drewd,
+     x  elrc,virlrc,epsq,fmax,opttol,rctter,rcut,rcutfb,
+     x  rcuttb,rprim,rvdw,temp,tstep,volm,engcfg,cvgerr)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for controlling subroutine calls for a
+c     structural minimisation to define a minimum state for
+c     hyperdynamics simulations
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lfcap,nogofr,lneut,lnsq,loglnk,stropt,lzeql
+      logical newlst,ltad,lsolva,lfree,lexcite
+
+      integer idnode,imcon,keyfce,keyfld,keyshl,keytol
+      integer keystr,kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp
+      integer nhko,nlatt,nneut,nospl,nscons,nstbgr,nstep,nsteql
+      integer ntangl,ntbond,ntdihd,ntfree,ntinv,ntpfbp,ntpmet
+      integer ntptbp,ntpter,ntpvdw,ntshl,ntteth,numrdf
+      integer nblock,pass,mxpass,mstep,ntcons,nsolva,isolva
+
+      real(8) alpha,delr,dlrpot,drewd,elrc,engang,engbnd
+      real(8) engcpe,engdih,engfbp,engfld,enginv,engshl,engsrp
+      real(8) engtbp,engter,engtet,epsq,fmax,opttol,rctter
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,shlke,engcfg,temp
+      real(8) tstep,virang,virbnd,vircpe,virdih,virfbp
+      real(8) virfld,virinv,virlrc,virmet,virshl,virsrp
+      real(8) virtbp,virter,virtet,volm,engmet,cfgold,cvgerr
+      real(8) hnorm,grad0,grad1,ff1,sgn,engord,virord
+      
+      data mxpass/1000/
+      
+c     control variables
+      
+      pass=0
+      keystr=0
+      numrdf=0
+      ltad=.true.
+      engcfg=1.d30
+      stropt=.false.
+      nogofr=.false.
+      
+c     dummy variables
+      
+      lsolva=.false.
+      lfree=.false.
+      lexcite=.false.
+      nsolva=0
+      isolva=1
+      engord=0.d0
+      virord=0.d0
+      
+c     relax the current structure
+      
+      do while(.not.stropt.and.pass.lt.mxpass)
+        
+        pass=pass+1
+        cfgold=engcfg
+        mstep=nstep+pass
+
+c     construct verlet neighbour list
+        
+        call nlist_driver
+     x    (newlst,lneut,lnsq,loglnk,ltad,natms,idnode,mxnode,imcon,
+     x    nneut,keyfce,rcut,delr,tstep)
+        
+c     calculate atomic forces
+        
+        call force_manager
+     x    (newlst,lneut,lnsq,nogofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x    lexcite,idnode,mxnode,natms,imcon,mstep,nstbgr,nsteql,
+     x    numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x    ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x    keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x    isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x    vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x    rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x    virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x    virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x    engcfg,fmax,temp,engord,virord)
+        
+c     frozen atoms option
+        
+        call freeze(natms)
+        
+c     structure optimisation
+        
+        call strucopt
+     x    (stropt,keystr,keytol,idnode,mxnode,natms,ntcons,nscons,
+     x    imcon,ngrp,ntfree,tstep,opttol,engcfg,hnorm,grad0,grad1,
+     x    ff1,sgn)
+        
+        cvgerr=abs(engcfg-cfgold)
+        
+      enddo
+            
+      return
+      end subroutine define_minimum_state
+      
+      subroutine write_reference_config
+     x  (fnam,direct,nfil,nnn,natms,imcon,idnode,engcfg)
+      
+c***********************************************************************
+c     
+c     dlpoly utility to write a minimum structure file in CONFIG
+c     format
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  june 2006
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      character*6 fnam
+      character*4 tail
+      character*6 direct
+      integer nfil,nnn,i,natms,imcon,idnode,levcfg
+      real(8) engcfg
+      
+      levcfg=0
+      
+c     node zero handles i/o
+      
+      if(idnode.eq.0)then
+        
+c     write configuration data to new configuration file
+        
+        write(tail,'(i4.4)')nnn
+        open(nfil,file=direct//'/'//fnam//tail,form='formatted')
+        
+        write(nfil,'(a10)')fnam//tail
+        write(nfil,'(3i10,g20.12)') levcfg,imcon,natms,engcfg
+
+        if(imcon.gt.0) write(nfil,'(3f20.12)') cell
+        
+        do i=1,natms
+          
+          write(nfil,'(a8,i10)') atmnam(i),i
+          write(nfil,'(3g20.10)') xxx(i),yyy(i),zzz(i)
+          
+        enddo
+        
+        close (nfil)
+        
+      endif
+      
+      nnn=nnn+1
+      
+      return
+      end subroutine write_reference_config
+      
+      subroutine read_reference_config
+     x  (fnam,direct,nfil,nnn,natms,imcon,idnode,engcfg)
+      
+c***********************************************************************
+c     
+c     dlpoly utility to read a reference structure file in CONFIG
+c     format
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  february 2007
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      character*6 fnam
+      character*4 tail
+      character*6 direct
+      integer nfil,nnn,i,natms,imcon,idnode,levcfg
+      real(8) engcfg
+      
+c     node zero handles i/o
+      
+      if(idnode.eq.0)then
+        
+c     read configuration data from configuration file on proc 0
+        
+        write(tail,'(i4.4)')nnn
+        open(nfil,file=direct//'/'//fnam//tail,form='formatted')
+        
+        read(nfil,*)
+        read(nfil,'(3i10,g20.12)')levcfg,imcon,natms,engcfg
+        buffer(1)=dble(levcfg)
+        buffer(2)=dble(imcon)
+        buffer(3)=dble(natms)
+        buffer(4)=engcfg
+        if(imcon.gt.0) read(nfil,'(3f20.12)') cell
+        do i=1,9
+          buffer(i+4)=cell(i)
+        enddo
+        call gdsum(buffer(1),13,buffer(14))
+        
+        do i=1,natms
+          
+          read(nfil,'(a8)') atmnam(i)
+          read(nfil,'(3g20.10)') xxx(i),yyy(i),zzz(i)
+          
+        enddo
+        
+        close (nfil)
+        
+      else
+        
+c     gather data from configuration file on procs > 0
+        
+        do i=1,13
+          buffer(i)=0.d0
+        enddo
+        call gdsum(buffer(1),13,buffer(14))
+
+        levcfg=nint(buffer(1))
+        imcon=nint(buffer(2))
+        natms=nint(buffer(3))
+        engcfg=buffer(4)
+        do i=1,9
+          cell(i)=buffer(i+4)
+        enddo
+        do i=1,natms
+          xxx(i)=0.d0
+          yyy(i)=0.d0
+          zzz(i)=0.d0
+        enddo
+        
+      endif
+      
+c     global gather of atomic coordinates
+      
+      call gdsum(xxx,natms,buffer)
+      call gdsum(yyy,natms,buffer)
+      call gdsum(zzz,natms,buffer)
+      
+      return
+      end subroutine read_reference_config
+      
+      subroutine store_config(lsave,idnode,mxnode,natms,strold,celold,
+     x  xold,yold,zold,vxold,vyold,vzold,fxold,fyold,fzold)
+
+c***********************************************************************
+c     
+c     dlpoly hyperdynamics routine for storing the current 
+c     configuration
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  sep  2006
+c     
+c**********************************************************************
+      
+      implicit none
+
+      logical lsave
+      integer idnode,mxnode,natms,iatm0,iatm1,i,j
+      
+      real(8) strold(9),celold(9)
+      real(8) xold(msatms),yold(msatms),zold(msatms)
+      real(8) vxold(msatms),vyold(msatms),vzold(msatms)
+      real(8) fxold(msatms),fyold(msatms),fzold(msatms)
+      
+c     block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+      if(lsave)then
+        
+c     save cell and stress tensors
+        
+        do i=1,9
+          
+          celold(i)=cell(i)
+          strold(i)=stress(i)
+          
+        enddo
+        
+c     save configuration
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          xold(j)=xxx(i)
+          yold(j)=yyy(i)
+          zold(j)=zzz(i)
+          vxold(j)=vxx(i)
+          vyold(j)=vyy(i)
+          vzold(j)=vzz(i)
+          fxold(j)=fxx(i)
+          fyold(j)=fyy(i)
+          fzold(j)=fzz(i)
+          
+        enddo
+        
+      else
+        
+c     restore cell and stress tensors
+        
+        do i=1,9
+          
+          cell(i)=celold(i)
+          stress(i)=strold(i)
+          
+        enddo
+        
+c     restore configuration
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          xxx(i)=xold(j)
+          yyy(i)=yold(j)
+          zzz(i)=zold(j)
+          vxx(i)=vxold(j)
+          vyy(i)=vyold(j)
+          vzz(i)=vzold(j)
+          fxx(i)=fxold(j)
+          fyy(i)=fyold(j)
+          fzz(i)=fzold(j)
+          
+        enddo
+        
+c     replication of full configuration data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          call merge(idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine store_config
+      
+      subroutine check_for_transition
+     x  (seek,same,scan,idnode,mxnode,natms,imcon,mdiff,nblock,
+     x  catchrad)
+      
+c***********************************************************************
+c     
+c     dlpoly hyperdynamics routine for checking when a transition
+c     has occured in a configuration
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  sep  2006
+c     
+c**********************************************************************
+      
+      implicit none
+
+      character*8 seek
+      logical same,safe,scan,all
+      integer idnode,mxnode,natms,imcon,nblock,mdiff
+      integer iatm0,iatm1,i,j
+      real(8) catchrad,catch2,rr2,dum,sxx,syy,szz,txx,tyy,tzz,pp2
+      
+      all=(seek.eq.'all     ')
+      
+c     flag for comparing structures
+      
+      same=.true.
+      
+c     block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     initialise search parameters
+      
+      catch2=catchrad**2
+      
+c     construct coordinate check arrays
+
+      do i=1,9
+        celchk(i)=cell(i)
+      enddo
+
+c     store structure in reduced coordinates (target atoms only)
+      
+      call invert(cell,rcell,dum)
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        
+        if(all.or.atmnam(i).eq.seek)then
+          
+          xchk(j)=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          ychk(j)=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          zchk(j)=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+        endif
+        
+      enddo
+      
+c     compare current structure with reference basin
+      
+      j=0
+      pp2=0.d0
+      safe=.true.
+      mdiff=ndiff
+      do i=iatm0,iatm1
+        
+        j=j+1
+        
+        if(all.or.atmnam(i).eq.seek)then
+          
+c     calculate separations in reduced units
+          
+          sxx=xchk(j)-xbas(j)
+          syy=ychk(j)-ybas(j)
+          szz=zchk(j)-zbas(j)
+          
+c     calculate minimum image separations
+          
+          sxx=sxx-nint(sxx)
+          syy=syy-nint(syy)
+          szz=szz-nint(szz)
+          
+c     set trial structure at minimum displacements from reference
+          
+          xchk(j)=xbas(j)+sxx
+          ychk(j)=ybas(j)+syy
+          zchk(j)=zbas(j)+szz
+          
+c     calculate atomic separations in real coordinates
+          
+          txx=(celchk(1)*xchk(j)+celchk(4)*ychk(j)+celchk(7)*zchk(j))
+     x      -(celbas(1)*xbas(j)+celbas(4)*ybas(j)+celbas(7)*zbas(j))
+          tyy=(celchk(2)*xchk(j)+celchk(5)*ychk(j)+celchk(8)*zchk(j))
+     x      -(celbas(2)*xbas(j)+celbas(5)*ybas(j)+celbas(8)*zbas(j))
+          tzz=(celchk(3)*xchk(j)+celchk(6)*ychk(j)+celchk(9)*zchk(j))
+     x      -(celbas(3)*xbas(j)+celbas(6)*ybas(j)+celbas(9)*zbas(j))
+          
+c     calculate total structural difference
+          
+          rr2=txx**2+tyy**2+tzz**2
+          pp2=max(pp2,rr2)
+          
+c     identify and store the displaced atoms
+          
+          if(scan.and.rr2.ge.catch2)then
+            
+            mdiff=mdiff+1
+            
+            if(mdiff.le.mxdiffs)then
+              
+              idabsn(mdiff)=i
+              xdiffs(mdiff)=txx
+              ydiffs(mdiff)=tyy
+              zdiffs(mdiff)=tzz
+              
+            else
+              
+              safe=.false.
+              
+            endif
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+c     global check on diffs arrays
+      
+      if(scan)then
+        
+        if(mxnode.gt.1)call gstate(safe)
+        if(.not.safe)then
+          
+          if(idnode.eq.0)write(nrite,
+     x      "(/,1x,'number of current diffs',i10)")mdiff
+          call error(idnode,2340)
+          
+        endif
+        
+      endif
+      
+c     global transition check
+      
+      same=(pp2.lt.catch2)
+      if(mxnode.gt.1)call gstate(same)
+      
+      return
+      end subroutine check_for_transition
+      
+      subroutine check_basins(newbsn,mdiff,mxnode)
+      
+c***********************************************************************
+c     
+c     dlpoly hyperdynamics routine for checking that a new basin is not
+c     one already known
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  jan  2007
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      logical same
+      integer newbsn,ia,ib,ic,id,ibsn,i,j,k,mxnode,mdiff
+      
+      ibsn=1
+      newbsn=0
+      ib=mdiff
+      ia=ndiff+1
+      same=.false.
+      do while(.not.same.and.ibsn.lt.numbsn)
+        
+        ic=nbsa(ibsn)
+        id=nbsb(ibsn)
+        
+        if(ib-ia.eq.id-ic)then
+          
+          same=.true.
+          
+          do k=0,ib-ia
+            
+            i=ia+k
+            j=ic+k
+            
+            if(.not.((idabsn(i).eq.idabsn(j)).and.
+     x        (abs(xdiffs(i)-xdiffs(j)).lt.0.1d0).and.
+     x        (abs(ydiffs(i)-ydiffs(j)).lt.0.1d0).and.
+     x        (abs(zdiffs(i)-zdiffs(j)).lt.0.1d0)))same=.false.
+            
+          enddo
+          
+        endif
+        
+c     check if same on all processors
+        
+        if(mxnode.gt.1)call gstate(same)
+        if(same)newbsn=ibsn
+        
+        ibsn=ibsn+1
+        
+      enddo
+      
+c     if not same - must be new basin!
+      
+      if(.not.same)newbsn=numbsn
+      
+      return
+      end subroutine check_basins
+      
+      subroutine neb_driver
+     x  (lfcap,lneut,lnsq,loglnk,lzeql,newlst,lneb,bsn1,
+     x  bsn2,idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,
+     x  keytol,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,ngrp,
+     x  ntcons,ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,
+     x  keyshl,ntfree,keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,
+     x  ntshl,nscons,delr,dlrpot,engcpe,engsrp,epsq,rcut,
+     x  rprim,rvdw,vircpe,virsrp,alpha,drewd,volm,
+     x  engmet,virmet,elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,
+     x  engfbp,virfbp,rctter,engter,virter,engbnd,virbnd,
+     x  engang,virang,engdih,virdih,enginv,virinv,engtet,
+     x  virtet,engshl,shlke,virshl,engfld,virfld,engcfg,fmax,
+     x  temp,tstep,opttol,sprneb,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for controlling a nudged elastic band 
+c     calculation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lneb,newlst,lneut,lnsq,stropt
+      logical lzeql,loglnk,lfcap
+      integer idnode,mxnode,natms,imcon,nstep,nstbgr,nsteql,mstep
+      integer keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw
+      integer ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl
+      integer keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nscons
+      integer ngrp,keytol,ntfree,iatm0,iatm1,iatm2,ntcons
+      integer i,j,k,n,pass,mxpass,nkinks,bsn1,bsn2,itrk
+      real(8) delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw
+      real(8) vircpe,virsrp,alpha,drewd,volm,engmet,virmet
+      real(8) elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp
+      real(8) rctter,engter,virter,engbnd,virbnd,engang,virang
+      real(8) engdih,virdih,enginv,virinv,engtet,virtet,engshl
+      real(8) shlke,virshl,engfld,virfld,engcfg,fmax,temp,tstep
+      real(8) sprneb,opttol,hyp_units,fac,xxn,yyn,zzn,tol,cvg,dum
+      
+      data mxpass/100/
+      
+c     control variables
+      
+      stropt=.false.
+      do n=0,mxneb
+        
+        keymin(n)=0
+        do i=1,5
+          optk(i,n)=0.d0
+        enddo
+        
+      enddo
+      if(lneb)numpro=-(100*bsn1+bsn2)
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      iatm2=iatm1-iatm0+1
+      
+c     read in the required start and end point configurations
+      
+      if(lneb)then
+        
+c     read data for first reference structure
+        
+        call read_reference_config
+     x    ('CFGBSN','BASINS',nbsn,bsn1,natms,imcon,idnode,engcfg)
+
+        engbsn(1)=engcfg
+        
+        do i=1,9
+          celbas(i)=cell(i)
+        enddo
+        call invert(cell,rcell,dum)
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          xbas(j)=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          ybas(j)=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          zbas(j)=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+        enddo
+        
+c     read data for second reference structure
+        
+        call read_reference_config
+     x    ('CFGBSN','BASINS',nbsn,bsn2,natms,imcon,idnode,engcfg)
+
+        engbsn(2)=engcfg
+        
+        do i=1,9
+          celchk(i)=cell(i)
+        enddo
+        call invert(cell,rcell,dum)
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          xchk(j)=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          ychk(j)=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          zchk(j)=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+        enddo
+        
+      endif
+      
+c     construct initial `bead' configurations in chain
+      
+      k=0
+      do n=0,mxneb
+        
+        j=0
+        fac=dble(n)/dble(mxneb)
+        
+c     construct linear mix of cell vectors
+        
+        do i=1,9
+          celneb(i,n)=(1.d0-fac)*celbas(i)+fac*celchk(i)
+        enddo
+        
+c     construct beads by linear interpolation
+        
+        do i=iatm0,iatm1
+          
+          j=j+1
+          k=k+1
+
+          xxn=xbas(j)+fac*((xchk(j)-xbas(j))-nint(xchk(j)-xbas(j)))
+          yyn=ybas(j)+fac*((ychk(j)-ybas(j))-nint(ychk(j)-ybas(j)))
+          zzn=zbas(j)+fac*((zchk(j)-zbas(j))-nint(zchk(j)-zbas(j)))
+          xneb(k)=celneb(1,n)*xxn+celneb(4,n)*yyn+celneb(7,n)*zzn
+          yneb(k)=celneb(2,n)*xxn+celneb(5,n)*yyn+celneb(8,n)*zzn
+          zneb(k)=celneb(3,n)*xxn+celneb(6,n)*yyn+celneb(9,n)*zzn
+  
+        enddo
+        
+      enddo
+      
+c     start of NEB optimisation
+      
+      pass=0
+      safe=.false.
+      do while(.not.safe.and.pass.lt.mxpass)
+        
+        pass=pass+1
+        safe=.true.
+        mstep=nstep+pass
+        
+c     calculate system forces on all beads
+        
+        call neb_system_forces
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,mxnode,
+     x    natms,mstep,imcon,nstbgr,nsteql,keyfce,kmax1,kmax2,
+     x    kmax3,nhko,nlatt,ntpvdw,ntpmet,nospl,multt,nneut,ntptbp,
+     x    ntpfbp,ntpter,keyshl,keyfld,ntbond,ntangl,ntdihd,ntinv,
+     x    ntteth,ntshl,delr,dlrpot,engcpe,engsrp,epsq,
+     x    rcut,rprim,rvdw,vircpe,virsrp,alpha,drewd,volm,
+     x    engmet,virmet,elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,
+     x    engfbp,virfbp,rctter,engter,virter,engbnd,virbnd,
+     x    engang,virang,engdih,virdih,enginv,virinv,engtet,
+     x    virtet,engshl,shlke,virshl,engfld,virfld,engcfg,fmax,
+     x    temp,tstep)
+        
+c     calculate spring forces on all beads
+        
+        call neb_spring_forces(idnode,mxnode,natms,nkinks,sprneb)
+        
+c     energy minimisation of each bead
+        
+        do n=0,mxneb
+          
+c     construct cell vectors for nth bead
+          
+          do i=1,9
+            cell(i)=celneb(i,n)
+          enddo
+          
+c     construct coordinate and force arrays for nth bead
+          
+          k=n*iatm2
+          do i=iatm0,iatm1
+            
+            k=k+1
+            xxx(i)=xneb(k)
+            yyy(i)=yneb(k)
+            zzz(i)=zneb(k)
+            fxx(i)=fxneb(k)
+            fyy(i)=fyneb(k)
+            fzz(i)=fzneb(k)
+            
+          enddo
+          
+c     restore search direction vector if keymin > 0
+          
+          if(keymin(n).gt.0)then
+            
+            k=n*iatm2
+            do i=iatm0,iatm1
+              
+              k=k+1
+              hhx(i)=hxneb(k)
+              hhy(i)=hyneb(k)
+              hhz(i)=hzneb(k)
+              
+            enddo
+            
+          endif
+          
+c     form complete global arrays
+          
+          if(mxnode.gt.1)then
+            
+            call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+            call merge(idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+            if(keymin(n).gt.0)
+     x        call merge(idnode,mxnode,natms,mxbuff,hhx,hhy,hhz,buffer)
+            
+          endif
+          
+c     structure optimisation
+          
+          call strucopt
+     x      (stropt,keymin(n),keytol,idnode,mxnode,natms,ntcons,nscons,
+     x      imcon,ngrp,ntfree,tstep,10.d0*opttol,engneb(n),optk(1,n),
+     x      optk(2,n),optk(3,n),optk(4,n),optk(5,n))
+          safe=safe.and.stropt
+          stropt=.false.
+          
+c     update coordinate arrays for nth bead
+          
+          k=n*iatm2
+          do i=iatm0,iatm1
+            
+            k=k+1
+            xneb(k)=xxx(i)
+            yneb(k)=yyy(i)
+            zneb(k)=zzz(i)
+            hxneb(k)=hhx(i)
+            hyneb(k)=hhy(i)
+            hzneb(k)=hhz(i)
+            
+          enddo
+          
+        enddo
+        
+      enddo
+      
+c     convergence check
+      
+c$$$      if(.not.safe)then
+c$$$        
+c$$$        call error(idnode,2320)
+c$$$        
+c$$$      else
+      
+c     save neb profile
+        
+        call write_profile(idnode,mxnode,natms,hyp_units)
+        
+c     write neb summary
+        
+        if(idnode.eq.0)then
+          
+          if(lneb)then
+            
+            write(nrite,'(/,1x,"summary of NEB calculation",/)')
+            write(nrite,'(1x,"path and energy for state",i4,
+     x        " ---> state",i4," transition")')bsn1,bsn2
+            write(nrite,'(1x,"convergence status :",l4)')safe
+            write(nrite,'(1x,"obtained after ",i4," iterations",/)')pass
+             
+            do n=0,mxneb
+              write(nrite,'(6x,1p,2e14.6)')path(n),engneb(n)/hyp_units
+            enddo
+           
+          else
+            
+            write(nevnt,'("NEB",i10,3i6,1p,2e14.5)')
+     x        nstep,pass,mxpass,mxneb+1,engbsn(1)/hyp_units,
+     x        engbsn(2)/hyp_units
+            write(nrite,'(1x,"NEB",i10,3i6,1p,2e14.5)')
+     x        nstep,pass,mxpass,mxneb+1,engbsn(1)/hyp_units,
+     x        engbsn(2)/hyp_units
+            write(nrite,"(1x,120('-'))")
+            
+          endif
+          
+        endif
+        
+c$$$      endif
+      
+c     end of NEB optimisation
+      
+      return
+      end subroutine neb_driver
+      
+      subroutine neb_system_forces
+     x  (lfcap,lneut,lnsq,loglnk,lzeql,newlst,idnode,mxnode,
+     x  natms,mstep,imcon,nstbgr,nsteql,keyfce,kmax1,kmax2,
+     x  kmax3,nhko,nlatt,ntpvdw,ntpmet,nospl,multt,nneut,ntptbp,
+     x  ntpfbp,ntpter,keyshl,keyfld,ntbond,ntangl,ntdihd,ntinv,
+     x  ntteth,ntshl,delr,dlrpot,engcpe,engsrp,epsq,
+     x  rcut,rprim,rvdw,vircpe,virsrp,alpha,drewd,volm,
+     x  engmet,virmet,elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,
+     x  engfbp,virfbp,rctter,engter,virter,engbnd,virbnd,
+     x  engang,virang,engdih,virdih,enginv,virinv,engtet,
+     x  virtet,engshl,shlke,virshl,engfld,virfld,engcfg,fmax,
+     x  temp,tstep)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating system forces in a nudged 
+c     elastic band calculation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newlst,lneut,lnsq,nogofr,lzeql,loglnk,lfcap,ltad
+      logical lsolva,lfree,lexcite
+      integer idnode,mxnode,natms,imcon,nstbgr,nsteql,mstep
+      integer numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw
+      integer ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl
+      integer keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl
+      integer iatm0,iatm1,iatm2,i,k,n,nsolva,isolva
+      real(8) delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw
+      real(8) vircpe,virsrp,alpha,drewd,volm,engmet,virmet
+      real(8) elrc,virlrc,rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp
+      real(8) rctter,engter,virter,engbnd,virbnd,engang,virang
+      real(8) engdih,virdih,enginv,virinv,engtet,virtet,engshl
+      real(8) shlke,virshl,engfld,virfld,engcfg,fmax,temp,tstep
+      real(8) engord,virord
+      
+      numrdf=0
+      ltad=.true.
+      nogofr=.false.
+      
+c     dummy variables
+      
+      lsolva=.false.
+      lfree=.false.
+      lexcite=.false.
+      nsolva=0
+      isolva=1
+      engord=0.d0
+      virord=0.d0
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      iatm2=iatm1-iatm0+1
+      
+c     calculate system forces for all beads
+      
+      do n=0,mxneb
+        
+c     construct cell vectors for one bead
+        
+        do i=1,9
+          cell(i)=celneb(i,n)
+        enddo
+        
+c     construct coordinate array for one bead
+        
+        k=n*iatm2
+        do i=iatm0,iatm1
+          
+          k=k+1
+          xxx(i)=xneb(k)
+          yyy(i)=yneb(k)
+          zzz(i)=zneb(k)
+          
+        enddo
+        
+c     form complete global arrays
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+c     construct verlet neighbour list
+        
+        call nlist_driver
+     x    (newlst,lneut,lnsq,loglnk,ltad,natms,idnode,mxnode,imcon,
+     x    nneut,keyfce,rcut,delr,tstep)
+        
+c     calculate atomic forces for one bead
+        
+        call force_manager
+     x    (newlst,lneut,lnsq,nogofr,lzeql,loglnk,lfcap,lsolva,lfree,
+     x    lexcite,idnode,mxnode,natms,imcon,mstep,nstbgr,nsteql,
+     x    numrdf,keyfce,kmax1,kmax2,kmax3,nhko,nlatt,ntpvdw,
+     x    ntpmet,nospl,multt,nneut,ntptbp,ntpfbp,ntpter,keyshl,
+     x    keyfld,ntbond,ntangl,ntdihd,ntinv,ntteth,ntshl,nsolva,
+     x    isolva,delr,dlrpot,engcpe,engsrp,epsq,rcut,rprim,rvdw,
+     x    vircpe,virsrp,alpha,drewd,volm,engmet,virmet,elrc,virlrc,
+     x    rcuttb,engtbp,virtbp,rcutfb,engfbp,virfbp,rctter,engter,
+     x    virter,engbnd,virbnd,engang,virang,engdih,virdih,enginv,
+     x    virinv,engtet,virtet,engshl,shlke,virshl,engfld,virfld,
+     x    engcfg,fmax,temp,engord,virord)
+        
+c     store configuration energy of bead
+        
+        engneb(n)=engcfg
+        
+c     frozen atoms option
+        
+        call freeze(natms)
+        
+c     allocate forces to bead atoms
+        
+        k=n*iatm2
+        do i=iatm0,iatm1
+          
+          k=k+1
+          fxneb(k)=fxx(i)
+          fyneb(k)=fyy(i)
+          fzneb(k)=fzz(i)
+          
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine neb_system_forces
+      
+      subroutine neb_spring_forces(idnode,mxnode,natms,nkinks,sprneb)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating spring forces in a nudged 
+c     elastic band calculation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,j,k,n,kp,km,idnode,mxnode,natms,iatm0,iatm1,iatm2
+      integer nkinks
+      real(8) rp2,rm2,tau2,fpar,vv0,vp1,vm1,aaa,bbb,txx,tyy,tzz
+      real(8) uxx,uyy,uzz,wxx,wyy,wzz,sxx,syy,szz,rxx,ryy,rzz
+      real(8) sprneb,fac,kink,det
+      real(8) rcella(9),rcellb(9),rcellc(9),cella(9),cellb(9),cellc(9)
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      iatm2=iatm1-iatm0+1
+      
+c     energies of first and last basins
+      
+      engneb(0)=engbsn(1)
+      engneb(mxneb)=engbsn(2)
+      
+c     calculate spring tangents for all beads
+      
+      nkinks=0
+      do n=1,mxneb-1
+        
+        rp2=0.d0
+        rm2=0.d0
+        tau2=0.d0
+        fpar=0.d0
+        kink=0.d0
+        vv0=engneb(n)
+        vp1=engneb(n+1)
+        vm1=engneb(n-1)
+        
+c     calculate tangent vector and scalar product with system force
+        
+        if(vp1.gt.vv0.and.vv0.gt.vm1)then
+          
+          aaa=1.d0
+          bbb=0.d0
+          
+        else if(vp1.lt.vv0.and.vv0.lt.vm1)then
+          
+          aaa=0.d0
+          bbb=1.d0
+          
+        else if(vp1.gt.vm1)then
+          
+          aaa=max(abs(vp1-vv0),abs(vv0-vm1))
+          bbb=min(abs(vp1-vv0),abs(vv0-vm1))
+          
+        else
+          
+          aaa=min(abs(vp1-vv0),abs(vv0-vm1))
+          bbb=max(abs(vp1-vv0),abs(vv0-vm1))
+          
+        endif
+        
+c     invert cell matrices
+        
+        do i=1,9
+          cella(i)=celneb(i,n-1)
+          cellb(i)=celneb(i,n)
+          cellc(i)=celneb(i,n+1)
+        enddo
+        call invert(cella,rcella,det)
+        call invert(cellb,rcellb,det)
+        call invert(cellc,rcellc,det)
+
+        j=0
+        k=n*iatm2
+        do i=iatm0,iatm1
+          
+          j=j+1
+          k=k+1
+          km=k-iatm2
+
+c     calculate first spring vector (pbc corrected)
+
+          sxx=rcellb(1)*xneb(k)+rcellb(4)*yneb(k)+rcellb(7)*zneb(k)
+          syy=rcellb(2)*xneb(k)+rcellb(5)*yneb(k)+rcellb(8)*zneb(k)
+          szz=rcellb(3)*xneb(k)+rcellb(6)*yneb(k)+rcellb(9)*zneb(k)
+          rxx=rcella(1)*xneb(km)+rcella(4)*yneb(km)+rcella(7)*zneb(km)
+          ryy=rcella(2)*xneb(km)+rcella(5)*yneb(km)+rcella(8)*zneb(km)
+          rzz=rcella(3)*xneb(km)+rcella(6)*yneb(km)+rcella(9)*zneb(km)
+          rxx=rxx-nint(rxx-sxx)
+          ryy=ryy-nint(ryy-syy)
+          rzz=rzz-nint(rzz-szz)
+          txx=xneb(k)-
+     x      (rxx*celneb(1,n-1)+ryy*celneb(4,n-1)+rzz*celneb(7,n-1))
+          tyy=yneb(k)-
+     x      (rxx*celneb(2,n-1)+ryy*celneb(5,n-1)+rzz*celneb(8,n-1))
+          tzz=zneb(k)-
+     x      (rxx*celneb(3,n-1)+ryy*celneb(6,n-1)+rzz*celneb(9,n-1))
+
+c     calculate second spring vector (pbc corrected)
+
+          kp=k+iatm2
+          rxx=rcellc(1)*xneb(kp)+rcellc(4)*yneb(kp)+rcellc(7)*zneb(kp)
+          ryy=rcellc(2)*xneb(kp)+rcellc(5)*yneb(kp)+rcellc(8)*zneb(kp)
+          rzz=rcellc(3)*xneb(kp)+rcellc(6)*yneb(kp)+rcellc(9)*zneb(kp)
+          rxx=rxx-nint(rxx-sxx)
+          ryy=ryy-nint(ryy-syy)
+          rzz=rzz-nint(rzz-szz)
+          uxx=-xneb(k)+
+     x      rxx*celneb(1,n+1)+ryy*celneb(4,n+1)+rzz*celneb(7,n+1)
+          uyy=-yneb(k)+
+     x      rxx*celneb(2,n+1)+ryy*celneb(5,n+1)+rzz*celneb(8,n+1)
+          uzz=-zneb(k)+
+     x      rxx*celneb(3,n+1)+ryy*celneb(6,n+1)+rzz*celneb(9,n+1)
+
+          rp2=rp2+uxx*uxx+uyy*uyy+uzz*uzz
+          rm2=rm2+txx*txx+tyy*tyy+tzz*tzz
+          wxx=aaa*uxx+bbb*txx
+          wyy=aaa*uyy+bbb*tyy
+          wzz=aaa*uzz+bbb*tzz
+          taux(j)=wxx
+          tauy(j)=wyy
+          tauz(j)=wzz
+          tau2=tau2+wxx*wxx+wyy*wyy+wzz*wzz
+          fpar=fpar+wxx*fxneb(k)+wyy*fyneb(k)+wzz*fzneb(k)
+          kink=kink+txx*uxx+tyy*uyy+tzz*uzz
+          
+        enddo
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=rp2
+          buffer(2)=rm2
+          buffer(3)=tau2
+          buffer(4)=fpar
+          buffer(5)=kink
+          call gdsum(buffer(1),5,buffer(6))
+          rp2=buffer(1)
+          rm2=buffer(2)
+          tau2=buffer(3)
+          fpar=buffer(4)
+          kink=buffer(5)
+          
+        endif
+        
+c     check for kinking of NEB
+        
+        kink=cos(kink/sqrt(rp2*rm2))
+        if(kink.lt.0.5d0)nkinks=nkinks+1
+        
+c     calculate final forces
+        
+        j=0
+        k=n*iatm2
+        tau2=sqrt(tau2)
+        fac=(sprneb*(sqrt(rp2)-sqrt(rm2))-fpar/tau2)/tau2
+        do i=iatm0,iatm1
+          
+          j=j+1
+          k=k+1
+          fxneb(k)=fxneb(k)+fac*taux(j)
+          fyneb(k)=fyneb(k)+fac*tauy(j)
+          fzneb(k)=fzneb(k)+fac*tauz(j)
+          
+        enddo
+        
+      enddo
+      
+c     abort if kinks detected
+      
+      if(nkinks.gt.0)then
+        
+        if(idnode.eq.0)
+     x    write(nrite,'(1x,"number of kinks detected ",i6)')nkinks
+        call error(idnode,2350)
+        
+      endif
+      
+      return
+      end subroutine neb_spring_forces
+      
+      subroutine transition_properties
+     x  (seek,ltad,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,
+     x  idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,kmax1,
+     x  kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,nneut,nospl,
+     x  nscons,nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,
+     x  ntinv,ntpfbp,ntpmet,ntptbp,ntpter,ntpvdw,ntshl,ntteth,
+     x  nturn,numbsn,alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,
+     x  fmax,opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,
+     x  tstep,volm,cfgtmp,cvgerr,estar,catchrad,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for analysing the NEB path and determining
+c     the destination state (if not end of chain).
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*8 seek
+      logical lfcap,lneut,lnsq,loglnk,lzeql,newlst,ltad,scan,same
+      integer nblock,idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons
+      integer kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt
+      integer nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond
+      integer ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,pass
+      integer ntpvdw,ntshl,ntteth,nturn,i,k,n,iatm0,iatm1,iatm2
+      integer numblock,numbsn,mdiff
+      real(8) alpha,delr,dlrpot,drewd,elrc,epsq,fmax,opttol,rctter
+      real(8) rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep,volm,cfgtmp
+      real(8) virlrc,cvgerr,estar,catchrad,hyp_units
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      iatm2=iatm1-iatm0+1
+      
+c     analyse neb profile
+      
+      call scan_profile(nturn,estar)
+      
+c     determine true new state from first maximum
+      
+      if(nturn.gt.1)then
+        
+        i=1
+        do while(ktrn(i).ge.0)
+          i=i+1
+        enddo
+        n=-ktrn(i)
+        
+c     construct cell vectors for nth bead
+        
+        do i=1,9
+          cell(i)=celneb(i,n)
+        enddo
+        
+c     construct coordinate force arrays for nth bead
+        
+        k=n*iatm2
+        do i=iatm0,iatm1
+          
+          k=k+1
+          xxx(i)=xneb(k)
+          yyy(i)=yneb(k)
+          zzz(i)=zneb(k)
+          
+        enddo
+        
+c     now minimise structure - this is correct new state
+        
+        call define_minimum_state
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,pass,
+     x    idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,
+     x    kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x    nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,
+     x    ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,
+     x    ntpvdw,ntshl,ntteth,alpha,delr,dlrpot,drewd,
+     x    elrc,virlrc,epsq,fmax,opttol,rctter,rcut,rcutfb,
+     x    rcuttb,rprim,rvdw,temp,tstep,volm,cfgtmp,cvgerr)
+        
+c     write events entry  for minimisation
+        
+        numblock=nstep/nblock
+        
+        if(idnode.eq.0)then
+          
+          write(nevnt,'("MIN",i10,3i6,1p,3e14.5)')
+     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+     x      cfgtmp/hyp_units,cvgerr/hyp_units
+          write(nrite,'(1x,"MIN",i10,3i6,1p,3e14.5)')
+     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+     x      cfgtmp/hyp_units,cvgerr/hyp_units
+          write(nrite,"(1x,120('-'))")
+          
+        endif
+        
+        if(ltad)then
+          
+c     determine differences for new state (TAD only)
+        
+          scan=.true.
+          call check_for_transition
+     x      (seek,same,scan,idnode,mxnode,natms,imcon,mdiff,nblock,
+     x      catchrad)
+          
+c     set difference counters and pointers
+          
+          if(numbsn.gt.mxbsn)call error(idnode,2330)
+          
+          ndiff=mdiff
+          
+          if(numbsn.gt.1)then
+            nbsa(numbsn)=nbsb(numbsn-1)+1
+          else
+            nbsa(numbsn)=1
+          endif
+          
+          nbsb(numbsn)=mdiff
+          
+c     save minimised starting structure as basin file
+          
+          call write_reference_config
+     x      ('CFGBSN','BASINS',nbsn,numbsn,natms,imcon,idnode,cfgtmp)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine transition_properties
+      
+      subroutine write_profile(idnode,mxnode,natms,hyp_units)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing profile file for NEB path
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2007
+c     
+c***********************************************************************
+      
+      character*4 tail
+      integer idnode,mxnode,natms,i,j,k,n,iatm0,iatm1,iatm2
+      real(8) hyp_units
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      iatm2=iatm1-iatm0+1
+      
+      if(idnode.eq.0)then
+        
+c     open profile data file
+      
+        if(numpro.lt.0)then
+
+          write(tail,'(i4.4)')iabs(numpro)
+          open(npro,file='PROFILES'//'/'//'PRX'//tail//'.XY',
+     x      form='formatted')
+          
+        else
+          
+          write(tail,'(i4.4)')numpro
+          open(npro,file='PROFILES'//'/'//'PRO'//tail//'.XY',
+     x      form='formatted')
+          
+        endif
+        
+      endif
+      
+c     calculate path
+      
+      path(0)=0.d0
+      if(idnode.eq.0)write(npro,'(1p,2e14.6)')path(0),
+     x  engneb(0)/hyp_units
+      
+      do n=1,mxneb
+        
+        path(n)=0.d0
+        k=n*iatm2
+        j=(n-1)*iatm2
+        do i=iatm0,iatm1
+          
+          j=j+1
+          k=k+1
+          path(n)=(xneb(k)-xneb(j))**2+(yneb(k)-yneb(j))**2+
+     x      (zneb(k)-zneb(j))**2+path(n)
+          
+        enddo
+        
+        if(mxnode.gt.1)call gdsum(path(n),1,buffer(1))
+        
+        path(n)=sqrt(path(n))+path(n-1)
+        if(idnode.eq.0)write(npro,'(1p,2e14.6)')path(n),
+     x    engneb(n)/hyp_units
+        
+      enddo
+      
+      numpro=numpro+1
+      
+      if(idnode.eq.0)close(npro)
+      
+      return
+      end subroutine write_profile
+      
+      subroutine scan_profile(nturn,estar)
+      
+c*********************************************************************
+c     
+c     dl_poly  routine for analysing neb energy profile
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith january 2007
+c     
+c*********************************************************************
+
+      implicit none
+      
+      integer, parameter :: nscan=100
+
+      integer i,np,n1,n2,npnts,fail,nturn
+      real(8) di,dj,rpd,uu,vv,v0,ss,estar
+      real(8), allocatable :: aa(:),dd(:),gg(:),zz(:)
+      
+c     allocate working arrays
+      
+      allocate (aa(0:mxneb),dd(0:mxneb),gg(0:mxneb),zz(0:mxneb),
+     x  stat=fail)
+      
+      npnts=mxneb+1
+      n1=npnts-1
+      n2=npnts-2
+      
+c     calculate spline coefficients
+      
+      gg(0)=0.d0
+      dd(0)=path(1)-path(0)
+      
+      do i=1,n1-1
+        
+        dd(i)=path(i+1)-path(i)
+        gg(i)=2.d0*(path(i+1)-path(i-1))
+        zz(i)=6.d0*((engneb(i+1)-engneb(i))/dd(i)-
+     x    (engneb(i)-engneb(i-1))/dd(i-1))
+        
+      enddo
+      
+      gg(n1)=0.d0
+      dd(n1)=0.d0
+      aa(0)=0.d0
+      aa(1)=dd(1)/gg(1)
+      
+      do i=2,n2-1
+        
+        gg(i)=gg(i)-dd(i-1)*aa(i-1)
+        aa(i)=dd(i)/gg(i)
+        
+      enddo
+      
+      gg(n1-1)=gg(n1-1)-dd(n2-1)*aa(n2-1)
+      gg(1)=zz(1)/gg(1)
+      
+      do i=2,n1-1
+        gg(i)=(zz(i)-dd(i-1)*gg(i-1))/gg(i)
+      enddo
+      
+      do i=1,n2-1
+        gg(n1-i)=gg(n1-i)-aa(n1-i)*gg(npnts-i)
+      enddo
+      
+c     now scan across the profile locating maxima and minima
+            
+      np=1
+      nturn=0
+      ss=1.d0
+      v0=engneb(0)
+      rpd=(path(npnts-1)-path(0))/dble(nscan)
+      
+      do i=2,nscan-1
+        
+        uu=rpd*dble(i)+path(0)
+        
+        do while(np.lt.npnts.and.uu.gt.path(np))
+          np=np+1
+        enddo
+
+        di=uu-path(np-1)
+        dj=path(np)-uu
+        vv=(di*engneb(np)+dj*engneb(np-1)-di*dj*
+     x    ((dd(np-1)+dj)*gg(np-1)+(dd(np-1)+di)*gg(np))/6.d0)/dd(np-1)
+        
+        if(ss.gt.0.d0.and.vv.le.v0)then
+          
+          nturn=nturn+1
+          xtrn(nturn)=uu
+          ytrn(nturn)=vv
+          ktrn(nturn)=np
+          
+        else if(ss.lt.0.d0.and.vv.gt.v0)then
+          
+          nturn=nturn+1
+          xtrn(nturn)=uu
+          ytrn(nturn)=vv
+          ktrn(nturn)=-np
+          
+        endif
+        
+        ss=sign(1.d0,vv-v0)
+        v0=vv
+        
+      enddo
+      
+c     estimated activation energy
+      
+      i=1
+      do while(ktrn(i).lt.0)
+        i=i+1
+      enddo
+      estar=ytrn(i)-engbsn(1)
+      
+c     deallocate working arrays
+      
+      deallocate (aa,dd,gg,zz,stat=fail)
+      
+      return
+      end subroutine scan_profile
+      
+      subroutine transition_time
+     x  (seek,lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,idnode,
+     x  imcon,keyfce,keyfld,keyshl,keytol,kmax1,kmax2,kmax3,
+     x  multt,mxnode,natms,ngrp,nhko,nlatt,nneut,nospl,nscons,
+     x  nstbgr,nstep,nsteql,ntangl,ntbond,ntdihd,ntfree,ntinv,
+     x  ntpfbp,ntpmet,ntptbp,ntpter,ntrack,ntpvdw,ntshl,ntteth,
+     x  ntcons,itrk,alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,
+     x  fmax,opttol,rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,
+     x  tstep,volm,cfgtmp,cvgerr,catchrad,timhop,hyp_units)
+
+c*********************************************************************
+c     
+c     dl_poly  routine for estimating the time of a transition
+c     from a backlog of previous configurations
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith february 2007
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      character*8 seek
+      logical same,minflg,lfcap,lneut,lnsq,loglnk,scan
+      logical lzeql,newlst
+      integer nblock,idnode,imcon,keyfce,keyfld,keyshl,keytol
+      integer kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt
+      integer nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond
+      integer ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter
+      integer ntpvdw,ntshl,ntteth,ntcons,ntrack,itrk,mdiff,pass
+      integer nback,ntry,numblock
+      real(8) alpha,delr,dlrpot,drewd,elrc,virlrc,epsq,fmax,opttol
+      real(8) rctter,rcut,rcutfb,rcuttb,rprim,rvdw,temp,tstep
+      real(8) volm,cfgtmp,cvgerr,eng,tol,catchrad,timhop,hyp_units
+      
+c     determine starting tracking file
+      
+      nback=min(numtrk,maxtrk)
+      
+c     search track files for transition
+        
+      itrk=0
+      same=.false.
+      
+      do while(.not.same.and.itrk.le.nback)
+        
+        itrk=itrk+1
+        ntry=mod(numtrk-itrk,maxtrk)
+        
+        call read_reference_config
+     x    ('CFGTRK','TRACKS',ntrk,ntry,natms,imcon,idnode,eng)
+        
+        call define_minimum_state
+     x    (lfcap,lneut,lnsq,loglnk,lzeql,newlst,nblock,pass,
+     x    idnode,imcon,keyfce,keyfld,keyshl,keytol,ntcons,
+     x    kmax1,kmax2,kmax3,multt,mxnode,natms,ngrp,nhko,nlatt,
+     x    nneut,nospl,nscons,nstbgr,nstep,nsteql,ntangl,ntbond,
+     x    ntdihd,ntfree,ntinv,ntpfbp,ntpmet,ntptbp,ntpter,
+     x    ntpvdw,ntshl,ntteth,alpha,delr,dlrpot,drewd,
+     x    elrc,virlrc,epsq,fmax,opttol,rctter,rcut,rcutfb,
+     x    rcuttb,rprim,rvdw,temp,tstep,volm,cfgtmp,cvgerr)
+        
+c     write events entry for minimisation (normally deactivated)
+        
+c$$$        if(idnode.eq.0)then
+c$$$          
+c$$$          numblock=nstep/nblock
+c$$$          write(nevnt,'("MIN",i10,3i6,1p,3e14.5)')
+c$$$     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+c$$$     x      cfgtmp/hyp_units,cvgerr/hyp_units
+c$$$          write(nrite,'(1x,"MIN",i10,3i6,1p,3e14.5)')
+c$$$     x      nstep,pass,numblock,keytol,opttol/hyp_units,
+c$$$     x      cfgtmp/hyp_units,cvgerr/hyp_units
+c$$$          write(nrite,"(1x,120('-'))")
+c$$$          
+c$$$        endif
+        
+c     check if still in base state
+        
+        scan=.false.
+        call check_for_transition
+     x    (seek,same,scan,idnode,mxnode,natms,imcon,mdiff,nblock,
+     x    catchrad)
+        
+      enddo
+      
+      timhop=timhyp-tstep*dble(ntrack)*(dble(itrk)-0.5d0)
+      tboost=track(ntry)
+      
+      return
+      end subroutine transition_time
+
+      subroutine scramble_velocities(idnode,natms)
+      
+c***********************************************************************
+c     
+c     dlpoly hyperdynamics routine for randomising velocities after a 
+c     transition has occured (use with identical species only)
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  jan  2007
+c     
+c**********************************************************************
+            
+      implicit none
+
+      integer idnode,natms,i,j,k,m,n
+      real(8) vvv
+
+      do j=1,10
+        
+        do i=1,natms
+          
+          k=int(natms*duni())+1
+          vvv=vxx(i)
+          vxx(i)=vxx(k)
+          vxx(k)=vvv
+          m=int(natms*duni())+1
+          vvv=vyy(i)
+          vyy(i)=vyy(m)
+          vyy(m)=vvv
+          n=int(natms*duni())+1
+          vvv=vzz(i)
+          vzz(i)=vzz(n)
+          vzz(n)=vvv
+          
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine scramble_velocities
+      
+      subroutine hyper_close(ltad,idnode,mxnode,natms,nsteql)
+      
+c***********************************************************************
+c     
+c     dlpoly routine for saving hyperdynamics restart data
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  dec  2007
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      logical ltad
+      integer idnode,mxnode,natms,nsteql
+      integer iatm0,iatm1,i,j,k,n,last,ierr,netdif
+      real(8) buff(2)
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     total number of atomic differences
+      
+      buff(1)=dble(ndiff)
+      call gdsum(buff(1),1,buff(2))
+      netdif=nint(buff(1))
+      
+      if(idnode.eq.0)then
+        
+c     open hyperdynamics restart file
+      
+        open(nhrs,file="HYPREV",form="unformatted")
+      
+c     write control variables
+        
+        write(nhrs)ltad,dble(numbsn),dble(numtrk),dble(numpro),
+     x    dble(netdif),dble(numdark),dble(nsteql),dble(numbpd),
+     x    timhyp,timres,tstop,tkeres,tboost,vbase,strres,celres
+        write(nhrs)track
+      endif
+      
+      if(ltad.and.numbsn.gt.1)then
+        
+c     load basin difference data
+        
+        n=0
+        do i=1,numbsn-1
+          
+          do j=nbsa(i),nbsb(i)
+            
+            buffer(n+1)=dble(idabsn(j))
+            buffer(n+2)=dble(i)
+            buffer(n+3)=xdiffs(j)
+            buffer(n+4)=ydiffs(j)
+            buffer(n+5)=zdiffs(j)
+            n=n+5
+            
+          enddo
+          
+        enddo
+        last=n
+        
+c     write basin difference data
+        
+        do k=1,mxnode-1
+          
+          if(idnode.eq.0)then
+            
+            
+            call csend(hyper_tag+k,buff,1,k,ierr)
+            call crecv(2*hyper_tag+k,buff,1)
+            call crecv(3*hyper_tag+k,buffer(last+1),nint(buff(1)))
+            last=nint(buff(1))+last
+            
+          elseif(k.eq.idnode)then
+            
+            call crecv(hyper_tag+k,buff,1)
+            buff(1)=dble(last)
+            call csend(2*hyper_tag+k,buff,1,0,ierr)
+            call csend(3*hyper_tag+k,buffer,last,0,ierr)
+            
+          endif
+          
+        enddo
+        
+        if(idnode.eq.0)write(nhrs)(buffer(i),i=1,last)
+        call gsync()
+        
+      endif
+      
+c     load reference block configuration data
+        
+      j=0
+      k=1
+      do i=iatm0,iatm1
+        
+        buffer(j+1)=xres(k)
+        buffer(j+2)=yres(k)
+        buffer(j+3)=zres(k)
+        j=j+3
+        k=k+1
+        
+      enddo
+      last=j
+      
+c     write reference block configuration data
+      
+      do k=1,mxnode-1
+        
+        if(idnode.eq.0)then
+          
+          call csend(hyper_tag+k,buff,1,k,ierr)
+          call crecv(2*hyper_tag+k,buff,1)
+          call crecv(3*hyper_tag+k,buffer(last+1),nint(buff(1)))
+          last=nint(buff(1))+last
+          
+        elseif(k.eq.idnode)then
+          
+          call crecv(hyper_tag+k,buff,1)
+          buff(1)=dble(last)
+          call csend(2*hyper_tag+k,buff,1,0,ierr)
+          call csend(3*hyper_tag+k,buffer,last,0,ierr)
+          
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)then
+        
+        write(nhrs)(buffer(i),i=1,last)
+        close(nhrs)
+        
+      endif
+      call gsync()
+      
+      return
+      end subroutine hyper_close
+      
+      subroutine hyper_open(ltad,idnode,mxnode,natms,nsteql)
+      
+c***********************************************************************
+c     
+c     dlpoly routine for reading hyperdynamics restart data
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  dec  2007
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      logical ltad,mtad
+      integer idnode,mxnode,natms,nsteql
+      integer iatm0,iatm1,i,j,k,n,last,netdif,ierr
+      real(8) buff(1)
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     restore control variables
+      
+      mtad=.true.
+      if(idnode.eq.0)then
+        
+c     open hyperdynamics restart file
+      
+        open(nhrs,file="HYPOLD",form="unformatted")
+      
+        read(nhrs)mtad,(buffer(i),i=1,30)
+        read(nhrs)track
+        
+      else
+        
+        do i=1,30
+          buffer(i)=0.d0
+        enddo
+        track(:)=0.d0
+        
+      endif
+      
+c     check restart file is tad compatible
+      
+      call gstate(mtad)
+      if(ltad.and.(.not.mtad))call error(idnode,2341)
+
+      call gdsum(buffer(1),31,buffer(32))
+      
+      numbsn=nint(buffer(1))
+      numtrk=nint(buffer(2))
+      numpro=nint(buffer(3))
+      netdif=nint(buffer(4))
+      numdark=nint(buffer(5))
+      nsteql=nint(buffer(6))
+      numbpd=nint(buffer(7))
+      timhyp=buffer(8)
+      timres=buffer(9)
+      tstop=buffer(10)
+      tkeres=buffer(11)
+      tboost=buffer(12)
+      vbase=buffer(13)
+      do i=1,9
+        
+        strres(i)=buffer(i+13)
+        celres(i)=buffer(i+22)
+
+      enddo
+      last=size(track)
+      call gdsum(track,last,buffer)
+
+      if(ltad.and.numbsn.gt.1)then
+        
+c     restore basin difference data
+        
+        last=5*netdif
+        if(idnode.eq.0)read(nhrs)(buffer(i),i=1,last)
+        
+        do k=1,mxnode-1
+          
+          if(idnode.eq.0)then
+            
+            call csend(hyper_tag+k,buffer,last,k,ierr)
+            
+          elseif(k.eq.idnode)then
+            
+            call crecv(hyper_tag+k,buffer,last)
+            
+          endif
+          
+        enddo
+        
+c     reject nonlocal basin difference data
+        
+        j=0
+        do i=1,last,5
+          
+          n=nint(buffer(i))
+          if(n.ge.iatm0.and.n.le.iatm1)then
+            
+            buffer(j+1)=buffer(i)
+            buffer(j+2)=buffer(i+1)
+            buffer(j+3)=buffer(i+2)
+            buffer(j+4)=buffer(i+3)
+            buffer(j+5)=buffer(i+4)
+            j=j+5
+            
+          endif
+          
+        enddo
+        last=j
+        
+c     unload basin difference data
+        
+        n=0
+        nbsa(1)=1
+        do i=1,numbsn-1
+          
+          if(i.gt.1)nbsa(i)=n+1
+          
+          do j=1,last,5
+            
+            if(nint(buffer(j+1)).eq.i)then
+              
+              n=n+1
+              idabsn(n)=nint(buffer(j))
+              xdiffs(n)=buffer(j+2)
+              ydiffs(n)=buffer(j+3)
+              zdiffs(n)=buffer(j+4)
+              
+            endif
+            
+          enddo
+          
+          nbsb(i)=n
+          
+        enddo
+        ndiff=n
+        call gsync()
+        
+      endif
+      
+c     retrieve reference block configuration data
+
+      last=3*natms
+      if(idnode.eq.0)read(nhrs)(buffer(i),i=1,last)
+      
+      do k=1,mxnode-1
+        
+c     read reference block configuration data
+        
+        if(idnode.eq.0)then
+          
+          call csend(hyper_tag+k,buffer,last,k,ierr)
+          
+        elseif(k.eq.idnode)then
+          
+          call crecv(hyper_tag+k,buffer,last)
+          
+        endif
+        
+      enddo
+      
+c     unload reference block configuration data
+        
+      n=1
+      j=3*(iatm0-1)
+      do i=iatm0,iatm1
+        
+        xres(n)=buffer(j+1)
+        yres(n)=buffer(j+2)
+        zres(n)=buffer(j+3)
+        j=j+3
+        n=n+1
+        
+      enddo
+      
+      if(idnode.eq.0)close(nhrs)
+      call gsync()
+      
+      return
+      end subroutine hyper_open
+      
+      subroutine bpd_forces(natms,keybpd,vmin,ebias,temp,engcfg)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for scaling forces in a bias potential dynamics 
+c     simulation using hamelberg, mongan and mccammon factor
+c     J. Chem. Phys. 120 (2004) 11919
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2008
+c     
+c***********************************************************************
+      
+      integer i,natms,mynode,keybpd
+      real(8) alpha,vmin,ebias,beta,temp,engcfg,eboost,hscale
+      real(8) engtmp
+      
+      boost=1.d0
+      numbpd=numbpd+1
+      
+c     reset potential energy wrt base level
+      
+      if(keybpd.eq.1)then
+        engtmp=engcfg-vbase
+      else
+        engtmp=engcfg-engbsn(1)
+      endif
+
+      if(ebias.gt.engtmp)then
+        
+c     bias potental boost
+        
+        alpha=ebias*(ebias-vmin)/vmin
+        beta=1.d0/(boltz*temp*dble(natms))
+        eboost=(ebias-engtmp)**2/(alpha+ebias-engtmp)
+        boost=exp(beta*eboost)
+        
+c     bias potential forces scaling factor
+        
+        hscale=(alpha/(alpha+ebias-engtmp))**2
+        
+c     scale forces
+        
+        do i=1,natms
+          
+          fxx(i)=fxx(i)*hscale
+          fyy(i)=fyy(i)*hscale
+          fzz(i)=fzz(i)*hscale
+          
+        enddo
+        
+      endif
+      
+c     accumulative average of boost factor
+      
+      tboost=boost/dble(numbpd)+dble(numbpd-1)*tboost/dble(numbpd)
+      
+      return
+      end subroutine bpd_forces
+
+      end module hyper_dynamics_module
diff -urN dl_class_1.9.orig/srcmod/images.f dl_class_1.9/srcmod/images.f
--- dl_class_1.9.orig/srcmod/images.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/images.f	2015-11-07 16:58:03.515055585 +0100
@@ -0,0 +1,261 @@
+      subroutine images
+     x  (imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating the minimum image
+c     of atom pairs within a specified MD cell
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     T3D optimised version. t.forester july 1994
+c     
+c     for
+c     imcon=0 no boundary conditions apply
+c     imcon=1 standard cubic boundaries apply
+c     imcon=2 orthorhombic boundaries apply
+c     imcon=3 parallelepiped boundaries apply
+c     imcon=4 truncated octahedron boundaries apply
+c     imcon=5 rhombic dodecahedron boundaries apply
+c     imcon=6 x-y parallelogram boundary conditions : no periodicity in z
+c     imcon=7 hexagonal prism boundaries apply
+c     
+c     note: in all cases the centre of the cell is at (0,0,0)
+c     warning - replicated data version: does not re-merge 
+c     coordinate arrays
+c     
+c***********************************************************************
+      
+      use error_module
+      
+      implicit none
+
+      integer imcon,idnode,mxnode,natms,iatm1,iatm2,i
+      real(8) cell,xxx,yyy,zzz,aaa,bbb,ccc,det,rt2,rt3,ssx
+      real(8) ssy,ssz,ddd,xss,yss,zss,rcell
+
+      dimension xxx(*),yyy(*),zzz(*)
+      dimension cell(9),rcell(9)
+
+      data rt2/1.41421356623d0/,rt3/1.7320508075d0/
+
+      if(imcon.gt.0) then
+
+c     block indices
+
+        iatm1 = (idnode*natms)/mxnode+1
+        iatm2 = ((idnode+1)*natms)/mxnode
+
+      endif
+      
+      if(imcon.eq.1)then
+
+c     standard cubic boundary conditions
+        
+        
+        aaa=1.d0/cell(1)
+
+        do i=iatm1,iatm2
+          xxx(i)=xxx(i)-cell(1)*nint(aaa*xxx(i))
+          yyy(i)=yyy(i)-cell(1)*nint(aaa*yyy(i))
+          zzz(i)=zzz(i)-cell(1)*nint(aaa*zzz(i))
+        enddo
+        
+      else if(imcon.eq.2)then
+
+c     rectangular (slab) boundary conditions
+        
+        aaa=1.d0/cell(1)
+        bbb=1.d0/cell(5)
+        ccc=1.d0/cell(9)
+        
+        do i=iatm1,iatm2
+          
+          xxx(i)=xxx(i)-cell(1)*nint(aaa*xxx(i))
+          yyy(i)=yyy(i)-cell(5)*nint(bbb*yyy(i))
+          zzz(i)=zzz(i)-cell(9)*nint(ccc*zzz(i))
+          
+        enddo
+        
+      else if(imcon.eq.3)then
+
+c     parallelepiped boundary conditions
+        
+        call invert(cell,rcell,det)
+        
+        do i=iatm1,iatm2
+          
+          ssx=(rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i))
+          ssy=(rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i))
+          ssz=(rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i))
+          
+          xss=ssx-nint(ssx)
+          yss=ssy-nint(ssy)
+          zss=ssz-nint(ssz)
+          
+          xxx(i)=(cell(1)*xss+cell(4)*yss+cell(7)*zss)
+          yyy(i)=(cell(2)*xss+cell(5)*yss+cell(8)*zss)
+          zzz(i)=(cell(3)*xss+cell(6)*yss+cell(9)*zss)
+          
+        enddo
+        
+      else if(imcon.eq.4)then
+
+c     truncated octahedral boundary conditions
+        
+        if(.not.(abs(cell(1)-cell(5)).lt.1.d-6.and.
+     x    abs(cell(5)-cell(9)).lt.1.d-6)) call error(idnode,130)
+        
+        aaa=1.d0/cell(1)
+        
+        do i=iatm1,iatm2
+          
+          xxx(i)=xxx(i)-cell(1)*nint(aaa*xxx(i))
+          yyy(i)=yyy(i)-cell(1)*nint(aaa*yyy(i))
+          zzz(i)=zzz(i)-cell(1)*nint(aaa*zzz(i))
+          
+          if((abs(xxx(i))+abs(yyy(i))+abs(zzz(i))).ge.
+     x      (0.75d0*cell(1)))then
+            
+            xxx(i)=xxx(i)-0.5d0*sign(cell(1),xxx(i))
+            yyy(i)=yyy(i)-0.5d0*sign(cell(1),yyy(i))
+            zzz(i)=zzz(i)-0.5d0*sign(cell(1),zzz(i))
+            
+          endif
+          
+        enddo
+        
+      else if(imcon.eq.5)then
+
+c     rhombic dodecahedral boundary conditions
+        
+        if(.not.(abs(cell(1)-cell(5)).lt.1.d-6.and.
+     x    abs(cell(9)-cell(1)*rt2).lt.1.d-6)) 
+     x    call error(idnode,140)
+        
+        aaa=1.d0/cell(1)
+        bbb=1.d0/cell(9)
+        
+        do i=iatm1,iatm2
+          
+          xxx(i)=xxx(i)-cell(1)*nint(aaa*xxx(i))
+          yyy(i)=yyy(i)-cell(1)*nint(aaa*yyy(i))
+          zzz(i)=zzz(i)-cell(9)*nint(bbb*zzz(i))
+          
+          if((abs(xxx(i))+abs(yyy(i))+abs(rt2*zzz(i))).ge.
+     x      cell(1))then
+            
+            xxx(i)=xxx(i)-0.5d0*sign(cell(1),xxx(i))
+            yyy(i)=yyy(i)-0.5d0*sign(cell(1),yyy(i))
+            zzz(i)=zzz(i)-0.5d0*sign(cell(9),zzz(i))
+            
+          endif
+          
+        enddo
+        
+      else if(imcon.eq.6) then
+
+c     x-y boundary conditions 
+
+        det = cell(1)*cell(5) - cell(2)*cell(4)
+
+        if(abs(det).lt.1.d-6)call error(idnode,120)
+        
+        det = 1.d0/det
+
+        rcell(1) =  det*cell(5)
+        rcell(2) = -det*cell(2)
+        rcell(4) = -det*cell(4)
+        rcell(5) =  det*cell(1)
+        
+        do i=iatm1,iatm2
+
+          ssx = rcell(1)*xxx(i) + rcell(4)*yyy(i)
+          ssy = rcell(2)*xxx(i) + rcell(5)*yyy(i)
+
+          xss = ssx - nint(ssx)
+          yss = ssy - nint(ssy)
+
+          xxx(i)=cell(1)*xss + cell(4)*yss
+          yyy(i)=cell(2)*xss + cell(5)*yss
+
+        enddo
+
+      else if(imcon.eq.7) then
+
+c     hexagonal prism boundary conditions
+        
+        if(abs(cell(1)-rt3*cell(5)).ge.1.d-6)
+     x    call error(idnode,135)
+        
+        aaa=cell(1)/(rt3*2.d0)
+        bbb=cell(1)/rt3
+        ccc=rt3/cell(1)
+        ddd=1.d0/cell(9)
+        
+        do i=iatm1,iatm2
+          
+          yyy(i)=yyy(i)-bbb*nint(ccc*yyy(i))
+          zzz(i)=zzz(i)-cell(9)*nint(ddd*zzz(i))
+          
+          if((abs(yyy(i))+abs(rt3*xxx(i))).ge.bbb)then
+            
+            xxx(i)=xxx(i)-rt3*sign(aaa,xxx(i))
+            yyy(i)=yyy(i)-sign(aaa,yyy(i))
+            
+          endif
+          
+        enddo
+        
+      endif
+      
+      return
+      end subroutine images
+      subroutine invert(a,b,d)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine to invert a 3 * 3 matrix using cofactors
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith       april 1992
+c     
+c***********************************************************************
+
+      implicit none
+
+      real(8) a,b,d,r
+
+      dimension a(9),b(9)
+
+c     calculate adjoint matrix
+      b(1)=a(5)*a(9)-a(6)*a(8)
+      b(2)=a(3)*a(8)-a(2)*a(9)
+      b(3)=a(2)*a(6)-a(3)*a(5)
+      b(4)=a(6)*a(7)-a(4)*a(9)
+      b(5)=a(1)*a(9)-a(3)*a(7)
+      b(6)=a(3)*a(4)-a(1)*a(6)
+      b(7)=a(4)*a(8)-a(5)*a(7)
+      b(8)=a(2)*a(7)-a(1)*a(8)
+      b(9)=a(1)*a(5)-a(2)*a(4)
+
+c     calculate determinant
+      d=a(1)*b(1)+a(4)*b(2)+a(7)*b(3)
+      r=0.d0
+      if(abs(d).gt.0.d0)r=1.d0/d
+
+c     complete inverse matrix
+      b(1)=r*b(1)
+      b(2)=r*b(2)
+      b(3)=r*b(3)
+      b(4)=r*b(4)
+      b(5)=r*b(5)
+      b(6)=r*b(6)
+      b(7)=r*b(7)
+      b(8)=r*b(8)
+      b(9)=r*b(9)
+
+      return
+      end subroutine invert
diff -urN dl_class_1.9.orig/srcmod/integrator_module.f dl_class_1.9/srcmod/integrator_module.f
--- dl_class_1.9.orig/srcmod/integrator_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/integrator_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,624 @@
+      module integrator_module
+
+c***********************************************************************
+c     
+c     dl_poly module for selecting verlet integration schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use error_module
+      use lf_motion_module
+      use lf_rotation1_module
+      use lf_rotation2_module
+      use pmf_module
+      use temp_scalers_module
+      use vv_motion_module
+      use vv_rotation1_module
+      use vv_rotation2_module
+      
+      contains
+      
+      subroutine lf_integrate
+     x  (lcnb,lshmov,lnfic,idnode,mxnode,imcon,natms,nstep,ngrp,
+     x  keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,nofic,
+     x  tstep,engke,engrot,tolnce,quattol,vircon,vircom,virtot,
+     x  temp,press,volm,sigma,taut,taup,chit,chip,consv,conint,
+     x  elrc,virlrc,virpmf)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting the integration algorithm
+c     to solve the the equations of motion. based on the leapfrog
+c     verlet algorithm
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith december 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,safep,safeq,lcnb,lshmov,lnfic
+      integer idnode,mxnode,imcon,natms,ngrp,keyens,nscons,nofic
+      integer ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,nstep
+      real(8) tstep,engke,engrot,tolnce,quattol,vircon,vircom
+      real(8) virtot,temp,press,volm,sigma,taut,taup,chit,chip
+      real(8) consv,conint,elrc,virlrc,virpmf
+      
+      safe=.true.
+      safeq=.true.
+      safep=.true.
+      
+      if(ngrp.eq.0) then
+        
+        if(keyens.eq.0) then
+
+c     verlet leapfrog 
+
+          call nve_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x      engke,tolnce,tstep,vircon)
+          
+        else if(keyens.eq.1) then
+
+c     Evans Gaussian Temperature constraints
+          
+          call nvt_e1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x      engke,tolnce,tstep,vircon)
+          
+        else if(keyens.eq.2) then
+
+c     Berendsen thermostat
+          
+          call nvt_b1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x      engke,taut,sigma,tolnce,tstep,vircon)
+          
+        else if(keyens.eq.3) then
+
+c     Nose-Hoover thermostat
+          
+          call nvt_h1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x      chit,consv,conint,engke,taut,sigma,tolnce,tstep,vircon)
+          
+        elseif(keyens.eq.4) then
+
+c     Berendsen thermostat and isotropic barostat
+
+          call npt_b1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x      ntcons,elrc,engke,virlrc,press,taup,taut,sigma,tolnce,
+     x      tstep,virtot,vircon,volm)
+
+        else if(keyens.eq.5) then
+
+c     Nose-Hoover thermostat and isotropic barostat 
+
+          call npt_h1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x      ntcons,chip,chit,conint,consv,elrc,engke,virlrc,press,
+     x      taup,taut,sigma,temp,tolnce,tstep,virtot,vircon,volm)
+
+        else if(keyens.eq.6) then
+
+c     Berendsen thermostat and barostat (cell shape varying)
+
+          call nst_b1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x      ntcons,mode,elrc,engke,virlrc,press,taup,taut,sigma,
+     x      tolnce,tstep,vircon,volm)
+
+        else if(keyens.eq.7) then
+
+c     Nose-Hoover thermostat and barostat (cell shape varying)
+          
+          call nst_h1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x      ntcons,mode,chit,conint,consv,elrc,engke,virlrc,press,
+     x      taup,taut,sigma,temp,tolnce,tstep,vircon,volm)
+
+        elseif(keyens.eq.8) then
+
+c     Potential of mean force in NVE
+
+            call pmflf
+     x        (safe,safep,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        ntcons,nspmf,ntpmf,engke,tolnce,tstep,vircon,virpmf)
+
+        endif
+
+      elseif(ngrp.gt.0) then
+
+c     apply rigid body equations of motion
+        
+        if(keyens.eq.0) then
+          
+          if(.not.lcnb) then
+
+            call nveq_1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,quattol,tolnce,tstep,vircom,
+     x        vircon)
+
+          else
+
+            call nveq_2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,quattol,tolnce,tstep,vircom,
+     x        vircon)
+
+          endif
+
+        elseif(keyens.eq.1) then
+
+c     invalid option
+
+          call error(idnode,430)
+          
+        elseif(keyens.eq.2) then
+          
+          if(.not.lcnb) then
+
+            call nvtq_b1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,quattol,sigma,taut,tolnce,
+     x        tstep,vircom,vircon)
+
+          else
+
+            call nvtq_b2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,quattol,sigma,taut,tolnce,
+     x        tstep,vircom,vircon)
+          
+          endif
+
+        elseif(keyens.eq.3) then
+          
+          if(.not.lcnb) then 
+
+            call nvtq_h1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,chit,consv,conint,engke,engrot,quattol,
+     x        sigma,taut,tolnce,tstep,vircom,vircon)
+
+          else
+
+            call nvtq_h2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,conint,consv,chit,engke,engrot,quattol,
+     x        sigma,taut,tolnce,tstep,vircom,vircon)
+
+          endif
+            
+        elseif(keyens.eq.4) then
+
+          if(.not.lcnb) then
+
+            call nptq_b1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,elrc,engke,engrot,virlrc,press,
+     x        quattol,sigma,taup,taut,tolnce,tstep,virtot,vircom,
+     x        vircon,volm)
+          
+          else
+
+            call nptq_b2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,elrc,engke,engrot,virlrc,press,
+     x        quattol,sigma,taup,taut,tolnce,tstep,vircom,vircon,
+     x        virtot,volm)
+
+          endif
+
+        elseif(keyens.eq.5) then
+          
+          if(.not.lcnb) then 
+
+            call nptq_h1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,chip,chit,consv,conint,elrc,engke,
+     x        engrot,virlrc,press,quattol,sigma,taup,taut,temp,tolnce,
+     x        tstep,virtot,vircom,vircon,volm)
+
+          else
+
+            call nptq_h2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,chip,chit,consv,conint,elrc,engke,
+     x        engrot,virlrc,press,quattol,sigma,taup,taut,temp,tolnce,
+     x        tstep,vircom,vircon,virtot,volm)
+
+          endif
+            
+        elseif(keyens.eq.6) then
+
+          if(.not.lcnb) then
+
+            call nstq_b1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,mode,elrc,engke,engrot,virlrc,press,
+     x        quattol,sigma,taup,taut,tolnce,tstep,vircom,vircon,volm)
+
+          else
+
+            call nstq_b2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,mode,elrc,engke,engrot,virlrc,press,
+     x        quattol,sigma,taup,taut,tolnce,tstep,vircom,vircon,volm)
+
+          endif
+
+        elseif(keyens.eq.7) then
+
+          if(.not.lcnb) then
+
+            call nstq_h1
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,mode,chit,conint,consv,elrc,engke,
+     x        engrot,virlrc,press,quattol,sigma,taup,taut,temp,tolnce,
+     x        tstep,vircom,vircon,volm)
+
+          else
+
+            call nstq_h2
+     x        (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,mode,chit,conint,consv,elrc,engke,
+     x        engrot,virlrc,press,quattol,sigma,taup,taut,temp,tolnce,
+     x        tstep,vircom,vircon,volm)
+            
+          endif
+
+        else
+
+c     invalid option
+
+          call error(idnode,430)
+
+        endif
+
+      endif
+
+c    check on convergence of pmf-shake
+
+      if(ntpmf.gt.0) then
+
+        if(mxnode.gt.1) call gstate(safep)
+        if(.not.safep) call error(idnode,438)
+
+      endif    
+
+c    check on convergence of shake
+
+      if(ntcons.gt.0) then
+
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) call error(idnode,105)
+
+      endif    
+
+c     check on convergence of quaternion algorithm
+
+      if(ngrp.gt.0) then
+
+        if(mxnode.gt.1) call gstate(safeq)
+        if(.not.safeq) call error(idnode,321)
+
+      endif
+
+c     eliminate "flying ice cube" in long simulations (Berendsen)
+      
+      if(lnfic.and.(keyens.eq.2.or.keyens.eq.4.or.keyens.eq.6))then
+        
+        if(mod(nstep,nofic).eq.0)then
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine lf_integrate
+
+      subroutine vv_integrate
+     x  (lcnb,lshmov,lnfic,isw,idnode,mxnode,imcon,natms,nstep,ngrp,
+     x  keyens,nscons,ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,nofic,
+     x  ntshl,keyshl,tstep,engke,engrot,tolnce,vircon,vircom,virtot,
+     x  temp,press,volm,sigma,taut,taup,chit,chip,consv,conint,elrc,
+     x  virlrc,virpmf,chit_shl,sigma_shl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for selecting the integration algorithm
+c     to solve the the equations of motion. based on the velocity
+c     verlet algorithm
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith february 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,safep,lcnb,lshmov,lnfic
+      integer isw,idnode,mxnode,imcon,natms,ngrp,keyens,nscons
+      integer ntcons,ntpatm,ntfree,nspmf,ntpmf,mode,nstep,nofic
+      integer ntshl,keyshl
+      real(8) tstep,engke,engrot,tolnce,vircon,vircom
+      real(8) virtot,temp,press,volm,sigma,taut,taup,chit,chip
+      real(8) consv,conint,elrc,virlrc,virpmf,chit_shl,sigma_shl
+      
+      if(ngrp.eq.0) then
+        
+        if(keyens.eq.0) then
+
+c     verlet leapfrog 
+
+          call nvevv_1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,tstep,engke,tolnce,vircon)
+          
+        else if(keyens.eq.1) then
+
+c     Evans Gaussian Temperature constraints
+          
+          call nvtvv_e1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,tstep,engke,tolnce,vircon)
+          
+        else if(keyens.eq.2) then
+
+c     Berendsen thermostat
+          
+          call nvtvv_b1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,tstep,taut,sigma,engke,tolnce,vircon)
+          
+        else if(keyens.eq.3) then
+
+c     Nose-Hoover thermostat
+          
+          call nvtvv_h1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,ntshl,keyshl,tstep,taut,sigma,chit,consv,
+     x      conint,engke,tolnce,vircon,chit_shl,sigma_shl)
+          
+        elseif(keyens.eq.4) then
+
+c     Berendsen thermostat and isotropic barostat
+
+          call nptvv_b1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,ntpatm,tstep,taut,taup,sigma,engke,press,elrc,
+     x      virlrc,tolnce,virtot,vircon,volm)
+
+        else if(keyens.eq.5) then
+
+c     Nose-Hoover thermostat and isotropic barostat 
+
+          call nptvv_h1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,ntpatm,ntshl,keyshl,tstep,taut,taup,sigma,temp,
+     x      chip,chit,consv,conint,engke,elrc,tolnce,vircon,
+     x      virtot,virlrc,volm,press,chit_shl,sigma_shl)
+
+        else if(keyens.eq.6) then
+
+c     Berendsen thermostat and barostat (cell shape varying)
+
+          call nstvv_b1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,ntpatm,mode,tstep,taut,taup,sigma,engke,press,
+     x      elrc,virlrc,tolnce,vircon,volm)
+
+        else if(keyens.eq.7) then
+
+c     Nose-Hoover thermostat and barostat (cell shape varying)
+          
+          call nstvv_h1
+     x      (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x      ntcons,ntpatm,mode,ntshl,keyshl,tstep,taut,taup,sigma,
+     x      temp,chit,consv,conint,engke,elrc,tolnce,vircon,
+     x      virlrc,volm,press,chit_shl,sigma_shl)
+
+        elseif(keyens.eq.8) then
+
+c     Potential of mean force in NVE
+
+          call pmfvv
+     x      (safe,safep,lshmov,isw,idnode,mxnode,imcon,natms,nscons,
+     x      ntcons,nspmf,ntpmf,engke,tolnce,tstep,vircon,virpmf)
+
+        endif
+
+      elseif(ngrp.gt.0) then
+
+c     apply rigid body equations of motion
+        
+        if(keyens.eq.0) then
+          
+          if(.not.lcnb) then
+
+            call nveqvv_1
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,tolnce,tstep,vircom,vircon)
+
+          else
+
+            call nveqvv_2
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,tolnce,tstep,vircom,vircon)
+            
+          endif
+
+        elseif(keyens.eq.1) then
+
+c     invalid option
+
+          call error(idnode,430)
+          
+        elseif(keyens.eq.2) then
+          
+          if(.not.lcnb) then
+
+            call nvtqvv_b1
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,taut,sigma,tolnce,tstep,
+     x        vircom,vircon)
+
+          else
+
+            call nvtqvv_b2
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,engke,engrot,taut,sigma,tolnce,tstep,
+     x        vircom,vircon)
+            
+          endif
+
+        elseif(keyens.eq.3) then
+          
+          if(.not.lcnb) then 
+
+            call nvtqvv_h1
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntshl,keyshl,chit,consv,conint,engke,
+     x        engrot,taut,sigma,tolnce,tstep,vircom,vircon,chit_shl,
+     x        sigma_shl)
+
+          else
+
+            call nvtqvv_h2
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntshl,keyshl,chit,consv,conint,engke,
+     x        engrot,taut,sigma,tolnce,tstep,vircom,vircon,chit_shl,
+     x        sigma_shl)
+
+          endif
+          
+        elseif(keyens.eq.4) then
+
+          if(.not.lcnb) then
+
+            call nptqvv_b1
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,engke,engrot,press,taut,taup,sigma,
+     x        tolnce,tstep,vircom,vircon,elrc,virlrc,virtot,volm)
+            
+          else
+
+            call nptqvv_b2
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,engke,engrot,press,taut,taup,sigma,
+     x        tolnce,tstep,vircom,vircon,elrc,virlrc,virtot,volm)
+
+          endif
+
+        elseif(keyens.eq.5) then
+          
+          if(.not.lcnb) then 
+
+            call nptqvv_h1
+     x        (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x        ntcons,ntpatm,ntfree,ntshl,keyshl,tstep,taut,taup,sigma,
+     x        temp,chip,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x        vircon,virtot,virlrc,vircom,volm,press,chit_shl,
+     x        sigma_shl)
+
+          else
+      
+            call nptqvv_h2
+     x        (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x        ntcons,ntpatm,ntfree,ntshl,keyshl,tstep,taut,taup,sigma,
+     x        temp,chip,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x        vircom,vircon,virtot,virlrc,volm,press,chit_shl,
+     x        sigma_shl)
+      
+          endif
+          
+        elseif(keyens.eq.6) then
+
+          if(.not.lcnb) then
+
+            call nstqvv_b1
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,mode,engke,engrot,press,taut,taup,
+     x        sigma,tolnce,tstep,vircom,vircon,elrc,virlrc,volm)
+
+          else
+
+            call nstqvv_b2
+     x        (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x        ntcons,ntfree,ntpatm,mode,engke,engrot,press,taut,taup,
+     x        sigma,tolnce,tstep,vircom,vircon,elrc,virlrc,volm)
+
+          endif
+
+        elseif(keyens.eq.7) then
+
+          if(.not.lcnb) then
+
+            call nstqvv_h1
+     x        (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x        ntcons,ntpatm,ntfree,mode,ntshl,keyshl,tstep,taut,taup,
+     x        sigma,temp,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x        vircon,virlrc,vircom,volm,press,chit_shl,sigma_shl)
+
+          else
+
+            call nstqvv_h2
+     x        (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x        ntcons,ntpatm,ntfree,mode,ntshl,keyshl,tstep,taut,taup,
+     x        sigma,temp,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x        vircom,vircon,virlrc,volm,press,chit_shl,sigma_shl)
+            
+          endif
+
+        else
+
+c     invalid option
+
+          call error(idnode,430)
+
+        endif
+
+      endif
+
+c     check on convergence of pmf-shake
+
+      if(ntpmf.gt.0) then
+
+        if(mxnode.gt.1) call gstate(safep)
+        if(.not.safep) call error(idnode,438)
+
+      endif    
+
+c     check on convergence of shake
+
+      if(ntcons.gt.0) then
+
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) call error(idnode,105)
+
+      endif    
+
+c     eliminate "flying ice cube" in long simulations (Berendsen)
+      
+      if(lnfic.and.(keyens.eq.2.or.keyens.eq.4.or.keyens.eq.6))then
+        
+        if(mod(nstep,nofic).eq.0)then
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine vv_integrate
+
+      end module integrator_module
diff -urN dl_class_1.9.orig/srcmod/inversion_module.f dl_class_1.9/srcmod/inversion_module.f
--- dl_class_1.9.orig/srcmod/inversion_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/inversion_module.f	2011-08-16 14:42:52.000000000 +0200
@@ -0,0 +1,828 @@
+      module inversion_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining inversion potential arrays
+c     copyright - daresbury laboratory
+c     
+c     author  - w. smith  sep 2003
+c     adapted - w. smith  jun 2008 : solvation, free energy, excitation
+c     adapted - w. smith  jan 2011 : metadynamics
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use metafreeze_module
+      use parse_module
+      use property_module
+      use setup_module
+      use site_module
+      use solvation_module
+
+      implicit none
+
+      real(8), allocatable :: prminv(:,:)
+      integer, allocatable :: listinv(:,:)
+      integer, allocatable :: numinv(:),keyinv(:),lstinv(:,:)
+
+      save prminv,listinv,numinv,keyinv,lstinv
+
+      contains
+
+      subroutine alloc_inv_arrays(idnode)
+
+      implicit none
+
+      integer i,fail,idnode
+      dimension fail(5)
+
+      do i=1,5
+        fail(i)=0
+      enddo
+
+      allocate (prminv(mxtinv,mxpinv),stat=fail(1))
+      allocate (numinv(mxtmls),stat=fail(2))
+      allocate (keyinv(mxtinv),stat=fail(3))
+      allocate (lstinv(mxtinv,4),stat=fail(4))
+      allocate (listinv(mxinv,5),stat=fail(5))
+
+      do i=1,5
+        if(fail(i).gt.0)call error(idnode,1120)
+      enddo
+
+      do i=1,mxtmls
+         numinv(i)=0
+      enddo
+
+      end subroutine alloc_inv_arrays
+
+      subroutine define_inversions
+     x  (safe,idnode,itmols,ninver,nsite,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining inversion angle potentials
+c     note: includes calcite planar potential which is not strictly
+c     an inversion potential and is different in implementation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe
+      character*8 keyword
+      character*1 message(80)
+      integer idnode,itmols,ninver,nsite,ntmp,inv,inv1,i
+      integer iatm1,iatm2,iatm3,iatm4,isite1,isite2,isite3,isite4
+      integer ia,ja,idum
+      real(8) engunit
+
+      ntmp=intstr(record,lenrec,idum)
+      numinv(itmols)=numinv(itmols)+ntmp
+      if(idnode.eq.0)then
+        write(nrite,"(/,1x,'number of inversion terms',
+     x    6x,i10)")ntmp
+        write(nrite,"(/,/,1x,'inversion potential details:',
+     x    /,/,21x,7x,'key',5x,'index',5x,'index',5x,
+     x    'index',5x,'index',5x,'f-const',7x,'angle',/)")
+      endif
+      
+      inv1=numinv(itmols)
+      do inv=1,inv1
+
+c     read inversion potential parameters
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        call copystring(record,message,80)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+        iatm1=intstr(record,lenrec,idum)
+        iatm2=intstr(record,lenrec,idum)
+        iatm3=intstr(record,lenrec,idum)
+        iatm4=intstr(record,lenrec,idum)
+
+c     test for frozen atom pairs
+
+        isite1=nsite-numsit(itmols)+iatm1
+        isite2=nsite-numsit(itmols)+iatm2
+        isite3=nsite-numsit(itmols)+iatm3
+        isite4=nsite-numsit(itmols)+iatm4
+
+        if(lfzsit(isite1)*lfzsit(isite2)*
+     x    lfzsit(isite3)*lfzsit(isite4).ne.0)then
+          
+          numinv(itmols)=numinv(itmols)-1
+          if(idnode.eq.0)write(nrite,'(14x,a16,40a1)')
+     x      '*** frozen *** ',(message(i),i=1,40)
+
+        else
+
+          ninver=ninver+1
+          
+          if(ninver.gt.mxtinv)call error(idnode,73)
+
+          if(keyword(1:4).eq.'harm')then
+            keyinv(ninver)=1
+          elseif(keyword(1:4).eq.'hcos')then
+            keyinv(ninver)=2
+          elseif(keyword(1:4).eq.'plan')then
+            keyinv(ninver)=3
+          elseif(keyword(1:4).eq.'calc')then
+            keyinv(ninver)=4
+          else
+            if(idnode.eq.0)write(nrite,*)record
+            call error(idnode,449)
+          endif
+
+          lstinv(ninver,1)=iatm1
+          lstinv(ninver,2)=iatm2
+          lstinv(ninver,3)=iatm3
+          lstinv(ninver,4)=iatm4
+          prminv(ninver,1)=dblstr(record,lenrec,idum)
+          prminv(ninver,2)=dblstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(27x,a4,4i10,1p,e12.4,0p,9f12.6)")
+     x      keyword(1:4),(lstinv(ninver,ia),ia=1,4),
+     x      (prminv(ninver,ja),ja=1,mxpinv)
+
+c     convert energies to internal units and angles to radians
+          
+          prminv(ninver,1)=prminv(ninver,1)*engunit
+
+          if(keyinv(ninver).eq.2)then
+
+            prminv(ninver,2)=cos(prminv(ninver,2)*(pi/180.d0))
+
+          elseif(keyinv(ninver).eq.4)then
+            
+            prminv(ninver,2)=prminv(ninver,2)*engunit
+            
+          endif
+          
+        endif
+
+      enddo
+      
+      return
+      end subroutine define_inversions
+
+      subroutine invfrc
+     x  (lsolva,lfree,lexcite,idnode,imcon,mxnode,ntinv,enginv,virinv)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating inversion energy and force 
+c     terms in molecular dynamics.
+c     
+c     copyright - daresbury laboratory 1996
+c     author    - w. smith       may   1996
+c     modified  - w.smith        jan   2011 : metadynamics
+c     
+c***********************************************************************
+            
+      implicit none
+
+      logical safe,lsolva,lfree,lexcite,lselect,lcalcite
+      logical idrive,jdrive,kdrive,ldrive
+      integer idnode,imcon,mxnode,ntinv,fail1,fail2
+      integer fail3,inv1,inv2,i,ii,ia,id,kk,ib,ic
+      real(8) strs(6),strs_loc(6)
+      real(8) xab,yab,zab,rab2,rrab,xac,yac,zac,rac2,rrac,xad,yad
+      real(8) zad,rad2,rrad,rbc,rcd,rdb,ubx,uby,ubz,ubn,rub,vbx
+      real(8) vby,vbz,rvb,wwb,ucx,ucy,ucz,ucn,vcx,vcy,vcz,rvc,wwc
+      real(8) udx,udy,udz,udn,vdx,vdy,vdz,vdn,rvd,wwd,cosb,cosc
+      real(8) cosd,thb,thc,thd,gamb,gamc,gamd,rubc,rubd,rucd,rucb
+      real(8) rudb,rudc,rvbc,rvbd,rvcd,rvcb,rvdb,rvdc,fax,fay,faz
+      real(8) fbx,fby,fbz,fcx,fcy,fcz,fdx,fdy,fdz,vbn,vcn,ruc,rud
+      real(8) uuu,uu2,uun,uux,uuy,uuz,enginv,virinv,omega,gamma
+      real(8) gamvir
+
+      real(8), allocatable :: xdab(:),ydab(:),zdab(:)
+      real(8), allocatable :: xdac(:),ydac(:),zdac(:)
+      real(8), allocatable :: xdad(:),ydad(:),zdad(:)
+      
+      data fail1,fail2,fail3/0,0,0/
+
+      allocate (xdab(msbad),ydab(msbad),zdab(msbad),stat=fail1)
+      allocate (xdac(msbad),ydac(msbad),zdac(msbad),stat=fail2)
+      allocate (xdad(msbad),ydad(msbad),zdad(msbad),stat=fail3)
+      if(fail1.ne.0.or.fail2.ne.0.or.fail3.ne.0)
+     x     call error(idnode,1130)
+
+c     check size of work arrays
+      
+      if((ntinv-mxnode+1)/mxnode.gt.msbad)call error(idnode,427)
+
+c     block indices
+      
+      inv1=(idnode*ntinv)/mxnode+1
+      inv2=((idnode+1)*ntinv)/mxnode
+      
+      safe=.true.
+      
+c     initialise accumulators
+      
+      enginv=0.d0
+      virinv=0.d0
+      inv_fre=0.d0
+      inv_vir=0.d0
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+      if(lsolva)then
+        
+        lcomp(4)=.true.
+        inv_sol(:)=0.d0
+        if(lexcite)inv_exc(:)=0.d0
+        
+      endif
+      
+c     calculate bond vectors
+      
+      ii=0
+      do i=inv1,inv2
+        
+        ii=ii+1
+        
+c     potential energy function type
+        
+        kk=listinv(ii,1)
+        
+c     indices of bonded atoms
+        
+        ia=listinv(ii,2)
+        ib=listinv(ii,3)
+        ic=listinv(ii,4)
+        id=listinv(ii,5)
+        
+c     define components of bond vectors
+        
+        xdab(ii)=xxx(ib)-xxx(ia)
+        ydab(ii)=yyy(ib)-yyy(ia)
+        zdab(ii)=zzz(ib)-zzz(ia)
+        
+        if(keyinv(kk).eq.4)then
+
+          xdac(ii)=xxx(ic)-xxx(ib)
+          ydac(ii)=yyy(ic)-yyy(ib)
+          zdac(ii)=zzz(ic)-zzz(ib)
+          
+          xdad(ii)=xxx(id)-xxx(ib)
+          ydad(ii)=yyy(id)-yyy(ib)
+          zdad(ii)=zzz(id)-zzz(ib)
+          
+        else
+          
+          xdac(ii)=xxx(ic)-xxx(ia)
+          ydac(ii)=yyy(ic)-yyy(ia)
+          zdac(ii)=zzz(ic)-zzz(ia)
+          
+          xdad(ii)=xxx(id)-xxx(ia)
+          ydad(ii)=yyy(id)-yyy(ia)
+          zdad(ii)=zzz(id)-zzz(ia)
+          
+        endif   
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,0,1,ii,cell,xdab,ydab,zdab)
+      call images(imcon,0,1,ii,cell,xdac,ydac,zdac)
+      call images(imcon,0,1,ii,cell,xdad,ydad,zdad)
+      
+c     loop over all specified inversions
+      
+      ii=0
+      do i=inv1,inv2
+        
+        ii=ii+1
+        
+c     select potential energy function type
+        
+        kk=listinv(ii,1)
+        lcalcite=(keyinv(kk).eq.4)
+        
+c     define components of bond vectors
+        
+        xab=xdab(ii)
+        yab=ydab(ii)
+        zab=zdab(ii)
+        rab2=xab*xab+yab*yab+zab*zab
+        rrab=1.d0/sqrt(rab2)
+        
+        xac=xdac(ii)
+        yac=ydac(ii)
+        zac=zdac(ii)
+        rac2=xac*xac+yac*yac+zac*zac
+        rrac=1.d0/sqrt(rac2)
+        
+        xad=xdad(ii)
+        yad=ydad(ii)
+        zad=zdad(ii)
+        rad2=xad*xad+yad*yad+zad*zad
+        rrad=1.d0/sqrt(rad2)
+        
+        if(lcalcite)then
+          
+c     calculate vector normal to plane
+        
+          uux=yac*zad-zac*yad
+          uuy=zac*xad-xac*zad
+          uuz=xac*yad-yac*xad
+          uun=1.d0/sqrt(uux**2+uuy**2+uuz**2)
+          uux=uun*uux
+          uuy=uun*uuy
+          uuz=uun*uuz
+          uuu=xab*uux+yab*uuy+zab*uuz
+          
+        else
+          
+c     scalar products of bond vectors
+        
+          rbc=xab*xac+yab*yac+zab*zac
+          rcd=xac*xad+yac*yad+zac*zad
+          rdb=xad*xab+yad*yab+zad*zab
+        
+c     calculate bond-angle-plane vectors
+        
+          ubx=xac*rrac+xad*rrad
+          uby=yac*rrac+yad*rrad
+          ubz=zac*rrac+zad*rrad
+          ubn=1.d0/sqrt(ubx**2+uby**2+ubz**2)
+          ubx=ubn*ubx
+          uby=ubn*uby
+          ubz=ubn*ubz
+          rub=xab*ubx+yab*uby+zab*ubz
+          
+          vbx=xac*rrac-xad*rrad
+          vby=yac*rrac-yad*rrad
+          vbz=zac*rrac-zad*rrad
+          vbn=1.d0/sqrt(vbx**2+vby**2+vbz**2)
+          vbx=vbn*vbx
+          vby=vbn*vby
+          vbz=vbn*vbz
+          rvb=xab*vbx+yab*vby+zab*vbz
+          wwb=sqrt(rub**2+rvb**2)
+          
+          ucx=xad*rrad+xab*rrab
+          ucy=yad*rrad+yab*rrab
+          ucz=zad*rrad+zab*rrab
+          ucn=1.d0/sqrt(ucx**2+ucy**2+ucz**2)
+          ucx=ucn*ucx
+          ucy=ucn*ucy
+          ucz=ucn*ucz
+          ruc=xac*ucx+yac*ucy+zac*ucz
+          
+          vcx=xad*rrad-xab*rrab
+          vcy=yad*rrad-yab*rrab
+          vcz=zad*rrad-zab*rrab
+          vcn=1.d0/sqrt(vcx**2+vcy**2+vcz**2)
+          vcx=vcn*vcx
+          vcy=vcn*vcy
+          vcz=vcn*vcz
+          rvc=xac*vcx+yac*vcy+zac*vcz
+          wwc=sqrt(ruc**2+rvc**2)
+          
+          udx=xab*rrab+xac*rrac
+          udy=yab*rrab+yac*rrac
+          udz=zab*rrab+zac*rrac
+          udn=1.d0/sqrt(udx**2+udy**2+udz**2)
+          udx=udn*udx
+          udy=udn*udy
+          udz=udn*udz
+          rud=xad*udx+yad*udy+zad*udz
+          
+          vdx=xab*rrab-xac*rrac
+          vdy=yab*rrab-yac*rrac
+          vdz=zab*rrab-zac*rrac
+          vdn=1.d0/sqrt(vdx**2+vdy**2+vdz**2)
+          vdx=vdn*vdx
+          vdy=vdn*vdy
+          vdz=vdn*vdz
+          rvd=xad*vdx+yad*vdy+zad*vdz
+          wwd=sqrt(rud**2+rvd**2)
+          
+c     calculate inversion angle cosines
+          
+          cosb=wwb*rrab
+          cosc=wwc*rrac
+          cosd=wwd*rrad
+          
+        endif
+        
+c     calculate potential energy and scalar force term
+        
+        if(keyinv(kk).eq.1)then
+          
+c     key=1 for harmonic inversion potential
+          
+          thb=acos(cosb)
+          thc=acos(cosc)
+          thd=acos(cosd)
+          omega=0.5d0*prminv(kk,1)*((thb-prminv(kk,2))**2+
+     x      (thc-prminv(kk,2))**2+(thd-prminv(kk,2))**2)/3.d0
+          gamvir=0.d0
+          
+          gamb=0.d0
+          if(abs(thb).gt.1.d-12)
+     x      gamb=prminv(kk,1)*(thb-prminv(kk,2))/(3.d0*sin(thb))
+          gamc=0.d0
+          if(abs(thc).gt.1.d-12)
+     x      gamc=prminv(kk,1)*(thc-prminv(kk,2))/(3.d0*sin(thc))
+          gamd=0.d0
+          if(abs(thd).gt.1.d-12)
+     x      gamd=prminv(kk,1)*(thd-prminv(kk,2))/(3.d0*sin(thd))
+          
+        else if(keyinv(kk).eq.2)then
+          
+c     key=2 for harmonic cosine inversion potential
+          
+          omega=0.5d0*prminv(kk,1)*((cosb-prminv(kk,2))**2+
+     x      (cosc-prminv(kk,2))**2+(cosb-prminv(kk,2))**2)/3.d0
+          gamvir=0.d0
+
+          gamb=-prminv(kk,1)*(cosb-prminv(kk,2))/3.d0
+          gamc=-prminv(kk,1)*(cosc-prminv(kk,2))/3.d0
+          gamd=-prminv(kk,1)*(cosd-prminv(kk,2))/3.d0
+          
+        else if(keyinv(kk).eq.3)then
+
+c     key=3 for planar inversion potentials
+          
+          omega=prminv(kk,1)*((1.d0-cosb)+(1.d0-cosc)+(1.d0-cosd))/3.d0
+          gamvir=0.d0
+          
+          gamb=prminv(kk,1)/3.d0
+          gamc=prminv(kk,1)/3.d0
+          gamd=prminv(kk,1)/3.d0
+
+        else if(keyinv(kk).eq.4)then
+          
+c     key=4 for planar calcite potential
+          
+          uu2=uuu*uuu
+          omega=uu2*(prminv(kk,1)+prminv(kk,2)*uu2)
+          gamvir=uu2*(2.d0*prminv(kk,1)+4.d0*prminv(kk,2)*uu2)
+          gamma=-uuu*(2.d0*prminv(kk,1)+4.d0*prminv(kk,2)*uu2)
+
+        else
+
+c     undefined potential
+          
+          safe=.false.
+          gamvir=0.d0
+          gamb=0.d0
+          gamc=0.d0
+          gamd=0.d0
+          
+        endif
+        
+c     indices of bonded atoms
+        
+        ia=listinv(ii,2)
+        ib=listinv(ii,3)
+        ic=listinv(ii,4)
+        id=listinv(ii,5)
+
+c     metadynamics local definitions
+        
+        if(lmetadyn)then
+          
+          idrive=driven(ltype(ia))
+          jdrive=driven(ltype(ib))
+          kdrive=driven(ltype(ic))
+          ldrive=driven(ltype(id))
+          
+        endif
+        
+c     set selection control
+        
+        lselect=.true.
+        
+        if(lexcite)then
+          
+c     selected excitation option
+        
+          if((atm_fre(ia).ne.1).and.(atm_fre(ib).ne.1).and.
+     x      (atm_fre(ic).ne.1).and.(atm_fre(id).ne.1))then
+            
+c     reset selection control
+            
+            lselect=(atm_fre(ia)+atm_fre(ib)+atm_fre(ic)+
+     x        atm_fre(id).eq.0)
+            
+            if(lsolva)then
+              inv_exc(atmolt(ia))=inv_exc(atmolt(ia))+omega
+            endif
+            
+          endif
+          
+        elseif(lfree)then
+          
+c     selected free energy option
+          
+          if((atm_fre(ia).eq.1).or.(atm_fre(ib).eq.1).or.
+     x      (atm_fre(ic).eq.1).or.(atm_fre(id).eq.1))then
+            
+c     set hamiltonian mixing parameter
+
+            inv_fre=inv_fre-omega
+            omega=lambda1*omega
+            gamb=lambda1*gamb
+            gamc=lambda1*gamc
+            gamd=lambda1*gamd
+            
+          elseif((atm_fre(ia).eq.2).or.(atm_fre(ib).eq.2).or.
+     x        (atm_fre(ic).eq.2).or.(atm_fre(id).eq.2))then
+            
+c     set hamiltonian mixing parameter
+
+            inv_fre=inv_fre+omega
+            omega=lambda2*omega
+            gamb=lambda2*gamb
+            gamc=lambda2*gamc
+            gamd=lambda2*gamd
+                        
+          endif
+          
+        endif
+        
+c     calculate bond and u,v scalar products
+        
+        if(.not.lcalcite)then
+          
+          rubc=xab*ucx+yab*ucy+zab*ucz
+          rubd=xab*udx+yab*udy+zab*udz
+          rucd=xac*udx+yac*udy+zac*udz
+          rucb=xac*ubx+yac*uby+zac*ubz
+          rudb=xad*ubx+yad*uby+zad*ubz
+          rudc=xad*ucx+yad*ucy+zad*ucz
+          
+          rvbc=xab*vcx+yab*vcy+zab*vcz
+          rvbd=xab*vdx+yab*vdy+zab*vdz
+          rvcd=xac*vdx+yac*vdy+zac*vdz
+          rvcb=xac*vbx+yac*vby+zac*vbz
+          rvdb=xad*vbx+yad*vby+zad*vbz
+          rvdc=xad*vcx+yad*vcy+zad*vcz
+          
+        endif
+        
+        if(lselect)then
+          
+c     calculate potential energy and virial
+          
+          enginv=enginv+omega
+          virinv=virinv+gamvir
+          
+c     calculate solvation energy
+          
+          if(lsolva)then
+            inv_sol(atmolt(ia))=inv_sol(atmolt(ia))+omega
+          endif
+          
+c     calculate atomic forces
+          
+          if(lcalcite)then
+            
+            fax=-gamma*uux
+            fay=-gamma*uuy
+            faz=-gamma*uuz
+            
+            fcx=gamma*uun*((yad*zab-zad*yab)-uuu*(yad*uuz-zad*uuy))
+            fcy=gamma*uun*((zad*xab-xad*zab)-uuu*(zad*uux-xad*uuz))
+            fcz=gamma*uun*((xad*yab-yad*xab)-uuu*(xad*uuy-yad*uux))
+            
+            fdx=gamma*uun*((yab*zac-zab*yac)-uuu*(zac*uuy-yac*uuz))
+            fdy=gamma*uun*((zab*xac-xab*zac)-uuu*(xac*uuz-zac*uux))
+            fdz=gamma*uun*((xab*yac-yab*xac)-uuu*(yac*uux-xac*uuy))
+            
+            fbx=-(fax+fcx+fdx)
+            fby=-(fay+fcy+fdy)
+            fbz=-(faz+fcz+fdz)
+            
+c     stress tensor calculation for calcite terms
+            
+            strs(1)=strs(1)+uuu*gamma*uux*uux
+            strs(2)=strs(2)+uuu*gamma*uux*uuy
+            strs(3)=strs(3)+uuu*gamma*uux*uuz
+            strs(4)=strs(4)+uuu*gamma*uuy*uuy
+            strs(5)=strs(5)+uuu*gamma*uuy*uuz
+            strs(6)=strs(6)+uuu*gamma*uuz*uuz
+          
+          else
+            
+            fbx=gamb*(-cosb*xab*rrab**2+rrab*(rub*ubx+rvb*vbx)/wwb)
+     x      +(ruc*ucn*rrab*(xac-ruc*ucx-(rbc-ruc*rubc)*xab*rrab**2)
+     x      -rvc*vcn*rrab*(xac-rvc*vcx-(rbc-rvc*rvbc)*xab*rrab**2))
+     x      *gamc*rrac/wwc
+     x      +(rud*udn*rrab*(xad-rud*udx-(rdb-rud*rubd)*xab*rrab**2)
+     x      +rvd*vdn*rrab*(xad-rvd*vdx-(rdb-rvd*rvbd)*xab*rrab**2))
+     x      *gamd*rrad/wwd
+          
+            fby=gamb*(-cosb*yab*rrab**2+rrab*(rub*uby+rvb*vby)/wwb)
+     x      +(ruc*ucn*rrab*(yac-ruc*ucy-(rbc-ruc*rubc)*yab*rrab**2)
+     x      -rvc*vcn*rrab*(yac-rvc*vcy-(rbc-rvc*rvbc)*yab*rrab**2))
+     x      *gamc*rrac/wwc
+     x      +(rud*udn*rrab*(yad-rud*udy-(rdb-rud*rubd)*yab*rrab**2)
+     x      +rvd*vdn*rrab*(yad-rvd*vdy-(rdb-rvd*rvbd)*yab*rrab**2))
+     x      *gamd*rrad/wwd
+          
+            fbz=gamb*(-cosb*zab*rrab**2+rrab*(rub*ubz+rvb*vbz)/wwb)
+     x      +(ruc*ucn*rrab*(zac-ruc*ucz-(rbc-ruc*rubc)*zab*rrab**2)
+     x      -rvc*vcn*rrab*(zac-rvc*vcz-(rbc-rvc*rvbc)*zab*rrab**2))
+     x      *gamc*rrac/wwc
+     x      +(rud*udn*rrab*(zad-rud*udz-(rdb-rud*rubd)*zab*rrab**2)
+     x      +rvd*vdn*rrab*(zad-rvd*vdz-(rdb-rvd*rvbd)*zab*rrab**2))
+     x      *gamd*rrad/wwd
+          
+            fcx=gamc*(-cosc*xac*rrac**2+rrac*(ruc*ucx+rvc*vcx)/wwc)
+     x      +(rud*udn*rrac*(xad-rud*udx-(rcd-rud*rucd)*xac*rrac**2)
+     x      -rvd*vdn*rrac*(xad-rvd*vdx-(rcd-rvd*rvcd)*xac*rrac**2))
+     x      *gamd*rrad/wwd
+     x      +(rub*ubn*rrac*(xab-rub*ubx-(rbc-rub*rucb)*xac*rrac**2)
+     x      +rvb*vbn*rrac*(xab-rvb*vbx-(rbc-rvb*rvcb)*xac*rrac**2))
+     x      *gamb*rrab/wwb
+          
+            fcy=gamc*(-cosc*yac*rrac**2+rrac*(ruc*ucy+rvc*vcy)/wwc)
+     x      +(rud*udn*rrac*(yad-rud*udy-(rcd-rud*rucd)*yac*rrac**2)
+     x      -rvd*vdn*rrac*(yad-rvd*vdy-(rcd-rvd*rvcd)*yac*rrac**2))
+     x      *gamd*rrad/wwd
+     x      +(rub*ubn*rrac*(yab-rub*uby-(rbc-rub*rucb)*yac*rrac**2)
+     x      +rvb*vbn*rrac*(yab-rvb*vby-(rbc-rvb*rvcb)*yac*rrac**2))
+     x      *gamb*rrab/wwb
+          
+            fcz=gamc*(-cosc*zac*rrac**2+rrac*(ruc*ucz+rvc*vcz)/wwc)
+     x      +(rud*udn*rrac*(zad-rud*udz-(rcd-rud*rucd)*zac*rrac**2)
+     x      -rvd*vdn*rrac*(zad-rvd*vdz-(rcd-rvd*rvcd)*zac*rrac**2))
+     x      *gamd*rrad/wwd
+     x      +(rub*ubn*rrac*(zab-rub*ubz-(rbc-rub*rucb)*zac*rrac**2)
+     x      +rvb*vbn*rrac*(zab-rvb*vbz-(rbc-rvb*rvcb)*zac*rrac**2))
+     x      *gamb*rrab/wwb
+          
+            fdx=gamd*(-cosd*xad*rrad**2+rrad*(rud*udx+rvd*vdx)/wwd)
+     x      +(rub*ubn*rrad*(xab-rub*ubx-(rdb-rub*rudb)*xad*rrad**2)
+     x      -rvb*vbn*rrad*(xab-rvb*vbx-(rdb-rvb*rvdb)*xad*rrad**2))
+     x      *gamb*rrab/wwb
+     x      +(ruc*ucn*rrad*(xac-ruc*ucx-(rcd-ruc*rudc)*xad*rrad**2)
+     x      +rvc*vcn*rrad*(xac-rvc*vcx-(rcd-rvc*rvdc)*xad*rrad**2))
+     x      *gamc*rrac/wwc
+          
+            fdy=gamd*(-cosd*yad*rrad**2+rrad*(rud*udy+rvd*vdy)/wwd)
+     x      +(rub*ubn*rrad*(yab-rub*uby-(rdb-rub*rudb)*yad*rrad**2)
+     x      -rvb*vbn*rrad*(yab-rvb*vby-(rdb-rvb*rvdb)*yad*rrad**2))
+     x      *gamb*rrab/wwb
+     x      +(ruc*ucn*rrad*(yac-ruc*ucy-(rcd-ruc*rudc)*yad*rrad**2)
+     x      +rvc*vcn*rrad*(yac-rvc*vcy-(rcd-rvc*rvdc)*yad*rrad**2))
+     x      *gamc*rrac/wwc
+          
+            fdz=gamd*(-cosd*zad*rrad**2+rrad*(rud*udz+rvd*vdz)/wwd)
+     x      +(rub*ubn*rrad*(zab-rub*ubz-(rdb-rub*rudb)*zad*rrad**2)
+     x      -rvb*vbn*rrad*(zab-rvb*vbz-(rdb-rvb*rvdb)*zad*rrad**2))
+     x      *gamb*rrab/wwb
+     x      +(ruc*ucn*rrad*(zac-ruc*ucz-(rcd-ruc*rudc)*zad*rrad**2)
+     x      +rvc*vcn*rrad*(zac-rvc*vcz-(rcd-rvc*rvdc)*zad*rrad**2))
+     x      *gamc*rrac/wwc
+          
+            fax=-(fbx+fcx+fdx)
+            fay=-(fby+fcy+fdy)
+            faz=-(fbz+fcz+fdz)
+            
+c     stress tensor calculation for inversion terms
+            
+            strs(1)=strs(1)+xab*fbx+xac*fcx+xad*fdx 
+            strs(2)=strs(2)+yab*fbx+yac*fcx+yad*fdx 
+            strs(3)=strs(3)+zab*fbx+zac*fcx+zad*fdx 
+            strs(4)=strs(4)+yab*fby+yac*fcy+yad*fdy 
+            strs(5)=strs(5)+yab*fbz+yac*fcz+yad*fdz 
+            strs(6)=strs(6)+zab*fbz+zac*fcz+zad*fdz 
+          
+          endif
+          
+          fxx(ia)=fxx(ia)+fax
+          fyy(ia)=fyy(ia)+fay
+          fzz(ia)=fzz(ia)+faz
+          
+          fxx(ib)=fxx(ib)+fbx
+          fyy(ib)=fyy(ib)+fby
+          fzz(ib)=fzz(ib)+fbz
+        
+          fxx(ic)=fxx(ic)+fcx
+          fyy(ic)=fyy(ic)+fcy
+          fzz(ic)=fzz(ic)+fcz
+          
+          fxx(id)=fxx(id)+fdx
+          fyy(id)=fyy(id)+fdy
+          fzz(id)=fzz(id)+fdz
+          
+        endif
+        
+c     metadynamics local parameters
+        
+        if(lmetadyn.and.(idrive.or.jdrive.or.kdrive.or.ldrive))then
+          
+c     local energy and virial
+          
+          eng_loc=eng_loc+omega
+          vir_loc=vir_loc+gamvir
+          
+c     local forces
+          
+          fxx_loc(ia)=fxx_loc(ia)+fax
+          fyy_loc(ia)=fyy_loc(ia)+fay
+          fzz_loc(ia)=fzz_loc(ia)+faz
+          
+          fxx_loc(ib)=fxx_loc(ib)+fbx
+          fyy_loc(ib)=fyy_loc(ib)+fby
+          fzz_loc(ib)=fzz_loc(ib)+fbz
+          
+          fxx_loc(ic)=fxx_loc(ic)+fcx
+          fyy_loc(ic)=fyy_loc(ic)+fcy
+          fzz_loc(ic)=fzz_loc(ic)+fcz
+          
+          fxx_loc(id)=fxx_loc(id)+fdx
+          fyy_loc(id)=fyy_loc(id)+fdy
+          fzz_loc(id)=fzz_loc(id)+fdz
+          
+c     local stress tensor
+          
+          strs_loc(1)=strs_loc(1)+xab*fbx+xac*fcx+xad*fdx 
+          strs_loc(2)=strs_loc(2)+yab*fbx+yac*fcx+yad*fdx 
+          strs_loc(3)=strs_loc(3)+zab*fbx+zac*fcx+zad*fdx 
+          strs_loc(4)=strs_loc(4)+yab*fby+yac*fcy+yad*fdy 
+          strs_loc(5)=strs_loc(5)+yab*fbz+yac*fcz+yad*fdz 
+          strs_loc(6)=strs_loc(6)+zab*fbz+zac*fcz+zad*fdz 
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+c     check for undefined potentials
+      
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)call error(idnode,449)
+      
+c     sum contributions over all nodes
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=enginv
+        buffer(2)=virinv
+        buffer(3)=inv_fre
+        buffer(4)=inv_vir
+        call gdsum(buffer(1),4,buffer(5))
+        enginv=buffer(1)
+        virinv=buffer(2)
+        inv_fre=buffer(3)
+        inv_vir=buffer(4)
+        
+        if(lsolva)then
+          
+          call gdsum(inv_sol(1),mxtmls,buffer(1))
+          if(lexcite)call gdsum(inv_exc(1),mxtmls,buffer(1))
+          
+        endif
+
+      endif
+      
+      deallocate (xdab,ydab,zdab,stat=fail1)
+      deallocate (xdac,ydac,zdac,stat=fail2)
+      deallocate (xdad,ydad,zdad,stat=fail3)
+      
+      return
+      end subroutine invfrc
+      
+      end module inversion_module
diff -urN dl_class_1.9.orig/srcmod/lf_motion_module.f dl_class_1.9/srcmod/lf_motion_module.f
--- dl_class_1.9.orig/srcmod/lf_motion_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/lf_motion_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,2994 @@
+      module lf_motion_module
+
+c***********************************************************************
+c     
+c     dl_poly module for verlet leap frog integration schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use error_module
+      use property_module
+      use setup_module
+      use shake_module
+      use site_module
+      use utility_module
+      
+      contains
+
+      subroutine rdshake_1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x  tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x  txx,tyy,tzz,xxt,yyt,zzt,stresh)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for applying bond constraint corrections after
+c     atomic integration.
+c     Must be used in conjunction with integration algorithms
+c     
+c     assume bond vectors dxx,dyy,dzz are input
+c     dxx =xxx(i) - xxx(j) etc
+c
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith august 1992.
+c     amended   - t. forester march 1994.
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lshmov
+      integer idnode,imcon,mxnode,natms,nscons,icyc,i,j,k
+      real(8) tolnce,tstep,vircon,stresh,dxx,dyy,dzz,strs1,strs2
+      real(8) strs3,strs5,strs6,strs9,tstep2,esig,esig1
+      real(8) dis,amti,amtj,omega2,gamma,gammi,gammj,dli,dlj
+      real(8) dxt,dyt,dzt,txx,tyy,tzz,xxt,yyt,zzt
+
+      dimension stresh(9)
+      dimension dxx(mxcons),dyy(mxcons),dzz(mxcons)
+      dimension dxt(mxcons),dyt(mxcons),dzt(mxcons)
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      
+c     test size of work arrays
+
+      safe=.true.
+      if(mxxdf.lt.nscons)safe=.false.
+
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe) call error(idnode,412)
+
+c     timestep squared
+
+      tstep2=tstep*tstep
+
+c     accumulators for stress tensor
+
+      vircon=0.d0
+      strs1=0.d0
+      strs2=0.d0
+      strs3=0.d0
+      strs5=0.d0
+      strs6=0.d0
+      strs9=0.d0
+
+c     application of constraint (shake) algorithm
+      
+      icyc=0
+      safe=.false.
+
+      do while(.not.safe.and.icyc.lt.mxshak)
+        
+        icyc=icyc+1
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate temporary bond vector
+          
+          dxt(k)=xxx(i)-xxx(j)
+          dyt(k)=yyy(i)-yyy(j)
+          dzt(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition
+        
+        call images(imcon,0,1,nscons,cell,dxt,dyt,dzt)
+        
+c     calculate maximum error in bondlength
+        
+        esig=0.d0
+        
+        do k=1,nscons
+          
+c     set bond parameter
+          
+          dis=prmcon(listcon(k,1))
+          esig1=abs(dxt(k)**2+dyt(k)**2+dzt(k)**2-dis**2)/dis
+          esig=max(esig,esig1)
+          
+        enddo
+        
+        esig=esig*0.5d0
+
+c     global verification of convergence
+        
+        safe=(esig.lt.tolnce)
+        
+        if(mxnode.gt.1)call gstate(safe)
+
+c     bypass calculations if all tolerances satisfied 
+        
+        if(.not.safe)then
+          
+c     initialise increment arrays
+          
+          do i=1,natms
+            
+            xxt(i)=0.d0
+            yyt(i)=0.d0
+            zzt(i)=0.d0
+            
+          enddo
+          
+c     calculate constraint forces
+          
+          do k=1,nscons
+            
+            i=listcon(k,2)
+            j=listcon(k,3)
+            
+c     set constraint parameters
+            
+            dis=prmcon(listcon(k,1))
+            omega2=dis*dis
+            amti= tstep2/weight(i)
+            amtj=-tstep2/weight(j)
+            
+            if(lstfrz(i).ne.0) amti=0.d0
+            if(lstfrz(j).ne.0) amtj=0.d0
+            
+c     constraint force parameter
+            
+            gamma=(omega2-(dxt(k)**2+dyt(k)**2+dzt(k)**2))/
+     x        (-2.d0*(amti-amtj)*
+     x        (dxx(k)*dxt(k)+dyy(k)*dyt(k)+dzz(k)*dzt(k)))
+            
+c     accumulate bond virial
+            
+            vircon=vircon+gamma*(dxx(k)**2+dyy(k)**2+dzz(k)**2)
+            
+            strs1=strs1-gamma*dxx(k)*dxx(k)
+            strs2=strs2-gamma*dxx(k)*dyy(k)
+            strs3=strs3-gamma*dxx(k)*dzz(k)
+            strs5=strs5-gamma*dyy(k)*dyy(k)
+            strs6=strs6-gamma*dyy(k)*dzz(k)
+            strs9=strs9-gamma*dzz(k)*dzz(k)
+            
+c     improve approximate atomic positions
+            
+            gammi=-gamma*amti
+            xxt(i)=xxt(i)+dxx(k)*gammi
+            yyt(i)=yyt(i)+dyy(k)*gammi
+            zzt(i)=zzt(i)+dzz(k)*gammi
+            
+            gammj=-gamma*amtj
+            xxt(j)=xxt(j)+dxx(k)*gammj
+            yyt(j)=yyt(j)+dyy(k)*gammj
+            zzt(j)=zzt(j)+dzz(k)*gammj
+            
+          enddo
+          
+c     transport temporary positions to other nodes
+          
+          if(mxnode.gt.1)then
+            
+            if(lshmov) call shmove
+     x        (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x        txx,tyy,tzz,buffer)
+            
+          endif
+          
+          do k=1,nscons
+            
+            i=listcon(k,2)
+            j=listcon(k,3)
+            
+            dli=1.d0/dble(listme(i))
+            dlj=1.d0/dble(listme(j))
+            
+            xxx(i)=xxx(i)+xxt(i)*dli
+            yyy(i)=yyy(i)+yyt(i)*dli
+            zzz(i)=zzz(i)+zzt(i)*dli
+            xxx(j)=xxx(j)+xxt(j)*dlj
+            yyy(j)=yyy(j)+yyt(j)*dlj
+            zzz(j)=zzz(j)+zzt(j)*dlj
+            
+          enddo
+          
+        endif
+
+      enddo
+        
+c     error exit for non-convergence
+
+      if(.not.safe)return
+
+c     complete stress tensor
+        
+      stresh(1)=strs1
+      stresh(2)=strs2
+      stresh(3)=strs3
+      stresh(4)=strs2
+      stresh(5)=strs5
+      stresh(6)=strs6
+      stresh(7)=strs3
+      stresh(8)=strs6
+      stresh(9)=strs9
+
+c     splice coordinate arrays across nodes
+
+      if(mxnode.gt.1)then
+
+        buffer(1)=vircon
+        call gdsum(buffer(1),1,buffer(2))
+        vircon=buffer(1)
+        call gdsum(stresh,9,buffer)
+        call splice 
+     x    (idnode,natms,listme,listot,xxx,yyy,zzz,buffer)
+
+      endif
+
+      return
+      end subroutine rdshake_1
+
+      subroutine nve_1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x  engke,tolnce,tstep,vircon)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics. Verlet leapfrog With RD-SHAKE
+c     
+c     parallel replicated data version : block data
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith august 1992.
+c     amended   - t.forester sept 1994
+c     amended   - t.forester dec  1994 : block data
+c     amended   - w.smith    oct  2005
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical safe,lshmov
+      integer idnode,imcon,mxnode,natms,nscons,ntcons,fail,iatm0
+      integer iatm1,i,j,k
+      real(8) engke,tolnce,tstep,vircon,strkin,rstep
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      
+      dimension strkin(9),fail(7)
+      
+c     allocate working arrays
+
+      do i=1,7
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(7))
+      do i=1,7
+         if(fail(i).ne.0)call error(idnode,1380)
+      enddo
+
+      safe=.false.
+      
+c     block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     store initial values of position and velocity
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     move atoms by leapfrog algorithm
+      
+      j=0
+      do i=iatm0,iatm1
+
+        j=j+1
+
+c     update velocities
+        
+        uxx(i)=vxx(i)+tstep*rmass(i)*fxx(i)
+        uyy(i)=vyy(i)+tstep*rmass(i)*fyy(i)
+        uzz(i)=vzz(i)+tstep*rmass(i)*fzz(i)
+
+c     update positions
+        
+        xxx(i)=xxo(j)+tstep*uxx(i)
+        yyy(i)=yyo(j)+tstep*uyy(i)
+        zzz(i)=zzo(j)+tstep*uzz(i)
+        
+      enddo
+      
+c     start of bond constraint procedures
+
+      if(ntcons.eq.0)safe=.true.
+      if(ntcons.gt.0)then
+
+c     global exchange of configuration data
+        
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+        
+        call rdshake_1
+     x    (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x    tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x    txx,tyy,tzz,xxt,yyt,zzt,strcns)
+
+c     calculate velocity correction
+        
+        j=0
+        rstep=1.d0/tstep
+        do i=iatm0,iatm1
+          
+          j=j+1
+
+c     calculate corrected velocity
+          
+          uxx(i)=(xxx(i)-xxo(j))*rstep
+          uyy(i)=(yyy(i)-yyo(j))*rstep
+          uzz(i)=(zzz(i)-zzo(j))*rstep
+          
+c     calculate the corrected forces
+          
+          fxx(i)=(uxx(i)-vxo(j))*weight(i)*rstep
+          fyy(i)=(uyy(i)-vyo(j))*weight(i)*rstep
+          fzz(i)=(uzz(i)-vzo(j))*weight(i)*rstep
+          
+        enddo
+        
+      endif
+
+c     calculate full timestep velocity
+
+      do i=iatm0,iatm1
+
+        vxx(i)=0.5d0*(vxx(i)+uxx(i))
+        vyy(i)=0.5d0*(vyy(i)+uyy(i))
+        vzz(i)=0.5d0*(vzz(i)+uzz(i))
+
+      enddo
+      
+c     calculate kinetic energy
+      
+      engke=getkin(natms,idnode,mxnode)
+      
+c     kinetic contribution to stress tensor
+      
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+      
+c     updated velocity
+      
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine nve_1
+
+      subroutine nvt_e1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x  engke,tolnce,tstep,vircon)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Evans
+c     thermostat.
+c     Comp. Phys. reports 1, 299, (1984)
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond CONSTRAINTS.
+c     
+c     copyright - daresbury laboratory
+c     author    - t forester july 1993
+c     amended   - w.smith october 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lshmov
+      integer idnode,imcon,mxnode,natms,nscons,ntcons,fail,iatm0
+      integer iatm1,i,j,k,iter,mxiter
+      real(8) engke,tolnce,tstep,vircon,strkin
+      real(8) rstep,chit,viracc,strcon,vdotf
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strkin(9),strcon(9),fail(7)
+      
+c     allocate working arrays
+
+      do i=1,7
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(7))
+      do i=1,7
+         if(fail(i).ne.0)call error(idnode,1390)
+      enddo
+
+      safe=.false.
+
+c     block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     initialise constraint virial accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial positions and velocities
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+        
+c     begin temperature control iteration
+      
+      mxiter=3
+      if(ntcons.eq.0)mxiter=2
+      chit=0.d0
+      
+      do iter=1,mxiter
+        
+c     move atoms by leapfrog algorithm
+        
+        j=0
+        
+        do i=iatm0,iatm1
+
+          j=j+1
+          
+c     update velocities
+          
+          uxx(i)=vxo(j)+tstep*(rmass(i)*fxx(i)-chit*vxx(i))
+          uyy(i)=vyo(j)+tstep*(rmass(i)*fyy(i)-chit*vyy(i))
+          uzz(i)=vzo(j)+tstep*(rmass(i)*fzz(i)-chit*vzz(i))
+          
+c     update positions
+          
+          xxx(i)=xxo(j)+tstep*uxx(i)
+          yyy(i)=yyo(j)+tstep*uyy(i)
+          zzz(i)=zzo(j)+tstep*uzz(i)
+          
+        enddo
+        
+c     start of bond constraint procedures
+        
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0)then
+          
+c     merge configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+c     accumulate constraint virial terms
+
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          do i=iatm0,iatm1
+            
+            j=j+1
+            
+c     calculate corrected velocity
+            
+            uxx(i)=(xxx(i)-xxo(j))*rstep
+            uyy(i)=(yyy(i)-yyo(j))*rstep
+            uzz(i)=(zzz(i)-zzo(j))*rstep
+            
+c     calculate the corrected forces
+            
+            fxx(i)=(uxx(i)-vxo(j))*weight(i)*rstep
+            fyy(i)=(uyy(i)-vyo(j))*weight(i)*rstep
+            fzz(i)=(uzz(i)-vzo(j))*weight(i)*rstep
+            
+          enddo
+          
+c     end of shake corrections
+
+        endif
+
+c     estimate velocity at the full step
+
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+c     calculate kinetic energy and evans thermostat parameter
+        
+        engke=0.d0
+        vdotf=0.d0
+        do i=iatm0,iatm1
+          
+          engke=engke+weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+          vdotf=vdotf+vxx(i)*fxx(i)+vyy(i)*fyy(i)+vzz(i)*fzz(i)
+          
+        enddo
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=engke
+          buffer(2)=vdotf
+          call gdsum(buffer(1),2,buffer(3))
+          engke=buffer(1)
+          vdotf=buffer(2)
+          
+        endif
+        chit=vdotf/engke
+        engke=0.5d0*engke
+        
+c     end of thermal constraint iteration
+        
+      enddo
+      
+c     kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+
+c     updated velocity
+
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine nvt_e1
+
+      subroutine nvt_b1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x  engke,taut,sigma,tolnce,tstep,vircon)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Berendsen
+c     thermostat.
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     copyright - daresbury laboratory 1993
+c     author    -    t. forester   may 1993
+c     amended : t.forester sept 1994
+c     amended : t.forester  dec 1994 : block data
+c     amended   - w.smith   oct 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lshmov
+      integer idnode,imcon,mxnode,natms,nscons,ntcons,fail
+      integer iatm0,iatm1,i,j,k,maxit,iter
+      real(8) engke,taut,sigma,tolnce,tstep,vircon,strkin,viracc
+      real(8) rstep,rtsq,chit0,strcon
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strkin(9),fail(8),strcon(9)
+      
+c     allocate working arrays
+
+      do i=1,8
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(7))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(8))
+      do i=1,8
+         if(fail(i).ne.0)call error(idnode,1400)
+      enddo
+
+      safe=.false.
+
+c     set up block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     initialise constraint virial accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+
+      enddo
+      
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     estimate kinetic energy at full timestep
+
+      j=0
+      do i=iatm0,iatm1
+
+        j=j+1
+
+        vxx(i)=vxo(j)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+0.5d0*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+      engke=getkin(natms,idnode,mxnode)
+      
+c     begin iterations !!-----------------------------------------------
+
+      maxit=3
+      if(ntcons.eq.0) maxit=maxit-1
+      do iter=1,maxit
+
+c     temperature scaling  coefficient - taut is the decay constant
+        
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+
+c     unconstrained new positions with thermostat
+        
+        j=0
+        do i=iatm0,iatm1
+
+          j=j+1
+
+c     advance velocity using leapfrog
+
+          uxx(i)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(i)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(i)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+
+c     advance positions using leapfrog
+
+          xxx(i)=xxo(j)+tstep*uxx(i)
+          yyy(i)=yyo(j)+tstep*uyy(i)
+          zzz(i)=zzo(j)+tstep*uzz(i)
+
+c     store uncorrected positions
+
+          xx1(j)=xxx(i)
+          yy1(j)=yyy(i)
+          zz1(j)=zzz(i)
+
+        enddo
+
+c     start of bond constraint procedures
+
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0.and.iter.eq.1)then
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     accumulate constraint virial terms
+
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2 
+          do i=iatm0,iatm1
+            
+            j=j+1
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+          
+c     end of shake corrections
+
+        endif
+
+c     calculate kinetic energy
+        
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+
+c     estimate velocity at the full step
+
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+        engke=getkin(natms,idnode,mxnode)
+        
+c     end of thermostat iterations
+
+      enddo
+
+c     kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+
+c     updated velocity
+
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine nvt_b1
+
+      subroutine nvt_h1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,nscons,ntcons,
+     x  chit,consv,conint,engke,taut,sigma,tolnce,tstep,vircon)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Hoover 
+c     thermostat.
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     copyright - daresbury laboratory
+c     author    - t. forester may 1993
+c     amended   - w.smith october 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lshmov
+      integer idnode,imcon,mxnode,natms,nscons,ntcons,fail,i,j,k
+      integer iatm0,iatm1,maxit,iter
+      real(8) chit,consv,conint,engke,taut,sigma,tolnce,tstep,vircon
+      real(8) strkin,rstep,rtsq,qmass,chitp,chit0,viracc
+      real(8) chitnew,strcon
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strkin(9),fail(8),strcon(9)
+      
+c     allocate working arrays
+
+      do i=1,8
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(7))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(8))
+      do i=1,8
+         if(fail(i).ne.0)call error(idnode,1410)
+      enddo
+
+      safe=.false.
+
+c     set up block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     inertia parameter for Nose-Hoover thermostat
+      
+      qmass=2.0d0*sigma*taut**2
+
+c     initialise constraint virial accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+
+      enddo
+      
+c     construct current bond vectors
+        
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     estimate velocities at full time step
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        vxx(i)=vxo(j)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+0.5d0*tstep*rmass(i)*fzz(i)
+        
+      enddo
+      
+c     kinetic energy at full time step
+      
+      engke=getkin(natms,idnode,mxnode)
+
+c     propagate chit
+
+      chitp=2.d0*(engke-sigma)/qmass
+      chitnew=chit+tstep*chitp
+      chit0=0.5d0*(chit+chitnew)
+
+c     begin iterations !!-----------------------------------------------
+
+      maxit=4
+      if(ntcons.eq.0) maxit=maxit-1
+      
+      do iter=1,maxit
+
+c     unconstrained new positions
+        
+        j=0
+        do i=iatm0,iatm1
+
+          j=j+1
+
+c     advance velocity using leapfrog
+
+          uxx(i)=vxo(j)+tstep*(fxx(i)*rmass(i)-chit0*vxx(i))
+          uyy(i)=vyo(j)+tstep*(fyy(i)*rmass(i)-chit0*vyy(i))
+          uzz(i)=vzo(j)+tstep*(fzz(i)*rmass(i)-chit0*vzz(i))
+
+c     advance positions using leapfrog
+
+          xxx(i)=xxo(j)+tstep*uxx(i)
+          yyy(i)=yyo(j)+tstep*uyy(i)
+          zzz(i)=zzo(j)+tstep*uzz(i)
+
+c     store uncorrected positions
+
+          xx1(j)=xxx(i)
+          yy1(j)=yyy(i)
+          zz1(j)=zzz(i)
+
+        enddo
+
+c     start of bond constraint procedures
+
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0.and.iter.eq.1)then
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     accumulate constraint virial terms
+
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2 
+          do i=iatm0,iatm1
+            
+            j=j+1
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+
+c     end of shake corrections
+          
+        endif
+
+c     estimate velocity at the full step
+
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+c     calculate kinetic energy
+
+        engke=getkin(natms,idnode,mxnode)
+        
+c     improved prediction of chit 
+
+        chitp=2.d0*(engke-sigma)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=0.5d0*(chit+chitnew)
+
+c     end of thermostat iterations
+
+      enddo
+
+c     kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)
+      enddo
+
+c     update thermostat
+
+      chit=chitnew
+
+c     conserved quantity less kinetic and potential energy terms
+      
+      conint=conint+tstep*chit0*qmass/taut**2
+      consv=conint+0.5d0*qmass*chit0**2
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+
+c     updated velocity
+
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine nvt_h1
+
+      subroutine npt_b1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x  ntcons,elrc,engke,virlrc,press,taup,taut,sigma,tolnce,
+     x  tstep,virtot,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Berendsen
+c     thermostat and isotropic pressure control
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version
+c     
+c     for systems using bond CONSTRAINTS. Frozen atoms feb 1994
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - t. forester dec 1993
+c     amended   - w.smith     oct 2005
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical safe,lshmov,newjob
+      integer idnode,imcon,mxnode,natms,ntpatm,nscons,ntcons
+      integer fail,i,j,k,iatm0,iatm1,maxit,iter
+      real(8) elrc,engke,virlrc,press,taup,taut,sigma,tolnce,tstep
+      real(8) virtot,vircon,volm,strkin,beta,volm0,cell0
+      real(8) elrc0,virlrc0,rstep,rtsq,psyst,chip0,scale
+      real(8) chit0,viracc,strcon
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strkin(9),cell0(9),fail(8),strcon(9)
+
+      save newjob,volm0,elrc0,virlrc0,dens0
+
+      data newjob/.true./
+      data beta/7.3728d-3/
+      
+c     allocate working arrays
+
+      do i=1,8
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(7))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(8))
+      do i=1,8
+         if(fail(i).ne.0)call error(idnode,1420)
+      enddo
+
+      safe=.false.
+
+c     store initial values of volume and long range corrections
+
+      if(newjob)then
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1430)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        newjob=.false.
+
+      endif
+
+c     set up block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     initialise constraint virial terms
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial cell vectors
+
+      do i=1,9
+        cell0(i)=cell(i)
+      enddo
+
+c     store initial values of position and velocity
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+
+      enddo
+      
+c     construct current bond vectors
+        
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     estimate velocity at full timestep
+
+      j=0
+      do i=iatm0,iatm1
+
+        j=j+1
+        vxx(i)=vxo(j)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+0.5d0*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     kinetic energy at current timestep
+
+      engke=getkin(natms,idnode,mxnode)
+
+c     pressure control variable - taup is pressure relaxation time
+
+      psyst=(2.d0*engke-virtot-vircon)/(3.d0*volm)
+      chip0=1.d0+beta*tstep*(psyst-press)/taup
+      scale=chip0**(1.d0/3.d0)
+      
+c     temperature scaling  coefficient - taut is temperature relaxation time
+
+      chit0=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+
+c     begin iterations !!-----------------------------------------------
+
+      maxit=5
+      if(ntcons.eq.0)maxit=maxit-1
+      
+      do iter=1,maxit
+
+c     unconstrained new positions
+        
+        j=0
+        do i=iatm0,iatm1
+
+          j=j+1
+
+c     advance velocity using leapfrog
+
+          uxx(i)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(i)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(i)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+
+c     update positions
+          
+          xxx(i)=tstep*uxx(i)+scale*xxo(j)
+          yyy(i)=tstep*uyy(i)+scale*yyo(j)
+          zzz(i)=tstep*uzz(i)+scale*zzo(j)
+
+        enddo
+        
+c     start of bond constraint procedures
+
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0)then
+
+c     store integrated positions
+
+          j=0
+          do i=iatm0,iatm1
+
+            j=j+1
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+c     estimate new cell tensor
+          
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+          
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     accumulate constraint virial terms
+
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2 
+          do i=iatm0,iatm1
+            
+            j=j+1
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+
+c     end of shake corrections
+          
+        endif
+
+c     estimate velocity at the full step
+
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+c     calculate kinetic energy
+
+        engke=getkin(natms,idnode,mxnode)
+        
+c     improved prediction of chip and chit
+
+        psyst=(2.d0*engke-virtot-vircon)/(3.d0*volm)
+        chip0=1.d0+beta*tstep*(psyst-press)/taup
+        scale=chip0**(1.d0/3.d0)
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+        
+c     end of thermostat iterations
+
+      enddo
+
+c     kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)
+      enddo
+
+c     update volume
+
+      volm=volm*chip0
+
+c     scale cell vectors - isotropic
+
+      do i=1,9
+        cell(i)=cell0(i)*scale
+      enddo
+
+c     construct scaling tensor (for use with tethers)
+
+      do i=2,8
+        eta(i)=0.d0
+      enddo
+      eta(1)=scale
+      eta(5)=scale
+      eta(9)=scale
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+
+c     updated velocity
+
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine npt_b1
+
+      subroutine npt_h1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x  ntcons,chip,chit,conint,consv,elrc,engke,virlrc,press,
+     x  taup,taut,sigma,temp,tolnce,tstep,virtot,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Hoover 
+c     thermostat+piston.
+c     
+c     reference: Melchionna, Ciccotti and Holian,
+c     Mol Phys 1993, 78, p533
+c     
+c     parallel replicated data version
+c     
+c     for systems using bond constraints (using atomic pressure)
+c     
+c     copyright daresbury laboratory 1995
+c     author    -    s. melchionna   april 1995
+c     and       -    t. forester     april 1995
+c     amended   -    w. smith     october  2005
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical safe,lshmov,newjob
+      integer idnode,imcon,mxnode,natms,ntpatm,nscons,ntcons
+      integer i,j,k,iatm0,iatm1,fail,maxit,iter
+      real(8) chip,chit,conint,consv,elrc,engke,virlrc,press
+      real(8) taup,taut,sigma,temp,tolnce,tstep,virtot,vircon,volm
+      real(8) strcon,volm0,elrc0,virlrc0,rstep,rtsq,qmass
+      real(8) chipnew,chitp,chitnew,chit0,volnew,scale,viracc,vold
+      real(8) cons1,cons2,cons3,strkin,cell0
+      real(8) pmass,totmas,chipp,chip0,com,vom
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strcon(9),fail(8),strkin(9),com(3),vom(3),cell0(9)
+      
+      save newjob,volm0,elrc0,virlrc0,cell0,dens0
+
+      data newjob/.true./
+
+c     allocate working arrays
+
+      do i=1,8
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(7))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(8))
+      do i=1,8
+         if(fail(i).ne.0)call error(idnode,1440)
+      enddo
+
+      safe=.false.
+
+c     store initial values of volume, long range corrections etc
+
+      if(newjob)then
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1450)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+        newjob=.false.
+
+      endif
+
+c     set up block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     inertia parameter for Nose-Hoover thermostat
+      
+      qmass=2.0d0*sigma*taut**2
+      pmass=2.0d0*sigma*taup**2
+
+c     initialise constraint virial accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial values of position and velocity
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+
+      enddo
+
+c     total system mass
+
+      totmas=getmass(natms,idnode,mxnode)
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate centre of mass
+
+      call getcom(natms,idnode,mxnode,totmas,com)
+
+c     estimate kinetic energy at current timestep
+
+      j=0
+      do i=iatm0,iatm1
+
+        j=j+1
+
+c     estimate velocity at the full step
+
+        vxx(i)=vxo(j)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+0.5d0*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     calculate kinetic energy
+
+      engke=getkin(natms,idnode,mxnode)
+        
+c     propagate chip
+
+      chipp=(2.d0*engke-virtot-vircon-3.d0*press*volm)/pmass-
+     x  chit*chip
+      chipnew=chip+tstep*chipp
+      chip0=0.5d0*(chip+chipnew)
+
+c     propagate chit
+
+      chitp=(2.d0*(engke-sigma)+pmass*chip**2-boltz*temp)/qmass
+      chitnew=chit+tstep*chitp
+      chit0=0.5d0*(chit+chitnew)
+
+c     begin iterations !!-----------------------------------------------
+
+      maxit=5
+      if(ntcons.eq.0) maxit=maxit-1
+      
+      do iter=1,maxit
+
+c     unconstrained new positions
+        
+        j=0
+        do i=iatm0,iatm1
+
+          j=j+1
+
+c     advance velocity using leapfrog
+
+          uxx(i)=vxo(j)+tstep*(fxx(i)*rmass(i)-(chit0+chip0)*vxx(i))
+          uyy(i)=vyo(j)+tstep*(fyy(i)*rmass(i)-(chit0+chip0)*vyy(i))
+          uzz(i)=vzo(j)+tstep*(fzz(i)*rmass(i)-(chit0+chip0)*vzz(i))
+
+c     advance positions using leapfrog
+
+          xxx(i)=xxo(j)+tstep*(uxx(i)+
+     x      chipnew*((xxx(i)+xxo(j))*0.5d0-com(1)))
+          yyy(i)=yyo(j)+tstep*(uyy(i)+
+     x      chipnew*((yyy(i)+yyo(j))*0.5d0-com(2)))
+          zzz(i)=zzo(j)+tstep*(uzz(i)+
+     x      chipnew*((zzz(i)+zzo(j))*0.5d0-com(3)))
+
+        enddo
+        
+c     start of bond constraint procedures
+
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0)then
+
+c     store integrated positions
+
+          j=0
+          do i=iatm0,iatm1
+
+            j=j+1
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     estimate new cell tensor
+
+          volnew=volm*exp(3.d0*tstep*chipnew)
+          scale=(volnew/volm0)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     accumulate constraint virial terms
+
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do i=iatm0,iatm1
+            
+            j=j+1
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+
+c     end of shake corrections
+          
+        endif
+
+c     estimate velocity at the full step
+
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+c     calculate kinetic energy
+
+        engke=getkin(natms,idnode,mxnode)
+        
+c     improved prediction of chip and chit 
+
+        chipp=(2.d0*engke-virtot-vircon-3.d0*press*volm)/pmass-
+     x    chit0*chip0
+        chipnew=chip+tstep*chipp
+        chip0=0.5d0*(chip+chipnew)
+
+        chitp=(2.d0*(engke-sigma)+pmass*chip0**2-boltz*temp)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=0.5d0*(chit+chitnew)
+
+c     end of thermostat iterations
+
+      enddo
+
+c     kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)
+      enddo
+
+c     update volume
+      
+      vold=volm
+      volm=volm*exp(3.d0*tstep*chipnew)
+
+c     scale cell vectors - isotropic
+
+      scale=(volm/volm0)**(1.d0/3.d0)
+      do i=1,9
+        cell(i)=cell0(i)*scale
+      enddo
+
+c     construct scaling tensor (for later!)
+
+      do i=2,8
+        eta(i)=0.d0
+      enddo
+      eta(1)=chipnew
+      eta(5)=chipnew
+      eta(9)=chipnew
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     update thermostat and barostat variables
+
+      chit=chitnew
+      chip=chipnew
+
+c     conserved quantity less kinetic and potential energy terms
+      
+      conint=conint+tstep*chit0*(qmass/taut**2+boltz*temp)
+      cons1=0.5d0*qmass*chit0**2
+      cons2=press*vold
+      cons3=0.5d0*pmass*chip0**2
+      consv=conint+cons1+cons2+cons3
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+      
+c     updated velocity
+      
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     ensure total momentum is zero
+
+      call getvom(natms,idnode,mxnode,totmas,vom)
+
+      do i=iatm0,iatm1
+        
+        vxx(i)=vxx(i)-vom(1)
+        vyy(i)=vyy(i)-vom(2)
+        vzz(i)=vzz(i)-vom(3)
+        
+      enddo
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine npt_h1
+
+      subroutine nst_b1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x  ntcons,mode,elrc,engke,virlrc,press,taup,taut,sigma,tolnce,
+     x  tstep,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Berendsen
+c     thermostat and anisotropic pressure control
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version
+c     
+c     for systems using bond CONSTRAINTS. Frozen atoms feb 1994
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - t. forester december 1993
+c     amended   - w. smith  october    2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lshmov,newjob
+      integer idnode,imcon,mxnode,natms,ntpatm,nscons,ntcons,mode
+      integer fail,i,j,k,iatm0,iatm1,maxit,iter
+      real(8) elrc,engke,virlrc,press,taup,taut,sigma,tolnce,tstep
+      real(8) vircon,volm,beta,volm0,elrc0,virlrc0,rstep,rtsq,chit0
+      real(8) viracc,strkin,strcon,cell0,stres0,uni
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strkin(9),strcon(9),cell0(9),fail(8),stres0(9),uni(9)
+
+      save newjob,volm0,elrc0,virlrc0,dens0
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data beta/7.3728d-3/
+      data newjob/.true./
+      
+c     allocate working arrays
+
+      do i=1,8
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(7))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(8))
+      do i=1,8
+         if(fail(i).ne.0)call error(idnode,1460)
+      enddo
+
+      safe=.false.
+
+c     store initial values of volume, long range corrections etc
+
+      if(newjob)then
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1470)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        newjob=.false.
+
+      endif
+
+c     set up block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     initialise constraint virial accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store original cell vectors and stress tensor
+
+      do i=1,9
+        
+        cell0(i)=cell(i)
+        stres0(i)=stress(i)
+        
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+
+      enddo
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     estimate kinetic energy at current timestep
+
+      j=0
+      do i=iatm0,iatm1
+
+        j=j+1
+        vxx(i)=vxo(j)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+0.5d0*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     calculate kinetic energy
+
+      engke=getkin(natms,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     current estimate of stres tensor
+
+      do i=1,9
+        stress(i)=stres0(i)+strkin(i)
+      enddo
+      
+c     initial estimate of eta matrix and chit 
+
+      chit0=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+      do i=1,9
+        eta(i)=beta*tstep/taup*(stress(i)/volm-press*uni(i))+uni(i)
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+      
+c     begin iterations !!-----------------------------------------------
+
+      maxit=5
+      if(ntcons.eq.0)maxit=maxit-1
+      
+      do iter=1,maxit
+
+c     unconstrained new positions
+        
+        j=0
+        do i=iatm0,iatm1
+
+          j=j+1
+
+c     advance velocity using leapfrog
+
+          uxx(i)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(i)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(i)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+
+c     update positions
+          
+          xxx(i)=tstep*uxx(i)+
+     x      eta(1)*xxo(j)+eta(4)*yyo(j)+eta(7)*zzo(j)
+          yyy(i)=tstep*uyy(i)+
+     x      eta(2)*xxo(j)+eta(5)*yyo(j)+eta(8)*zzo(j)
+          zzz(i)=tstep*uzz(i)+
+     x      eta(3)*xxo(j)+eta(6)*yyo(j)+eta(9)*zzo(j)
+
+        enddo
+        
+c     start of bond constraint procedures
+        
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0)then
+
+c     store integrated positions
+
+          j=0
+          do i=iatm0,iatm1
+
+            j=j+1
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+c     estimate new cell parameters
+      
+          call mat_mul(eta,cell0,cell)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     accumulate constraint virial terms
+
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2 
+          do i=iatm0,iatm1
+            
+            j=j+1
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+
+c     estimate velocity at the full step
+
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+c     calculate kinetic energy
+
+        engke=getkin(natms,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stres0(i)+strcns(i)+strkin(i)
+        enddo
+
+c     improved calculation of eta matrix and chit 
+
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+        do i=1,9
+          eta(i)=beta*tstep/taup*(stress(i)/volm-press*uni(i))+uni(i)
+        enddo
+        if(mode.gt.0)then
+          eta(3)=0.d0
+          eta(6)=0.d0
+          eta(7)=0.d0
+          eta(8)=0.d0
+          if(mode.lt.3)then
+            eta(2)=0.d0
+            eta(4)=0.d0
+            if(mode.eq.2)then
+              eta(1)=0.5d0*(eta(1)+eta(5))
+              eta(5)=eta(1)
+            endif
+          endif
+        endif
+        
+c     end of thermostat and barostat iterations
+
+      enddo
+
+c     update volume
+      
+      volm=volm*eta(1)*eta(5)*eta(9)
+
+c     adjust cell vectors - anisotropic
+
+      call mat_mul(eta,cell0,cell)
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     restore half step velocity
+
+      do i=iatm0,iatm1
+
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine nst_b1
+
+      subroutine nst_h1
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,ntpatm,nscons,
+     x  ntcons,mode,chit,conint,consv,elrc,engke,virlrc,press,
+     x  taup,taut,sigma,temp,tolnce,tstep,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Hoover 
+c     thermostat+piston.
+c     
+c     Parrinello - Rahman type : changing cell shape.
+c     
+c     reference: Melchionna, Ciccotti and Holian,
+c     Mol Phys 1993, 78, p533
+c     
+c     parallel replicated data version
+c     
+c     for systems using bond constraints (using atomic pressure)
+c     
+c     copyright daresbury laboratory 1995
+c     author    -    t. forester     june  1995
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical safe,lshmov,newjob
+      integer idnode,imcon,mxnode,natms,ntpatm,nscons,ntcons
+      integer fail,i,j,k,iatm0,iatm1,maxit,iter,mode
+      real(8) chip,chit,conint,consv,elrc,engke,virlrc,press
+      real(8) taup,taut,sigma,temp,tolnce,tstep,vircon,volm
+      real(8) strcon,strkin,etanew,eta0,cell0,volm0,elrc0,virlrc0
+      real(8) rstep,rtsq,pmass,qmass,totmas,com,vom,uni,fac
+      real(8) chitp,chitnew,chit0,xxa,yya,zza,etadot
+      real(8) viracc,cons1,cons2,cons3,vold,stres0
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      dimension strkin(9),strcon(9),fail(8),com(3),vom(3)
+      dimension etanew(9),eta0(9),cell0(9),stres0(9),uni(9)
+
+      save newjob,volm0,elrc0,virlrc0,dens0
+
+      data newjob/.true./,uni/1.d0,3*0.d0,1.d0,3*0.d0,1.d0/
+      
+c     allocate working arrays
+      
+      do i=1,8
+         fail(i)=0
+      enddo
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(6))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(7))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(8))
+      do i=1,8
+         if(fail(i).ne.0)call error(idnode,1480)
+      enddo
+
+      safe=.false.
+
+c     store initial values of volume, long range corrections etc
+
+      if(newjob)then
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1490)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        newjob=.false.
+
+      endif
+
+c     set up block indices
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     inertia parameter for Nose-Hoover thermostat
+      
+      qmass=2.0d0*sigma*taut**2
+      pmass=2.0d0*sigma*taup**2
+
+c     initialise constraint virial accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store original cell vectors and stress tensor
+
+      do i=1,9
+        
+        cell0(i)=cell(i)
+        stres0(i)=stress(i)
+        
+      enddo
+
+c     store initial values of position and velocity
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+
+      enddo
+
+c     total system mass
+
+      totmas=getmass(natms,idnode,mxnode)
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate system centre of mass
+
+      call getcom(natms,idnode,mxnode,totmas,com)
+
+c     estimate kinetic energy at current timestep
+
+      j=0
+      do i=iatm0,iatm1
+
+        j=j+1
+
+c     estimate position at current time step
+
+        xxx(i)=xxo(j)+tstep*(vxo(j)+tstep*rmass(i)*fxx(i))
+        yyy(i)=yyo(j)+tstep*(vyo(j)+tstep*rmass(i)*fyy(i))
+        zzz(i)=zzo(j)+tstep*(vzo(j)+tstep*rmass(i)*fzz(i))
+        
+c     estimate velocity at the full step
+
+        vxx(i)=vxo(j)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+0.5d0*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     calculate kinetic energy
+
+      engke=getkin(natms,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+      call kinstress(natms,idnode,mxnode,strkin)
+
+c     initial estimate of stress tensor
+
+      do i=1,9
+        stress(i)=stres0(i)+strkin(i)
+      enddo
+
+c     propagation of eta
+
+      fac=9.d0
+      do i=1,9
+        etanew(i)=eta(i)+tstep*((stress(i)-press*volm*uni(i))/pmass-
+     x    chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        fac=5.d0
+        etanew(3)=0.d0
+        etanew(6)=0.d0
+        etanew(7)=0.d0
+        etanew(8)=0.d0
+        if(mode.lt.3)then
+          fac=3.d0
+          etanew(2)=0.d0
+          etanew(4)=0.d0
+          if(mode.eq.2)then
+            fac=2.d0
+            etanew(1)=0.5d0*(etanew(1)+etanew(5))
+            etanew(5)=etanew(1)
+          endif
+        endif
+      endif
+      do i=1,9
+        eta0(i)=0.5d0*(etanew(i)+eta(i)) 
+      enddo
+
+c     propagate chit
+
+      etadot=sdot0(9,eta0,eta0)
+      if(mode.eq.2)etadot=etadot-eta0(1)**2
+      chitp=(2.d0*(engke-sigma)+pmass*etadot-fac*boltz*temp)/qmass
+      chitnew=chit+tstep*chitp
+      chit0=0.5d0*(chit+chitnew)
+
+c     begin iterations !!-----------------------------------------------
+
+      maxit=5
+      if(ntcons.eq.0) maxit=maxit-1
+      do iter=1,maxit
+
+c     unconstrained new positions
+        
+        j=0
+        do i=iatm0,iatm1
+
+          j=j+1
+
+c     advance velocity using leapfrog
+
+          uxx(i)=vxo(j)+tstep*(fxx(i)*rmass(i)-(eta0(1)+chit0)*vxx(i)-
+     x      eta0(4)*vyy(i)-eta0(7)*vzz(i))
+          uyy(i)=vyo(j)+tstep*(fyy(i)*rmass(i)-(eta0(5)+chit0)*vyy(i)-
+     x      eta0(2)*vxx(i)-eta0(8)*vzz(i))
+          uzz(i)=vzo(j)+tstep*(fzz(i)*rmass(i)-(eta0(9)+chit0)*vzz(i)-
+     x      eta0(3)*vxx(i)-eta0(6)*vyy(i))
+
+c     advance positions using leapfrog
+
+          xxa=(xxx(i)+xxo(j))*0.5d0-com(1)
+          yya=(yyy(i)+yyo(j))*0.5d0-com(2)
+          zza=(zzz(i)+zzo(j))*0.5d0-com(3)
+
+          xxx(i)=xxo(j)+tstep*(uxx(i)+
+     x      etanew(1)*xxa+etanew(4)*yya+etanew(7)*zza)
+          yyy(i)=yyo(j)+tstep*(uyy(i)+
+     x      etanew(2)*xxa+etanew(5)*yya+etanew(8)*zza)
+          zzz(i)=zzo(j)+tstep*(uzz(i)+
+     x      etanew(3)*xxa+etanew(6)*yya+etanew(9)*zza)
+
+        enddo
+        
+c     start of bond constraint procedures
+        
+        if(ntcons.eq.0)safe=.true.
+        if(ntcons.gt.0)then
+
+c     store integrated positions
+
+          j=0
+          do i=iatm0,iatm1
+
+            j=j+1
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     estimate new cell parameters
+        
+        do i=1,9
+          cell(i)=cell0(i)
+        enddo
+        call cell_propagate(tstep,cell,etanew)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     contribution to constraint virial
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2 
+          do i=iatm0,iatm1
+            
+            j=j+1
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+
+c     estimate velocity at the full step
+
+        j=0
+        do i=iatm0,iatm1
+          
+          j=j+1
+
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+
+        enddo
+
+c     calculate kinetic energy
+
+        engke=getkin(natms,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stres0(i)+strcns(i)+strkin(i)
+        enddo
+
+c     improved prediction of eta
+
+        do i=1,9
+          etanew(i)=eta(i)+tstep*((stress(i)-press*volm*uni(i))/pmass-
+     x      chit0*eta0(i))
+        enddo
+        if(mode.gt.0)then
+          etanew(3)=0.d0
+          etanew(6)=0.d0
+          etanew(7)=0.d0
+          etanew(8)=0.d0
+          if(mode.lt.3)then
+            etanew(2)=0.d0
+            etanew(4)=0.d0
+            if(mode.eq.2)then
+              etanew(1)=0.5d0*(etanew(1)+etanew(5))
+              etanew(5)=etanew(1)
+            endif
+          endif
+        endif
+        do i=1,9
+          eta0(i)=0.5d0*(etanew(i)+eta(i)) 
+        enddo
+
+c     improved prediction of chit
+
+        etadot=sdot0(9,eta0,eta0)
+        if(mode.eq.2)etadot=etadot-eta0(1)**2
+        chitp=(2.d0*(engke-sigma)+pmass*etadot-fac*boltz*temp)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=0.5d0*(chit+chitnew)
+
+c     end of thermostat iterations
+
+      enddo
+
+c     update thermostat and barostat variables
+
+      chit=chitnew
+      do i=1,9
+        eta(i)=etanew(i)
+      enddo
+
+c     update volume
+      
+      chip=eta(1)+eta(5)+eta(9)
+      vold=volm
+      volm=volm*exp(tstep*chip)
+
+c     adjust cell vectors - anisotropic
+
+      do i=1,9
+        cell(i)=cell0(i)
+      enddo
+      call cell_propagate(tstep,cell,eta)
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     conserved quantity less kinetic and potential energy
+      
+      conint=conint+tstep*chit0*(qmass/taut**2+fac*boltz*temp)
+      cons1=0.5d0*qmass*chit0**2
+      cons2=press*vold
+      etadot=sdot0(9,eta0,eta0)
+      if(mode.eq.2)etadot=etadot-eta0(1)**2
+      cons3=0.5d0*pmass*etadot
+      consv=conint+cons1+cons2+cons3
+
+c     restore half step velocity
+
+      do i=iatm0,iatm1
+        
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+        
+      enddo
+
+c     ensure total momentum is zero
+
+      call getvom(natms,idnode,mxnode,totmas,vom)
+
+      do i=iatm0,iatm1
+        
+        vxx(i)=vxx(i)-vom(1)
+        vyy(i)=vyy(i)-vom(2)
+        vzz(i)=vzz(i)-vom(3)
+        
+      enddo
+
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+      deallocate (uxx,uyy,uzz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(3))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(4))
+      
+      return
+      end subroutine nst_h1
+      
+      end module lf_motion_module
diff -urN dl_class_1.9.orig/srcmod/lf_rotation1_module.f dl_class_1.9/srcmod/lf_rotation1_module.f
--- dl_class_1.9.orig/srcmod/lf_rotation1_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/lf_rotation1_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,5315 @@
+      module lf_rotation1_module
+      
+c***********************************************************************
+c     
+c     dl_poly module 1 for verlet leap frog rotational integration 
+c     schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use error_module
+      use lf_motion_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use utility_module
+      
+      contains
+      
+      subroutine update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c***********************************************************************
+c     
+c     dlpoly routine to update the quaternion arrays as part of
+c     the leapfrog algorithm
+c     
+c     copyright daresbury laboratory
+c     author   -  w.smith october 2005
+c     based on -  t.forester oct. 1993
+c     
+c**********************************************************************
+
+      implicit none
+
+      real(8), parameter :: pt5=0.5d0
+
+      logical safeq
+      integer igrp1,igrp2,jg,itq,ig
+      real(8) qn0,qn1,qn2,qn3,qn0a,qn1a,qn2a,qn3a,qn0b,qn1b,qn2b,qn3b
+      real(8) rnorm,tstep,quattol,eps
+      real(8) opx(msgrp),opy(msgrp),opz(msgrp)
+      real(8) oqx(msgrp),oqy(msgrp),oqz(msgrp)
+
+      jg=0
+      safeq=.true.
+
+      do ig=igrp1,igrp2
+
+        jg=jg+1
+
+c     first iteration of new quaternions (lab fixed)
+        
+        qn0=q0(ig)+(-q1(ig)*opx(jg)-q2(ig)*opy(jg)-q3(ig)*opz(jg))
+     x    *tstep*pt5
+        qn1=q1(ig)+( q0(ig)*opx(jg)-q3(ig)*opy(jg)+q2(ig)*opz(jg))
+     x    *tstep*pt5
+        qn2=q2(ig)+( q3(ig)*opx(jg)+q0(ig)*opy(jg)-q1(ig)*opz(jg))
+     x    *tstep*pt5
+        qn3=q3(ig)+(-q2(ig)*opx(jg)+q1(ig)*opy(jg)+q0(ig)*opz(jg))
+     x    *tstep*pt5
+        
+        qn0b=0.d0
+        qn1b=0.d0
+        qn2b=0.d0
+        qn3b=0.d0
+        
+        itq=0
+        eps=1.0d9
+        do while((itq.lt.mxquat).and.(eps.gt.quattol))
+          
+          itq=itq+1
+          
+          qn0a=pt5*(-q1(ig)*opx(jg)-q2(ig)*opy(jg)-q3(ig)*opz(jg))
+     x      +pt5*(-qn1*oqx(jg)-qn2*oqy(jg)-qn3*oqz(jg))
+          qn1a=pt5*(  q0(ig)*opx(jg)-q3(ig)*opy(jg)+q2(ig)*opz(jg))
+     x      +   pt5*( qn0*oqx(jg)-qn3*oqy(jg)+qn2*oqz(jg))
+          qn2a=pt5*(  q3(ig)*opx(jg)+q0(ig)*opy(jg)-q1(ig)*opz(jg))
+     x      +   pt5*( qn3*oqx(jg)+qn0*oqy(jg)-qn1*oqz(jg))
+          qn3a=pt5*(-q2(ig)*opx(jg)+q1(ig)*opy(jg)+q0(ig)*opz(jg))
+     x      +   pt5*(-qn2*oqx(jg)+qn1*oqy(jg)+qn0*oqz(jg))
+          
+          qn0=q0(ig)+pt5*qn0a*tstep
+          qn1=q1(ig)+pt5*qn1a*tstep
+          qn2=q2(ig)+pt5*qn2a*tstep
+          qn3=q3(ig)+pt5*qn3a*tstep
+          
+          rnorm=1.d0/sqrt(qn0**2+qn1**2+qn2**2+qn3**2)
+          qn0=qn0*rnorm
+          qn1=qn1*rnorm
+          qn2=qn2*rnorm
+          qn3=qn3*rnorm
+          
+c     convergence test 
+          
+          eps=sqrt(((qn0a-qn0b)**2+(qn1a-qn1b)**2+(qn2a-qn2b)**2
+     x      +(qn3a-qn3b)**2)*tstep**2)
+          
+          qn0b=qn0a
+          qn1b=qn1a
+          qn2b=qn2a
+          qn3b=qn3a
+          
+        enddo
+        
+        if(itq.ge.mxquat) safeq=.false.
+        
+c     store new quaternions
+        
+        q0(ig)=qn0
+        q1(ig)=qn1
+        q2(ig)=qn2
+        q3(ig)=qn3
+        
+      enddo
+
+      return
+      end subroutine update_quaternions
+      
+      subroutine nveq_1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,quattol,tolnce,tstep,vircom,
+     x  vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame
+c     omx,omy,omz = angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=12
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,safeq,lshmov,newjob
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer fail,i,igrp,igrp1,igrp2,idum,ifre1,ifre2,j,ifre
+      integer jg,ig,k,id,jr
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon
+      real(8) strkin,rot,rstep,rtsq,engtrn,vaa,vbb,vcc
+      real(8) trx,try,trz,delx,dely,delz,engfke
+      real(8) strgrp,tqx,tqy,tqz,fmx,fmy,fmz
+
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+
+      dimension strkin(9),strgrp(9),rot(9),fail(nnn)
+      
+      save igrp1,igrp2,ifre1,ifre2
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(12))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1500)
+      enddo
+     
+      if(newjob)then
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        newjob=.false.
+        
+      endif
+
+      safe=.false.
+
+c     store initial values of position and velocity
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+      
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     integrate 'free' particles
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+c     advance velocity by leapfrog
+
+        uxx(i)=vxo(j)+tstep*rmass(i)*fxx(i)
+        uyy(i)=vyo(j)+tstep*rmass(i)*fyy(i)
+        uzz(i)=vzo(j)+tstep*rmass(i)*fzz(i)
+
+c     advance position by leapfrog
+
+        xxx(i)=xxo(j)+tstep*uxx(i)
+        yyy(i)=yyo(j)+tstep*uyy(i)
+        zzz(i)=zzo(j)+tstep*uzz(i)
+        
+      enddo
+
+      if(ntcons.eq.0) safe=.true.
+      if(ntcons.gt.0) then
+
+c     store integrated positions
+
+        j=0
+        do ifre=ifre1,ifre2
+
+          i=lstfre(ifre)
+          j=j+1
+          xx1(j)=xxx(i)
+          yy1(j)=yyy(i)
+          zz1(j)=zzz(i)
+
+        enddo
+
+c     global exchange of configuration data
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+        
+        call rdshake_1
+     x    (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x    tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x    txx,tyy,tzz,xxt,yyt,zzt,strcns)
+        
+c     calculate force and velocity corrections
+        
+        j=0
+        rstep=1.d0/tstep
+        rtsq=1.d0/tstep**2
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     calculate force correction
+        
+          fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+          fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+          fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+
+c     calculate velocity correction
+
+          uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+          uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+          uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+        enddo
+
+c     end of shake corrections
+        
+      endif
+
+c     estimate full step velocity
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        
+        vxx(i)=0.5d0*(uxx(i)+vxo(j))
+        vyy(i)=0.5d0*(uyy(i)+vyo(j))
+        vzz(i)=0.5d0*(uzz(i)+vzo(j))
+        
+      enddo
+      
+c     calculate new kinetic energy at current timestep
+      
+      engfke=getkinf(ntfree,idnode,mxnode)
+      
+c     kinetic contribution to stress tensor
+        
+      call kinstressf(ntfree,idnode,mxnode,strkin)
+
+c     restore free atom half step velocity
+      
+      do ifre=ifre1,ifre2
+        
+        i=lstfre(ifre)
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+        
+      enddo
+        
+c     *************  Rigid body motion ****************************
+
+c     translational rigid body motion
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+c     calculate net force on rigid body
+        
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+          
+        enddo
+
+c     advance velocity by leapfrog
+        
+        uxx(ig)=gvxx(ig)+fmx*tstep/gmass(id)
+        uyy(ig)=gvyy(ig)+fmy*tstep/gmass(id)
+        uzz(ig)=gvzz(ig)+fmz*tstep/gmass(id)
+
+c     advance position by leapfrog
+
+        gcmx(ig)=gcmx(ig)+tstep*uxx(ig)
+        gcmy(ig)=gcmy(ig)+tstep*uyy(ig)
+        gcmz(ig)=gcmz(ig)+tstep*uzz(ig)
+
+c     estimate velocity at full time step
+
+        gvxx(ig)=0.5d0*(gvxx(ig)+uxx(ig))
+        gvyy(ig)=0.5d0*(gvyy(ig)+uyy(ig))
+        gvzz(ig)=0.5d0*(gvzz(ig)+uzz(ig))
+        
+      enddo
+
+c     calculate rigid body translational kinetic energy
+
+      engtrn=getkint(ngrp,idnode,mxnode)
+      
+c     total translational kinetic energy
+      
+      engke=engtrn+engfke
+
+c     calculate rigid body kinetic stress tensor
+      
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+c     restore rigid body half timestep velocity
+
+      do ig=igrp1,igrp2
+
+        gvxx(ig)=uxx(ig)
+        gvyy(ig)=uyy(ig)
+        gvzz(ig)=uzz(ig)
+
+      enddo
+      
+c     calculate rigid body contribution to stress tensor
+
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     calculate torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx=0.d0
+        tqy=0.d0
+        tqz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx=tqx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy=tqy+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz=tqz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+        
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     store current angular velocity
+
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+
+c       iterate angular velocity for time step n (e. yezdimer)
+
+        do i=1,5
+        
+          trx=(tqx*rot(1)+tqy*rot(4)+tqz*rot(7))*rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*rotinx(id,2)
+          try=(tqx*rot(2)+tqy*rot(5)+tqz*rot(8))*rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*rotiny(id,2)
+          trz=(tqx*rot(3)+tqy*rot(6)+tqz*rot(9))*rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*rotinz(id,2)
+
+          delx=tstep*trx
+          dely=tstep*try
+          delz=tstep*trz
+
+c     improved angular velocity at time step n
+
+          opx(jg)=omx(ig)+delx*pt5
+          opy(jg)=omy(ig)+dely*pt5
+          opz(jg)=omz(ig)+delz*pt5
+
+        enddo
+
+c     angular velocity at time step n+1/2
+
+        uxx(ig)=omx(ig)+delx
+        uyy(ig)=omy(ig)+dely
+        uzz(ig)=omz(ig)+delz
+
+c     angular velocity at time step n+1  (needed for quat algorithm)
+        
+        oqx(jg)=omx(ig)+delx*1.5d0
+        oqy(jg)=omy(ig)+dely*1.5d0
+        oqz(jg)=omz(ig)+delz*1.5d0
+
+c     angular velocity at timestep n
+        
+        omx(ig)=omx(ig)+pt5*delx
+        omy(ig)=omy(ig)+pt5*dely
+        omz(ig)=omz(ig)+pt5*delz
+        
+      enddo
+
+c     rotational kinetic energy
+        
+      engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step angular velocity
+
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+        omx(ig)=uxx(ig)
+        omy(ig)=uyy(ig)
+        omz(ig)=uzz(ig)
+        
+      enddo
+      
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)
+      enddo
+      
+c     minimum images of group positions and particle positions
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies - relative to c.o.m
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+        
+      endif
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     deallocate work arrays
+
+      deallocate(opx,opy,opz,xxt,yyt,zzt,stat=fail(1))
+      deallocate(oqx,oqy,oqz,dtx,dty,dtz,stat=fail(2))
+      deallocate(dxx,dyy,dzz,uxx,uyy,uzz,stat=fail(3))
+      deallocate(txx,tyy,tzz,dxt,dyt,dzt,stat=fail(4))
+      deallocate(xxo,yyo,zzo,xx1,yy1,zz1,stat=fail(5))
+      deallocate(vxo,vyo,vzo,gcxo,gcyo,gczo,stat=fail(6))
+      
+      return
+      end subroutine nveq_1
+
+      subroutine nvtq_b1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,quattol,sigma,taut,tolnce,
+     x  tstep,vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Berendsen
+c     thermostat.
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame
+c     omx,omy,omz = angular velocity in body fixed frame (principle axis)
+c     rotinx,y,z = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,lshmov,safeq,newjob
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer i,fail,igrp,igrp1,igrp2,ifre,ifre1,ifre2,jg,ig
+      integer j,k,jr,id,mxiter,iter,idum
+      real(8) engke,engrot,quattol,sigma,taut,tolnce,tstep,vircom
+      real(8) vircon,strkin,strgrp,rot,rstep,rtsq
+      real(8) engtrn,trx,try,trz,chit0,rgmas,engfke
+      real(8) vaa,vbb,vcc,engtot,viracc,strcon
+      
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+
+      dimension strkin(9),strgrp(9),strcon(9),rot(9),fail(nnn)
+      
+      save igrp1,igrp2,ifre1,ifre2,newjob
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(12))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(13))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(14))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(15))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1510)
+      enddo
+     
+      if(newjob)then
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+
+      endif
+
+      safe=.false.
+
+c     initialise constraint virial terms
+      
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+      
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+      
+      endif
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1 
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacements
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     estimate velocity and temperature at half-time step
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+        vxx(i)=vxo(j)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+pt5*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     kinetic energy of free atoms
+
+      engfke=getkinf(ntfree,idnode,mxnode)
+
+c     estimate kinetic energy of rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+c     calculate net force on rigid body
+        
+        fmx(jg)=0.d0
+        fmy(jg)=0.d0
+        fmz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx(jg)=fmx(jg)+fxx(i)
+          fmy(jg)=fmy(jg)+fyy(i)
+          fmz(jg)=fmz(jg)+fzz(i)
+          
+        enddo
+
+c     centre of mass velocities at half-step
+        
+        gvxx(ig)=gvxo(jg)+pt5*tstep*fmx(jg)/gmass(id)
+        gvyy(ig)=gvyo(jg)+pt5*tstep*fmy(jg)/gmass(id)
+        gvzz(ig)=gvzo(jg)+pt5*tstep*fmz(jg)/gmass(id)
+
+      enddo
+
+c     translation kinetic energy of rigid bodies
+
+      engtrn=getkint(ngrp,idnode,mxnode)
+      
+c     calculate rigid body contribution to stress tensor
+
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx(jg)=0.d0
+        tqy(jg)=0.d0
+        tqz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+        
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     angular velocity at time step n (first guess)
+
+        opx(jg)=omxo(jg)
+        opy(jg)=omyo(jg)
+        opz(jg)=omzo(jg)
+
+c     iterate angular velocity for time step n (e. yezdimer)
+        
+        do i=1,5
+          
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*rotinz(id,2)
+
+c     improved angular velocity at time step n
+          
+          opx(jg)=omx(ig)+pt5*tstep*trx
+          opy(jg)=omy(ig)+pt5*tstep*try
+          opz(jg)=omz(ig)+pt5*tstep*trz
+        
+        enddo
+        
+c     store angular velocity at timestep n
+        
+        omx(ig)=opx(jg)
+        omy(ig)=opy(jg)
+        omz(ig)=opz(jg)
+        
+      enddo
+      
+c     rigid body rotational kinetic energy
+
+      engrot=getkinr(ngrp,idnode,mxnode)
+
+c     temperature scaling  coefficient - taut is the relaxation time
+      
+      engtot=engfke+engrot+engtrn
+      chit0= sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+
+c     begin iterations !!-----------------------------------------------
+
+      mxiter=2
+      if(ntcons.eq.0) mxiter=mxiter-1
+      
+      do iter=1,mxiter
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     advance velocity using leapfrog
+
+          uxx(i)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(i)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(i)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+
+c     update positions 
+          
+          xxx(i)=tstep*uxx(i)+xxo(j)
+          yyy(i)=tstep*vyy(i)+yyo(j)
+          zzz(i)=tstep*uzz(i)+zzo(j)
+
+        enddo
+
+        if(ntcons.eq.0) safe=.true.
+        if(ntcons.gt.0.and.iter.eq.1) then
+
+c     store integrated positions
+
+          j=0
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+c     contribution to constraint virial 
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+        
+c     calculate force and velocity corrections
+        
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            
+c     calculate force correction
+        
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+
+c     calculate velocity correction
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+            
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+c     estimate full step velocity
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        
+        vxx(i)=0.5d0*(uxx(i)+vxo(j))
+        vyy(i)=0.5d0*(uyy(i)+vyo(j))
+        vzz(i)=0.5d0*(uzz(i)+vzo(j))
+        
+      enddo
+      
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        if(iter.eq.mxiter)call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore free atom half step velocity
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          vxx(i)=uxx(i)
+          vyy(i)=uyy(i)
+          vzz(i)=uzz(i)
+          
+        enddo
+        
+c     ********: rigid body motion - thermostated  :************
+        
+c     ***** step 1 : integrate centre of mass motion *********
+        
+        jg =0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     calculate thermostated velocities
+          
+          rgmas=1.d0/gmass(id)
+          uxx(ig)=(gvxo(jg)+tstep*(fmx(jg)*rgmas))*chit0
+          uyy(ig)=(gvyo(jg)+tstep*(fmy(jg)*rgmas))*chit0
+          uzz(ig)=(gvzo(jg)+tstep*(fmz(jg)*rgmas))*chit0
+
+c     update positions 
+          
+          gcmx(ig)=gcxo(jg)+tstep*uxx(ig)
+          gcmy(ig)=gcyo(jg)+tstep*uyy(ig)
+          gcmz(ig)=gczo(jg)+tstep*uzz(ig)
+          
+c     calculate full step velocities
+          
+          gvxx(ig)=0.5d0*(gvxo(jg)+uxx(ig))
+          gvyy(ig)=0.5d0*(gvyo(jg)+uyy(ig))
+          gvzz(ig)=0.5d0*(gvzo(jg)+uzz(ig))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+        if(iter.eq.mxiter)call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocities 
+
+        do ig=igrp1,igrp2
+
+          gvxx(ig)=uxx(ig)
+          gvyy(ig)=uyy(ig)
+          gvzz(ig)=uzz(ig)
+          
+        enddo
+        
+c     ****** step 2 : integrate rotational motion **********
+        
+        jg=0
+        safeq=.true.
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     scaled angular velocity at time step n
+            
+          omx(ig)=(omxo(jg)+pt5*tstep*trx)*chit0
+          omy(ig)=(omyo(jg)+pt5*tstep*try)*chit0
+          omz(ig)=(omzo(jg)+pt5*tstep*trz)*chit0
+
+c     angular velocity at time step n+1/2
+          
+          uxx(ig)=(omxo(jg)+tstep*trx)*chit0
+          uyy(ig)=(omyo(jg)+tstep*try)*chit0
+          uzz(ig)=(omzo(jg)+tstep*trz)*chit0
+
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=(omxo(jg)+1.5d0*tstep*trx)*chit0
+          oqy(jg)=(omyo(jg)+1.5d0*tstep*try)*chit0
+          oqz(jg)=(omzo(jg)+1.5d0*tstep*trz)*chit0
+
+        enddo
+        
+c     calculate rigid body rotational energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+
+c     restore half step angular velocity
+
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(ig)
+          omy(ig)=uyy(ig)
+          omz(ig)=uzz(ig)
+          
+        enddo
+
+c     total translational kinetic energy
+      
+        engke=engtrn+engfke
+      
+c     total kinetic energy
+        
+        engtot=engke+engrot
+        
+c     improved prediction of chit
+
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+
+c     end of thermostat/barostat iterations
+
+      enddo
+
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     minimum images 
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+      
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+      
+c     merge new atomic coordinates and velocities
+      
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+      
+      endif
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(5))
+      deallocate (fmx,fmy,fmz,tqx,tqy,tqz,stat=fail(6))
+      deallocate (omxo,omyo,omzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,gvxo,gvyo,gvzo,stat=fail(8))
+      
+      return
+      end subroutine nvtq_b1
+
+      subroutine nvtq_h1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,chit,consv,conint,engke,engrot,quattol,
+     x  sigma,taut,tolnce,tstep,vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Hoover 
+c     thermostat.
+c     
+c     for systems using bond constraints
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame
+c     omx,omy,omz = angular velocity in body fixed frame (principle axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,lshmov,safeq,newjob
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer fail,i,idum,igrp,igrp1,igrp2,ifre,ifre1,ifre2
+      integer j,k,ig,jg,jr,id,iter,mxiter
+      real(8) chit,consv,conint,engke,engrot,quattol,sigma,taut
+      real(8) tolnce,tstep,vircom,vircon,strkin,strgrp,strcon,rot
+      real(8) rstep,rtsq,qmass,engtrn,cons1,engtot,vaa,vbb,vcc
+      real(8) chit0,chitnew,chitp,viracc,rgmas,trx,try,trz,delx
+      real(8) dely,delz,engfke
+
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+
+      dimension strkin(9),strgrp(9),strcon(9),rot(9),fail(nnn)
+      
+      save igrp1,igrp2,ifre1,ifre2,qmass,newjob
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(12))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(13))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(14))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(15))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1520)
+      enddo
+
+      if(newjob)then
+        
+c     inertia parameter for Nose-Hoover thermostat
+        
+        qmass=2.0d0*sigma*taut**2
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+
+c     initialise constraint virial terms
+      
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+      
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1 
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacements
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     estimate velocity and temperature at half-time step
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+        vxx(i)=vxo(j)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+pt5*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     kinetic energy of free atoms
+
+      engfke=getkinf(ntfree,idnode,mxnode)
+      
+c     estimate kinetic energy of rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+
+c     calculate net force on rigid body
+        
+        fmx(jg)=0.d0
+        fmy(jg)=0.d0
+        fmz(jg)=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx(jg)=fmx(jg)+fxx(i)
+          fmy(jg)=fmy(jg)+fyy(i)
+          fmz(jg)=fmz(jg)+fzz(i)
+          
+        enddo
+
+c     centre of mass velocities at half-step
+        
+        gvxx(ig)=gvxo(jg)+pt5*tstep*fmx(jg)/gmass(id)
+        gvyy(ig)=gvyo(jg)+pt5*tstep*fmy(jg)/gmass(id)
+        gvzz(ig)=gvzo(jg)+pt5*tstep*fmz(jg)/gmass(id)
+
+      enddo
+
+c     translation kinetic energy of rigid bodies
+
+      engtrn=getkint(ngrp,idnode,mxnode)
+
+c     calculate rigid body contribution to stress tensor
+
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx(jg)=0.d0
+        tqy(jg)=0.d0
+        tqz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+        
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     angular velocity at time step n (first guess)
+
+        opx(jg)=omxo(jg)
+        opy(jg)=omyo(jg)
+        opz(jg)=omzo(jg)
+
+c     iterate angular velocity for time step n (e. yezdimer)
+        
+        do i=1,5
+          
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     improved angular velocity at time step n
+          
+          opx(jg)=omx(ig)+pt5*tstep*trx
+          opy(jg)=omy(ig)+pt5*tstep*try
+          opz(jg)=omz(ig)+pt5*tstep*trz
+        
+        enddo
+
+c     store angular velocity at timestep n
+        
+        omx(ig)=opx(jg)
+        omy(ig)=opy(jg)
+        omz(ig)=opz(jg)
+        
+      enddo
+      
+c     rigid body rotational kinetic energy
+
+      engrot=getkinr(ngrp,idnode,mxnode)
+
+c     propagate chit
+
+      engke=engfke+engtrn
+      engtot=engke+engrot
+      chitp=2.d0*(engtot-sigma)/qmass
+      chitnew=chit+tstep*chitp
+      chit0=0.5d0*(chit+chitnew)
+
+c     begin iterations !!-----------------------------------------------
+
+      mxiter=4
+      if(ntcons.eq.0) mxiter=mxiter-1
+      
+      do iter=1,mxiter
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     advance velocity using leapfrog
+
+          uxx(i)=vxo(j)+tstep*(fxx(i)*rmass(i)-chit0*vxx(i))
+          uyy(i)=vyo(j)+tstep*(fyy(i)*rmass(i)-chit0*vyy(i))
+          uzz(i)=vzo(j)+tstep*(fzz(i)*rmass(i)-chit0*vzz(i))
+
+c     advance positions using leapfrog
+
+          xxx(i)=xxo(j)+tstep*uxx(i)
+          yyy(i)=yyo(j)+tstep*uyy(i)
+          zzz(i)=zzo(j)+tstep*uzz(i)
+
+        enddo
+
+        if(ntcons.eq.0) safe=.true.
+        if(ntcons.gt.0.and.iter.eq.1) then
+
+c     store integrated positions
+
+          j=0
+          do ifre=ifre1,ifre2
+            
+            j=j+1
+            i=lstfre(ifre)
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+            
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     contribution to constraint virial 
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate force and velocity corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            
+c     calculate force correction
+        
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+
+c     calculate velocity correction
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+            
+          enddo
+
+c     end of shake corrections
+          
+        endif
+
+c     estimate full step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+          
+        enddo
+        
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+        if(iter.eq.mxiter)then
+          
+c     kinetic contribution to stress tensor
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)
+          
+c     restore free atom half step velocity
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            vxx(i)=uxx(i)
+            vyy(i)=uyy(i)
+            vzz(i)=uzz(i)
+            
+          enddo
+          
+        endif
+        
+c     ********: rigid body motion - thermostated  :************
+        
+c     ***** step 1 : integrate centre of mass motion *********
+        
+        jg =0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     calculate thermostated velocities
+          
+          rgmas=1.d0/gmass(id)
+          uxx(ig)=gvxo(jg)+tstep*(fmx(jg)*rgmas-chit0*gvxx(ig))
+          uyy(ig)=gvyo(jg)+tstep*(fmy(jg)*rgmas-chit0*gvyy(ig))
+          uzz(ig)=gvzo(jg)+tstep*(fmz(jg)*rgmas-chit0*gvzz(ig))
+
+c     update positions
+
+          gcmx(ig)=gcxo(jg)+tstep*uxx(ig)
+          gcmy(ig)=gcyo(jg)+tstep*uyy(ig)
+          gcmz(ig)=gczo(jg)+tstep*uzz(ig)
+
+c     calculate full step velocities
+          
+          gvxx(ig)=0.5d0*(gvxo(jg)+uxx(ig))
+          gvyy(ig)=0.5d0*(gvyo(jg)+uyy(ig))
+          gvzz(ig)=0.5d0*(gvzo(jg)+uzz(ig))
+          
+        enddo
+
+c     calculate kinetic energy
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+        if(iter.eq.mxiter)then
+
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+          
+c     restore half step velocities 
+          
+          do ig=igrp1,igrp2
+            
+            gvxx(ig)=uxx(ig)
+            gvyy(ig)=uyy(ig)
+            gvzz(ig)=uzz(ig)
+            
+          enddo
+        
+        endif
+        
+c     ****** step 2 : integrate rotational motion **********
+        
+        safeq=.true.
+        engrot=0.d0
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     correction due to thermostat
+
+          delx=tstep*(trx-chit0*pt5*(omx(ig)+omxo(jg)))
+          dely=tstep*(try-chit0*pt5*(omy(ig)+omyo(jg)))
+          delz=tstep*(trz-chit0*pt5*(omz(ig)+omzo(jg)))
+
+c     angular velocity at time step n
+          
+          omx(ig)=omxo(jg)+delx*pt5
+          omy(ig)=omyo(jg)+dely*pt5
+          omz(ig)=omzo(jg)+delz*pt5
+
+c     angular velocity at time step n+1/2
+          
+          uxx(ig)=omxo(jg)+delx
+          uyy(ig)=omyo(jg)+dely
+          uzz(ig)=omzo(jg)+delz
+
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+
+        enddo
+
+c     calculate rigid body rotational energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+
+c     restore half step angular velocity
+
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(ig)
+          omy(ig)=uyy(ig)
+          omz(ig)=uzz(ig)
+          
+        enddo
+
+c     improved prediction of chit 
+
+        engke=engfke+engtrn
+        engtot=engke+engrot
+        chitp=2.d0*(engtot-sigma)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=0.5d0*(chit+chitnew)
+
+c     end of thermostat iterations
+
+      enddo
+
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     minimum images 
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+c     update thermostat variable
+
+      chit=chitnew
+
+c     conserved quantity less kinetic and potential energy terms
+      
+      conint=conint+tstep*chit0*qmass/taut**2
+      cons1=0.5d0*qmass*chit0**2
+      consv=conint+cons1
+
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+      
+c     merge new atomic coordinates and velocities
+      
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+      
+      endif
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(5))
+      deallocate (fmx,fmy,fmz,tqx,tqy,tqz,stat=fail(6))
+      deallocate (omxo,omyo,omzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,gvxo,gvyo,gvzo,stat=fail(8))
+      
+      return
+      end subroutine nvtq_h1
+
+      subroutine nptq_b1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,elrc,engke,engrot,virlrc,press,
+     x  quattol,sigma,taup,taut,tolnce,tstep,virtot,vircom,
+     x  vircon,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Berendsen
+c     thermostat and barostat.
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame (input)
+c     omx,omy,omz = angular velocity in body fixed frame (principl axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,lshmov,newjob,safeq
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ntpatm,i,fail,igrp,igrp1,igrp2,idum,ifre,ifre1
+      integer ifre2,j,jg,ig,jr,k,id,iter,mxiter
+      real(8) elrc,engke,engrot,virlrc,press,quattol,sigma,taup,taut
+      real(8) tolnce,tstep,virtot,vircom,vircon,volm,rot,engfke,uni
+      real(8) cell0,beta,volm0,elrc0,virlrc0,rstep,rtsq
+      real(8) engtrn,trx,try,trz,chip0,scale,engtot,chit0,viracc,czero
+      real(8) rgmas,vaa,vbb,vcc,strkin,strcon,strgrp,psyst
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+
+      dimension fail(nnn),rot(9),cell0(9),czero(9),uni(9)
+      dimension strcon(9),strgrp(9),strkin(9)
+
+      save newjob,volm0,elrc0,virlrc0,cell0,dens0,igrp1,igrp2
+      save ifre1,ifre2
+      
+      data newjob/.true./,beta/7.3728d-3/
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(12))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(13))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(14))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(15))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1530)
+      enddo
+     
+      if(newjob) then
+
+c     store initial values of volume and long range corrections
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1540)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+
+c     constraint stress tensor accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+      
+c     current cell vectors
+      
+      do i=1,9
+        czero(i)=cell(i)
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+      
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1 
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacements
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     estimate velocity and temperature at half-time step
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+        vxx(i)=vxo(j)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+pt5*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     kinetic energy of free atoms
+
+      engfke=getkinf(ntfree,idnode,mxnode)
+
+c     estimate kinetic energy of rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+c     calculate net force on rigid body
+        
+        fmx(jg)=0.d0
+        fmy(jg)=0.d0
+        fmz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx(jg)=fmx(jg)+fxx(i)
+          fmy(jg)=fmy(jg)+fyy(i)
+          fmz(jg)=fmz(jg)+fzz(i)
+          
+        enddo
+
+c     centre of mass velocities at half-step
+        
+        gvxx(ig)=gvxo(jg)+pt5*tstep*fmx(jg)/gmass(id)
+        gvyy(ig)=gvyo(jg)+pt5*tstep*fmy(jg)/gmass(id)
+        gvzz(ig)=gvzo(jg)+pt5*tstep*fmz(jg)/gmass(id)
+
+      enddo
+
+c     translation kinetic energy of rigid bodies
+
+      engtrn=getkint(ngrp,idnode,mxnode)
+      
+c     calculate rigid body contribution to stress tensor
+
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx(jg)=0.d0
+        tqy(jg)=0.d0
+        tqz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+        
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     angular velocity at time step n (first guess)
+
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+
+c       iterate angular velocity for time step n (e. yezdimer)
+
+        do i=1,5
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     improved angular velocity at time step n
+
+          opx(jg)=omx(ig)+pt5*tstep*trx
+          opy(jg)=omy(ig)+pt5*tstep*try
+          opz(jg)=omz(ig)+pt5*tstep*trz
+
+        enddo
+
+c     store angular velocity at timestep n
+        
+        omx(ig)=opx(jg)
+        omy(ig)=opy(jg)
+        omz(ig)=opz(jg)
+        
+      enddo
+      
+c     rigid body rotational kinetic energy
+
+      engrot=getkinr(ngrp,idnode,mxnode)
+
+c     pressure control variable - taup is the relaxation time
+
+      engke=engfke+engtrn
+      psyst=(2.d0*engke-virtot-vircon-vircom)/(3.d0*volm)
+      chip0=1.d0+beta*tstep*(psyst-press)/taup
+      scale=chip0**(1.d0/3.d0)
+      
+c     temperature scaling  coefficient - taut is the relaxation time
+      
+      engtot=engke+engrot
+      chit0= sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+
+c     begin iterations !!-----------------------------------------------
+
+      mxiter=5
+      if(ntcons.eq.0) mxiter=mxiter-1
+      
+      do iter=1,mxiter
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     advance velocity using leapfrog
+
+          uxx(i)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(i)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(i)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+
+c     update positions
+          
+          xxx(i)=tstep*uxx(i)+scale*xxo(j)
+          yyy(i)=tstep*uyy(i)+scale*yyo(j)
+          zzz(i)=tstep*uzz(i)+scale*zzo(j)
+
+        enddo
+
+c     estimate new cell tensor
+
+        do i=1,9
+          cell(i)=scale*czero(i)
+        enddo
+
+        if(ntcons.eq.0) safe=.true.
+        if(ntcons.gt.0) then
+
+c     store integrated positions
+
+          j=0
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     contribution to constraint virial 
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate force correction
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do ifre=ifre1,ifre2
+            
+            j=j+1
+            i=lstfre(ifre)
+
+c     calculate force correction
+        
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+
+c     calculate velocity correction
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+            
+          enddo
+
+c     end of shake corrections
+          
+        endif
+
+c     estimate full step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+          
+        enddo
+        
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        if(iter.eq.mxiter)call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore free atom half step velocity
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          vxx(i)=uxx(i)
+          vyy(i)=uyy(i)
+          vzz(i)=uzz(i)
+          
+        enddo
+        
+c     ********: rigid body motion - thermostated  :************
+
+c     ***** step 1 : integrate centre of mass motion *********
+        
+        jg =0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     calculate thermostated velocities
+          
+          rgmas=1.d0/gmass(id)
+          uxx(ig)=(gvxo(jg)+tstep*(fmx(jg)*rgmas))*chit0
+          uyy(ig)=(gvyo(jg)+tstep*(fmy(jg)*rgmas))*chit0
+          uzz(ig)=(gvzo(jg)+tstep*(fmz(jg)*rgmas))*chit0
+
+c     update positions : 
+          
+          gcmx(ig)=scale*gcxo(jg)+tstep*uxx(ig)
+          gcmy(ig)=scale*gcyo(jg)+tstep*uyy(ig)
+          gcmz(ig)=scale*gczo(jg)+tstep*uzz(ig)
+          
+c     calculate full step velocities
+          
+          gvxx(ig)=0.5d0*(gvxo(jg)+uxx(ig))
+          gvyy(ig)=0.5d0*(gvyo(jg)+uyy(ig))
+          gvzz(ig)=0.5d0*(gvzo(jg)+uzz(ig))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+        if(iter.eq.mxiter)call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocities 
+
+        do ig=igrp1,igrp2
+
+          gvxx(ig)=uxx(ig)
+          gvyy(ig)=uyy(ig)
+          gvzz(ig)=uzz(ig)
+          
+        enddo
+        
+c     ****** step 2 : integrate rotational motion **********
+        
+        jg=0
+        safeq=.true.
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     scaled angular velocity at time step n
+          
+          omx(ig)=(omxo(jg)+pt5*tstep*trx)*chit0
+          omy(ig)=(omyo(jg)+pt5*tstep*try)*chit0
+          omz(ig)=(omzo(jg)+pt5*tstep*trz)*chit0
+
+c     angular velocity at time step n+1/2
+          
+          uxx(ig)=(omxo(jg)+tstep*trx)*chit0
+          uyy(ig)=(omyo(jg)+tstep*try)*chit0
+          uzz(ig)=(omzo(jg)+tstep*trz)*chit0
+
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=(omxo(jg)+1.5d0*tstep*trx)*chit0
+          oqy(jg)=(omyo(jg)+1.5d0*tstep*try)*chit0
+          oqz(jg)=(omzo(jg)+1.5d0*tstep*trz)*chit0
+
+        enddo
+        
+c     calculate rigid body rotational energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+
+c     restore half step angular velocity
+
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(ig)
+          omy(ig)=uyy(ig)
+          omz(ig)=uzz(ig)
+          
+        enddo
+        
+c     total translational kinetic energy
+      
+        engke=engtrn+engfke
+      
+c     total kinetic energy
+        
+        engtot=engke+engrot
+        
+c     improved pressure control variable
+
+        psyst=(2.d0*engke-virtot-vircon-vircom)/(3.d0*volm)
+        chip0=1.d0+beta*tstep*(psyst-press)/taup
+        scale=chip0**(1.d0/3.d0)
+        
+c     improved temperature scaling  coefficient
+        
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+        
+c     end of thermostat/barostat iterations
+
+      enddo
+
+c     scale cell vectors
+
+      scale=((chip0*volm)/volm0)**(1.d0/3.d0)
+
+      do i=1,9
+        cell(i)=scale*cell0(i)
+      enddo
+
+c     construct scaling tensor (for later!)
+
+      do i=1,9
+        eta(i)=scale*uni(i)
+      enddo
+
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     minimum images 
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+      
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+
+c     merge new atomic coordinates and velocities
+      
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+      
+      endif
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(5))
+      deallocate (fmx,fmy,fmz,tqx,tqy,tqz,stat=fail(6))
+      deallocate (omxo,omyo,omzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,gvxo,gvyo,gvzo,stat=fail(8))
+      
+      return
+      end subroutine nptq_b1
+
+      subroutine nptq_h1
+     x (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,chip,chit,consv,conint,elrc,engke,
+     x  engrot,virlrc,press,quattol,sigma,taup,taut,temp,tolnce,
+     x  tstep,virtot,vircom,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Hoover
+c     thermostat and barostat (Melchionna et al variant)
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame (input)
+c     omx,omy,omz = angular velocity in body fixed frame (principl axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,safeq,lshmov,newjob
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ntpatm,fail,i,igrp,igrp1,igrp2,ifre,ifre1,ifre2
+      integer j,k,ig,jg,jr,id,iter,mxiter,idum
+      real(8) chip,chit,consv,conint,elrc,engke,engrot,virlrc,press
+      real(8) quattol,sigma,taup,taut,temp,tolnce,tstep,virtot,vircom
+      real(8) vircon,volm,cell0,rot,volm0,elrc0,rtsq,uni
+      real(8) virlrc0,strkin,rstep,qmass,pmass,strgrp,strcon
+      real(8) trx,try,trz,chipp,chipnew,chip0,engtot,chitp
+      real(8) chitnew,chit0,volnew,scale,viracc,rgmas
+      real(8) vaa,vbb,vcc,vold,cons1,cons2,cons3,delx,dely,delz
+      real(8) engtrn,totmas,com,vom,engfke
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+
+      dimension fail(nnn),rot(9),cell0(9),uni(9)
+      dimension strkin(9),strcon(9),strgrp(9),com(3),vom(3)
+
+      save newjob,volm0,elrc0,virlrc0,cell0,dens0,pmass,qmass
+      save igrp1,igrp2,ifre1,ifre2,totmas
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(12))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(13))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(14))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(15))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1550)
+      enddo
+
+      if(newjob) then
+
+c     store initial values of volume and long range corrections
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1560)
+
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+
+c     inertia parameter for Nose-Hoover thermostat
+        
+        qmass=2.0d0*sigma*taut**2
+        pmass=2.0d0*sigma*taup**2
+        
+c     total system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+
+      safe=.false.
+
+c     temporary stress tensor accumulators
+
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+
+c     ensure total momentum is zero
+
+      call getvom(natms,idnode,mxnode,totmas,vom)
+      
+c     correction to velocities
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)-vom(1)
+        vyy(i)=vyy(i)-vom(2)
+        vzz(i)=vzz(i)-vom(3)
+
+      enddo
+
+      do ig=igrp1,igrp2
+
+        gvxx(ig)=gvxx(ig)-vom(1)
+        gvyy(ig)=gvyy(ig)-vom(2)
+        gvzz(ig)=gvzz(ig)-vom(3)
+
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+      
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacements
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     calculate centre of mass
+
+      call getcom(natms,idnode,mxnode,totmas,com)
+      
+c     estimate velocity at full step
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+        vxx(i)=vxo(j)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+pt5*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     kinetic energy of free atoms
+
+      engfke=getkinf(ntfree,idnode,mxnode)
+
+c     estimate kinetic energy of rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+c     calculate net force on rigid body
+        
+        fmx(jg)=0.d0
+        fmy(jg)=0.d0
+        fmz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx(jg)=fmx(jg)+fxx(i)
+          fmy(jg)=fmy(jg)+fyy(i)
+          fmz(jg)=fmz(jg)+fzz(i)
+          
+        enddo
+
+c     centre of mass velocities at half-step
+        
+        gvxx(ig)=gvxo(jg)+pt5*tstep*fmx(jg)/gmass(id)
+        gvyy(ig)=gvyo(jg)+pt5*tstep*fmy(jg)/gmass(id)
+        gvzz(ig)=gvzo(jg)+pt5*tstep*fmz(jg)/gmass(id)
+
+      enddo
+
+c     translation kinetic energy of rigid bodies
+
+      engtrn=getkint(ngrp,idnode,mxnode)
+      
+c     calculate rigid body contribution to stress tensor
+
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx(jg)=0.d0
+        tqy(jg)=0.d0
+        tqz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     angular velocity at time step n (first guess)
+
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+
+c       iterate angular velocity for time step n (e. yezdimer)
+
+        do i=1,5
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     improved angular velocity at time step n
+
+          opx(jg)=omx(ig)+pt5*tstep*trx
+          opy(jg)=omy(ig)+pt5*tstep*try
+          opz(jg)=omz(ig)+pt5*tstep*trz
+          
+        enddo
+
+c     store angular velocity at timestep n
+        
+        omx(ig)=opx(jg)
+        omy(ig)=opy(jg)
+        omz(ig)=opz(jg)
+        
+      enddo
+      
+c     rigid body rotational kinetic energy
+
+      engrot=getkinr(ngrp,idnode,mxnode)
+
+c     propagate chip
+
+      engke=engfke+engtrn
+      chipp=(2.d0*engke-virtot-vircon-vircom-3.d0*press*volm)/pmass-
+     x  chit*chip
+      chipnew=chip+tstep*chipp
+      chip0=0.5d0*(chip+chipnew)
+
+c     propagate chit
+
+      engtot=engke+engrot
+      chitp=(2.d0*(engtot-sigma)+pmass*chip0**2-boltz*temp)/qmass
+      chitnew=chit+tstep*chitp
+      chit0=0.5d0*(chit+chitnew)
+
+c     begin iterations !!-----------------------------------------------
+
+      mxiter=5
+      if(ntcons.eq.0) mxiter=mxiter-1
+      
+      do iter=1,mxiter
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     advance velocity using leapfrog
+
+          uxx(i)=vxo(j)+tstep*(fxx(i)*rmass(i)-(chit0+chip0)*vxx(i))
+          uyy(i)=vyo(j)+tstep*(fyy(i)*rmass(i)-(chit0+chip0)*vyy(i))
+          uzz(i)=vzo(j)+tstep*(fzz(i)*rmass(i)-(chit0+chip0)*vzz(i))
+
+c     advance positions using leapfrog
+
+          xxx(i)=xxo(j)+tstep*(uxx(i)+
+     x      chipnew*((xxx(i)+xxo(j))*0.5d0-com(1)))
+          yyy(i)=yyo(j)+tstep*(uyy(i)+
+     x      chipnew*((yyy(i)+yyo(j))*0.5d0-com(2)))
+          zzz(i)=zzo(j)+tstep*(uzz(i)+
+     x      chipnew*((zzz(i)+zzo(j))*0.5d0-com(3)))
+
+        enddo
+
+c     estimate new cell parameters
+
+        volnew=volm*exp(3.d0*tstep*chipnew)
+        scale=(volnew/volm0)**(1.d0/3.d0)
+        do i=1,9
+          cell(i)=cell0(i)*scale
+        enddo
+        
+        if(ntcons.eq.0) safe=.true.
+        if(ntcons.gt.0) then
+
+c     store integrated positions
+
+          j=0
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     contribution to constraint virial 
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     calculate force correction
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do ifre=ifre1,ifre2
+            
+            j=j+1
+            i=lstfre(ifre)
+            
+c     calculate force correction
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+
+c     calculate velocity correction
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+            
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+
+c     estimate full step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+          
+        enddo
+        
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        if(iter.eq.mxiter)then
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)
+          
+c     restore free atom half step velocity
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            vxx(i)=uxx(i)
+            vyy(i)=uyy(i)
+            vzz(i)=uzz(i)
+            
+          enddo
+        
+        endif
+        
+c     ********: rigid body motion - thermostated  :***********
+
+c     ***** step 1 : integrate centre of mass motion *********
+        
+        jg =0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     calculate thermostated velocities
+          
+          rgmas=1.d0/gmass(id)
+          uxx(ig)=gvxo(jg)+tstep*(fmx(jg)*rgmas-(chit0+chip0)*
+     x      gvxx(ig))
+          uyy(ig)=gvyo(jg)+tstep*(fmy(jg)*rgmas-(chit0+chip0)*
+     x      gvyy(ig))
+          uzz(ig)=gvzo(jg)+tstep*(fmz(jg)*rgmas-(chit0+chip0)*
+     x      gvzz(ig))
+
+c     advance positions using leapfrog
+
+          gcmx(ig)=gcxo(jg)+tstep*(uxx(ig)+
+     x      chipnew*((gcmx(ig)+gcxo(jg))*0.5d0-com(1)))
+          gcmy(ig)=gcyo(jg)+tstep*(uyy(ig)+
+     x      chipnew*((gcmy(ig)+gcyo(jg))*0.5d0-com(2)))
+          gcmz(ig)=gczo(jg)+tstep*(uzz(ig)+
+     x      chipnew*((gcmz(ig)+gczo(jg))*0.5d0-com(3)))
+          
+c     calculate full step velocities
+          
+          gvxx(ig)=0.5d0*(gvxo(jg)+uxx(ig))
+          gvyy(ig)=0.5d0*(gvyo(jg)+uyy(ig))
+          gvzz(ig)=0.5d0*(gvzo(jg)+uzz(ig))
+          
+        enddo
+
+c     calculate kinetic energy and stress tensor
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+        if(iter.eq.mxiter)call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocities 
+
+        do ig=igrp1,igrp2
+
+          gvxx(ig)=uxx(ig)
+          gvyy(ig)=uyy(ig)
+          gvzz(ig)=uzz(ig)
+          
+        enddo
+        
+c     ****** step 2 : integrate rotational motion **********
+        
+        jg=0
+        safeq=.true.
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+          
+c     correction due to thermostat
+
+          delx=tstep*(trx-chit0*pt5*(omx(ig)+omxo(jg)))
+          dely=tstep*(try-chit0*pt5*(omy(ig)+omyo(jg)))
+          delz=tstep*(trz-chit0*pt5*(omz(ig)+omzo(jg)))
+
+c     angular velocity at time step n
+          
+          omx(ig)=omxo(jg)+delx*pt5
+          omy(ig)=omyo(jg)+dely*pt5
+          omz(ig)=omzo(jg)+delz*pt5
+
+c     angular velocity at time step n+1/2
+          
+          uxx(ig)=omxo(jg)+delx
+          uyy(ig)=omyo(jg)+dely
+          uzz(ig)=omzo(jg)+delz
+
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+
+        enddo
+
+c     calculate rigid body rotational energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+
+c     restore half step angular velocity
+
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(ig)
+          omy(ig)=uyy(ig)
+          omz(ig)=uzz(ig)
+          
+        enddo
+        
+c     improved prediction of chip
+
+        engke=engfke+engtrn
+        chipp=(2.d0*engke-virtot-vircom-vircon-3.d0*press*volm)/pmass-
+     x    chit0*chip0
+        chipnew=chip+tstep*chipp
+        chip0=0.5d0*(chip+chipnew)
+
+c     improved prediction of chit
+        
+        engtot=engke+engrot
+        chitp=(2.d0*(engtot-sigma)+pmass*chip0**2-boltz*temp)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=0.5d0*(chit+chitnew)
+
+c     end of thermostat iterations
+
+      enddo
+
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     minimum images
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+c     update volume
+
+      vold=volm
+      volm=volm*exp(3.d0*tstep*chipnew)
+
+c     scale cell vectors - isotropic
+
+      scale=(volm/volm0)**(1.d0/3.d0)
+      do i=1,9
+        cell(i)=cell0(i)*scale
+      enddo
+
+c     construct scaling tensor (for later!)
+
+      do i=1,9
+        eta(i)=chipnew*uni(i)
+      enddo
+
+c     update thermostat and barostat variables
+
+      chit=chitnew
+      chip=chipnew
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     conserved quantity less kinetic and potential energy terms
+      
+      conint=conint+tstep*chit0*(qmass/taut**2+boltz*temp)
+      cons1=0.5d0*qmass*chit0**2
+      cons2=press*vold
+      cons3=0.5d0*pmass*chip0**2
+      consv=conint+cons1+cons2+cons3
+
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+      
+c     merge new atomic coordinates and velocities
+      
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+      
+      endif
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(5))
+      deallocate (fmx,fmy,fmz,tqx,tqy,tqz,stat=fail(6))
+      deallocate (omxo,omyo,omzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,gvxo,gvyo,gvzo,stat=fail(8))
+      
+      return
+      end subroutine nptq_h1
+
+      subroutine nstq_b1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,mode,elrc,engke,engrot,virlrc,press,
+     x  quattol,sigma,taup,taut,tolnce,tstep,vircom,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Berendsen
+c     thermostat and barostat. (cell may change shape).
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame (input)
+c     omx,omy,omz = angular velocity in body fixed frame (principl axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,lshmov,newjob,safeq
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ntpatm,fail,i,idum,igrp,igrp1,igrp2,ifre,ifre1,mode
+      integer ifre2,j,k,ig,jg,jr,id,iter,mxiter
+      real(8) elrc,engke,engrot,virlrc,press,quattol,sigma,taup,taut
+      real(8) tolnce,tstep,vircom,vircon,volm,beta,uni,cell0
+      real(8) volm0,elrc0,virlrc0,rot,rstep,rtsq,engfke
+      real(8) engtrn,trx,try,trz,engtot,chit0,rgmas
+      real(8) vaa,vbb,vcc,viracc,strkin,strcon,strgrp,stres0
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+
+      dimension strkin(9),strcon(9),strgrp(9),stres0(9),rot(9)
+      dimension fail(nnn),uni(9),cell0(9)
+
+      save newjob,volm0,elrc0,virlrc0,dens0
+      save igrp1,igrp2,ifre1,ifre2
+
+      data newjob/.true./, beta/7.3728d-3/
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxxdf),yyo(mxxdf),zzo(mxxdf),stat=fail(9))
+      allocate (xx1(mxxdf),yy1(mxxdf),zz1(mxxdf),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(12))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(13))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(14))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(15))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1570)
+      enddo
+
+      if(newjob) then
+
+c     store initial values of volume, long range corrections etc
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1580)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe= (igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        newjob=.false.
+
+      endif
+      
+      safe=.false.
+      
+c     temporary stress tensor accumulators and new cell
+
+      vircon=0.d0
+      do i=1,9
+
+        strcns(i)=0.d0
+        cell0(i)=cell(i)
+        stres0(i)=stress(i)
+
+      enddo
+
+c     store initial values of position and velocity
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+
+      enddo
+
+c     construct current bond vectors - required by shake
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+      
+      endif
+      
+c     calculate atom displacement from coms
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1 
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     estimate velocity at half-time step
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+        vxx(i)=vxo(j)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+pt5*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     estimate kinetic energy of free atoms
+
+      engfke=getkinf(ntfree,idnode,mxnode)
+
+c     stress tensor of free atoms
+
+      call kinstressf(ntfree,idnode,mxnode,strkin)
+
+c     estimate translational kinetic energy of rigid bodies
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+c     calculate net force on rigid body
+        
+        fmx(jg)=0.d0
+        fmy(jg)=0.d0
+        fmz(jg)=0.d0
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+
+c     forces on centre of mass
+          
+          fmx(jg)=fmx(jg)+fxx(i)
+          fmy(jg)=fmy(jg)+fyy(i)
+          fmz(jg)=fmz(jg)+fzz(i)
+          
+        enddo
+
+c     centre of mass velocities at half-step
+        
+        gvxx(ig)=gvxo(jg)+pt5*tstep*fmx(jg)/gmass(id)
+        gvyy(ig)=gvyo(jg)+pt5*tstep*fmy(jg)/gmass(id)
+        gvzz(ig)=gvzo(jg)+pt5*tstep*fmz(jg)/gmass(id)
+        
+      enddo
+
+c     translational kinetic energy of rigid body
+      
+      engtrn=getkint(ngrp,idnode,mxnode)
+      
+c     stress tensor of rigid body
+      
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+      
+c     calculate rigid body contribution to stress tensor
+
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     calculate torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx(jg)=0.d0
+        tqy(jg)=0.d0
+        tqz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+c     angular velocity at time step n (first guess)
+
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+
+c       iterate angular velocity for time step n (e. yezdimer)
+
+        do i=1,5
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     improved angular velocity at time step n
+
+          opx(jg)=omx(ig)+pt5*tstep*trx
+          opy(jg)=omy(ig)+pt5*tstep*try
+          opz(jg)=omz(ig)+pt5*tstep*trz
+
+        enddo
+
+c     store angular velocity at timestep n
+        
+        omx(ig)=opx(jg)
+        omy(ig)=opy(jg)
+        omz(ig)=opz(jg)
+        
+      enddo
+
+c     calculate rotational kinetic energy of rigid bodies
+
+      engrot=getkinr(ngrp,idnode,mxnode)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stres0(i)+strkin(i)+strgrp(i)+strbod(i)
+      enddo
+      
+c     find eta - taup is the relaxation time
+
+      do i=1,9
+        eta(i)=beta*tstep/taup*(stress(i)/volm-press*uni(i))+uni(i)
+      enddo
+      if(mode.gt.0)then
+        eta(3)=0.d0
+        eta(6)=0.d0
+        eta(7)=0.d0
+        eta(8)=0.d0
+        if(mode.lt.3)then
+          eta(2)=0.d0
+          eta(4)=0.d0
+          if(mode.eq.2)then
+            eta(1)=0.5d0*(eta(1)+eta(5))
+            eta(5)=eta(1)
+          endif
+        endif
+      endif
+
+c     temperature scaling  coefficient - taut is the relaxation time
+      
+      engke=engfke+engtrn
+      engtot=engke+engrot
+      chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+      
+c     begin iterations !!-----------------------------------------------
+
+      mxiter=5
+      if(ntcons.eq.0) mxiter=mxiter-1
+      
+      do iter=1,mxiter
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     advance velocity using leapfrog
+
+          uxx(i)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(i)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(i)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+
+c     update positions
+          
+          xxx(i)=tstep*uxx(i)+eta(1)*xxo(j)+eta(4)*yyo(j)+eta(7)*zzo(j)
+          yyy(i)=tstep*uyy(i)+eta(2)*xxo(j)+eta(5)*yyo(j)+eta(8)*zzo(j)
+          zzz(i)=tstep*uzz(i)+eta(3)*xxo(j)+eta(6)*yyo(j)+eta(9)*zzo(j)
+
+        enddo
+
+c     estimate new cell tensor
+
+        call mat_mul(eta,cell0,cell)
+
+        if(ntcons.eq.0) safe=.true.
+        if(ntcons.gt.0) then
+
+c     store integrated positions
+
+          j=0
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+          
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     contribution to constraint virial 
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            
+c     calculate force correction
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+c     calculate velocity correction
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+          enddo
+
+c     end of shake corrections
+          
+        endif
+
+c     estimate full step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+          
+        enddo
+        
+c     calculate new kinetic energy 
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     calculate current stress tensor
+
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+
+c     restore half step velocity
+          
+        if(iter.eq.mxiter)then
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            vxx(i)=uxx(i)
+            vyy(i)=uyy(i)
+            vzz(i)=uzz(i)
+            
+          enddo
+          
+        endif
+        
+c     ********: rigid body motion - thermostated  :***********
+
+c     ***** step 1 : integrate centre of mass motion *********
+        
+        jg =0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     calculate thermostated velocities
+          
+          rgmas=1.d0/gmass(id)
+          uxx(ig)=(gvxo(jg)+tstep*(fmx(jg)*rgmas))*chit0
+          uyy(ig)=(gvyo(jg)+tstep*(fmy(jg)*rgmas))*chit0
+          uzz(ig)=(gvzo(jg)+tstep*(fmz(jg)*rgmas))*chit0
+
+c     update positions : 
+
+          gcmx(ig)=tstep*uxx(ig)+eta(1)*gcxo(jg)+eta(4)*gcyo(jg)+
+     x      eta(7)*gczo(jg)
+          gcmy(ig)=tstep*uyy(ig)+eta(2)*gcxo(jg)+eta(5)*gcyo(jg)+
+     x      eta(8)*gczo(jg)
+          gcmz(ig)=tstep*uzz(ig)+eta(3)*gcxo(jg)+eta(6)*gcyo(jg)+
+     x      eta(9)*gczo(jg)
+
+c     full step com velocity
+
+          gvxx(ig)=0.5d0*(gvxo(jg)+uxx(ig))
+          gvyy(ig)=0.5d0*(gvyo(jg)+uyy(ig))
+          gvzz(ig)=0.5d0*(gvzo(jg)+uzz(ig))
+          
+        enddo
+
+c     calculate rigid body kinetic energy and stress tensor
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+c     restore half step velocity
+
+        do ig=igrp1,igrp2
+
+          gvxx(ig)=uxx(ig)
+          gvyy(ig)=uyy(ig)
+          gvzz(ig)=uzz(ig)
+
+        enddo
+
+c     ****** step 2 : integrate rotational motion **********
+        
+        jg=0
+        safeq=.true.
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     scaled angular velocity at time step n
+            
+          omx(ig)=(omxo(jg)+pt5*tstep*trx)*chit0
+          omy(ig)=(omyo(jg)+pt5*tstep*try)*chit0
+          omz(ig)=(omzo(jg)+pt5*tstep*trz)*chit0
+
+c     angular velocity at time step n+1/2
+          
+          uxx(ig)=(omxo(jg)+tstep*trx)*chit0
+          uyy(ig)=(omyo(jg)+tstep*try)*chit0
+          uzz(ig)=(omzo(jg)+tstep*trz)*chit0
+
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=(omxo(jg)+1.5d0*tstep*trx)*chit0
+          oqy(jg)=(omyo(jg)+1.5d0*tstep*try)*chit0
+          oqz(jg)=(omzo(jg)+1.5d0*tstep*trz)*chit0
+
+        enddo
+        
+c     rotational kinetic energy
+
+        engrot=getkinr(ngrp,idnode,mxnode)
+
+c     restore half step angular velocity
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(ig)
+          omy(ig)=uyy(ig)
+          omz(ig)=uzz(ig)
+
+        enddo
+        
+c     complete stress tensor - add all contributions
+
+        do i=1,9
+          stress(i)=stres0(i)+strkin(i)+strgrp(i)+strbod(i)+strcns(i)
+        enddo
+
+c     improved prediction of eta and chit 
+
+        do i=1,9
+          eta(i)=beta*tstep/taup*(stress(i)/volm-press*uni(i))+uni(i)
+        enddo
+        if(mode.gt.0)then
+          eta(3)=0.d0
+          eta(6)=0.d0
+          eta(7)=0.d0
+          eta(8)=0.d0
+          if(mode.lt.3)then
+            eta(2)=0.d0
+            eta(4)=0.d0
+            if(mode.eq.2)then
+              eta(1)=0.5d0*(eta(1)+eta(5))
+              eta(5)=eta(1)
+            endif
+          endif
+        endif
+
+        engke=engfke+engtrn
+        engtot=engke+engrot
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+
+c     end of thermostat/barostat iterations
+
+      enddo
+
+c     update cell vectors
+
+      call mat_mul(eta,cell0,cell)
+
+c     update volume
+      
+      volm=volm*eta(1)*eta(5)*eta(9)
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     minimum images 
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+      
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+      
+c     merge new atomic coordinates and velocities
+      
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+      
+      endif
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     deallocate work arrays
+
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(5))
+      deallocate (fmx,fmy,fmz,tqx,tqy,tqz,stat=fail(6))
+      deallocate (omxo,omyo,omzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,gvxo,gvyo,gvzo,stat=fail(8))
+      
+      return
+      end subroutine nstq_b1
+
+      subroutine nstq_h1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,mode,chit,conint,consv,elrc,engke,engrot,
+     x  virlrc,press,quattol,sigma,taup,taut,temp,tolnce,tstep,
+     x  vircom,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - verlet leapfrog with Hoover like
+c     thermostat and barostat. (cell may change shape).
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame (input)
+c     omx,omy,omz = angular velocity in body fixed frame (principle axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june  1995
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,lshmov,newjob,safeq
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ntpatm,fail,i,igrp,igrp1,igrp2,ifre,ifre1,ifre2
+      integer j,k,ig,jg,jr,id,iter,mxiter,idum,mode
+      real(8) chit,conint,consv,elrc,engke,engrot,virlrc,press,quattol
+      real(8) sigma,taup,taut,temp,tolnce,tstep,vircom,vircon,volm
+      real(8) strkin,strcon,strgrp,eta0,etanew,rot,cell0,volm0,stres0
+      real(8) elrc0,virlrc0,rstep,rtsq,qmass,pmass,totmas
+      real(8) engtrn,trx,try,trz,engtot,engfke,fac,etadot
+      real(8) chitp,chitnew,chit0,xxa,yya,zza,viracc,rgmas,uni
+      real(8) delx,dely,delz,vold,cons1,cons2,cons3
+      real(8) vaa,vbb,vcc,chip,com,vom
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+
+      dimension eta0(9),etanew(9),rot(9),cell0(9),fail(nnn),uni(9)
+      dimension strkin(9),strcon(9),strgrp(9),stres0(9),com(3),vom(3)
+      
+      save newjob,volm0,elrc0,virlrc0,dens0,pmass,qmass,totmas
+      save igrp1,igrp2,ifre1,ifre2
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(12))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(13))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(14))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(15))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1590)
+      enddo
+
+      if(newjob) then
+        
+c     store initial values of volume, long range corrections etc
+      
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1600)
+
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     inertia parameter for Nose-Hoover thermostat
+        
+        qmass=2.0d0*sigma*taut**2
+        pmass=2.0d0*sigma*taup**2
+
+c     calculate total system mass 
+
+        totmas=getmass(natms,idnode,mxnode)
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      
+c     initialise stress tensor accumulators
+
+      vircon=0.d0
+
+      do i=1,9
+
+        strcns(i)=0.d0
+        cell0(i)=cell(i)
+        stres0(i)=stress(i)
+        
+      enddo
+
+c     ensure total momentum is zero
+      
+      call getvom(natms,idnode,mxnode,totmas,vom)
+
+c     correction to velocities
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)-vom(1)
+        vyy(i)=vyy(i)-vom(2)
+        vzz(i)=vzz(i)-vom(3)
+
+      enddo
+
+      do ig=igrp1,igrp2
+
+        gvxx(ig)=gvxx(ig)-vom(1)
+        gvyy(ig)=gvyy(ig)-vom(2)
+        gvzz(ig)=gvzz(ig)-vom(3)
+
+      enddo
+
+c     store initial values of position and velocity
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        
+      enddo
+
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+      
+      endif
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1 
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+
+c     calculate centre of mass
+      
+      call getcom(natms,idnode,mxnode,totmas,com)
+      
+c     estimate velocity at full step
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+
+        vxx(i)=vxo(j)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyo(j)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzo(j)+pt5*tstep*rmass(i)*fzz(i)
+        
+      enddo
+      
+c     estimate kinetic energy
+        
+      engfke=getkinf(ntfree,idnode,mxnode)
+
+c     estimate stress tensor
+      
+      call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     estimate rigid body translational kinetic energy
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+
+c     calculate net force on rigid body
+        
+        fmx(jg)=0.d0
+        fmy(jg)=0.d0
+        fmz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx(jg)=fmx(jg)+fxx(i)
+          fmy(jg)=fmy(jg)+fyy(i)
+          fmz(jg)=fmz(jg)+fzz(i)
+          
+        enddo
+
+c     centre of mass velocities at half-step
+        
+        gvxx(ig)=gvxo(jg)+pt5*tstep/gmass(id)*fmx(jg)
+        gvyy(ig)=gvyo(jg)+pt5*tstep/gmass(id)*fmy(jg)
+        gvzz(ig)=gvzo(jg)+pt5*tstep/gmass(id)*fmz(jg)
+
+      enddo
+      
+c     rigid body translational kinetic energy
+        
+      engtrn=getkint(ngrp,idnode,mxnode)
+
+c     rigid body stress tensor
+        
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+      
+c     calculate rgid body contribution to stress tensor
+      
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx(jg)=0.d0
+        tqy(jg)=0.d0
+        tqz(jg)=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     angular velocity at time step n (first guess)
+
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+
+c       iterate angular velocity for time step n (e. yezdimer)
+
+        do i=1,5
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     improved angular velocity at time step n
+
+          opx(jg)=omx(ig)+pt5*tstep*trx
+          opy(jg)=omy(ig)+pt5*tstep*try
+          opz(jg)=omz(ig)+pt5*tstep*trz
+
+        enddo
+
+c     store angular velcoity at timestep n
+        
+        omx(ig)=opx(jg)
+        omy(ig)=opy(jg)
+        omz(ig)=opz(jg)
+        
+      enddo
+
+c     calculate rotational kinetic energy of rigid bodies
+
+      engrot=getkinr(ngrp,idnode,mxnode)
+
+c     complete stress tensor
+
+      do i=1,9
+        stress(i)=stres0(i)+strkin(i)+strgrp(i)+strbod(i)
+      enddo
+      
+c     propagate eta
+      
+      fac=9.d0
+      do i=1,9
+        etanew(i)=eta(i)+tstep*((stress(i)-press*volm*uni(i))/pmass-
+     x    chit*eta(i))
+      enddo
+      if(mode.gt.0)then
+        fac=5.d0
+        etanew(3)=0.d0
+        etanew(6)=0.d0
+        etanew(7)=0.d0
+        etanew(8)=0.d0
+        if(mode.lt.3)then
+          fac=3.d0
+          etanew(2)=0.d0
+          etanew(4)=0.d0
+          if(mode.eq.2)then
+            fac=2.d0
+            etanew(1)=0.5d0*(etanew(1)+etanew(5))
+            etanew(5)=etanew(1)
+          endif
+        endif
+      endif
+      do i=1,9
+        eta0(i)=0.5d0*(etanew(i)+eta(i)) 
+      enddo
+
+c     propagate chit
+      
+      engke=engfke+engtrn
+      engtot=engke+engrot
+      etadot=sdot0(9,eta0,eta0)
+      if(mode.eq.2)etadot=etadot-eta0(1)**2
+      chitp=(2.d0*(engtot-sigma)+pmass*etadot-fac*boltz*temp)/qmass
+      chitnew=chit+tstep*chitp
+      chit0=0.5d0*(chit+chitnew)
+
+c     begin iterations !!-----------------------------------------------
+
+      mxiter=5
+      if(ntcons.eq.0) mxiter=mxiter-1
+      
+      do iter=1,mxiter
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+
+c     advance velocity using leapfrog
+
+          uxx(i)=vxo(j)+tstep*(fxx(i)*rmass(i)-
+     x      (chit0+eta0(1))*vxx(i)-eta0(4)*vyy(i)-eta0(7)*vzz(i))
+          uyy(i)=vyo(j)+tstep*(fyy(i)*rmass(i)-
+     x      eta0(2)*vxx(i)-(eta0(5)+chit0)*vyy(i)-eta0(8)*vzz(i))
+          uzz(i)=vzo(j)+tstep*(fzz(i)*rmass(i)-
+     x      eta0(3)*vxx(i)-eta0(6)*vyy(i)-(eta0(9)+chit0)*vzz(i))
+
+c     advance positions using leapfrog
+
+          xxa=(xxx(i)+xxo(j))*0.5d0-com(1)
+          yya=(yyy(i)+yyo(j))*0.5d0-com(2)
+          zza=(zzz(i)+zzo(j))*0.5d0-com(3)
+
+          xxx(i)=xxo(j)+tstep*(uxx(i)+
+     x      eta0(1)*xxa+eta0(4)*yya+eta0(7)*zza)
+          yyy(i)=yyo(j)+tstep*(uyy(i)+
+     x      eta0(2)*xxa+eta0(5)*yya+eta0(8)*zza)
+          zzz(i)=zzo(j)+tstep*(uzz(i)+
+     x      eta0(3)*xxa+eta0(6)*yya+eta0(9)*zza)
+          
+        enddo
+
+c     estimate new cell parameters
+        
+        do i=1,9
+          cell(i)=cell0(i)
+        enddo
+        call cell_propagate(tstep,cell,etanew)
+
+        if(ntcons.eq.0) safe=.true.
+        if(ntcons.gt.0) then
+
+c     store integrated positions
+
+          j=0
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+            xx1(j)=xxx(i)
+            yy1(j)=yyy(i)
+            zz1(j)=zzz(i)
+
+          enddo
+
+c     global exchange of configuration data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply constraint correction
+          
+          call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+
+c     contribution to constraint virial 
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     calculate other constraint corrections
+          
+          j=0
+          rstep=1.d0/tstep
+          rtsq=1.d0/tstep**2
+          do ifre=ifre1,ifre2
+
+            j=j+1
+            i=lstfre(ifre)
+
+c     calculate corrected velocity
+            
+            uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+            uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+            uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+
+c     calculate the corrected forces
+            
+            fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+            fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+            fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+            
+          enddo
+
+c     end of shake corrections
+          
+        endif
+        
+c     estimate velocity at the full step
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=0.5d0*(uxx(i)+vxo(j))
+          vyy(i)=0.5d0*(uyy(i)+vyo(j))
+          vzz(i)=0.5d0*(uzz(i)+vzo(j))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore free half step velocity
+          
+        if(iter.eq.mxiter)then
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            vxx(i)=uxx(i)
+            vyy(i)=uyy(i)
+            vzz(i)=uzz(i)
+            
+          enddo
+          
+        endif
+        
+c     ********: rigid body motion - thermostated  :***********
+        
+c     ***** step 1 : integrate centre of mass motion *********
+        
+        jg =0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     calculate thermostated velocities
+          
+          rgmas=1.d0/gmass(id)
+          uxx(ig)=gvxo(jg)+tstep*(fmx(jg)*rgmas-
+     x      (chit0+eta0(1))*gvxx(ig)-eta0(4)*gvyy(ig)-eta0(7)*gvzz(ig))
+          uyy(ig)=gvyo(jg)+tstep*(fmy(jg)*rgmas-
+     x      eta0(2)*gvxx(ig)-(eta0(5)+chit0)*gvyy(ig)-eta0(8)*gvzz(ig))
+          uzz(ig)=gvzo(jg)+tstep*(fmz(jg)*rgmas-
+     x      eta0(3)*gvxx(ig)-eta0(6)*gvyy(ig)-(eta0(9)+chit0)*gvzz(ig))
+
+c     advance positions using leapfrog
+
+          xxa=(gcmx(ig)+gcxo(jg))*0.5d0-com(1)
+          yya=(gcmy(ig)+gcyo(jg))*0.5d0-com(2)
+          zza=(gcmz(ig)+gczo(jg))*0.5d0-com(3)
+
+          gcmx(ig)=gcxo(jg)+tstep*(uxx(ig)+
+     x      eta0(1)*xxa+eta0(4)*yya+eta0(7)*zza)
+          gcmy(ig)=gcyo(jg)+tstep*(uyy(ig)+
+     x      eta0(2)*xxa+eta0(5)*yya+eta0(8)*zza)
+          gcmz(ig)=gczo(jg)+tstep*(uzz(ig)+
+     x      eta0(3)*xxa+eta0(6)*yya+eta0(9)*zza)
+
+c     full step com velocity
+
+          gvxx(ig)=0.5d0*(gvxo(jg)+uxx(ig))
+          gvyy(ig)=0.5d0*(gvyo(jg)+uyy(ig))
+          gvzz(ig)=0.5d0*(gvzo(jg)+uzz(ig))
+          
+        enddo
+
+c     calculate rigid body kinetic energy and stress tensor
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+c     restore half step velocity
+
+        if(iter.eq.mxiter)then
+          
+          do ig=igrp1,igrp2
+            
+            gvxx(ig)=uxx(ig)
+            gvyy(ig)=uyy(ig)
+            gvzz(ig)=uzz(ig)
+            
+          enddo
+          
+        endif
+        
+c     ****** step 2 : integrate rotational motion **********
+        
+        jg=0
+        safeq=.true.
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+          trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x      rotinx(id,2)
+     x     +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x      rotinx(id,2)
+          try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x      rotiny(id,2)
+     x     +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x      rotiny(id,2)
+          trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x      rotinz(id,2)
+     x     +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x      rotinz(id,2)
+
+c     correction due to thermostat
+
+          delx=tstep*(trx-chit0*pt5*(omx(ig)+omxo(jg)))
+          dely=tstep*(try-chit0*pt5*(omy(ig)+omyo(jg)))
+          delz=tstep*(trz-chit0*pt5*(omz(ig)+omzo(jg)))
+
+c     angular velocity at time step n
+          
+          omx(ig)=omxo(jg)+delx*pt5
+          omy(ig)=omyo(jg)+dely*pt5
+          omz(ig)=omzo(jg)+delz*pt5
+
+c     angular velocity at time step n+1/2
+          
+          uxx(ig)=omxo(jg)+delx
+          uyy(ig)=omyo(jg)+dely
+          uzz(ig)=omzo(jg)+delz
+
+c     angular velocity at time step n+1  (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+
+        enddo
+        
+c     rotational kinetic energy
+
+        engrot=getkinr(ngrp,idnode,mxnode)
+
+c     restore half step angular velocity
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(ig)
+          omy(ig)=uyy(ig)
+          omz(ig)=uzz(ig)
+
+        enddo
+        
+c     complete stress tensor - add all contributions
+
+        do i=1,9
+          stress(i)=stres0(i)+strkin(i)+strgrp(i)+strbod(i)+strcns(i)
+        enddo
+
+c     improved prediction of eta and chit 
+
+        do i=1,9
+          etanew(i)=eta(i)+tstep*((stress(i)-press*volm*uni(i))/pmass-
+     x      chit0*eta0(i))
+        enddo
+        if(mode.gt.0)then
+          etanew(3)=0.d0
+          etanew(6)=0.d0
+          etanew(7)=0.d0
+          etanew(8)=0.d0
+          if(mode.lt.3)then
+            etanew(2)=0.d0
+            etanew(4)=0.d0
+            if(mode.eq.2)then
+              etanew(1)=0.5d0*(etanew(1)+etanew(5))
+              etanew(5)=etanew(1)
+            endif
+          endif
+        endif
+        do i=1,9
+          eta0(i)=0.5d0*(etanew(i)+eta(i)) 
+        enddo
+
+        engke=engfke+engtrn
+        engtot=engke+engrot
+        etadot=sdot0(9,eta0,eta0)
+        if(mode.eq.2)etadot=etadot-eta0(1)**2
+        chitp=(2.d0*(engtot-sigma)+pmass*etadot-fac*boltz*temp)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=0.5d0*(chit+chitnew)
+
+c     end of thermostat/barostat iterations
+
+      enddo
+
+c     assign new quaternions
+
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+
+c     minimum images 
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+
+        id=lstgtp(ig)
+
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x     +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x     +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x     +gcmz(ig)
+
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+
+c     update thermostat and barostat variables
+
+      chit=chitnew
+      do i=1,9
+        eta(i)=etanew(i)
+      enddo
+
+c     update volume
+      
+      chip=eta(1)+eta(5)+eta(9)
+      vold=volm
+      volm=volm*exp(tstep*chip)
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+
+c     conserved quantity less kinetic and potential energy
+      
+      conint=conint+tstep*chit0*(qmass/taut**2+fac*boltz*temp)
+      cons1=0.5d0*qmass*chit0**2
+      cons2=press*vold
+      etadot=sdot0(9,eta0,eta0)
+      if(mode.eq.2)etadot=etadot-eta0(1)**2
+      cons3=0.5d0*pmass*etadot
+      consv=conint+cons1+cons2+cons3
+      
+      if(mxnode.gt.1) then
+
+c     merge new group coordinates and velocities
+      
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+      
+c     merge new atomic coordinates and velocities
+      
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)
+     x    call merge1(idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+      
+      endif
+
+c     ensure all atoms are within cell boundaries
+
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+
+c     deallocate work arrays
+
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (xx1,yy1,zz1,vxo,vyo,vzo,stat=fail(5))
+      deallocate (fmx,fmy,fmz,tqx,tqy,tqz,stat=fail(6))
+      deallocate (omxo,omyo,omzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,gvxo,gvyo,gvzo,stat=fail(8))
+      
+      return
+      end subroutine nstq_h1
+      
+      end module lf_rotation1_module
diff -urN dl_class_1.9.orig/srcmod/lf_rotation2_module.f dl_class_1.9/srcmod/lf_rotation2_module.f
--- dl_class_1.9.orig/srcmod/lf_rotation2_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/lf_rotation2_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,5007 @@
+      module lf_rotation2_module
+      
+c***********************************************************************
+c     
+c     dl_poly module 2 for verlet leap frog rotational integration 
+c     schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use error_module
+      use lf_rotation1_module
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use utility_module
+      
+      contains
+      
+      subroutine nveq_2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,quattol,tolnce,tstep,vircom,
+     x  vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - rigid body sites and constraint sites 
+c     may coincide.
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame (input)
+c     omx,omy,omz = angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june  1995
+c     amended     w.smith nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newstep,newjob,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon
+      real(8) rot,strkin,strcon,strgrp,engfke,engtrn
+      real(8) delx,dely,delz,trx,try,trz,vaa,vbb,vcc,viracc
+      
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn)
+      
+      save newjob,igrp1,igrp2,ifre1,ifre2
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1620)
+      enddo
+      
+      if(newjob)then
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+      if(ntcons.gt.0)then
+        
+c     construct current bond vectors
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     accumulators for constraint and virial stress tensor
+      
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+      
+c     start of shake cycle
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=1
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     integrate 'free' particles
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity by leapfrog
+          
+          uxx(j)=vxo(j)+tstep*rmass(i)*fxx(i)
+          uyy(j)=vyo(j)+tstep*rmass(i)*fyy(i)
+          uzz(j)=vzo(j)+tstep*rmass(i)*fzz(i)
+          
+c     advance position by leapfrog
+          
+          xxx(i)=xxo(i)+tstep*uxx(j)
+          yyy(i)=yyo(i)+tstep*uyy(j)
+          zzz(i)=zzo(i)+tstep*uzz(j)
+          
+c     estimate full step velocities
+          
+          vxx(i)=pt5*(uxx(j)+vxo(j))
+          vyy(i)=pt5*(uyy(j)+vyo(j))
+          vzz(i)=pt5*(uzz(j)+vzo(j))
+          
+        enddo
+        
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocities
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     *************  Rigid body motion ****************************
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     advance velocity by leapfrog
+          
+          uxx(jg)=gvxo(jg)+tstep/gmass(id)*fmx(jg)
+          uyy(jg)=gvyo(jg)+tstep/gmass(id)*fmy(jg)
+          uzz(jg)=gvzo(jg)+tstep/gmass(id)*fmz(jg)
+          
+c     advance position by leapfrog
+          
+          gcmx(ig)=gcxo(jg)+tstep*uxx(jg)
+          gcmy(ig)=gcyo(jg)+tstep*uyy(jg)
+          gcmz(ig)=gczo(jg)+tstep*uzz(jg)
+          
+c     centre of mass velocities at full step
+          
+          gvxx(ig)=pt5*(uxx(jg)+gvxo(jg))
+          gvyy(ig)=pt5*(uyy(jg)+gvyo(jg))
+          gvzz(ig)=pt5*(uzz(jg)+gvzo(jg))
+
+        enddo
+        
+c     translational kinetic energy 
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocity
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          gvxx(ig)=uxx(jg)
+          gvyy(ig)=uyy(jg)
+          gvzz(ig)=uzz(jg)
+          
+        enddo
+        
+c     calculate rigid body contribution to stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+c     improved angular velocity at time step n
+            
+            delx=tstep*trx
+            dely=tstep*try
+            delz=tstep*trz
+            
+            opx(jg)=omxo(jg)+delx*pt5
+            opy(jg)=omyo(jg)+dely*pt5
+            opz(jg)=omzo(jg)+delz*pt5
+            
+          enddo
+          
+c     angular velocity at time step n+1/2
+          
+          uxx(jg)=omxo(jg)+delx
+          uyy(jg)=omyo(jg)+dely
+          uzz(jg)=omzo(jg)+delz
+          
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+          
+c     angular velocity at time step n
+          
+          omx(ig)=opx(jg)
+          omy(ig)=opy(jg)
+          omz(ig)=opz(jg)
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step angular velocity
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     minimum images of group positions and particle positions
+        
+        call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     total kinetic energy
+      
+      engke=engfke+engtrn
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     complete stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,fmx,fmy,fmz,stat=fail(5))
+      deallocate (tqx,tqy,tqz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nveq_2
+      
+      subroutine nvtq_b2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,quattol,sigma,taut,tolnce,
+     x  tstep,vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - rigid body sites and constraint sites
+c     may coincide.
+c     
+c     verlet leapfrog with Berendsen thermostat.
+c
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz=torque in lab fixed frame (input)
+c     omx,omy,omz=angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june 1995
+c     amended     w.smith nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newstep,newjob,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon,engfke
+      real(8) rot,strkin,strgrp,strcon,engtrn,trx,try,trz
+      real(8) delx,dely,delz,vaa,vbb,vcc,viracc,engtot,chit0
+      real(8) sigma,taut
+      
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn)
+      
+      save chit0,igrp1,igrp2,ifre1,ifre2,newjob
+      
+      data chit0/1.d0/,newjob/.true./
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1630)
+      enddo
+      
+      if(newjob)then
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+        
+        call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+        
+c     accumulators for constraint stress and virial
+      
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+      
+c     shake and thermostat iterations start here
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=2
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     integrate 'free' particles
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity by leapfrog
+          
+          uxx(j)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(j)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(j)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+          
+c     advance position by leapfrog
+          
+          xxx(i)=xxo(i)+tstep*uxx(j)
+          yyy(i)=yyo(i)+tstep*uyy(j)
+          zzz(i)=zzo(i)+tstep*uzz(j)
+          
+c     calculate full time velocity
+          
+          vxx(i)=pt5*(uxx(j)+vxo(j))
+          vyy(i)=pt5*(uyy(j)+vyo(j))
+          vzz(i)=pt5*(uzz(j)+vzo(j))
+          
+        enddo
+        
+c     calculate kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     calculate kinetic stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     *************  Rigid body motion ****************************
+        
+c     translational kinetic energy
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     update centre of mass velocities
+          
+          gvxx(ig)=gvxo(jg)+tstep/gmass(id)*fmx(jg)
+          gvyy(ig)=gvyo(jg)+tstep/gmass(id)*fmy(jg)
+          gvzz(ig)=gvzo(jg)+tstep/gmass(id)*fmz(jg)
+          
+        enddo
+        
+c     translational kinetic energy 
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          
+c     advance velocity by leapfrog
+          
+          gvxx(ig)=(gvxo(jg)+tstep/gmass(id)*fmx(jg))*chit0
+          gvyy(ig)=(gvyo(jg)+tstep/gmass(id)*fmy(jg))*chit0
+          gvzz(ig)=(gvzo(jg)+tstep/gmass(id)*fmz(jg))*chit0
+          
+c     advance position by leapfrog
+          
+          gcmx(ig)=gcxo(jg)+tstep*gvxx(ig)
+          gcmy(ig)=gcyo(jg)+tstep*gvyy(ig)
+          gcmz(ig)=gczo(jg)+tstep*gvzz(ig)
+          
+        enddo
+        
+c     calculate rigid body stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+c     improved angular velocity at time step n
+            
+            delx=tstep*trx
+            dely=tstep*try
+            delz=tstep*trz
+            
+            opx(jg)=(omxo(jg)+delx*pt5)
+            opy(jg)=(omyo(jg)+dely*pt5)
+            opz(jg)=(omzo(jg)+delz*pt5)
+            
+          enddo
+          
+c     scaled angular velocity at timestep n
+          
+          omx(ig)=opx(jg)*chit0
+          omy(ig)=opy(jg)*chit0
+          omz(ig)=opz(jg)*chit0
+          
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=(omxo(jg)+delx*1.5d0)*chit0
+          oqy(jg)=(omyo(jg)+dely*1.5d0)*chit0
+          oqz(jg)=(omzo(jg)+delz*1.5d0)*chit0
+          
+c     angular velocity at full time step
+          
+          uxx(jg)=(omxo(jg)+delx)*chit0
+          uyy(jg)=(omyo(jg)+dely)*chit0
+          uzz(jg)=(omzo(jg)+delz)*chit0
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step angular velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     new estimate of chit
+        
+        engke=engfke+engtrn
+        engtot=engke+engrot 
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+c     minimum images of group positions and particle positions
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+      
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x      +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x      +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x      +gcmz(ig)
+          
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+          
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+      
+      
+      if(mxnode.gt.1)then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     complete stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)+strgrp(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,tqx,tqy,tqz,stat=fail(5))
+      deallocate (fmx,fmy,fmz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nvtq_b2
+      
+      subroutine nvtq_h2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,conint,consv,chit,engke,engrot,quattol,
+     x  sigma,taut,tolnce,tstep,vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - rigid body sites and constraint sites
+c     may coincide.
+c     
+c     verlet leapfrog with Hoover thermostat.
+c
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame (input)
+c     omx,omy,omz = angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june 1995
+c     amended     w.smith nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newstep,newjob,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon,engtot
+      real(8) rot,strkin,strcon,strgrp,engtrn,engfke,trx,try,trz
+      real(8) delx,dely,delz,vaa,vbb,vcc,viracc,sigma,taut,chit0
+      real(8) chitnew,chitp,conint,consv,chit,qmass
+      
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn)
+      
+      save newjob,igrp1,igrp2,ifre1,ifre2,qmass
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1640)
+      enddo
+      
+      if(newjob)then
+        
+c     mass parameters for thermostat
+        
+        qmass=2.d0*sigma*taut**2
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atoms displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     initial thermostat variable
+      
+      chit0=chit
+      
+c     accumulators for constraint stress and virial
+      
+      vircon=0.d0
+      do i=1,9
+        strcns(i)=0.d0
+      enddo
+      
+c     shake iterations and thermostat iterations start here
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=3
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     integrate 'free' particles
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity by leapfrog
+          
+          uxx(j)=vxo(j)+tstep*(fxx(i)*rmass(i)-(chit0)*
+     x      pt5*(vxx(i)+vxo(j)))
+          uyy(j)=vyo(j)+tstep*(fyy(i)*rmass(i)-(chit0)*
+     x      pt5*(vyy(i)+vyo(j)))
+          uzz(j)=vzo(j)+tstep*(fzz(i)*rmass(i)-(chit0)*
+     x      pt5*(vzz(i)+vzo(j)))
+          
+c     advance position by leapfrog
+          
+          xxx(i)=xxo(i)+tstep*uxx(j)
+          yyy(i)=yyo(i)+tstep*uyy(j)
+          zzz(i)=zzo(i)+tstep*uzz(j)
+          
+c     estimate full step velocities
+          
+          vxx(i)=pt5*(vxo(j)+uxx(j))
+          vyy(i)=pt5*(vyo(j)+uyy(j))
+          vzz(i)=pt5*(vzo(j)+uzz(j))
+          
+        enddo
+        
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     calculate kinetic stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     *************  Rigid body motion ****************************
+        
+c     translational kinetic energy
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     advance velocity by leapfrog
+          
+          uxx(jg)=gvxo(jg)+tstep*(fmx(jg)/gmass(id)-chit0*
+     x      pt5*(gvxx(ig)+gvxo(jg)))
+          uyy(jg)=gvyo(jg)+tstep*(fmy(jg)/gmass(id)-chit0*
+     x      pt5*(gvyy(ig)+gvyo(jg)))
+          uzz(jg)=gvzo(jg)+tstep*(fmz(jg)/gmass(id)-chit0*
+     x      pt5*(gvzz(ig)+gvzo(jg)))
+          
+c     advance position by leapfrog
+          
+          gcmx(ig)=gcxo(jg)+tstep*uxx(jg)
+          gcmy(ig)=gcyo(jg)+tstep*uyy(jg)
+          gcmz(ig)=gczo(jg)+tstep*uzz(jg)
+          
+c     centre of mass velocities at half-step
+          
+          gvxx(ig)=pt5*(gvxo(jg)+uxx(jg))
+          gvyy(ig)=pt5*(gvyo(jg)+uyy(jg))
+          gvzz(ig)=pt5*(gvzo(jg)+uzz(jg))
+          
+        enddo
+        
+c     translational kinetic energy 
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocity
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          gvxx(ig)=uxx(jg)
+          gvyy(ig)=uyy(jg)
+          gvzz(ig)=uzz(jg)
+          
+        enddo
+        
+c     calculate rigid body stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+c     improved angular velocity at time step n
+            
+            opx(jg)=omxo(jg)+pt5*tstep*trx
+            opy(jg)=omyo(jg)+pt5*tstep*try
+            opz(jg)=omzo(jg)+pt5*tstep*trz
+            
+          enddo
+          
+c     correction due to thermostat
+          
+          delx=tstep*(trx-chit0*pt5*(omx(ig)+omxo(jg)))
+          dely=tstep*(try-chit0*pt5*(omy(ig)+omyo(jg)))
+          delz=tstep*(trz-chit0*pt5*(omz(ig)+omzo(jg)))
+          
+c     angular velocity at time step n
+          
+          omx(ig)=omxo(jg)+delx*pt5
+          omy(ig)=omyo(jg)+dely*pt5
+          omz(ig)=omzo(jg)+delz*pt5
+          
+c     angular velocity at time step n+1/2
+          
+          uxx(jg)=omxo(jg)+delx
+          uyy(jg)=omyo(jg)+dely
+          uzz(jg)=omzo(jg)+delz
+          
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step angular velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     new estimate of chit
+        
+        engke=engfke+engtrn
+        engtot=engke+engrot
+        chitp=2.d0*(engtot-sigma)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=pt5*(chit+chitnew)
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10.and.icyc.gt.3)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+c     minimum images of group positions and particle positions
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+      
+c     new atomic positions for atoms in rigid bodies
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x      +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x      +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x      +gcmz(ig)
+          
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+          
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     complete stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)+strgrp(i)+strbod(i)
+      enddo
+      
+c     update thermostat variable
+      
+      chit=chitnew
+      
+c     conserved quantity less kinetic and potential energy terms
+      
+      conint=conint+tstep*chit0*qmass/taut**2
+      consv=conint+pt5*qmass*chit0**2
+      
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,tqx,tqy,tqz,stat=fail(5))
+      deallocate (fmx,fmy,fmz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nvtq_h2
+      
+      subroutine nptq_b2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,elrc,engke,engrot,virlrc,press,
+     x  quattol,sigma,taup,taut,tolnce,tstep,vircom,vircon,
+     x  virtot,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - rigid body sites and constraint sites
+c     may coincide.
+c     
+c     verlet leapfrog with Berendsen thermostat and barostat.
+c     (cell may change volume)
+c
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz=torque in lab fixed frame (input)
+c     omx,omy,omz=angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june 1995
+c     amended     w.smith     sep 1999
+c     amended     w.smith     nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newstep,newjob,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc,ntpatm
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon
+      real(8) rot,strkin,strgrp,strcon,engtrn,engfke,trx,try,trz
+      real(8) delx,dely,delz,czero
+      real(8) vaa,vbb,vcc,viracc,beta,elrc,virlrc,press,engtot
+      real(8) sigma,taup,taut,virtot,volm,cell0,elrc0,virlrc0
+      real(8) chit0,volm0,chip0,psyst,scale
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn)
+      dimension cell0(9),czero(9)
+      
+      save newjob,volm0,elrc0,virlrc0,czero,chit0,chip0,dens0
+      save igrp1,igrp2,ifre1,ifre2
+      
+      data newjob/.true./
+      data beta/7.3728d-3/
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1670)
+      enddo
+      
+c     store initial values of volume and long range corrections
+      
+      if(newjob) then
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1660)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        do i=1,9
+          czero(i)=cell(i)
+        enddo
+        newjob=.false.
+        
+        chit0=1.d0
+        chip0=1.d0
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     set constraint stress and virial and inital cell vectors
+      
+      vircon=0.d0
+      do i=1,9
+        
+        strcns(i)=0.d0
+        cell0(i)=cell(i)
+        
+      enddo
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     length scaling parameter
+      
+      scale=chip0**(1.d0/3.d0)
+      
+c     shake iterations and thermostat iterations start here
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=3
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore cell vectors
+        
+        do i=1,9
+          cell(i)=cell0(i)
+        enddo
+
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     integrate 'free' particles
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity by leapfrog
+          
+          uxx(j)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(j)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(j)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+          
+c     advance position by leapfrog
+          
+          xxx(i)=xxo(i)*scale+tstep*uxx(j)
+          yyy(i)=yyo(i)*scale+tstep*uyy(j)
+          zzz(i)=zzo(i)*scale+tstep*uzz(j)
+          
+c     estimate full step velocity
+          
+          vxx(i)=pt5*(vxo(j)+uxx(j))
+          vyy(i)=pt5*(vyo(j)+uyy(j))
+          vzz(i)=pt5*(vzo(j)+uzz(j))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     calculate kinetic stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     *************  Rigid body motion ****************************
+        
+c     translational kinetic energy
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     advance velocity by leapfrog
+          
+          uxx(jg)=(gvxo(jg)+tstep/gmass(id)*fmx(jg))*chit0
+          uyy(jg)=(gvyo(jg)+tstep/gmass(id)*fmy(jg))*chit0
+          uzz(jg)=(gvzo(jg)+tstep/gmass(id)*fmz(jg))*chit0
+          
+c     advance position by leapfrog
+          
+          gcmx(ig)=gcxo(jg)*scale+tstep*uxx(jg)
+          gcmy(ig)=gcyo(jg)*scale+tstep*uyy(jg)
+          gcmz(ig)=gczo(jg)*scale+tstep*uzz(jg)
+          
+c     centre of mass velocities at full step
+          
+          gvxx(ig)=pt5*(gvxo(jg)+uxx(jg))
+          gvyy(ig)=pt5*(gvyo(jg)+uyy(jg))
+          gvzz(ig)=pt5*(gvzo(jg)+uzz(jg))
+          
+        enddo
+        
+c     translational kinetic energy 
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocity
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          gvxx(ig)=uxx(jg)
+          gvyy(ig)=uyy(jg)
+          gvzz(ig)=uzz(jg)
+          
+        enddo
+        
+c     calculate rigid body stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+            delx=tstep*trx
+            dely=tstep*try
+            delz=tstep*trz
+            
+c     improved angular velocity at time step n
+            
+            opx(jg)=(omxo(jg)+pt5*delx)
+            opy(jg)=(omyo(jg)+pt5*dely)
+            opz(jg)=(omzo(jg)+pt5*delz)
+            
+          enddo
+          
+c     scaled angular velocity at time step n
+          
+          omx(ig)=opx(jg)*chit0
+          omy(ig)=opy(jg)*chit0
+          omz(ig)=opz(jg)*chit0
+          
+c     angular velocity at time step n+1  (needed for quat algorithm)
+          
+          oqx(jg)=(omxo(jg)+delx*1.5d0)*chit0
+          oqy(jg)=(omyo(jg)+dely*1.5d0)*chit0
+          oqz(jg)=(omzo(jg)+delz*1.5d0)*chit0
+          
+c     angular velocity at time step n+1/2
+          
+          uxx(jg)=(omxo(jg)+delx)*chit0
+          uyy(jg)=(omyo(jg)+dely)*chit0
+          uzz(jg)=(omzo(jg)+delz)*chit0
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     minimum images of group positions and particle positions
+        
+        call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     pressure control variable
+        
+        engke=engfke+engtrn
+        psyst=(2.d0*engke-virtot-vircon-vircom)/(3.d0*volm)
+        chip0=1.d0+beta*tstep*(psyst-press)/taup
+        scale=chip0**(1.d0/3.d0)
+        
+c     new estimate of chit
+        
+        engtot=engke+engrot 
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+c     new cell parameters 
+          
+          do i=1,9
+            cell(i)=scale*cell0(i)
+          enddo
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+c     scale cell vectors
+      
+      scale=((chip0*volm)/volm0)**(1.d0/3.d0)
+      do i=1,9
+        cell(i)=scale*czero(i)
+      enddo
+      
+c     construct scaling tensor (for later!)
+      
+      do i=2,8
+        eta(i)=0.d0
+      enddo
+      eta(1)=scale
+      eta(5)=scale
+      eta(9)=scale
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     complete stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)+strgrp(i)+strbod(i)
+      enddo
+
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,tqx,tqy,tqz,stat=fail(5))
+      deallocate (fmx,fmy,fmz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nptq_b2
+      
+      subroutine nptq_h2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,chip,chit,consv,conint,elrc,engke,
+     x  engrot,virlrc,press,quattol,sigma,taup,taut,temp,tolnce,
+     x  tstep,vircom,vircon,virtot,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - rigid body sites and constraint sites
+c     may coincide.
+c     
+c     verlet leapfrog with Hoover thermostat and barostat. 
+c     (cell may change volume)
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz=torque in lab fixed frame (input)
+c     omx,omy,omz=angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june 1995
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newstep,newjob,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc,ntpatm
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon,com
+      real(8) rot,strkin,strcon,strgrp,vom,engtrn,trx,try,trz
+      real(8) delx,dely,delz,engfke
+      real(8) vaa,vbb,vcc,viracc,pmass,qmass,totmas,czero
+      real(8) chip,chit,consv,conint,elrc,virlrc,press,sigma,taup,taut
+      real(8) temp,virtot,cell0,volm0,elrc0,virlrc0
+      real(8) chit0,chip0,chipnew,chipp,engtot,chitnew,chitp,volnew
+      real(8) scale,volm,vold,cons1,cons2,cons3
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn)
+      dimension czero(9),cell0(9),com(3),vom(3)
+      
+      save newjob,volm0,elrc0,virlrc0,czero,dens0,pmass,qmass
+      save igrp1,igrp2,ifre1,ifre2,totmas
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1670)
+      enddo
+      
+      if(newjob) then
+        
+c     inertia parameter for Nose-Hoover thermostat
+        
+        qmass=2.0d0*sigma*taut**2
+        pmass=2.0d0*sigma*taup**2
+        
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1680)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        do i=1,9
+          czero(i)=cell(i)
+        enddo
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+c     calculate system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     ensure total momentum is zero
+      
+      call getvom(natms,idnode,mxnode,totmas,vom)
+      
+      do ifre=ifre1,ifre2
+        
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)-vom(1)
+        vyy(i)=vyy(i)-vom(2)
+        vzz(i)=vzz(i)-vom(3)
+        
+      enddo
+      
+      do ig=igrp1,igrp2
+        
+        gvxx(ig)=gvxx(ig)-vom(1)
+        gvyy(ig)=gvyy(ig)-vom(2)
+        gvzz(ig)=gvzz(ig)-vom(3)
+        
+      enddo
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+c     calculate centre of mass
+      
+      call getcom(natms,idnode,mxnode,totmas,com)
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     initial thermostat and barostat variables
+      
+      chit0=chit
+      chip0=chip
+      chipnew=chip
+      
+c     initialise constraint stress and virial
+      
+      vircon=0.d0
+      do i=1,9
+        
+        strcns(i)=0.d0
+        cell0(i)=cell(i)
+        
+      enddo
+      
+c     shake iterations and thermostat iterations start here
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=4
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore cell vectors
+        
+        do i=1,9
+          cell(i)=cell0(i)
+        enddo
+        
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     integrate unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity using leapfrog
+          
+          uxx(j)=vxo(j)+tstep*(fxx(i)*rmass(i)-(chit0+chip0)*
+     x      pt5*(vxx(i)+vxo(j)))
+          uyy(j)=vyo(j)+tstep*(fyy(i)*rmass(i)-(chit0+chip0)*
+     x      pt5*(vyy(i)+vyo(j)))
+          uzz(j)=vzo(j)+tstep*(fzz(i)*rmass(i)-(chit0+chip0)*
+     x      pt5*(vzz(i)+vzo(j)))
+          
+c     advance position using leapfrog
+          
+          xxx(i)=xxo(i)+tstep*(uxx(j)+
+     x      chipnew*((xxx(i)+xxo(i))*pt5-com(1)))
+          yyy(i)=yyo(i)+tstep*(uyy(j)+
+     x      chipnew*((yyy(i)+yyo(i))*pt5-com(2)))
+          zzz(i)=zzo(i)+tstep*(uzz(j)+
+     x      chipnew*((zzz(i)+zzo(i))*pt5-com(3)))
+          
+c     estimate full step velocity
+          
+          vxx(i)=pt5*(uxx(j)+vxo(j))
+          vyy(i)=pt5*(uyy(j)+vyo(j))
+          vzz(i)=pt5*(uzz(j)+vzo(j))
+          
+        enddo
+        
+c     calculate new kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     calculate kinetic stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocity
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     *************  Rigid body motion ****************************
+        
+c     translational kinetic energy
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     advance velocity by leapfrog
+          
+          uxx(jg)=gvxo(jg)+tstep*(fmx(jg)/gmass(id)-(chit0+chip0)*
+     x      pt5*(gvxx(ig)+gvxo(jg)))
+          uyy(jg)=gvyo(jg)+tstep*(fmy(jg)/gmass(id)-(chit0+chip0)*
+     x      pt5*(gvyy(ig)+gvyo(jg)))
+          uzz(jg)=gvzo(jg)+tstep*(fmz(jg)/gmass(id)-(chit0+chip0)*
+     x      pt5*(gvzz(ig)+gvzo(jg)))
+          
+c     advance position by leapfrog
+          
+          gcmx(ig)=gcxo(jg)+tstep*(uxx(jg)+
+     x      chipnew*((gcxo(jg)+gcmx(ig))*pt5-com(1)))
+          gcmy(ig)=gcyo(jg)+tstep*(uyy(jg)+
+     x      chipnew*((gcyo(jg)+gcmy(ig))*pt5-com(2)))
+          gcmz(ig)=gczo(jg)+tstep*(uzz(jg)+
+     x      chipnew*((gczo(jg)+gcmz(ig))*pt5-com(3)))
+          
+c     estimate full step velocities
+          
+          gvxx(ig)=pt5*(gvxo(jg)+uxx(jg))
+          gvyy(ig)=pt5*(gvyo(jg)+uyy(jg))
+          gvzz(ig)=pt5*(gvzo(jg)+uzz(jg))
+          
+        enddo
+        
+c     translational kinetic energy 
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          gvxx(ig)=uxx(jg)
+          gvyy(ig)=uyy(jg)
+          gvzz(ig)=uzz(jg)
+          
+        enddo
+        
+c     calculate rigid body stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+c     improved angular velocity at time step n
+            
+            opx(jg)=omxo(jg)+pt5*tstep*trx
+            opy(jg)=omyo(jg)+pt5*tstep*try
+            opz(jg)=omzo(jg)+pt5*tstep*trz
+            
+          enddo
+          
+c     correction due to thermostat
+          
+          delx=tstep*(trx-chit0*pt5*(omx(ig)+omxo(jg)))
+          dely=tstep*(try-chit0*pt5*(omy(ig)+omyo(jg)))
+          delz=tstep*(trz-chit0*pt5*(omz(ig)+omzo(jg)))
+          
+c     angular velocity at time step n
+          
+          omx(ig)=omxo(jg)+delx*pt5
+          omy(ig)=omyo(jg)+dely*pt5
+          omz(ig)=omzo(jg)+delz*pt5
+          
+c     angular velocity at time step n+1/2
+          
+          uxx(jg)=omxo(jg)+delx
+          uyy(jg)=omyo(jg)+dely
+          uzz(jg)=omzo(jg)+delz
+          
+c     angular velocity at time step n+1  (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     minimum images of group positions and particle positions
+        
+        call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     new estimate of chip and chit
+        
+        engke=engfke+engtrn
+        chipp=(2.d0*engke-virtot-vircom-vircon-3.d0*press*volm)/pmass-
+     x    chit0*chip0
+        chipnew=chip+tstep*chipp
+        chip0=pt5*(chip+chipnew)
+        
+        engtot=engke+engrot
+        chitp=(2.d0*(engtot-sigma)+pmass*chip0**2-boltz*temp)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=pt5*(chit+chitnew)
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+c     estimate new cell tensor
+          
+          volnew=volm*exp(3.d0*tstep*chipnew)
+          scale=(volnew/volm0)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=czero(i)*scale
+          enddo
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+c     update volume
+      
+      vold=volm
+      volm=volm*exp(3.d0*tstep*chipnew)
+      
+c     scale cell vectors-isotropic
+      
+      scale=(volm/volm0)**(1.d0/3.d0)
+      do i=1,9
+        cell(i)=czero(i)*scale
+      enddo
+      
+c     construct scaling tensor (for later!)
+      
+      do i=2,8
+        eta(i)=0.d0
+      enddo
+      eta(1)=chipnew
+      eta(5)=chipnew
+      eta(9)=chipnew
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+      
+c     update thermostat and barostat variables
+      
+      chit=chitnew
+      chip=chipnew
+      
+c     conserved quantity less kinetic and potential energy terms
+      
+      conint=conint+tstep*chit0*(qmass/taut**2+boltz*temp)
+      cons1=pt5*qmass*chit0**2
+      cons2=press*vold
+      cons3=pt5*pmass*chip0**2
+      consv=conint+cons1+cons2+cons3
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     complete stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strcns(i)+strkin(i)+strgrp(i)+strbod(i)
+      enddo
+      
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,tqx,tqy,tqz,stat=fail(5))
+      deallocate (fmx,fmy,fmz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nptq_h2
+      
+      subroutine nstq_b2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,mode,elrc,engke,engrot,virlrc,press,
+     x  quattol,sigma,taup,taut,tolnce,tstep,vircom,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints. Rigid body sites and constraint sites may
+c     coincide. 
+c     
+c     verlet leapfrog with Berendsen thermostat and barostat. 
+c     (cell may change shape)
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     tqx,tqy,tqz=torque in lab fixed frame (input)
+c     omx,omy,omz=angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june  1995
+c     amended     w.smith nov 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,lshmov,newjob,safeq,newstep,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons,mode
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc,ntpatm
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon
+      real(8) rot,strkin,strcon,strgrp,engtrn,trx,try,trz
+      real(8) delx,dely,delz,engfke
+      real(8) vaa,vbb,vcc,viracc,elrc,virlrc,press,sigma
+      real(8) taup,taut,volm,cell0,volm0,elrc0,chit0,uni
+      real(8) beta,stres0,engtot,virlrc0
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn)
+      dimension cell0(9),uni(9),stres0(9)
+      
+      save newjob,volm0,elrc0,virlrc0,chit0,dens0
+      save igrp1,igrp2,ifre1,ifre2
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      data beta/7.3728d-3/
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1690)
+      enddo
+      
+c     store initial values of volume, long range corrections etc
+      
+      if(newjob) then
+        
+        chit0=1.d0
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1700)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     set virial, strain and stress tensors
+      
+      vircon=0.d0
+      do i=1,9
+        
+        eta(i)=uni(i)
+        strcns(i)=0.d0
+        cell0(i)=cell(i)
+        stres0(i)=stress(i)
+        
+      enddo
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     shake iterations and thermostat iterations start here
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=4
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity using leapfrog
+          
+          uxx(j)=(vxo(j)+tstep*rmass(i)*fxx(i))*chit0
+          uyy(j)=(vyo(j)+tstep*rmass(i)*fyy(i))*chit0
+          uzz(j)=(vzo(j)+tstep*rmass(i)*fzz(i))*chit0
+          
+c     update positions
+          
+          xxx(i)=tstep*uxx(j)+eta(1)*xxo(i)+eta(4)*yyo(i)+eta(7)*zzo(i)
+          yyy(i)=tstep*uyy(j)+eta(2)*xxo(i)+eta(5)*yyo(i)+eta(8)*zzo(i)
+          zzz(i)=tstep*uzz(j)+eta(3)*xxo(i)+eta(6)*yyo(i)+eta(9)*zzo(i)
+          
+c     calculate velocity at full time step
+          
+          vxx(i)=pt5*(uxx(j)+vxo(j))
+          vyy(i)=pt5*(uyy(j)+vyo(j))
+          vzz(i)=pt5*(uzz(j)+vzo(j))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocities
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     ********: rigid body motion - thermostated  :***********
+        
+c     translational kinetic energy
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     calculate thermostated velocities
+          
+          uxx(jg)=(gvxo(jg)+tstep/gmass(id)*fmx(jg))*chit0
+          uyy(jg)=(gvyo(jg)+tstep/gmass(id)*fmy(jg))*chit0
+          uzz(jg)=(gvzo(jg)+tstep/gmass(id)*fmz(jg))*chit0
+          
+c     update positions
+          
+          gcmx(ig)=tstep*uxx(jg)+
+     x      eta(1)*gcxo(jg)+eta(4)*gcyo(jg)+eta(7)*gczo(jg)
+          gcmy(ig)=tstep*uyy(jg)+
+     x      eta(2)*gcxo(jg)+eta(5)*gcyo(jg)+eta(8)*gczo(jg)
+          gcmz(ig)=tstep*uzz(jg)+
+     x      eta(3)*gcxo(jg)+eta(6)*gcyo(jg)+eta(9)*gczo(jg)
+          
+c     centre of mass velocities at full step
+          
+          gvxx(ig)=pt5*(gvxo(jg)+uxx(jg))
+          gvyy(ig)=pt5*(gvyo(jg)+uyy(jg))
+          gvzz(ig)=pt5*(gvzo(jg)+uzz(jg))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocity
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          gvxx(ig)=uxx(jg)
+          gvyy(ig)=uyy(jg)
+          gvzz(ig)=uzz(jg)
+          
+        enddo
+        
+c     calculate rigid body stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+            delx=tstep*trx
+            dely=tstep*try
+            delz=tstep*trz
+            
+c     improved angular velocity at time step n
+            
+            opx(jg)=(omxo(jg)+pt5*delx)
+            opy(jg)=(omyo(jg)+pt5*dely)
+            opz(jg)=(omzo(jg)+pt5*delz)
+            
+          enddo
+          
+c     scaled angular velocity at time step n
+          
+          omx(ig)=opx(jg)*chit0
+          omy(ig)=opy(jg)*chit0
+          omz(ig)=opz(jg)*chit0
+          
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=(omxo(jg)+delx*1.5d0)*chit0
+          oqy(jg)=(omyo(jg)+dely*1.5d0)*chit0
+          oqz(jg)=(omzo(jg)+delz*1.5d0)*chit0
+          
+c     angular velocity at time step n+1/2
+          
+          uxx(jg)=(omxo(jg)+delx)*chit0
+          uyy(jg)=(omyo(jg)+dely)*chit0
+          uzz(jg)=(omzo(jg)+delz)*chit0
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step angular velocity
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     minimum images of group positions and particle positions
+        
+        call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     calculate total stress tensor
+        
+        do i=1,9
+          stress(i)=stres0(i)+strcns(i)+strkin(i)+strgrp(i)+strbod(i)
+        enddo
+        
+c     calculate new cell tensor
+        
+        call mat_mul(eta,cell0,cell)
+        
+c     calculate eta tensor
+        
+        do i=1,9
+          eta(i)=beta*tstep/taup*(stress(i)/volm-press*uni(i))+uni(i)
+        enddo
+        if(mode.gt.0)then
+          eta(3)=0.d0
+          eta(6)=0.d0
+          eta(7)=0.d0
+          eta(8)=0.d0
+          if(mode.lt.3)then
+            eta(2)=0.d0
+            eta(4)=0.d0
+            if(mode.eq.2)then
+              eta(1)=0.5d0*(eta(1)+eta(5))
+              eta(5)=eta(1)
+            endif
+          endif
+        endif
+        
+c     new estimate of chit
+        
+        engke=engfke+engtrn
+        engtot=engke+engrot
+        chit0=sqrt(1.d0+tstep/taut*(sigma/engtot-1.d0))
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+c     update volume
+      
+      volm=volm*eta(1)*eta(5)*eta(9)
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,tqx,tqy,tqz,stat=fail(5))
+      deallocate (fmx,fmy,fmz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nstq_b2
+      
+      subroutine nstq_h2
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,mode,chit,conint,consv,elrc,engke,engrot,
+     x  virlrc,press,quattol,sigma,taup,taut,temp,tolnce,tstep,
+     x  vircom,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints- rigid body sites and constraint sites 
+c     may coincide. 
+c     
+c     verlet leapfrog with Hoover like thermostat and barostat. 
+c     (cell may change shape)
+c     
+c     parallel replicated data version : block data
+c     
+c     for systems using bond constraints
+c     
+c     tqx,tqy,tqz=torque in lab fixed frame (input)
+c     omx,omy,omz=angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1995
+c     author      t.forester june  1995
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=16
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newstep,newjob,cycle
+      integer fail,imcon,idnode,mxnode,natms,ngrp,nscons
+      integer ntcons,ntfree,igrp,igrp1,igrp2,idum,ifre,ifre1,ifre2
+      integer i,j,k,jg,ig,jr,id,mxshak1,icyc,ntpatm,mode
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon
+      real(8) rot,strkin,strcon,strgrp,engtrn,vxt,vyt,vzt,trx,try,trz
+      real(8) delx,dely,delz,vaa,vbb,vcc,viracc,com,fac,etadot
+      real(8) chit,conint,consv,virlrc,elrc,press,sigma,taut,taup
+      real(8) volm,eta0,etanew,cell0,volm0,elrc0,virlrc0,pmass,qmass
+      real(8) totmas,chit0,xxa,yya,zza,chip,chitp,vom,engfke
+      real(8) chitnew,vold,cons1,cons2,cons3,temp,uni
+      real(8) stres0,engtot
+      
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: fmx(:),fmy(:),fmz(:)
+      real(8), allocatable :: tqx(:),tqy(:),tqz(:)
+      real(8), allocatable :: omxo(:),omyo(:),omzo(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      real(8), allocatable :: qn0(:),qn1(:),qn2(:),qn3(:)
+      
+      dimension rot(9),strkin(9),strcon(9),strgrp(9),fail(nnn),vom(3)
+      dimension cell0(9),eta0(9),etanew(9),stres0(9),uni(9),com(3)
+      
+      save newjob,volm0,elrc0,virlrc0,dens0,pmass,qmass
+      save igrp1,igrp2,ifre1,ifre2,totmas
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(6))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate (fmx(msgrp),fmy(msgrp),fmz(msgrp),stat=fail(11))
+      allocate (tqx(msgrp),tqy(msgrp),tqz(msgrp),stat=fail(12))
+      allocate (omxo(msgrp),omyo(msgrp),omzo(msgrp),stat=fail(13))
+      allocate (gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(14))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(15))
+      allocate (qn0(msgrp),qn1(msgrp),qn2(msgrp),qn3(msgrp),
+     x  stat=fail(16))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1710)
+      enddo
+      
+      if(newjob) then
+        
+c     inertia parameter for Nose-Hoover thermostat
+        
+        qmass=2.0d0*sigma*taut**2
+        pmass=2.0d0*sigma*taup**2
+        
+c     store initial values of volume, long range corrections etc
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        fail(1)=0
+        allocate (dens0(mxatyp),stat=fail(1))
+        if(fail(1).ne.0)call error(idnode,1720)
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+c     system total mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      cycle=.true.
+      
+c     ensure total momentum is zero
+      
+      call getvom(natms,idnode,mxnode,totmas,vom)
+      
+c     correction to velocities
+      
+      do ifre=ifre1,ifre2
+        
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)-vom(1)
+        vyy(i)=vyy(i)-vom(2)
+        vzz(i)=vzz(i)-vom(3)
+        
+      enddo
+      
+      do ig=igrp1,igrp2
+        
+        gvxx(ig)=gvxx(ig)-vom(1)
+        gvyy(ig)=gvyy(ig)-vom(2)
+        gvzz(ig)=gvzz(ig)-vom(3)
+        
+      enddo
+      
+c     store initial values of position and velocity
+      
+      do i=1,natms
+        
+        xxo(i)=xxx(i)
+        yyo(i)=yyy(i)
+        zzo(i)=zzz(i)
+        
+      enddo
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        omxo(jg)=omx(ig)
+        omyo(jg)=omy(ig)
+        omzo(jg)=omz(ig)
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        gvxo(jg)=gvxx(ig)
+        gvyo(jg)=gvyy(ig)
+        gvzo(jg)=gvzz(ig)
+        qn0(jg)=q0(ig)
+        qn1(jg)=q1(ig)
+        qn2(jg)=q2(ig)
+        qn3(jg)=q3(ig)
+        
+      enddo
+      
+c     calculate centre of mass
+      
+      call getcom(natms,idnode,mxnode,totmas,com)
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     calculate atom displacement from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxo(i)-gcxo(jg)
+          dty(jr)=yyo(i)-gcyo(jg)
+          dtz(jr)=zzo(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     initial thermostat and barostat variables and new cell
+      
+      chit0=chit
+      do i=1,9
+        
+        eta0(i)=eta(i)
+        cell0(i)=cell(i)
+        
+      enddo
+      
+c     initialise constraint stress and virial
+      
+      vircon=0.d0
+      do i=1,9
+        
+        strcns(i)=0.d0
+        stres0(i)=stress(i)
+        
+      enddo
+      
+c     shake and thermostat iterations start here
+      
+      icyc=0
+      mxshak1=mxshak
+      if(ntcons.eq.0)mxshak1=4
+      do while(cycle.and.icyc.le.mxshak1)
+        
+        icyc=icyc+1
+        
+c     restore cell vectors
+        
+        do i=1,9
+          cell(i)=cell0(i)
+        enddo
+        
+c     restore original quaternions for this step
+
+        jg=0
+        do ig=igrp1,igrp2
+
+          jg=jg+1
+          q0(ig)=qn0(jg)
+          q1(ig)=qn1(jg)
+          q2(ig)=qn2(jg)
+          q3(ig)=qn3(jg)
+          
+        enddo
+
+c     integrate unconstrained new positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     advance velocity using leapfrog
+          
+          vxt=pt5*(vxx(i)+vxo(j))
+          vyt=pt5*(vyy(i)+vyo(j))
+          vzt=pt5*(vzz(i)+vzo(j))
+          
+          uxx(j)=vxo(j)+tstep*(fxx(i)*rmass(i)-
+     x      (eta0(1)+chit0)*vxt-eta0(4)*vyt-eta0(7)*vzt)
+          uyy(j)=vyo(j)+tstep*(fyy(i)*rmass(i)-
+     x      eta0(2)*vxt-(eta0(5)+chit0)*vyt-eta0(8)*vzt)
+          uzz(j)=vzo(j)+tstep*(fzz(i)*rmass(i)-
+     x      eta0(3)*vxt-eta0(6)*vyt-(eta0(9)+chit0)*vzt)
+          
+c     advance positions using leapfrog
+          
+          xxa=(xxx(i)+xxo(i))*pt5-com(1)
+          yya=(yyy(i)+yyo(i))*pt5-com(2)
+          zza=(zzz(i)+zzo(i))*pt5-com(3)
+          
+          xxx(i)=xxo(i)+tstep*(uxx(j)+
+     x      eta0(1)*xxa+eta0(4)*yya+eta0(7)*zza)
+          yyy(i)=yyo(i)+tstep*(uyy(j)+
+     x      eta0(2)*xxa+eta0(5)*yya+eta0(8)*zza)
+          zzz(i)=zzo(i)+tstep*(uzz(j)+
+     x      eta0(3)*xxa+eta0(6)*yya+eta0(9)*zza)
+          
+c     estimate full step  velocities
+          
+          vxx(i)=pt5*(uxx(j)+vxo(j))
+          vyy(i)=pt5*(uyy(j)+vyo(j))
+          vzz(i)=pt5*(uzz(j)+vzo(j))
+          
+        enddo
+        
+c     kinetic energy at current timestep
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        
+c     kinetic contribution stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        
+c     restore half step velocities
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=uxx(j)
+          vyy(i)=uyy(j)
+          vzz(i)=uzz(j)
+          
+        enddo
+        
+c     ********: rigid body motion - thermostated  :************
+        
+c     translational kinetic energy
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     calculate centre of mass forces
+          
+          fmx(jg)=0.d0
+          fmy(jg)=0.d0
+          fmz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            fmx(jg)=fmx(jg)+fxx(i)
+            fmy(jg)=fmy(jg)+fyy(i)
+            fmz(jg)=fmz(jg)+fzz(i)
+            
+          enddo
+          
+c     calculate thermostated velocities
+          
+          vxt=pt5*(gvxx(ig)+gvxo(jg))
+          vyt=pt5*(gvyy(ig)+gvyo(jg))
+          vzt=pt5*(gvzz(ig)+gvzo(jg))
+          
+          uxx(jg)=gvxo(jg)+tstep*(fmx(jg)/gmass(id)-
+     x      (chit0+eta0(1))*vxt-eta0(4)*vyt-eta0(7)*vzt)
+          uyy(jg)=gvyo(jg)+tstep*(fmy(jg)/gmass(id)-
+     x      eta0(2)*vxt-(eta0(5)+chit0)*vyt-eta0(8)*vzt)
+          uzz(jg)=gvzo(jg)+tstep*(fmz(jg)/gmass(id)-
+     x      eta0(3)*vxt-eta0(6)*vyt-(eta0(9)+chit0)*vzt)
+          
+c     advance positions using leapfrog
+          
+          xxa=(gcmx(ig)+gcxo(jg))*pt5-com(1)
+          yya=(gcmy(ig)+gcyo(jg))*pt5-com(2)
+          zza=(gcmz(ig)+gczo(jg))*pt5-com(3)
+          
+          gcmx(ig)=gcxo(jg)+tstep*(uxx(jg)+
+     x      eta0(1)*xxa+eta0(4)*yya+eta0(7)*zza)
+          gcmy(ig)=gcyo(jg)+tstep*(uyy(jg)+
+     x      eta0(2)*xxa+eta0(5)*yya+eta0(8)*zza)
+          gcmz(ig)=gczo(jg)+tstep*(uzz(jg)+
+     x      eta0(3)*xxa+eta0(6)*yya+eta0(9)*zza)
+          
+c     estimate full step velocities
+          
+          gvxx(ig)=pt5*(gvxo(jg)+uxx(jg))
+          gvyy(ig)=pt5*(gvyo(jg)+uyy(jg))
+          gvzz(ig)=pt5*(gvzo(jg)+uzz(jg))
+          
+        enddo
+        
+c     calculate kinetic energy
+        
+        engtrn=getkint(ngrp,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     restore half step velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          gvxx(ig)=uxx(jg)
+          gvyy(ig)=uyy(jg)
+          gvzz(ig)=uzz(jg)
+          
+        enddo
+        
+c     calculate rigid body stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     torques in lab frame
+        
+        jr=0
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+          tqx(jg)=0.d0
+          tqy(jg)=0.d0
+          tqz(jg)=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            tqx(jg)=tqx(jg)+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            tqy(jg)=tqy(jg)+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            tqz(jg)=tqz(jg)+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          
+c     current rotational matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     angular velocity at time step n (first guess)
+          
+          opx(jg)=omxo(jg)
+          opy(jg)=omyo(jg)
+          opz(jg)=omzo(jg)
+          
+c     iterate angular velocity for time step n (e. yezdimer)
+          
+          do i=1,5
+            
+            trx=(tqx(jg)*rot(1)+tqy(jg)*rot(4)+tqz(jg)*rot(7))*
+     x        rotinx(id,2)
+     x        +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*
+     x        rotinx(id,2)
+            try=(tqx(jg)*rot(2)+tqy(jg)*rot(5)+tqz(jg)*rot(8))*
+     x        rotiny(id,2)
+     x        +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*
+     x        rotiny(id,2)
+            trz=(tqx(jg)*rot(3)+tqy(jg)*rot(6)+tqz(jg)*rot(9))*
+     x        rotinz(id,2)
+     x        +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*
+     x        rotinz(id,2)
+            
+c     improved angular velocity at time step n
+            
+            opx(jg)=omxo(jg)+pt5*tstep*trx
+            opy(jg)=omyo(jg)+pt5*tstep*try
+            opz(jg)=omzo(jg)+pt5*tstep*trz
+            
+          enddo
+          
+c     correction due to thermostat
+          
+          delx=tstep*(trx-chit0*pt5*(omx(ig)+omxo(jg)))
+          dely=tstep*(try-chit0*pt5*(omy(ig)+omyo(jg)))
+          delz=tstep*(trz-chit0*pt5*(omz(ig)+omzo(jg)))
+          
+c     angular velocity at time step n
+          
+          omx(ig)=omxo(jg)+delx*pt5
+          omy(ig)=omyo(jg)+dely*pt5
+          omz(ig)=omzo(jg)+delz*pt5
+          
+c     angular velocity at time step n+1/2
+          
+          uxx(jg)=omxo(jg)+delx
+          uyy(jg)=omyo(jg)+dely
+          uzz(jg)=omzo(jg)+delz
+          
+c     angular velocity at time step n+1 (needed for quat algorithm)
+          
+          oqx(jg)=omxo(jg)+delx*1.5d0
+          oqy(jg)=omyo(jg)+dely*1.5d0
+          oqz(jg)=omzo(jg)+delz*1.5d0
+          
+        enddo
+        
+c     rotational kinetic energy
+        
+        engrot=getkinr(ngrp,idnode,mxnode)
+        
+c     restore half step velocities
+        
+        jg=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          opx(jg)=omx(ig)
+          opy(jg)=omy(ig)
+          opz(jg)=omz(ig)
+          omx(ig)=uxx(jg)
+          omy(ig)=uyy(jg)
+          omz(ig)=uzz(jg)
+          
+        enddo
+        
+c     assign new quaternions
+        
+        call update_quaternions
+     x    (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+        
+c     minimum images of group positions and particle positions
+        
+        call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     new atomic positions for atoms in rigid bodies
+        
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+          jg=jg+1
+          id=lstgtp(ig)
+          
+c     new rotational matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+            
+c     new atomic velocites in body frame
+            
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+            
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+        
+c     merge new atomic coordinates 
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     calculate total stress tensor
+        
+        do i=1,9
+          stress(i)=stres0(i)+strcns(i)+strkin(i)+strgrp(i)+strbod(i)
+        enddo
+        
+c     propagate eta
+        
+        fac=9.d0
+        do i=1,9
+          etanew(i)=eta(i)+tstep*((stress(i)-press*volm*uni(i))/pmass-
+     x      chit0*eta0(i))
+        enddo
+        if(mode.gt.0)then
+          fac=5.d0
+          etanew(3)=0.d0
+          etanew(6)=0.d0
+          etanew(7)=0.d0
+          etanew(8)=0.d0
+          if(mode.lt.3)then
+            fac=3.d0
+            etanew(2)=0.d0
+            etanew(4)=0.d0
+            if(mode.eq.2)then
+              fac=2.d0
+              etanew(1)=0.5d0*(etanew(1)+etanew(5))
+              etanew(5)=etanew(1)
+            endif
+          endif
+        endif
+        do i=1,9
+          eta0(i)=pt5*(etanew(i)+eta(i)) 
+        enddo
+        
+c     propagate chit
+        
+        etadot=sdot0(9,eta0,eta0)
+        if(mode.eq.2)etadot=etadot-eta0(1)**2
+        engke=engfke+engtrn
+        engtot=engke+engrot
+        chitp=(2.d0*(engtot-sigma)+pmass*etadot-fac*boltz*temp)/qmass
+        chitnew=chit+tstep*chitp
+        chit0=pt5*(chit+chitnew)
+        
+c     estimate new cell parameters
+        
+        call cell_propagate(tstep,cell,etanew)
+        
+        if(ntcons.gt.0) then
+          
+c     apply constraint correction
+          
+          newstep=.false.
+          if(icyc.eq.1)newstep=.true.
+          
+          call qshake
+     x      (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x      nscons,tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,
+     x      dzt,txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          if(abs(viracc).le.1.d-10)cycle=.false.
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     end of shake corrections
+          
+        endif
+        
+      enddo
+      
+c     update thermostat and barostat variables
+      
+      chit=chitnew
+      do i=1,9
+        eta(i)=etanew(i)
+      enddo
+      
+c     update volume
+      
+      chip=eta(1)+eta(5)+eta(9)
+      vold=volm
+      volm=volm*exp(tstep*chip)
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+      
+c     conserved quantity less kinetic and potential energy
+      
+      conint=conint+tstep*chit0*(qmass/taut**2+fac*boltz*temp)
+      cons1=pt5*qmass*chit0**2
+      cons2=press*vold
+      etadot=sdot0(9,eta0,eta0)
+      if(mode.eq.2)etadot=etadot-eta0(1)**2
+      cons3=pt5*pmass*etadot
+      consv=conint+cons1+cons2+cons3
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+c     merge new quaternions
+        
+        call merge4(idnode,mxnode,ngrp,mxbuff,q0,q1,q2,q3,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     deallocate work arrays
+      
+      deallocate (opx,opy,opz,oqx,oqy,oqz,stat=fail(1))
+      deallocate (dtx,dty,dtz,dxx,dyy,dzz,stat=fail(2))
+      deallocate (uxx,uyy,uzz,txx,tyy,tzz,stat=fail(3))
+      deallocate (dxt,dyt,dzt,xxo,yyo,zzo,stat=fail(4))
+      deallocate (vxo,vyo,vzo,tqx,tqy,tqz,stat=fail(5))
+      deallocate (fmx,fmy,fmz,omxo,omyo,omzo,stat=fail(6))
+      deallocate (gvxo,gvyo,gvzo,gcxo,gcyo,gczo,stat=fail(7))
+      deallocate (xxt,yyt,zzt,qn0,qn1,qn2,qn3,stat=fail(8))
+      
+      return
+      end subroutine nstq_h2
+      
+      subroutine qshake
+     x  (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x  nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x  dzt,txx,tyy,tzz,xxt,yyt,zzt,stresh)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for appling bond constraint corrections after
+c     atomic integration. Assumes rigid bodies connected by constraints
+c     If this is not so use rdshake_1 instead
+c     Must be used in conjunction with leapfrog integration algorithms
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - t. forester june 1995
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lshmov,newstep,newjob
+      integer fail,idnode,imcon,mxnode,natms,nscons,i,j,k
+      integer ik,ig,id,jj
+      real(8) tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,txx,tyy
+      real(8) tzz,xxt,yyt,zzt,stresh,tstep2,esig,dis,dis2
+      real(8) xxa,yya,zza,tax,tay,taz,doti,amti,amtj
+      real(8) trx,try,trz,vix,viy,viz,vxi,vyi,vzi
+      real(8) vjx,vjy,vjz,vxj,vyj,vzj,gamma,dli,dlj,rot
+      
+      real(8), allocatable :: redmass(:),esig1(:)
+      
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension dxx(mxcons),dyy(mxcons),dzz(mxcons)
+      dimension dxt(mxcons),dyt(mxcons),dzt(mxcons)
+      dimension stresh(9),rot(9)
+      
+      save newjob,esig1,redmass
+      
+      data newjob/.true./,fail/0/
+      
+      if(newjob)then
+        
+        allocate (redmass(mxcons),esig1(mxcons),stat=fail)
+        if(fail.ne.0)call error(idnode,1610)
+        newjob=.false.
+        
+      endif
+      
+c     constraint virial
+      
+      vircon=0.d0
+      
+c     accumulators for stress tensor
+      
+      do i=1,9
+        stresh(i)=0.d0
+      enddo
+      
+c     timestep squared
+      
+      tstep2=tstep*tstep
+      
+c     one iteration of constraint (shake) algorithm
+      
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+        
+c     calculate temporary bond vector
+        
+        dxt(k)=xxx(i)-xxx(j)
+        dyt(k)=yyy(i)-yyy(j)
+        dzt(k)=zzz(i)-zzz(j)
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,0,1,nscons,cell,dxt,dyt,dzt)
+      
+c     calculate maximum error in bondlength
+      
+      esig=0.d0
+      do k=1,nscons
+        
+c     set bond parameter
+        
+        dis=prmcon(listcon(k,1))
+        dis2=dis*dis
+        esig1(k)=0.5d0*(dis2-(dxt(k)**2+dyt(k)**2+dzt(k)**2))/dis2
+        esig=max(esig,abs(esig1(k)))
+
+      enddo
+      
+c     global verification of convergence
+      
+      safe=(esig.lt.tolnce)
+      
+      if(mxnode.gt.1)call gstate(safe)
+      
+c     terminate iteration if all tolerances satisfied 
+      
+      if (.not.safe) then
+        
+c     initialise force increment arrays
+        
+        do i=1,natms
+          
+          xxt(i)=0.d0
+          yyt(i)=0.d0
+          zzt(i)=0.d0
+          
+        enddo
+        
+c     calculate constraint forces
+        
+        ik=0
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     assign effective reduced mass
+          
+          if(newstep) then
+            
+            ig=lstbod(i)
+            
+            if(ig.eq.0) then
+              
+              amti=rmass(i)
+              
+            else
+              
+              ik=ik+1
+              id=lstgtp(ig)
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+              
+              jj=lstcsit(ik)
+              
+c     site to com in lab frame
+              
+              xxa=(gxx(id,jj)*rot(1)+gyy(id,jj)*rot(2)+
+     x          gzz(id,jj)*rot(3))
+              yya=(gxx(id,jj)*rot(4)+gyy(id,jj)*rot(5)+
+     x          gzz(id,jj)*rot(6))
+              zza=(gxx(id,jj)*rot(7)+gyy(id,jj)*rot(8)+
+     x          gzz(id,jj)*rot(9))
+              
+c     find cross product between interatomic vector and vector to com
+              
+              tax=yya*dzz(k)-zza*dyy(k)
+              tay=zza*dxx(k)-xxa*dzz(k)
+              taz=xxa*dyy(k)-yya*dxx(k)
+              
+c     transform to body fixed frame
+              
+              trx=(tax*rot(1)+tay*rot(4)+taz*rot(7))*rotinx(id,2)
+              try=(tax*rot(2)+tay*rot(5)+taz*rot(8))*rotiny(id,2)
+              trz=(tax*rot(3)+tay*rot(6)+taz*rot(9))*rotinz(id,2)
+              
+c     direction of induced velocites in body frame
+              
+              vix=try*gzz(id,jj)-trz*gyy(id,jj)
+              viy=trz*gxx(id,jj)-trx*gzz(id,jj)
+              viz=trx*gyy(id,jj)-try*gxx(id,jj)
+              
+c     transform to lab frame
+              
+              vxi=vix*rot(1)+viy*rot(2)+viz*rot(3)
+              vyi=vix*rot(4)+viy*rot(5)+viz*rot(6)
+              vzi=vix*rot(7)+viy*rot(8)+viz*rot(9)
+              
+c     find dot product between induced translational and rotational velocities
+              
+              doti=abs(vxi*dxx(k)+vyi*dyy(k)+vzi*dzz(k))
+              doti=doti/dis2
+              
+              amti=(1.d0/gmass(id)+doti)
+              
+            endif
+            
+            ig=lstbod(j)
+            if(ig.eq.0) then
+              
+              amtj=rmass(j)
+              
+            else
+              
+              ik=ik+1
+              id=lstgtp(ig)
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+              
+              jj=lstcsit(ik)
+              
+c     site to com in lab frame
+              
+              xxa=(gxx(id,jj)*rot(1)+gyy(id,jj)*rot(2)+
+     x          gzz(id,jj)*rot(3))
+              yya=(gxx(id,jj)*rot(4)+gyy(id,jj)*rot(5)+
+     x          gzz(id,jj)*rot(6))
+              zza=(gxx(id,jj)*rot(7)+gyy(id,jj)*rot(8)+
+     x          gzz(id,jj)*rot(9))
+              
+c     find cross product between interatomic vector and vector to com
+              
+              tax =yya*dzz(k)-zza*dyy(k)
+              tay =zza*dxx(k)-xxa*dzz(k)
+              taz =xxa*dyy(k)-yya*dxx(k)
+              
+c     transform to body fixed frame
+              
+              trx=(tax*rot(1)+tay*rot(4)+taz*rot(7))*rotinx(id,2)
+              try=(tax*rot(2)+tay*rot(5)+taz*rot(8))*rotiny(id,2)
+              trz=(tax*rot(3)+tay*rot(6)+taz*rot(9))*rotinz(id,2)
+              
+c     direction of induced velocites in body frame
+              
+              vjx=try*gzz(id,jj)-trz*gyy(id,jj)
+              vjy=trz*gxx(id,jj)-trx*gzz(id,jj)
+              vjz=trx*gyy(id,jj)-try*gxx(id,jj)
+              
+c     transform to lab frame
+              
+              vxj=vjx*rot(1)+vjy*rot(2)+vjz*rot(3)
+              vyj=vjx*rot(4)+vjy*rot(5)+vjz*rot(6)
+              vzj=vjx*rot(7)+vjy*rot(8)+vjz*rot(9)
+              
+c     find dot product between induced translational and rotational velocities
+              
+              doti=abs(vxj*dxx(k)+vyj*dyy(k)+vzj*dzz(k))
+              doti=doti/dis2
+              
+              amtj=(1.d0/gmass(id)+doti)
+              
+            endif
+            
+            redmass(k)=1.d0/(amti+amtj)/tstep2
+            
+          endif
+          
+c     constraint force parameter 
+          
+          gamma=esig1(k)*redmass(k)
+          
+c     accumulate bond virial
+          
+          vircon=vircon-gamma*(dxx(k)**2+dyy(k)**2+dzz(k)**2)
+          
+          stresh(1)=stresh(1)+gamma*dxx(k)*dxx(k)
+          stresh(2)=stresh(2)+gamma*dxx(k)*dyy(k)
+          stresh(3)=stresh(3)+gamma*dxx(k)*dzz(k)
+          stresh(5)=stresh(5)+gamma*dyy(k)*dyy(k)
+          stresh(6)=stresh(6)+gamma*dyy(k)*dzz(k)
+          stresh(9)=stresh(9)+gamma*dzz(k)*dzz(k)
+          
+c     improved atomic force
+          
+          xxt(i)=xxt(i)+dxx(k)*gamma
+          yyt(i)=yyt(i)+dyy(k)*gamma
+          zzt(i)=zzt(i)+dzz(k)*gamma
+          
+          xxt(j)=xxt(j)-dxx(k)*gamma
+          yyt(j)=yyt(j)-dyy(k)*gamma
+          zzt(j)=zzt(j)-dzz(k)*gamma
+          
+        enddo
+        
+c     transport temporary positions to other nodes
+        
+        if(mxnode.gt.1)then
+          
+          if(lshmov) call shmove
+     x      (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x      txx,tyy,tzz,buffer)
+          
+        endif
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dli=1.d0/dble(listme(i))
+          dlj=1.d0/dble(listme(j))
+          
+          fxx(i)=fxx(i)+xxt(i)*dli
+          fyy(i)=fyy(i)+yyt(i)*dli
+          fzz(i)=fzz(i)+zzt(i)*dli
+          fxx(j)=fxx(j)+xxt(j)*dlj
+          fyy(j)=fyy(j)+yyt(j)*dlj
+          fzz(j)=fzz(j)+zzt(j)*dlj
+          
+        enddo
+        
+c     complete (symmetrical) stress tensor
+        
+        stresh(4)=stresh(2)
+        stresh(7)=stresh(3)
+        stresh(8)=stresh(6)
+        
+c     splice force arrays across nodes
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=vircon
+          call gdsum(buffer(1),1,buffer(2))
+          vircon=buffer(1)
+          call gdsum(stresh,9,buffer)
+          call splice 
+     x      (idnode,natms,listme,listot,fxx,fyy,fzz,buffer)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine qshake
+      
+      end module lf_rotation2_module
diff -urN dl_class_1.9.orig/srcmod/Makefile dl_class_1.9/srcmod/Makefile
--- dl_class_1.9.orig/srcmod/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Makefile	2015-11-07 17:50:35.290629862 +0100
@@ -0,0 +1,115 @@
+# Master makefile for DL_POLY Classic
+# Author: W. Smith January Dec 2010
+# 
+#=======================================================================
+# Define default settings
+#=======================================================================
+
+BINROOT = ../execute
+CC  := $(CC)
+CPP = $(CXX)
+EX = DLPOLY.X
+EXE = $(BINROOT)/$(EX)
+FC=undefined
+SHELL=/bin/sh
+TYPE=par
+
+#=====================================================================
+# Define object files
+
+OBJ_MOD = parse_module.o setup_module.o error_module.o \
+	site_module.o config_module.o pair_module.o utility_module.o \
+	metafreeze_module.o solvation_module.o tether_module.o \
+	vdw_module.o property_module.o rigid_body_module.o \
+	angles_module.o bonds_module.o shake_module.o \
+	inversion_module.o dihedral_module.o core_shell_module.o \
+	exclude_module.o ewald_module.o coulomb_module.o\
+	external_field_module.o four_body_module.o \
+	hkewald_module.o metal_module.o ensemble_tools_module.o \
+	temp_scalers_module.o three_body_module.o spme_module.o \
+	tersoff_module.o neu_coul_module.o \
+	nlist_builders_module.o forces_module.o \
+	lf_motion_module.o lf_rotation1_module.o \
+	lf_rotation2_module.o vv_motion_module.o \
+	vv_rotation1_module.o vv_rotation2_module.o \
+	pmf_module.o integrator_module.o optimiser_module.o \
+	hyper_dynamics_module.o driver_module.o \
+	define_system_module.o
+
+OBJ_SRC = dlpoly.o
+
+OBJ_PAR = basic_comms.o merge_tools.o pass_tools.o
+
+HEAD_METAD = Plumed/metadyn.h
+
+include Plumed/plumed.inc
+
+OBJ_METAD = $(PLUMED_OBJECTS) images.o
+
+#=====================================================================
+# Define targets
+all:
+	@echo "Error - please specify a target machine!"
+	@echo "Permissible targets for this Makefile are:"
+	@echo "                                          "
+	@echo "gfortran                   (parallel)"
+	@echo "woodcrest                  (parallel)"
+	@echo "         "
+	@echo "Please examine Makefile for details"
+
+# system specific targets follow :
+
+#================== GNU Fortran, MPI version ==============================
+gfortran:
+	$(MAKE) FC="$(MPIF90)" LD="$(MPIF90) -o" \
+	LDFLAGS="$(LDFLAGS)" \
+	FFLAGS="-c $(LDFLAGS)" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#================= Woodcrest =========================================
+woodcrest:
+	$(MAKE) LD="mpif90 -o" LDFLAGS="" \
+	FC=mpif90 FFLAGS="-c -O3" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#=====================================================================
+# Default code for parallel (MPI) execution
+
+par: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(OBJ_SRC)
+	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(RECON_LIBS) $(OBJ_SRC)
+	mv $(EX) $(EXE)
+
+#=====================================================================
+# Check that a machine has been specified
+check:
+	@if test $(FC) = "undefined";\
+	then echo "You must specify a target machine!"; \
+	exit 99;\
+	fi
+
+#=====================================================================
+# Clean up the source directory
+clean:
+	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(OBJ_SRC) *.mod
+
+#=====================================================================
+# Declare dependencies
+.f.o: 
+	$(FC) $(FFLAGS) $*.f
+
+.c.o: $(HEAD_METAD) 
+	$(CC) -DDL_POLY $(RECON_FLAGS) -DMPI -c $(CFLAGS) $< -o $@
+
+%.o: %.cpp $(HEAD_RECON) 
+	$(CPP) -DMPI $(RECON_FLAGS) -c $(CFLAGS) $< -o $@
+
+#=====================================================================
+# Declare dependency on module files
+
+$(OBJ_SRC): $(OBJ_MOD)
+
+#=====================================================================
+# Declare dependency for C header files
+
+$(OBJ_METAD): $(HEAD_METAD)
+$(OBJ_RECON): $(HEAD_RECON)
diff -urN dl_class_1.9.orig/srcmod/Makefile~ dl_class_1.9/srcmod/Makefile~
--- dl_class_1.9.orig/srcmod/Makefile~	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Makefile~	2015-11-07 17:50:14.761037627 +0100
@@ -0,0 +1,115 @@
+# Master makefile for DL_POLY Classic
+# Author: W. Smith January Dec 2010
+# 
+#=======================================================================
+# Define default settings
+#=======================================================================
+
+BINROOT = ../execute
+CC  := $(CC)
+CPP = $(CXX)
+EX = DLPOLY.X
+EXE = $(BINROOT)/$(EX)
+FC=undefined
+SHELL=/bin/sh
+TYPE=par
+
+#=====================================================================
+# Define object files
+
+OBJ_MOD = parse_module.o setup_module.o error_module.o \
+	site_module.o config_module.o pair_module.o utility_module.o \
+	metafreeze_module.o solvation_module.o tether_module.o \
+	vdw_module.o property_module.o rigid_body_module.o \
+	angles_module.o bonds_module.o shake_module.o \
+	inversion_module.o dihedral_module.o core_shell_module.o \
+	exclude_module.o ewald_module.o coulomb_module.o\
+	external_field_module.o four_body_module.o \
+	hkewald_module.o metal_module.o ensemble_tools_module.o \
+	temp_scalers_module.o three_body_module.o spme_module.o \
+	tersoff_module.o neu_coul_module.o \
+	nlist_builders_module.o forces_module.o \
+	lf_motion_module.o lf_rotation1_module.o \
+	lf_rotation2_module.o vv_motion_module.o \
+	vv_rotation1_module.o vv_rotation2_module.o \
+	pmf_module.o integrator_module.o optimiser_module.o \
+	hyper_dynamics_module.o driver_module.o \
+	define_system_module.o
+
+OBJ_SRC = dlpoly.o
+
+OBJ_PAR = basic_comms.o merge_tools.o pass_tools.o
+
+HEAD_METAD = Plumed/metadyn.h
+
+include Plumed/plumed.inc
+
+OBJ_METAD = $(PLUMED_OBJECTS) images.o
+
+#=====================================================================
+# Define targets
+all:
+	@echo "Error - please specify a target machine!"
+	@echo "Permissible targets for this Makefile are:"
+	@echo "                                          "
+	@echo "gfortran                   (parallel)"
+	@echo "woodcrest                  (parallel)"
+	@echo "         "
+	@echo "Please examine Makefile for details"
+
+# system specific targets follow :
+
+#================== GNU Fortran, MPI version ==============================
+gfortran:
+	$(MAKE) FC="$(FC)" LD="$(FC) -o" \
+	LDFLAGS="$(LDFLAGS) -ffast-math" \
+	FFLAGS="-c $(LDFLAGS) -ffast-math" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#================= Woodcrest =========================================
+woodcrest:
+	$(MAKE) LD="mpif90 -o" LDFLAGS="" \
+	FC=mpif90 FFLAGS="-c -O3" \
+	EX=$(EX) BINROOT=$(BINROOT) $(TYPE)
+
+#=====================================================================
+# Default code for parallel (MPI) execution
+
+par: check $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(OBJ_SRC)
+	$(LD) $(EX) $(LDFLAGS) $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(RECON_LIBS) $(OBJ_SRC)
+	mv $(EX) $(EXE)
+
+#=====================================================================
+# Check that a machine has been specified
+check:
+	@if test $(FC) = "undefined";\
+	then echo "You must specify a target machine!"; \
+	exit 99;\
+	fi
+
+#=====================================================================
+# Clean up the source directory
+clean:
+	rm -f $(OBJ_MOD) $(OBJ_PAR) $(OBJ_METAD) $(OBJ_RECON) $(OBJ_SRC) *.mod
+
+#=====================================================================
+# Declare dependencies
+.f.o: 
+	$(FC) $(FFLAGS) $*.f
+
+.c.o: $(HEAD_METAD) 
+	$(CC) -DDL_POLY $(RECON_FLAGS) -DMPI -c $(CFLAGS) $< -o $@
+
+%.o: %.cpp $(HEAD_RECON) 
+	$(CPP) -DMPI $(RECON_FLAGS) -c $(CFLAGS) $< -o $@
+
+#=====================================================================
+# Declare dependency on module files
+
+$(OBJ_SRC): $(OBJ_MOD)
+
+#=====================================================================
+# Declare dependency for C header files
+
+$(OBJ_METAD): $(HEAD_METAD)
+$(OBJ_RECON): $(HEAD_RECON)
diff -urN dl_class_1.9.orig/srcmod/merge_tools.f dl_class_1.9/srcmod/merge_tools.f
--- dl_class_1.9.orig/srcmod/merge_tools.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/merge_tools.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,670 @@
+      subroutine merge(idnode,mxnode,natms,nbuff,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for merging coordinate arrays across
+c     a number of processors
+c     
+c     parallel replicated data version
+c
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith november 1992.
+c     MPI version - t. forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      use error_module
+
+      implicit none
+
+      integer idnode,mxnode,natms,nbuff,nsize,ierr,iatm1,iatm2
+      integer j,i,k,jdnode,kdnode,katm1,katm2,iatm,katm
+      real*8 xxx(natms),yyy(natms),zzz(natms),buffer(nbuff)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE), request
+
+CMPIU      define MPI_SEND MPI_SEND_
+CMPIU      define MPI_IRECV MPI_IRECV_
+CMPIU      define MPI_WAIT MPI_WAIT_
+
+c     check that buffer is large enough
+
+      nsize=(natms+mxnode-1)/mxnode
+      if(nbuff.lt.6*nsize)call error(idnode,47)
+
+c     load initial transfer buffer
+
+      j=0
+
+c     set up this nodes atoms
+
+      iatm1 = (idnode*natms)/mxnode + 1
+      iatm2 = ((idnode+1)*natms)/mxnode
+
+      iatm = iatm2-iatm1+1
+	
+      do i=iatm1,iatm2
+
+         buffer(j+1)=xxx(i)
+         buffer(j+2)=yyy(i)
+         buffer(j+3)=zzz(i)
+         j=j+3
+
+      enddo
+
+
+      call gsync()
+
+c     identity of neighbour node for systolic transfer
+
+      jdnode=mod(idnode+1,mxnode)
+
+      do k=1,mxnode-1
+
+c     identity of node of origin of incoming data
+
+         kdnode=mod(idnode+mxnode-k,mxnode)
+
+c     identity of incoming  atoms
+
+         katm1 = (kdnode*natms)/mxnode + 1
+         katm2 = ((kdnode+1)*natms)/mxnode
+         katm = katm2-katm1 + 1
+
+c     systolic data pulse to transfer data
+
+         call MPI_IRECV(buffer(3*nsize+1),3*nsize,MPI_DOUBLE_PRECISION,
+     x        MPI_ANY_SOURCE,Merge_tag+k,MPI_COMM_WORLD,request,ierr)
+
+         call MPI_SEND(buffer(1),3*nsize,MPI_DOUBLE_PRECISION,jdnode,
+     x        Merge_tag+k,MPI_COMM_WORLD,ierr)
+
+         call MPI_WAIT(request,status,ierr)
+
+c     merge the incoming data into current arrays
+
+         j=3*nsize
+
+         do i=katm1,katm2
+
+            xxx(i)=buffer(j+1)
+            yyy(i)=buffer(j+2)
+            zzz(i)=buffer(j+3)
+            j=j+3
+
+         enddo
+
+c     shift new data to start of buffer
+
+         do i=1,3*nsize
+
+            buffer(i)=buffer(3*nsize+i)
+
+         enddo
+
+      enddo
+      
+      return
+      end
+
+      subroutine merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for merging together coordinate arrays
+c     across a number of processors during rigid body algorithm
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - t.forester  november 1993
+c     systolic pulse version. T3D t.forester sept 1994
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c*********************************************************************
+      
+      use setup_module
+      use error_module
+
+      implicit none
+
+      include "comms.inc"
+      
+      logical safe
+      integer idnode,mxnode,natms,ierr,i,j,k,l,mxb,nout,nin
+      integer nin1,jdnode,j1,kdnode
+      integer lstme(natms)
+      real*8 xxx(mxatms),yyy(mxatms),zzz(mxatms),buffer(mxbuff)
+      
+      integer status(MPI_STATUS_SIZE), request
+
+CMPIU      define MPI_SEND MPI_SEND_
+CMPIU      define MPI_IRECV MPI_IRECV_
+CMPIU      define MPI_WAIT MPI_WAIT_
+
+      
+      safe =.true.
+      
+c     load up buffers
+      
+      j=1
+      l=1
+      do while(lstme(l).gt.0.and.l.le.natms)
+        
+        i=lstme(l)
+        buffer(j+1)=dble(i)
+        buffer(j+2)=xxx(i)
+        buffer(j+3)=yyy(i)
+        buffer(j+4)=zzz(i)
+        j=j+4
+        l=l+1
+        
+      enddo
+      
+c     length of message
+      
+      buffer(1) = dble(j)
+      
+c     array position for incoming messages
+      
+      mxb = mxbuff/2
+      
+c     load initial transfer buffer
+      
+      call gsync()
+      
+c     identity of neighbour node for systolic transfer
+      
+      jdnode=mod(idnode+1,mxnode)
+      
+      do k=1,mxnode-1
+        
+c     identity of node of origin of incoming data
+        
+        kdnode=mod(idnode+mxnode-k,mxnode)
+        
+c     out going message size
+        
+        nout = nint(buffer(1))
+        
+        call MPI_IRECV(nin,1,MPI_INTEGER,
+     x    MPI_ANY_SOURCE,Merge1_tag+k,MPI_COMM_WORLD,request,ierr)
+        
+        call MPI_SEND(nout,1,MPI_INTEGER,jdnode,
+     x    Merge1_tag+k,MPI_COMM_WORLD,ierr)
+        
+        call MPI_WAIT(request,status,ierr)
+        
+        call MPI_IRECV(buffer(mxb),nin,MPI_DOUBLE_PRECISION,
+     x    MPI_ANY_SOURCE,Merge1_tag+k,MPI_COMM_WORLD,request,ierr)
+        
+        call MPI_SEND(buffer(1),nout,MPI_DOUBLE_PRECISION,jdnode,
+     x    Merge1_tag+k,MPI_COMM_WORLD,ierr)
+        
+        call MPI_WAIT(request,status,ierr)
+        
+c     check buffer array not exceeded
+        
+        if(nin.gt.mxbuff-mxb) safe =.false.
+        
+c     position of first data element in incoming array
+        
+        nin1 = (nin-1)/4
+        j = mxb+1
+        
+        do j1=1,nin1
+          
+          i = nint(buffer(j))
+          xxx(i)=buffer(j+1)
+          yyy(i)=buffer(j+2)
+          zzz(i)=buffer(j+3)
+          j=j+4
+          
+        enddo
+        
+c     shift new data to start of buffer
+        
+        do i=1,nin
+          
+          buffer(i)=buffer(mxb-1+i)
+          
+        enddo
+        
+      enddo
+      
+c     global check 
+      
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe) call error(idnode,47)
+      
+      return
+      end
+
+      subroutine merge4(idnode,mxnode,ngrp,nbuff,q0,q1,q2,q3,buffer)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for merging coordinate arrays across
+c     a number of processors
+c     
+c     parallel replicated data version
+c
+c     copyright - daresbury laboratory 1994
+c     author    - t.forester  february 1994
+c     T3D version - sept 1994 t.forester
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c
+c*********************************************************************
+
+      use error_module
+      
+      implicit none
+      
+      integer idnode,mxnode,ngrp,nbuff,ierr,nsize,i,j,igrp1,igrp2
+      integer k,jdnode,kdnode,kgrp1,kgrp2
+      real*8 q0(ngrp),q1(ngrp),q2(ngrp),q3(ngrp),buffer(nbuff)
+
+      include "comms.inc"
+
+      integer status(MPI_STATUS_SIZE), request
+
+CMPIU      define MPI_SEND MPI_SEND_
+CMPIU      define MPI_IRECV MPI_IRECV_
+CMPIU      define MPI_WAIT MPI_WAIT_
+
+
+c     check that buffer is large enough
+
+      nsize=(ngrp+mxnode-1)/mxnode
+      if(nbuff.lt.8*nsize)call error(idnode,47)
+
+c     load initial transfer buffer
+
+      j=0
+
+      igrp1 = (idnode*ngrp)/mxnode+1
+      igrp2 = ((idnode+1)*ngrp)/mxnode
+
+      do i=igrp1,igrp2
+
+         buffer(j+1)=q0(i)
+         buffer(j+2)=q1(i)
+         buffer(j+3)=q2(i)
+         buffer(j+4)=q3(i)
+         j=j+4
+
+      enddo
+
+      call gsync()
+
+c     identity of neighbour node for systolic transfer
+
+      jdnode=mod(idnode+1,mxnode)
+     
+      do k=1,mxnode-1
+
+c     identity of node of origin of incoming data
+
+         kdnode=mod(idnode+mxnode-k,mxnode)
+
+c	identity of incoming groups 
+
+         kgrp1 = (kdnode*ngrp)/mxnode+1
+         kgrp2 = ((kdnode+1)*ngrp)/mxnode
+
+         call MPI_IRECV(buffer(4*nsize+1),4*nsize,MPI_DOUBLE_PRECISION,
+     x        MPI_ANY_SOURCE,Merge4_tag+k,MPI_COMM_WORLD,request,ierr)
+
+         call MPI_SEND(buffer(1),4*nsize,MPI_DOUBLE_PRECISION,jdnode,
+     x        Merge4_tag+k,MPI_COMM_WORLD,ierr)
+
+         call MPI_WAIT(request,status,ierr)
+
+c     merge the incoming data into current arrays
+
+         j=4*nsize
+
+         do i=kgrp1,kgrp2
+
+            q0(i)=buffer(j+1)
+            q1(i)=buffer(j+2)
+            q2(i)=buffer(j+3)
+            q3(i)=buffer(j+4)
+            j=j+4
+
+         enddo
+
+c     shift new data to start of buffer
+
+         do i=1,4*nsize
+
+            buffer(i)=buffer(4*nsize+i)
+
+         enddo
+
+      enddo
+      
+      return
+      end
+
+      subroutine shlmerge(idnode,mxnode,ntshl)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for merging core-shell velocity data
+c     to restore data replication on all nodes
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - w. smith february 1993
+c     MPI version - w. smith june 1995
+c     CPP version - w. smith june 1995
+c     
+c***********************************************************************
+     
+      use setup_module
+      use config_module
+      use core_shell_module
+      use error_module
+
+      implicit none
+
+      include "comms.inc"
+      
+      integer idnode,mxnode,ntshl,ierr,i,j,k,n,m,ishl1,ishl2,nsize
+      integer jdnode,kshl1,kshl2,kdnode
+
+      integer status(MPI_STATUS_SIZE), request
+
+CMPIU      define MPI_SEND MPI_SEND_
+CMPIU      define MPI_IRECV MPI_IRECV_
+CMPIU      define MPI_WAIT MPI_WAIT_
+
+c     check that buffer is large enough
+      
+      nsize=8*((ntshl+mxnode-1)/mxnode)
+      
+      if(mxbuff.lt.2*nsize)call error(idnode,425)
+
+c     block indices
+
+      ishl1 = (idnode*ntshl)/mxnode+1
+      ishl2 = ((idnode+1)*ntshl)/mxnode
+
+c     load initial transfer buffer
+      
+      n=0
+      m=0
+      
+      do k=ishl1,ishl2
+
+        m=m+1
+        
+c     indices of core and shell
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+        buffer(n+1)=dble(i)
+        buffer(n+2)=dble(j)
+        buffer(n+3)=vxx(i)
+        buffer(n+4)=vyy(i)
+        buffer(n+5)=vzz(i)
+        buffer(n+6)=vxx(j)
+        buffer(n+7)=vyy(j)
+        buffer(n+8)=vzz(j)
+        n=n+8
+
+      enddo
+      
+      call gsync()
+      
+c     identity of neighbour node for systolic transfer
+      
+      jdnode=mod(idnode+1,mxnode)
+      
+      do k=1,mxnode-1
+
+c     identity of node of origin of incoming data
+        
+        kdnode=mod(idnode+mxnode-k,mxnode)
+        
+c     systolic data pulse to transfer data
+        
+        call MPI_IRECV(buffer(nsize+1),nsize,MPI_DOUBLE_PRECISION,
+     x    MPI_ANY_SOURCE,Shell_tag+k,MPI_COMM_WORLD,request,ierr)
+
+        call MPI_SEND(buffer(1),nsize,MPI_DOUBLE_PRECISION,jdnode,
+     x    Shell_tag+k,MPI_COMM_WORLD,ierr)
+
+         call MPI_WAIT(request,status,ierr)
+
+c     merge the incoming data into current arrays
+        
+        n=nsize
+
+c     block indices
+
+        kshl1 = (kdnode*ntshl)/mxnode+1
+        kshl2 = ((kdnode+1)*ntshl)/mxnode
+
+        do m=kshl1,kshl2
+          
+          i=nint(buffer(n+1))
+          j=nint(buffer(n+2))
+          
+          vxx(i)=buffer(n+3)
+          vyy(i)=buffer(n+4)
+          vzz(i)=buffer(n+5)
+          vxx(j)=buffer(n+6)
+          vyy(j)=buffer(n+7)
+          vzz(j)=buffer(n+8)
+
+          n=n+8
+          
+        enddo
+        
+c     shift new data to start of buffer
+        
+        do i=1,nsize
+          
+          buffer(i)=buffer(nsize+i)
+          
+        enddo
+        
+      enddo
+      
+      return
+      end
+
+      subroutine shmove
+     x     (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x      txx,tyy,tzz,buffer)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for passing coordinate updates between
+c     nodes during the shake iteration cycle
+c     
+c     parallel replicated data algorithm 
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith august 1992.
+c     MPI version - t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+
+      use setup_module
+
+      implicit none
+
+      include "comms.inc"
+
+      integer idnode, mxnode, natms,ierr,i,k,j0,k0,n,jdnode,j
+      integer lishap(mxlshp),lashap(mxproc)
+
+      integer status(MPI_STATUS_SIZE), request
+
+CMPIU      define MPI_SEND MPI_SEND_
+CMPIU      define MPI_IRECV MPI_IRECV_
+CMPIU      define MPI_WAIT MPI_WAIT_
+
+      real*8 xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      real*8 txx(mxatms),tyy(mxatms),tzz(mxatms)
+      real*8 buffer(mxbuff)
+
+c     store increments to be transferred
+
+      do i=1,natms
+
+         txx(i)=xxt(i)
+         tyy(i)=yyt(i)
+         tzz(i)=zzt(i)
+
+      enddo
+
+c     transfer coordinate data to all nodes
+
+      call gsync()
+
+      do k=1,mxnode-1
+
+         i=0
+         j0=0
+         if(k.gt.1)j0=lashap(k-1)
+
+         do j=j0+1,lashap(k)
+
+            buffer(i+1)=txx(lishap(j))
+            buffer(i+2)=tyy(lishap(j))
+            buffer(i+3)=tzz(lishap(j))
+            i=i+3                             
+                                               
+         enddo
+
+c     inter node communication
+
+         k0=0
+
+         if(k+1.lt.mxnode)k0=lashap(mxnode-k-1)
+         n=3*(lashap(mxnode-k)-k0)
+         jdnode=mod(idnode+k,mxnode)
+
+c     check for zero length messages
+
+         if(n.gt.0) call MPI_IRECV(buffer(i+1),n,MPI_DOUBLE_PRECISION,
+     x        MPI_ANY_SOURCE,Shmove_tag+k,MPI_COMM_WORLD,request,ierr)
+
+         if(i.gt.0) call MPI_SEND(buffer(1),i,MPI_DOUBLE_PRECISION,
+     x        jdnode,Shmove_tag+k,MPI_COMM_WORLD,ierr)
+
+         if(n.gt.0) call MPI_WAIT(request,status,ierr)
+
+c     consolidate transferred data
+
+         do j=k0+1,lashap(mxnode-k)
+
+            xxt(lishap(j))=xxt(lishap(j))+buffer(i+1)
+            yyt(lishap(j))=yyt(lishap(j))+buffer(i+2)
+            zzt(lishap(j))=zzt(lishap(j))+buffer(i+3)
+            i=i+3
+
+         enddo
+         
+      enddo
+      
+      return
+      end
+
+      subroutine splice
+     x      (idnode,natms,listme,listot,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for splicing together coordinate arrays
+c     across a number of processors during shake algorithm
+c     
+c     parallel replicated data version
+c
+c     copyright - daresbury laboratory 1993
+c     author    - w. smith       march 1993
+c
+c     second version of splice
+c
+c*********************************************************************
+
+      use setup_module
+      use error_module
+      
+      implicit none
+
+      integer idnode,natms,listme,listot,j,n3,i,lastot
+      real*8 xxx,yyy,zzz,buffer
+
+      dimension listme(mxatms),listot(mxatms)
+      dimension xxx(natms),yyy(natms),zzz(natms)
+      dimension buffer(mxbuff)
+
+c     check buffer size
+
+      if(mxbuff.lt.6*natms) call error(idnode,190)
+
+c     load initial transfer buffers
+
+      j=3*natms
+      n3=3*natms
+
+      do i=1,natms
+
+         if(listot(i).gt.0)then
+
+            if(listme(i).gt.0)then
+
+               buffer(j+1)=xxx(i)
+               buffer(j+2)=yyy(i)
+               buffer(j+3)=zzz(i)
+
+            else
+
+               buffer(j+1)=0.d0
+               buffer(j+2)=0.d0
+               buffer(j+3)=0.d0
+
+            endif
+
+            j=j+3
+
+         endif
+
+      enddo
+
+      lastot=j-n3
+
+c     splice constraint coordinates
+
+      if(lastot.gt.0) call gdsum(buffer(n3+1),lastot,buffer(1))
+
+c     reconstitute coordinate arrays
+
+      j=n3
+
+      do i=1,natms
+
+         if(listot(i).gt.0)then
+
+            xxx(i)=buffer(j+1)/dble(listot(i))
+            yyy(i)=buffer(j+2)/dble(listot(i))
+            zzz(i)=buffer(j+3)/dble(listot(i))
+
+            j=j+3
+
+         endif
+
+      enddo
+      
+      return
+      end
diff -urN dl_class_1.9.orig/srcmod/metafreeze_module.f dl_class_1.9/srcmod/metafreeze_module.f
--- dl_class_1.9.orig/srcmod/metafreeze_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/metafreeze_module.f	2012-04-24 18:30:31.000000000 +0200
@@ -0,0 +1,3539 @@
+      module metafreeze_module
+
+c---------------------------------------------------------------------
+c     
+c     Metafreeze module for metadynamics
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c     Adapted for dl_poly classic w. smith dec 2010
+c
+c---------------------------------------------------------------------
+      
+      implicit none
+      
+c     Minimise usage by making everything private
+      
+      private
+
+c---------------------------------------------------------------------
+c     P u b l i c   R o u t i n e s
+c     ...  unless exposed here.
+c---------------------------------------------------------------------
+      
+      public :: define_metadynamics ! Called to intitialise this module
+      public :: metafreeze_driver ! Called at every MD time-step
+
+c---------------------------------------------------------------------
+c     P u b l i c   V a r i a b l e s
+c---------------------------------------------------------------------
+      
+      public :: lmetadyn  ! Is this a metadynamics calculation?
+      public :: driven    ! Is this atom site involved in metadynamics
+      public :: lstein,ltet,lglobpe,llocpe,ncolvar,nq4,nq6,ntet,hkey
+      public :: meta_step_int,globpe_scale,locpe_scale,ref_W_aug
+      public :: h_aug,wt_Dt
+
+c     Local copies of exluded atom arrays note that these are
+c     not indexed by atom number, but by an index which loops
+c     over the atoms handles by each MPI rank.
+      public :: mtd_nexatm,mtd_lexatm
+
+c------------------------------------
+c     Populated from CONTROL file   
+c------------------------------------
+      
+      logical,save :: lmetadyn =.false. ! Master metadynamics flag
+      
+c-------------------------------------------------------
+c     Energy, virial, stress and forces from 'local' pe
+c     Populated by dlpoly energy routines  
+c-------------------------------------------------------
+      
+      
+      public :: eng_loc,vir_loc,stress_loc  
+      public :: fxx_loc,fyy_loc,fzz_loc
+
+c----------------------------------------------------------------------
+c     Data accumulated for local potential energy (computed elsewhere) 
+c----------------------------------------------------------------------
+      
+      real(8),save                           :: eng_loc,vir_loc
+      real(8),dimension(9),save              :: stress_loc
+      real(8),allocatable,dimension(:),save  :: fxx_loc,fyy_loc,fzz_loc
+      
+c----------------------------------------------------------------------
+c     Arrays holding information on excluded interactions. Replicated 
+c     here to avoid a compilation dependency loop which would occur
+c     if simply using the arrays already in exclude_module.f
+c----------------------------------------------------------------------
+      integer,allocatable,dimension(:),save   :: mtd_nexatm
+      integer,allocatable,dimension(:,:),save :: mtd_lexatm
+
+c---------------------------------------------------------------------
+c     P r i v a t e   V a r i a b l e s 
+c---------------------------------------------------------------------
+
+c----------------------------------------------------------------
+c     Collective variables and derivatives of v_aug w.r.t colvars
+c----------------------------------------------------------------
+
+      integer,parameter :: maxhis = 150000 ! Size of history arrays      
+      real(8),allocatable,dimension(:),save   :: colvar,dcolvar
+      real(8),allocatable,dimension(:),save   :: colvar_scale
+
+c----------------------------------------------------------------
+c     Positions and heights of previous Gaussians in colvar space
+c----------------------------------------------------------------
+      
+      real(8),allocatable,dimension(:,:),save :: colvar_his
+      real(8),allocatable,dimension(:),save   :: w_aug
+      
+c------------------------------
+c     Read from CONTROL file
+c------------------------------
+      
+      integer,save :: ncolvar  = 0 ! Total number of collvars
+      logical,save :: lstein   =.false. ! Q4/Q6 collective variables
+      logical,save :: ltet     =.false. ! Tetrahedral order parameter
+      logical,save :: lglobpe  =.false. ! Global potential energy
+      logical,save :: llocpe   =.false. ! Local potential energy
+      
+      integer,save :: nq4   = 0 ! Number of Q4 pair types
+      integer,save :: nq6   = 0 ! Number of Q6 pair types
+      integer,save :: ntet  = 0 ! Number of zeta triplets
+      
+      real(8),save :: globpe_scale = 1.0d0 ! Scaling factors for local 
+      real(8),save :: locpe_scale  = 1.0d0 ! and global pe colvars
+      
+      real(8),save :: ref_W_aug=1.0d0 ! Reference Gaussian height
+      real(8),save :: h_aug=1.0d0     ! Gaussian width
+      integer,save :: hkey=0          ! Height control scheme
+      real(8),save :: wt_Dt=100.0d0   ! "Well-tempered" parameter
+      integer,save :: meta_step_int=5 ! interval between depositions
+      
+c----------------------------------------
+c     Read from STEINHARDT or TETRAHEDRAL
+c----------------------------------------
+      
+c     Global Steinhardt order parameters
+      
+      real(8),allocatable,dimension(:),save   :: q4_global 
+      real(8),allocatable,dimension(:),save   :: q6_global 
+      
+c     Global Tetrahedral order parameters
+      
+      real(8),allocatable,dimension(:),save   :: zeta_global 
+      
+c     Bookkeeping arrays for order parameter computation
+      
+      character(8),allocatable,dimension(:,:),save  :: q4label
+      character(8),allocatable,dimension(:,:),save  :: q6label
+      character(8),allocatable,dimension(:),save    :: zetalabel
+      
+c     Inner and outer cutoffs
+      
+      real(8),allocatable,dimension(:,:),save :: q4cutoff
+      real(8),allocatable,dimension(:,:),save :: q6cutoff
+      real(8),allocatable,dimension(:,:),save :: zetacutoff
+      
+c     Scaling factors for q4 and q6
+      
+      real(8),allocatable,dimension(:),save   :: q4scale
+      real(8),allocatable,dimension(:),save   :: q6scale
+      real(8),allocatable,dimension(:),save   :: zetascale
+      
+c     Number of nearest neighbours for q4, q6 and zeta
+      
+      integer,allocatable,dimension(:),save   :: q4nn,q6nn
+      integer,allocatable,dimension(:),save   :: zetann
+
+c------------------------------------------------------------
+c     Arrays holding data for computation of order parameters
+c------------------------------------------------------------
+      
+c     Steinhardt site-site interaction arrays
+      
+      integer,allocatable,dimension(:,:),save  :: q4site
+      integer,allocatable,dimension(:,:),save  :: q6site
+      integer,allocatable,dimension(:)  ,save  :: zetasite
+      
+c     Number of included sites
+      
+      integer,allocatable,dimension(:),save    :: q4ninc
+      integer,allocatable,dimension(:),save    :: q6ninc
+      integer,allocatable,dimension(:),save    :: zetaninc
+      
+c     Real and imaginary parts of q4bar and q6bar
+      
+      real(8),allocatable,dimension(:,:),save :: ReQ6bar,ImQ6bar
+      real(8),allocatable,dimension(:,:),save :: ReQ4bar,ImQ4bar
+      
+c     Max number of entries in co-ordination shell
+      
+      integer,parameter :: mxflist = 50 
+      integer :: mxninc
+      
+c     Full neighbour list for Tetrahedral order parameter
+      
+      integer,allocatable,dimension(:)  ,save   :: nflist 
+      integer,allocatable,dimension(:,:),save   :: flist
+      
+c-------------------------------------
+c     Internal bookkeeping
+c-------------------------------------
+      
+      logical,allocatable,dimension(:),save :: driven ! Metadynamics option
+      integer,save :: meta_step=1 ! Current metadynamics step number
+      real(8),save :: meta_energy ! Value of metadynamics bias potential
+      
+      integer,save :: wl_nbins=30    ! Number of bins for WL recursion
+      integer,save :: wl_cycle=0     ! Current WL cycle
+      real(8),save :: wl_range=0.175 ! range of WL 
+      real(8),allocatable,dimension(:),save :: wl_bin ! WL bins
+
+c--------------------------------------
+c     Miscellaneous internal variables
+c--------------------------------------
+
+      integer,allocatable,dimension(:) :: buff ! Comms buffer
+
+c     File units
+      
+      integer,save :: stn = 91  ! STEINHARDT
+      integer,save :: mtd = 92  ! METADYNAMICS
+      integer,save :: zta = 93  ! ZETA
+      integer,save :: wlb = 94  ! WL_BINS.DAT
+      
+c     Error flag
+      
+      integer,dimension(100) :: ierr = 0
+      
+c     Local store of comms variables
+c     Assuming no task farming, comms will require changing if farmed
+      
+      integer, save :: myrank,commsize 
+      logical, save :: onroot
+      real(8),save :: kt
+
+      contains
+
+      Subroutine Metafreeze_Driver
+     x  (imcon,natms,temp,nstep,engcfg,virtot,engord,virord)
+      
+c---------------------------------------------------------------------
+c     Top level metadynamics routine called after evaluation of all 
+c     other energetic and force terms within the main molecular 
+c     dynamics loop. 
+c     
+c     1. Computes the ncolvar order parameters
+c     2. Deposits a new Gaussian at the current collective variables 
+c        as the current number of steps reaches meta_step_int
+c     3. Computed the bias potential and its derivative w.r.t. the 
+c        ncolvar collective variables.
+c     4. Computes the forces stresses and virial resulting from the 
+c        bias
+c     
+c     Author  D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c
+c---------------------------------------------------------------------
+
+      use setup_module,    only : boltz
+      use config_module,   only : fxx,fyy,fzz,stress
+      
+      implicit none
+      
+      integer,intent(in)    :: nstep,imcon,natms
+      real(8),intent(in)    :: engcfg,virtot,temp
+      real(8),intent(out)   :: engord,virord
+      
+c     Local variables
+      
+      integer       :: k,iq,itet,ibin,nfail,my_meta_step
+      integer,save  :: nlastg = 0
+      real(8)       :: height,buff1,wl_mean
+      logical       :: flat,safe
+      
+c------------------------------------------------------
+c     Compute order parameters / collective variables
+c------------------------------------------------------
+
+c     Steinhardt order parameters
+      
+      if ( nq4>0.or.nq6>0 ) call compute_steinhardt(imcon,natms)
+      
+      k = 1
+      do iq = 1,nq4
+        colvar(k) = q4_global(iq)
+        k = k + 1
+      end do
+      do iq = 1,nq6
+        colvar(k) = q6_global(iq)
+        k = k + 1
+      end do
+      
+c     Tetrahedral order parameters
+      
+      if ( ntet > 0 ) then
+        call compute_tet_nlist(imcon,natms)
+        call compute_tetrahedral(imcon,natms)
+      end if  
+      
+      do itet = 1,ntet
+        colvar(k) = zeta_global(itet)
+        k = k + 1
+      end do
+      
+c     Energy order parameters
+      
+      if (lglobpe) then
+        colvar(k) = engcfg
+        k = k + 1
+      end if
+      if (llocpe) then
+        
+c     Global reduction of local virial and energy
+        
+        if ( commsize > 1 ) call gdsum(eng_loc,1,buff1)
+        if ( commsize > 1 ) call gdsum(vir_loc,1,buff1)
+        colvar(k)   = eng_loc
+        k = k + 1
+      end if
+      
+      if ( k-1/=ncolvar ) call Mfrz_Error(2500,0.d0) 
+      
+      if ( hkey==1 ) then
+        k = int(dble(wl_nbins)*colvar(1)/wl_range) + 1
+        if ( k < wl_nbins) wl_bin(k) = wl_bin(k) + 1.0d0
+      end if
+      
+c--------------------------------------------------------
+c     Deposit a new Gaussian if now is the correct time
+c--------------------------------------------------------
+      
+      if ( (mod(nstep,meta_step_int)==0).and.(nstep>nlastg) ) then
+        nlastg = nstep          ! Avoid multiple depositions at the
+                                ! same timestep (relaxed shell model)
+        
+        select case (hkey)
+          
+        case(0)
+          
+c     Always deposit Gaussians of the same height
+          
+          height = ref_W_aug
+          
+        case(1)
+          
+c     Wang-Landau style recursion
+          
+          open(unit=wlb,file='WL_BINS.DAT',status='replace')
+          
+          do ibin = 1,wl_nbins
+            write(wlb,*)ibin,wl_bin(ibin)
+          end do
+          
+          close(wlb)
+          
+          if ( ncolvar/=1 ) then
+            call Mfrz_Error(2501,0.d0)
+          else
+            
+            height    = ref_W_aug*(0.5d0**dble(wl_cycle))
+            
+            nfail = 0
+            wl_mean = 0.d0
+            do ibin = 6,wl_nbins-5
+              wl_mean = wl_mean + wl_bin(ibin)
+              nfail = nfail + 1
+            end do
+            wl_mean = wl_mean/dble(nfail)
+            
+            nfail = 0
+            flat = .true.
+            do ibin = 6,wl_nbins-5
+              if ( wl_bin(ibin) < 0.8d0*wl_mean ) then
+                if ( nfail > 2 ) flat = .false.
+                nfail = nfail + 1
+              end if
+            end do
+            
+            if ( flat.and.(sum(wl_bin)>50.0d0) ) then
+              wl_cycle = wl_cycle + 1
+              wl_bin   = 0.0d0
+            end if
+            
+            height = ref_W_aug*(0.5d0**dble(wl_cycle))
+            
+          end if   
+          
+        case(2)
+          
+c     Well-tempered metadynamics
+          
+          meta_energy = 0.0d0
+          call compute_bias_potential()
+          
+          height = ref_W_aug*exp(-meta_energy/wt_Dt)
+          
+        case default
+          
+          call Mfrz_Error(2502,0.d0)
+          
+        end select
+        
+        call deposit_gaussian(height,temp)
+        my_meta_step = (meta_step-1)/commsize + 1
+        safe = ( maxhis >= my_meta_step )
+        call gstate(safe)
+        if ( .not.safe ) call Mfrz_Error(2503,0.d0)
+        
+      end if
+      
+c-----------------------------------------------------------
+c     Compute the bias potential and its derivatives w.r.t.
+c     to the ncolvar collective variables.                 
+c-----------------------------------------------------------
+      
+      call compute_bias_potential()
+
+c-----------------------------------------------------------
+c     Add in the forces, stresses and virial contributions
+c     from this derivative.
+c-----------------------------------------------------------
+      
+      virord = 0.0d0            ! Zero the virial
+      
+c     Must compute contributions from pe order parameters
+c     first before we change any forces.
+      
+      k = nq4+nq6+ntet+1
+      
+c     Energy order parameters
+      
+      if (lglobpe) then
+        
+        fxx(:) = fxx(:)*(1.0d0+dcolvar(k))
+        fyy(:) = fyy(:)*(1.0d0+dcolvar(k))  
+        fzz(:) = fzz(:)*(1.0d0+dcolvar(k))
+        
+c     correct for later summation:
+        
+        virord = virord+dcolvar(k)*virtot/dble(commsize)
+        stress = stress*(1.0d0+dcolvar(k))
+        
+      end if
+      if (llocpe) then
+        
+        fxx(:) = fxx(:) + fxx_loc(:)*dcolvar(k)
+        fyy(:) = fyy(:) + fyy_loc(:)*dcolvar(k)
+        fzz(:) = fzz(:) + fzz_loc(:)*dcolvar(k)
+        
+c     correct for later summation:
+        
+        virord = virord + dcolvar(k)*vir_loc/dble(commsize)
+        stress = stress + stress_loc*dcolvar(k)
+        
+      end if
+      
+c     Steinhardt order parameters
+      
+      if ( nq4>0.or.nq6>0 ) call 
+     x  compute_steinhardt_forces(imcon,natms,engord,virord)
+      
+c     Tetrahedral order parameters
+      
+      if ( ntet > 0 ) call
+     x  compute_tetrahedral_forces(imcon,natms,engord,virord)
+      
+c     global reduction of virord
+
+      if ( commsize > 1 ) call gdsum(virord,1,buff1)
+      
+      engord = meta_energy
+
+c     write(0,'("DEBUG : engord = ",F12.6)')engord/(temp*boltz)
+      
+      return
+      
+      end Subroutine Metafreeze_Driver
+      
+      Subroutine Deposit_Gaussian(height,temp)
+
+c---------------------------------------------------------------------
+c     
+c     Deposits a new Gaussian at the current collective variables and 
+c     appends to the METADYNAMICs file.
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c
+c---------------------------------------------------------------------
+      
+      use setup_module, only : boltz
+      
+      implicit none
+      
+      real(8),intent(in) :: height,temp
+      integer       :: my_meta_step
+      character(11) :: fmtstring
+      
+c     store current order parameters and Gaussian height
+      
+      if ( mod(meta_step-1,commsize) == myrank ) then
+        
+        my_meta_step = (meta_step-1)/commsize + 1
+        w_aug(my_meta_step)        = height
+        colvar_his(:,my_meta_step) = colvar(:)
+        
+      end if
+      
+      if (onroot) then
+        
+c     Create format string
+        
+        write(fmtstring,'("(I8,",I1,"E15.6)")')ncolvar+1
+        
+c     write METADYNAMICS file
+        
+        open(unit=mtd,file='METADYNAMICS',status='old',position=
+     x    'append',iostat=ierr(1))
+        write(unit=mtd,fmt=fmtstring)meta_step,colvar(:),
+     x    height/(temp*boltz)
+        close(unit=mtd)
+        
+      end if
+      
+      meta_step = meta_step+1
+      
+      return
+      
+      end Subroutine Deposit_Gaussian
+
+      Subroutine Compute_Bias_Potential()
+      
+c---------------------------------------------------------------------
+c
+c     Computes the augmenting bias potential as a function of the 
+c     collective variables. Also computes the derivative of the bias 
+c     potential w.r.t. the collective variables required to compute 
+c     the metadynamics forces.
+c
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c     
+c---------------------------------------------------------------------
+      
+      implicit none
+      
+      integer :: istep,ic,k,my_meta_step
+      real(8) :: vsq,exp1,dWpsq
+      real(8),allocatable,dimension(:) :: buff1,buff2
+      
+      allocate(buff1(1:2*(ncolvar+1)),stat=ierr(1))
+      allocate(buff2(1:2*(ncolvar+1)),stat=ierr(2))
+      
+      if (any(ierr/=0)) call Mfrz_Error(2504,0.d0)
+
+c     Set squared-width of gaussians
+      
+      dWpsq = 1.0d0/h_aug**2
+      meta_energy  = 0.0d0
+      
+c     Zero accumulators of derivative w.r.t. each order parameter
+      
+      dcolvar(:) = 0.0d0
+      my_meta_step = (meta_step-1)/commsize + 1
+      do istep=1,my_meta_step
+        
+        vsq = 0.0d0
+        do ic = 1,ncolvar
+          vsq = vsq + ( colvar_scale(ic)*(colvar(ic) - 
+     x          colvar_his(ic,istep)) )**2
+        end do
+        exp1 = w_aug(istep)*exp(-0.5d0*vsq*dWpsq)
+        do ic = 1,ncolvar
+          dcolvar(ic) = dcolvar(ic) - (colvar_scale(ic)**2)*exp1*
+     x                  (colvar(ic) - colvar_his(ic,istep))*dWpsq
+        end do
+        
+        meta_energy = meta_energy + exp1
+        
+      end do
+      
+      buff1(1) = meta_energy
+      k = 2
+      do ic = 1,ncolvar
+        buff1(k) = dcolvar(ic)
+        k = k + 1
+      end do
+      
+      if ( commsize > 1 ) then
+        call gdsum(buff1,ncolvar+1,buff2)
+      end if
+      
+      meta_energy = buff1(1)
+      
+      k = 2
+      do ic=1,ncolvar
+        dcolvar(ic) = buff1(k)
+        k = k + 1
+      end do
+
+c     write(0,'("DEBUG : CV derivs = ",6F15.6)')dcolvar
+
+      deallocate(buff1,buff2,stat=ierr(1))
+      
+      return
+      
+      end Subroutine Compute_Bias_Potential
+      
+      Subroutine Define_Metadynamics(tm,ts,natms,ntpatm,temp)
+      
+c---------------------------------------------------------------------
+c     Processes the metadynamics input file. This is done in several 
+c     stages.
+c     1. Process the metadynamics control data read from the CONTROL
+c        file, which defines the number of collective variables and
+c        indicates if we need to read from auxilliary input files 
+c        (e.g. STEINHARDT or ZETA) which define order parameters.
+c     2. Read and process these auxilliary files.
+c     3. Process the information obtained from the CONTROL file which
+c        controls the properties of the Gaussians used to build the 
+c        bias potential.
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c     Adapted w. smith  - jan 2011
+c     
+c---------------------------------------------------------------------
+      
+      use site_module
+      use config_module, only : ltype
+      use parse_module
+      
+      implicit none
+      
+      integer,intent(in) :: tm,ts,natms,ntpatm
+      real(8),intent(in) :: temp
+      
+c     Local variables
+      
+      integer :: isite,jsite,ilin,i,iq,iatm0,iatm1,istrd,iatm,k,n,idum
+      logical :: lexist,go,safe
+      real(8) :: waug,dummy(1)
+      
+c     Allocate the driven list. Modifications elsewhere in DLPOLY always
+c     check if sites are driven (for accumulation of local PE) and hence
+c     this should be allocated if this is a metadynamics run or not.
+      
+      allocate(driven(1:size(unqatm)),stat=ierr(1))
+      if (ierr(1)/=0) call Mfrz_Error(2505,0.d0)
+      driven = .false.
+
+c     Do nothing else if the metafreeze flag has not been set in CONTROL
+      
+      if (.not.lmetadyn) then
+        return
+      end if
+      
+      myrank=tm 
+      commsize = ts
+      onroot = (myrank==0)
+
+    
+c$$$     DEBUG
+cc$$$    if (onroot) write(0,'("================================")')
+cc$$$    if (onroot) write(0,'("Available sites from site module")')
+cc$$$    if (onroot) write(0,'("================================")')
+cc$$$    if (onroot) then
+cc$$$       do isite = 1,size(unqatm)
+cc$$$          write(0,'("Site index ",i4,": ",a8)')isite,unqatm(isite)
+cc$$$       end do
+cc$$$    end if
+    
+c     Cannot bias the global and local PE in the same run.
+      
+      if ( lglobpe.and.llocpe ) call Mfrz_Error(2509,0.d0)
+
+c     Allocate local force arrays if anything is driven.
+      
+      allocate(fxx_loc(1:mxatms),stat=ierr(1))
+      allocate(fyy_loc(1:mxatms),stat=ierr(2))
+      allocate(fzz_loc(1:mxatms),stat=ierr(3))
+      if (any(ierr/=0)) call Mfrz_Error(2510,0.d0)
+   
+c     Allocate arrays to hold collective variables 
+      
+      allocate( colvar(1:ncolvar),stat=ierr(1))
+      allocate(dcolvar(1:ncolvar),stat=ierr(2))
+      allocate(colvar_his(1:ncolvar,1:maxhis),stat=ierr(3))
+      allocate(colvar_scale(1:ncolvar),stat=ierr(4))
+      allocate(w_aug(1:maxhis),stat=ierr(5))
+      if (any(ierr/=0)) call Mfrz_Error(2511,0.d0)
+      
+c     Allocate Wang-Landau bin array
+
+      allocate(wl_bin(1:wl_nbins),stat=ierr(1))
+      if (any(ierr/=0)) call Mfrz_Error(2512,0.d0)
+      wl_bin = 0.0d0
+      
+c-------------------------------------------------------------
+c     Process Steinhardt order parameter settings if present
+c-------------------------------------------------------------
+      
+      if ( lstein ) then
+        
+        allocate(q4label(1:2,1:nq4),stat=ierr(1))
+        allocate(q6label(1:2,1:nq6),stat=ierr(2))
+        allocate(q4cutoff(1:2,1:nq4),stat=ierr(3))
+        allocate(q6cutoff(1:2,1:nq6),stat=ierr(4))
+        allocate(q4scale(1:nq4),stat=ierr(5))
+        allocate(q6scale(1:nq6),stat=ierr(6))
+        allocate(q4nn(1:nq4),stat=ierr(7))
+        allocate(q6nn(1:nq6),stat=ierr(8))
+        allocate(q4ninc(1:nq4),stat=ierr(9))
+        allocate(q6ninc(1:nq6),stat=ierr(10))
+        allocate(buff(1:max(nq4,nq6)),stat=ierr(11))
+        allocate(q4_global(1:nq4),stat=ierr(12))
+        allocate(q6_global(1:nq6),stat=ierr(13))
+        allocate(ReQ4Bar(-4:+4,1:nq4),stat=ierr(14))
+        allocate(ImQ4Bar(-4:+4,1:nq4),stat=ierr(15))
+        allocate(ReQ6Bar(-6:+6,1:nq6),stat=ierr(16))
+        allocate(ImQ6Bar(-6:+6,1:nq6),stat=ierr(17))       
+        if (any(ierr/=0)) call Mfrz_Error(2515,0.d0)
+        
+c     Open STEINHARDT file and process
+        
+        if (onroot) then
+          open(unit=stn,file='STEINHARDT',status='old',iostat=ierr(1))
+        else
+          ierr(1)=0
+        endif
+        call gisum(ierr(1),1,ierr(2))
+        if ( ierr(1)/=0 ) call Mfrz_Error(2516,0.d0)
+        
+        ilin = 1
+        safe=.true.
+        if (nq4>0) then
+          call getrec(safe,myrank,stn) ! Ignore q4 comment line
+          ilin = ilin + 1
+          do i = 1,nq4
+            call getrec(safe,myrank,stn)
+            if (safe) then
+              call getword(q4label(1,i),record,8,lenrec)
+              call getword(q4label(2,i),record,8,lenrec)
+              q4cutoff(1,i)=dblstr(record,lenrec,idum)
+              q4cutoff(2,i)=dblstr(record,lenrec,idum)
+              q4scale(i)=dblstr(record,lenrec,idum)
+              q4nn(i)=intstr(record,lenrec,idum)
+              ierr(ilin)=0
+            else
+              ierr(ilin)=1
+            endif
+            ilin = ilin + 1
+          end do
+        end if
+        if (nq6>0) then
+          call getrec(safe,myrank,stn) ! Ignore q6 comment line
+          ilin = ilin + 1
+          do i = 1,nq6
+            call getrec(safe,myrank,stn)
+            if (safe) then
+              call getword(q6label(1,i),record,8,lenrec)
+              call getword(q6label(2,i),record,8,lenrec)
+              q6cutoff(1,i)=dblstr(record,lenrec,idum)
+              q6cutoff(2,i)=dblstr(record,lenrec,idum)
+              q6scale(i)=dblstr(record,lenrec,idum)
+              q6nn(i)=intstr(record,lenrec,idum)
+              ierr(ilin)=0
+            else
+              ierr(ilin)=1
+            endif
+            ilin = ilin + 1
+          end do
+        end if
+        if (onroot) close(unit=stn)
+        
+        call gisum(ierr(1),ilin-1,ierr(ilin))
+        do i = 1,ilin-1
+          if (ierr(i)/=0) then
+            call Mfrz_Error(2521,dble(i))
+          end if
+        end do
+        
+c     Create array indicating which site-site connections use
+c     which set of q4 cut-offs, scaling factors and num neighbours.
+       
+       allocate(q4site(1:size(unqatm),1:size(unqatm)),stat=ierr(1))
+       if (ierr(1)/=0) call Mfrz_Error(2517,0.d0)
+       q4site(:,:) = 0
+       
+       do isite = 1,ntpatm
+         do jsite = isite,ntpatm
+           do iq = 1,nq4
+             if ((q4label(1,iq)==unqatm(isite)).and.
+     x         (q4label(2,iq)==unqatm(jsite))) then
+               q4site(jsite,isite) = iq
+               q4site(isite,jsite) = iq
+               driven(jsite) = .true.
+               driven(isite) = .true.
+             end if
+           end do
+         end do
+       end do
+
+       allocate(q6site(1:size(unqatm),1:size(unqatm)),stat=ierr(1))
+       if (ierr(1)/=0) call Mfrz_Error(2518,0.d0)
+       q6site(:,:) = 0
+       do isite = 1,ntpatm
+         do jsite = isite,ntpatm
+           do iq = 1,nq6
+             if ((q6label(1,iq)==unqatm(isite)).and.
+     x         q6label(2,iq)==unqatm(jsite)) then
+               q6site(jsite,isite) = iq
+               q6site(isite,jsite) = iq
+               driven(jsite) = .true.
+               driven(isite) = .true.
+             end if
+           end do
+         end do
+       end do
+       
+c     Count number of included sites
+       
+       iatm0 = myrank+1
+       iatm1 = natms
+       istrd = commsize
+       
+       q4ninc = 0 
+       q6ninc = 0
+       do iatm = iatm0,iatm1,istrd
+         
+         isite = ltype(iatm)
+         
+         do iq = 1,nq4
+           if (unqatm(isite)==q4label(1,iq)) q4ninc(iq) = q4ninc(iq) + 1
+         end do
+         do iq = 1,nq6
+           if (unqatm(isite)==q6label(1,iq)) q6ninc(iq) = q6ninc(iq) + 1
+         end do
+         
+       end do
+       
+       if ( commsize > 0 ) then
+         if (nq4>0) call gisum(q4ninc,nq4,buff(1:nq4))
+         if (nq6>0) call gisum(q6ninc,nq6,buff(1:nq6))
+       end if
+       
+       deallocate(buff,stat=ierr(1))
+       if (ierr(1)/=0) call Mfrz_Error(2519,0.d0)
+       
+      end if                    ! end if steinhardt order parameters
+      
+      if ( ltet ) then
+        
+        allocate(zetacutoff(1:2,1:ntet),stat=ierr(1))
+        allocate(zeta_global(1:ntet),stat=ierr(2))
+        allocate(zetascale(1:ntet),stat=ierr(3))
+        allocate(zetalabel(1:ntet),stat=ierr(4))
+        allocate(zetann(1:ntet),stat=ierr(5))
+        allocate(zetaninc(1:ntet),stat=ierr(6))
+        allocate(buff(1:ntet),stat=ierr(7))
+        if (any(ierr/=0)) call Mfrz_Error(2522,0.d0)
+        
+c     Open ZETA file and process
+
+        if (onroot) then
+          open(unit=zta,file='ZETA',status='old',iostat=ierr(1))
+        else
+          ierr(1)=0
+        endif
+        call gisum(ierr(1),1,ierr(2))
+        if ( ierr(1)/=0 ) call Mfrz_Error(2523,0.d0)
+        
+        ilin = 1
+        safe=.true.
+        if (ntet>0) then
+          call getrec(safe,myrank,zta) ! Ignore comment line
+          ilin = ilin + 1
+          do i = 1,ntet
+            call getrec(safe,myrank,zta)
+            if (safe) then
+              call getword(zetalabel(i),record,8,lenrec)
+              zetacutoff(1,i)=dblstr(record,lenrec,idum)
+              zetacutoff(2,i)=dblstr(record,lenrec,idum)
+              zetascale(i)=dblstr(record,lenrec,idum)
+              zetann(i)=intstr(record,lenrec,idum)
+              ierr(ilin)=0
+            else
+              ierr(ilin)=1
+            endif
+            ilin = ilin + 1
+          end do
+        end if
+        if (onroot) close(unit=zta)
+
+        call gisum(ierr(1),ilin-1,ierr(ilin))
+        do i = 1,ilin-1
+          if (ierr(i)/=0) then
+            call Mfrz_Error(2529,dble(i))
+          end if
+        end do
+        
+c     Create array indicating which site-site connections use
+c     which set of q4 cut-offs, scaling factors and num neighbours.
+        
+        allocate(zetasite(1:size(unqatm)),stat=ierr(1))
+        if (ierr(1)/=0) call Mfrz_Error(2524,0.d0)
+        zetasite(:) = 0
+        
+        do isite = 1,size(unqatm)
+          do iq = 1,ntet
+            if (zetalabel(iq)==unqatm(isite)) then
+              zetasite(isite) = iq
+              driven(isite) = .true.
+            end if
+          end do
+        end do
+        
+c     Count number of included sites
+        
+        iatm0 = myrank+1
+        iatm1 = natms
+        istrd = commsize
+        
+        zetaninc(:) = 0
+        do iatm = iatm0,iatm1,istrd
+          
+          isite = ltype(iatm)
+          
+          do iq = 1,ntet
+            if (unqatm(isite)==zetalabel(iq)) 
+     x        zetaninc(iq) = zetaninc(iq) + 1
+          end do
+        end do
+        
+        if (commsize>1) then
+          if (ntet>0) call gisum(zetaninc,ntet,buff)
+        end if
+        
+c$$$        do iq = 1,ntet
+c$$$          write(0,'("Number of sites for zeta type ",I5," : ",I5)')
+c$$$     x      iq,zetaninc(iq)
+c$$$        end do
+        
+        mxninc = max(100,4*maxval(zetaninc)/commsize)
+        allocate(nflist(1:mxninc),stat=ierr(1))
+        allocate(flist(1:mxflist,1:mxninc),stat=ierr(2))
+        if (any(ierr/=0)) call Mfrz_Error(2525,0.d0)
+        
+        deallocate(buff,stat=ierr(1))
+        if (ierr(1)/=0) call Mfrz_Error(2519,0.d0)
+        
+      end if                    ! end if tetrahedral order parameters
+      
+c     Check total number of collective variables (ncolvar) matches total
+c     number specified by nq4, nq6, ntet and potential energy flags.
+      
+      k = 0
+      if (llocpe  ) k = k + 1
+      if (lglobpe ) k = k + 1
+      k = k + ntet + nq4 + nq6
+      if ( k /= ncolvar ) call Mfrz_Error(2527,0.d0)
+    
+c     populate colvar_scale
+      
+      k = 1
+      do iq = 1,nq4
+        colvar_scale(k) = q4scale(iq)
+        k = k + 1
+      end do
+      do iq = 1,nq6
+        colvar_scale(k) = q6scale(iq)
+        k = k + 1
+      end do
+      do iq = 1,ntet
+        colvar_scale(k) = zetascale(iq)
+        k = k + 1
+      end do
+      if (lglobpe) then
+        colvar_scale(k) = globpe_scale
+        k = k + 1
+      end if
+      if (llocpe) then
+        colvar_scale(k) = locpe_scale
+        k = k + 1
+      end if
+      
+c     write(0,*)lglobpe,llocpe
+c     write(0,'("DEBUG : CV Scaling factors : ",6F15.6)')colvar_scale(:)
+
+
+c     Convert into internal units
+      
+      wt_Dt = wt_Dt*temp*boltz
+      ref_W_aug = ref_W_aug*temp*boltz
+      kt        = temp*boltz
+      
+c---------------------------------------------------------------------
+c     Purge the METADYNAMICS file or re-open and read if this is a 
+c     restart. N.B. we assume a restart if REVOLD if present and 
+c     ignore keyres.
+c---------------------------------------------------------------------
+      
+      if (onroot) then
+        inquire(file='REVOLD',exist=lexist)
+      else
+        lexist=.true.
+      endif
+      call gstate(lexist)
+      
+      if (lexist) then
+        
+c     read contents of METADYNAMICS file
+        
+        if (onroot) then
+          
+          open(unit=mtd,file='METADYNAMICS',status='old',iostat=ierr(1))
+          
+          k = 0
+          do
+            read(unit=mtd,fmt=*,end=10)meta_step,colvar(:),waug
+            waug = waug*temp*boltz
+            if (k == 0) then
+              n = (meta_step-1)/commsize + 1
+              colvar_his(:,n)=colvar(:)
+              w_aug(n)=waug
+            else
+              dummy(1)=dble(meta_step)
+              call csend(17947,dummy,1,k,idum)
+              call csend(17948,colvar,ncolvar,k,ierr(3))
+              dummy(1)=waug
+              call csend(17949,dummy,1,k,ierr(4))
+            end if
+            
+            k = k + 1
+            if (k == commsize) k = 0
+          end do
+          
+   10     close(unit=mtd)
+          
+          do k=1,commsize-1
+            dummy(1)=-dble(meta_step)
+            call csend(17947,dummy,1,k,ierr(2))
+          end do
+          
+        else
+          
+          go = .true.
+          do while(go)
+            
+            call crecv(17947,dummy,1)
+            meta_step=nint(dummy(1))
+            ierr(2)=0
+            
+            if ( meta_step < 0 ) then
+              meta_step = -meta_step
+              go = .false.
+            else
+              call crecv(17948,colvar,ncolvar)
+              ierr(3)=0
+              call crecv(17949,dummy,1)
+              waug=dummy(1)
+              ierr(4)=0
+              n = (meta_step-1)/commsize + 1
+              colvar_his(:,n)=colvar(:)
+              w_aug(n)=waug
+            end if
+          
+          enddo
+          
+        end if
+        call gisum(ierr(1),4,ierr(5))
+        do i=1,4
+          if (ierr(i)/=0) call Mfrz_Error(2531,0.d0)
+        enddo
+        meta_step = meta_step + 1
+        
+      else
+        
+c     purge any existing METADYNAMICS file
+        
+        if (onroot) then
+          
+          open(unit=mtd,file='METADYNAMICS',status='replace',
+     x      iostat=ierr(1))
+          close(unit=mtd)
+          
+        end if
+        
+      end if
+      
+      return
+      
+      end Subroutine Define_Metadynamics
+      
+      Function Fc(r,inner_cut,outer_cut)
+      
+c---------------------------------------------------------------------
+c
+c     Computes the smooth cut-off function used when computing an order
+c     parameter as a function of pair separation.
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c     
+c---------------------------------------------------------------------
+      
+      implicit none
+      
+      real(8),parameter :: Pi=3.141592653589793238462643383279502884d0
+      real(8),intent(in) :: r,inner_cut,outer_cut
+      real(8) :: fc
+      
+      if ( r > outer_cut ) then
+        fc = 0.0d0
+      elseif ( r > inner_cut ) then
+        fc = 0.5d0*cos((r-inner_cut)*Pi/(outer_cut-inner_cut))+0.5d0
+      elseif ( r <= inner_cut ) then
+        fc = 1.0d0
+      else
+        call Mfrz_Error(2532,r)
+      end if
+      
+      return
+      
+      end Function Fc
+      
+      Function Dfc(r,inner_cut,outer_cut)
+      
+c---------------------------------------------------------------------
+c     Computes the derivative of the smooth cut-off function used when
+c     computing an order parameter as a function of pair separation.
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley
+c     
+c---------------------------------------------------------------------
+      
+      implicit none
+      
+      real(8),parameter :: Pi=3.141592653589793238462643383279502884d0
+      real(8),intent(in) :: r,inner_cut,outer_cut
+      real(8) :: dfc
+      
+      if ( r > outer_cut ) then
+        dfc = 0.0d0
+      elseif ( r > inner_cut ) then
+        dfc = -0.5d0*sin((r-inner_cut)*Pi/(outer_cut-inner_cut))
+     x    *Pi/(outer_cut-inner_cut)
+      else
+        dfc = 0.0d0
+      end if
+      
+      return
+      
+      end Function Dfc
+  
+      subroutine compute_steinhardt(imcon,natms)
+      
+c---------------------------------------------------------------------
+c     
+c     Computes nq4 Q4 and nq6 Q6 global order parameters.
+c
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley October 2008
+c     
+c---------------------------------------------------------------------
+      
+      use config_module
+      use site_module
+      use setup_module,   only : mxlist
+      use utility_module, only : images
+      
+      implicit none
+      
+c     Arguments
+      
+      integer,intent(in) :: imcon,natms
+      
+c     sqrt(pi/13) , sqrt(pi/9) , 1/3
+      
+      real(8),parameter :: rpibtt = 0.491590249d0
+      real(8),parameter :: rpibn  = 0.590817950d0
+      real(8),parameter :: third  = 1.0d0/3.0d0
+      
+c     Prefactors for spherical harmonics with l = 6
+      
+      real(8),parameter :: ypre6m6 =  0.48308411358006625446748d0
+      real(8),parameter :: ypre6m5 =  1.67345245810009801701312d0
+      real(8),parameter :: ypre6m4 =  0.35678126285399802686271d0
+      real(8),parameter :: ypre6m3 =  0.65139048586771575166665d0
+      real(8),parameter :: ypre6m2 =  0.32569524293385787583333d0
+      real(8),parameter :: ypre6m1 =  0.41197551630114082055201d0
+      real(8),parameter :: ypre6m0 =  0.06356920226762842462964d0
+      real(8),parameter :: ypre6p1 = -0.41197551630114082055201d0
+      real(8),parameter :: ypre6p2 =  0.32569524293385787583333d0
+      real(8),parameter :: ypre6p3 = -0.65139048586771575166665d0
+      real(8),parameter :: ypre6p4 =  0.35678126285399802686271d0
+      real(8),parameter :: ypre6p5 = -1.67345245810009801701312d0
+      real(8),parameter :: ypre6p6 =  0.48308411358006625446748d0
+      
+c     Prefactors for spherical harmonics with l = 4
+      
+      real(8),parameter :: ypre4m4 =  0.44253269244498261159038d0
+      real(8),parameter :: ypre4m3 =  1.25167147089835228968013d0
+      real(8),parameter :: ypre4m2 =  0.33452327177864460416856d0
+      real(8),parameter :: ypre4m1 =  0.47308734787878004013351d0
+      real(8),parameter :: ypre4m0 =  0.10578554691520430930396d0
+      real(8),parameter :: ypre4p1 = -0.47308734787878004013351d0
+      real(8),parameter :: ypre4p2 =  0.33452327177864460416856d0
+      real(8),parameter :: ypre4p3 = -1.25167147089835228968013d0
+      real(8),parameter :: ypre4p4 =  0.44253269244498261159038d0
+      
+c     Maximum no. of entries in solvation list
+      
+      integer :: maxneigh
+      
+c     Solvation shell information - Q4
+      
+      real(8),allocatable,dimension(:) :: solvx4,solvy4,solvz4
+      real(8),allocatable,dimension(:) :: solvrmag4,solvimag4,solvrsq4
+      integer,allocatable,dimension(:) :: solvlist4,solvtype4
+      integer :: isolvmax4
+      
+c     Solvation shell information - Q6
+      
+      real(8),allocatable,dimension(:) :: solvx6,solvy6,solvz6
+      real(8),allocatable,dimension(:) :: solvrmag6,solvimag6,solvrsq6
+      integer,allocatable,dimension(:) :: solvlist6,solvtype6
+      integer :: isolvmax6
+      
+c     separation vectors and powers thereof
+      
+      real(8),allocatable,dimension(:) :: xdf,ydf,zdf
+      real(8) :: x,y,z
+      real(8) :: x2,y2,z2,x3,y3,z3
+      real(8) :: x4,y4,z4,x5,y5,z5
+      real(8) :: x6,y6,z6
+      real(8) :: invrc,invrs
+
+c     list of separation vectors
+      integer :: numdst
+      integer,allocatable,dimension(:) :: dstlst
+
+      
+c     Comms buffers
+      
+      real(8),allocatable,dimension(:) :: buff1,buff2
+      
+c     Temporaries
+      
+      real(8) :: tmpsq,f_ij,df_ij,ReYlm,ImYlm,tmpvar
+      
+c     Loop counters
+      
+      integer :: iatm1,iatm0,iatm,isite,istrd,ii,isolv4,isolv6,isolv
+      integer :: idi,idj,limit,nn,k,jatm,jsite,q4type,q6type
+      integer :: itype,jtype,l,m,iq
+      
+      maxneigh = 100            ! Max number of atoms in coordination shell
+
+      ierr = 0                  ! Error flags
+      
+
+c     DQ - modified 10/12/11, arrays now big enough
+c     to hold maximum number of neighbours plus
+c     maximum number of excluded atoms.
+      allocate(xdf(1:mxlist+mxexcl),stat=ierr(1))
+      allocate(ydf(1:mxlist+mxexcl),stat=ierr(2))
+      allocate(zdf(1:mxlist+mxexcl),stat=ierr(3))
+
+c     DQ - modified 10/12/11, array to hold a list of
+c     all atom entries in the above three arrays
+      allocate(dstlst(1:mxlist+mxexcl),stat=ierr(4))
+      
+      allocate(solvx4(1:maxneigh),stat=ierr(5))
+      allocate(solvy4(1:maxneigh),stat=ierr(6))
+      allocate(solvz4(1:maxneigh),stat=ierr(7))
+      allocate(solvrmag4(1:maxneigh),stat=ierr(8))
+      allocate(solvimag4(1:maxneigh),stat=ierr(9))
+      allocate(solvrsq4 (1:maxneigh),stat=ierr(10))
+      allocate(solvlist4(1:maxneigh),stat=ierr(11)) 
+      allocate(solvtype4(1:maxneigh),stat=ierr(12))
+      
+      allocate(solvx6(1:maxneigh),stat=ierr(13))
+      allocate(solvy6(1:maxneigh),stat=ierr(14))
+      allocate(solvz6(1:maxneigh),stat=ierr(15))
+      allocate(solvrmag6(1:maxneigh),stat=ierr(16))
+      allocate(solvimag6(1:maxneigh),stat=ierr(17))
+      allocate(solvrsq6 (1:maxneigh),stat=ierr(18))
+      allocate(solvlist6(1:maxneigh),stat=ierr(19)) 
+      allocate(solvtype6(1:maxneigh),stat=ierr(20))
+      if (any(ierr/=0)) call Mfrz_Error(2533,0.d0) 
+      
+      allocate(buff1(1:18*nq4+26*nq6),stat=ierr(1))
+      allocate(buff2(1:18*nq4+26*nq6),stat=ierr(2))    
+      if (any(ierr/=0)) call Mfrz_Error(2534,0.d0)
+      
+c     Zero accumulators used in Steinhardt order parameters
+      
+      ReQ6bar = 0.0d0
+      ImQ6bar = 0.0d0
+      ReQ4bar = 0.0d0
+      ImQ4bar = 0.0d0
+      
+c     Set atoms looped over by current rank
+      
+      iatm0 = myrank+1
+      iatm1 = natms
+      istrd = commsize
+      
+      ii = 0
+      do iatm = iatm0,iatm1,istrd
+        
+c --------------------------------------------------------------
+c     Build a list of the required connections to iatm. This  
+c     differs depending on the version of DLPOLY we are using.
+c     First we loop over atoms in the neighbour list of iatm.
+c---------------------------------------------------------------
+      
+      ii = ii + 1
+      isite=ltype(iatm)
+      limit=lentry(ii)
+      nn = 0
+      do k = 1,limit
+        
+        jatm  = list(ii,k)
+        jsite = ltype(jatm)
+        
+        if ( q4site(jsite,isite)+q6site(jsite,isite)==0 ) cycle
+        
+        nn = nn + 1
+
+        dstlst(nn) = jatm
+        
+        xdf(nn)=xxx(jatm)-xxx(iatm)
+        ydf(nn)=yyy(jatm)-yyy(iatm)
+        zdf(nn)=zzz(jatm)-zzz(iatm) 
+        
+      end do
+
+c --------------------------------------------------------------
+c     Next we loop over the excluded atom list of iatm and add 
+c     and pairs needed for computation of the current OP.
+c---------------------------------------------------------------
+
+ccc   DEBUG
+ccc      write(0,'("atom ",I5," has ",I5," excluded interactions")')
+ccc     x iatm,mtd_nexatm(iatm)
+
+      do k = 1,mtd_nexatm(ii)
+
+         jatm  = mtd_lexatm(ii,k)
+         jsite = ltype(jatm)
+
+ccc   DEBUG
+ccc         write(0,'("Interaction with atom ",I5," is excluded. ")')jatm
+
+         if ( q4site(jsite,isite)+q6site(jsite,isite)==0 ) cycle
+        
+         nn = nn + 1
+        
+         dstlst(nn) = jatm
+
+         xdf(nn)=xxx(jatm)-xxx(iatm)
+         ydf(nn)=yyy(jatm)-yyy(iatm)
+         zdf(nn)=zzz(jatm)-zzz(iatm) 
+
+      end do
+
+ccc   DEBUG
+ccc      write(0,'("Num neighbours to consider for atom ",I5," : ",I5)')
+ccc     x iatm,nn
+
+      numdst = nn
+
+      call images(imcon,0,1,nn,cell,xdf,ydf,zdf)
+      nn = 0
+      isolvmax4 = 0
+      isolvmax6 = 0
+      isolv4 = 0
+      isolv6 = 0
+
+      do k = 1,numdst
+        jatm  = dstlst(k)
+        jsite = ltype(jatm)
+        
+        if ( q4site(jsite,isite)+q6site(jsite,isite)==0 ) cycle
+        
+        nn = nn + 1
+        
+        q4type = q4site(jsite,isite)
+        q6type = q6site(jsite,isite)
+        
+        tmpsq = xdf(nn)*xdf(nn)+ydf(nn)*ydf(nn)+zdf(nn)*zdf(nn)
+        
+        if (nq4>0) then
+          
+c     Add to solvation lists if within cut-off 
+          
+          if (  tmpsq < q4cutoff(2,q4type)**2 ) then
+            isolv4 = isolv4 + 1
+            solvlist4(isolv4) = jatm
+            solvrsq4(isolv4)  = tmpsq
+            solvrmag4(isolv4) = sqrt(tmpsq)
+            solvimag4(isolv4) = 1.0d0/solvrmag4(isolv4)
+            solvx4(isolv4)    = xdf(nn)
+            solvy4(isolv4)    = ydf(nn)
+            solvz4(isolv4)    = zdf(nn)
+            solvtype4(isolv4) = q4type
+          end if
+        end if
+        
+        if (nq6>0) then
+          
+c     Add to solvation lists if within cut-off 
+          
+          if (  tmpsq < q6cutoff(2,q6type)**2 ) then
+            isolv6 = isolv6 + 1
+            solvlist6(isolv6) = jatm
+            solvrsq6(isolv6)  = tmpsq
+            solvrmag6(isolv6) = sqrt(tmpsq)
+            solvimag6(isolv6) = 1.0d0/solvrmag6(isolv6)
+            solvx6(isolv6)    = xdf(nn)
+            solvy6(isolv6)    = ydf(nn)
+            solvz6(isolv6)    = zdf(nn)
+            solvtype6(isolv6) = q6type
+          end if
+        end if
+        isolvmax4 = isolv4
+        isolvmax6 = isolv6
+        if ((isolv4>maxneigh) .or. (isolv6>maxneigh))
+     x    call Mfrz_Error(2535,0.d0)
+        
+      end do                    ! end loop over k
+
+ccc      write(0,'("Num in range for OPs on atom ",I5," : ",I5)')
+ccc     x iatm,isolvmax4
+
+      
+c---------------------------------------------------------
+c     Compute Q4 Steinhardt order parameters              
+c---------------------------------------------------------
+      
+      if ( (nq4>0).and.isolvmax4>0 ) then
+        
+        do isolv4 = 1,isolvmax4
+          
+          jatm = solvlist4(isolv4)
+          itype = solvtype4(isolv4)
+          
+          invrc = solvimag4(isolv4)**6
+          invrs = solvimag4(isolv4)**4
+          
+          x     = solvx4(isolv4)
+          y     = solvy4(isolv4)
+          z     = solvz4(isolv4)
+          
+          f_ij  = fc(solvrmag4(isolv4),q4cutoff(1,itype),
+     x              q4cutoff(2,itype))
+          
+          x2 = x*x
+          y2 = y*y
+          z2 = z*z
+          
+          x3 = x2*x
+          y3 = y2*y
+          z3 = z2*z
+          
+          x4 = x2*x2
+          y4 = y2*y2
+          z4 = z2*z2
+          
+          x5 = x4*x
+          y5 = y4*y
+          z5 = z4*z
+          
+          x6 = x4*x2
+          y6 = y4*y2
+          z6 = z4*z2
+          
+c----------------------------------------------------------
+c     Real and imaginary contribution to Q4bar(-4/+4)
+c----------------------------------------------------------
+          
+          ReYlm = ypre4m4*invrs*(x4-6.d0*x2*y2+y4)
+          ImYlm = ypre4m4*invrs*(-4.d0*x3*y+4.d0*x*y3)
+          
+          ReQ4bar(-4,itype) = ReQ4bar(-4,itype) + f_ij*ReYlm
+          ImQ4bar(-4,itype) = ImQ4bar(-4,itype) + f_ij*ImYlm
+
+          ReQ4bar(+4,itype) = ReQ4bar(+4,itype) + f_ij*ReYlm
+          ImQ4bar(+4,itype) = ImQ4bar(+4,itype) - f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary contribution to Q4bar(-3/+3)
+c----------------------------------------------------------
+          
+          ReYlm = ypre4m3*invrs*z*(x3-3.d0*x*y2)
+          ImYlm = ypre4m3*invrs*z*(-3.d0*x2*y+y3)
+          
+          ReQ4bar(-3,itype) = ReQ4bar(-3,itype) + f_ij*ReYlm
+          ImQ4bar(-3,itype) = ImQ4bar(-3,itype) + f_ij*ImYlm
+
+          ReQ4bar(+3,itype) = ReQ4bar(+3,itype) - f_ij*ReYlm
+          ImQ4bar(+3,itype) = ImQ4bar(+3,itype) + f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary contribution to Q4bar(-2/+2)
+c----------------------------------------------------------
+          
+          ReYlm = -ypre4m2*invrs*(x2-y2)*(-6.d0*z2+x2+y2)
+          ImYlm = ypre4m2*invrs*2.d0*(-6.d0*z2+x2+y2)*x*y
+          
+          ReQ4bar(-2,itype) = ReQ4bar(-2,itype) + f_ij*ReYlm
+          ImQ4bar(-2,itype) = ImQ4bar(-2,itype) + f_ij*ImYlm
+
+          ReQ4bar(+2,itype) = ReQ4bar(+2,itype) + f_ij*ReYlm
+          ImQ4bar(+2,itype) = ImQ4bar(+2,itype) - f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary contribution to Q4bar(-1/+1)
+c----------------------------------------------------------
+          
+          ReYlm = -ypre4m1*invrs*z*(-4.d0*z2+3.d0*x2+3.d0*y2)*x
+          ImYlm = ypre4m1*invrs*z*(-4.d0*z2+3.d0*x2+3.d0*y2)*y
+          
+          ReQ4bar(-1,itype) = ReQ4bar(-1,itype) + f_ij*ReYlm
+          ImQ4bar(-1,itype) = ImQ4bar(-1,itype) + f_ij*ImYlm
+
+          ReQ4bar(+1,itype) = ReQ4bar(+1,itype) - f_ij*ReYlm
+          ImQ4bar(+1,itype) = ImQ4bar(+1,itype) + f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary contribution to Q4bar(0)
+c----------------------------------------------------------
+          
+          ReYlm = ypre4m0*invrs*(8.d0*z4-24.d0*z2*x2-24.d0*z2*y2+
+     x      3.d0*x4+6.d0*x2*y2+3.d0*y4)
+          
+          ReQ4bar(0,itype)  = ReQ4bar(0,itype) + f_ij*ReYlm
+          
+        end do                  ! end loop over connection list for iatm
+        
+      end if                    ! end if computing Q4
+      
+c------------------------------------------------
+c     Compute Q6 Steinhardt order parameters     
+c------------------------------------------------
+      
+      if ( (nq6>0).and.isolvmax6>0 ) then
+        
+        do isolv6 = 1,isolvmax6
+          
+          jatm = solvlist6(isolv6)
+          itype = solvtype6(isolv6)
+          
+          invrc = solvimag6(isolv6)**6
+          invrs = solvimag6(isolv6)**4
+          
+          x     = solvx6(isolv6)
+          y     = solvy6(isolv6)
+          z     = solvz6(isolv6)
+          
+          f_ij  =  fc(solvrmag6(isolv6),q6cutoff(1,itype),
+     x               q6cutoff(2,itype))
+          
+          x2 = x*x
+          y2 = y*y
+          z2 = z*z
+          
+          x3 = x2*x
+          y3 = y2*y
+          z3 = z2*z
+          
+          x4 = x2*x2
+          y4 = y2*y2
+          z4 = z2*z2
+          
+          x5 = x4*x
+          y5 = y4*y
+          z5 = z4*z
+          
+          x6 = x4*x2
+          y6 = y4*y2
+          z6 = z4*z2
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(-6/+6)
+c----------------------------------------------------------
+          
+          ReYlm = ypre6m6*invrc*(x6-15.0d0*x4*y2+15.0d0*x2*y4-y6)
+          ImYlm = ypre6m6*invrc*(-6.0d0*x5*y+20.0d0*x3*y3-6.0d0*x*y5)
+          
+          ReQ6bar(-6,itype) = ReQ6bar(-6,itype) + f_ij*ReYlm
+          ImQ6bar(-6,itype) = ImQ6bar(-6,itype) + f_ij*ImYlm
+
+          ReQ6bar(+6,itype) = ReQ6bar(+6,itype) + f_ij*ReYlm
+          ImQ6bar(+6,itype) = ImQ6bar(+6,itype) - f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(-5/+5)
+c----------------------------------------------------------
+          
+          ReYlm = -ypre6m5*invrc*z*(-x5+10.0d0*x3*y2-5.0d0*x*y4)
+          ImYlm = -ypre6m5*invrc*z*(5.0d0*x4*y-10.0d0*x2*y3+y5)
+          
+          ReQ6bar(-5,itype) = ReQ6bar(-5,itype) + f_ij*ReYlm
+          ImQ6bar(-5,itype) = ImQ6bar(-5,itype) + f_ij*ImYlm
+
+          ReQ6bar(+5,itype) = ReQ6bar(+5,itype) - f_ij*ReYlm
+          ImQ6bar(+5,itype) = ImQ6bar(+5,itype) + f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(-4/+4)
+c----------------------------------------------------------
+          
+          ReYlm = ypre6m4*invrc*(10.0d0*z2-x2-y2)*(x4-6.0d0*x2*y2+y4)
+          ImYlm = ypre6m4*invrc*(10.0d0*z2-x2-y2)*(-4.0d0*x3*y+
+     x            4.0d0*x*y3)
+          
+          ReQ6bar(-4,itype) = ReQ6bar(-4,itype) + f_ij*ReYlm
+          ImQ6bar(-4,itype) = ImQ6bar(-4,itype) + f_ij*ImYlm
+
+          ReQ6bar(+4,itype) = ReQ6bar(+4,itype) + f_ij*ReYlm
+          ImQ6bar(+4,itype) = ImQ6bar(+4,itype) - f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(-3/+3)
+c----------------------------------------------------------
+          
+          ReYlm = -ypre6m3*invrc*z*(8.0d0*z2-3.0d0*x2-3.0d0*y2)*
+     x             (-x3+3.0d0*x*y2)
+          ImYlm = -ypre6m3*invrc*z*(8.0d0*z2-3.0d0*x2-3.0d0*y2)*
+     x             (3.0d0*x2*y-y3)
+          
+          ReQ6bar(-3,itype) = ReQ6bar(-3,itype) + f_ij*ReYlm
+          ImQ6bar(-3,itype) = ImQ6bar(-3,itype) + f_ij*ImYlm
+
+          ReQ6bar(+3,itype) = ReQ6bar(+3,itype) - f_ij*ReYlm
+          ImQ6bar(+3,itype) = ImQ6bar(+3,itype) + f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(-2/+2)
+c----------------------------------------------------------
+
+          ReYlm =  ypre6m2*invrc*(16.0d0*z4-16.0d0*z2*x2-16.0d0*z2*y2+
+     x             x4+2.0d0*x2*y2+y4)*(x2-y2)
+          ImYlm = -ypre6m2*invrc*2.0d0*(16.0d0*z4-16.0d0*z2*x2-16.0d0*
+     x             z2*y2+x4+2.0d0*x2*y2+y4)*x*y
+          
+          ReQ6bar(-2,itype) = ReQ6bar(-2,itype) + f_ij*ReYlm
+          ImQ6bar(-2,itype) = ImQ6bar(-2,itype) + f_ij*ImYlm
+
+          ReQ6bar(+2,itype) = ReQ6bar(+2,itype) + f_ij*ReYlm
+          ImQ6bar(+2,itype) = ImQ6bar(+2,itype) - f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(-1/+1)
+c----------------------------------------------------------
+          
+          ReYlm =  ypre6m1*z*invrc*(8.0d0*z4-20.0d0*z2*x2-20.0d0*z2*y2+
+     x             5.0d0*x4+10.0d0*x2*y2+5.0d0*y4)*x
+          ImYlm = -ypre6m1*z*invrc*(8.0d0*z4-20.0d0*z2*x2-20.0d0*z2*y2+
+     x             5.0d0*x4+10.0d0*x2*y2+5.0d0*y4)*y
+          
+          ReQ6bar(-1,itype) = ReQ6bar(-1,itype) + f_ij*ReYlm
+          ImQ6bar(-1,itype) = ImQ6bar(-1,itype) + f_ij*ImYlm
+
+          ReQ6bar(+1,itype) = ReQ6bar(+1,itype) - f_ij*ReYlm
+          ImQ6bar(+1,itype) = ImQ6bar(+1,itype) + f_ij*ImYlm
+          
+c----------------------------------------------------------
+c     Real and imaginary conribution to Q6bar(0)
+c----------------------------------------------------------
+          
+          ReYlm =  ypre6m0*invrc*(16.0d0*z6-120.0d0*z4*x2-120.0d0*z4*
+     x             y2+90.0d0*z2*x4+180.0d0*z2*x2*y2+90.0d0*z2*y4-5.0d0
+     x             *x6-15.0d0*x4*y2-15.0d0*x2*y4-5.0d0*y6)
+          
+          ReQ6bar(0,itype) = ReQ6bar(0,itype) + f_ij*ReYlm
+          
+        end do                  ! end loop over connection list for iatm
+        
+      end if                    ! end if computing Q6
+      
+      end do                    ! end loop over iatm
+      
+c-----------------------------------------------
+c     Global summation of order parameters      
+c-----------------------------------------------
+      
+      l = 1
+      do itype = 1,nq4
+        do m = -4,4
+          buff1(l) = ReQ4bar(m,itype)
+          l = l + 1
+        end do
+        do m = -4,4
+          buff1(l) = ImQ4bar(m,itype)
+          l = l + 1
+        end do
+      end do
+      do itype = 1,nq6
+        do m = -6,6
+          buff1(l) = ReQ6bar(m,itype)
+          l = l + 1
+        end do
+        do m = -6,6
+          buff1(l) = ImQ6bar(m,itype)
+          l = l + 1
+        end do
+      end do
+      
+      if (commsize>1)   call gdsum(buff1,18*nq4+26*nq6,buff2)
+      
+      l = 1
+      do itype = 1,nq4
+        do m = -4,4
+          ReQ4bar(m,itype) = buff1(l)
+          l = l + 1
+        end do
+        do m = -4,4
+          ImQ4bar(m,itype) = buff1(l)
+          l = l + 1
+        end do
+      end do
+      do itype = 1,nq6
+        do m = -6,6
+          ReQ6bar(m,itype) = buff1(l)
+          l = l + 1
+        end do
+        do m = -6,6
+          ImQ6bar(m,itype) = buff1(l)
+          l = l + 1
+        end do
+      end do
+      
+c---------------------------------------------------
+c     Final computation of global order parameters  
+c---------------------------------------------------
+      
+      l = 1
+      do iq = 1,nq4
+        tmpvar = 0.0d0
+        do m = 1,18
+          tmpvar = tmpvar + buff1(l)**2
+          l = l + 1
+        end do
+        q4_global(iq) = 4.0d0*rpibn*sqrt(tmpvar)/
+     x                  dble(q4ninc(iq)*q4nn(iq))
+      end do
+      
+      do iq = 1,nq6
+        tmpvar = 0.0d0
+        do m = 1,26
+          tmpvar = tmpvar + buff1(l)**2
+          l = l + 1
+        end do
+        q6_global(iq) = 4.0d0*rpibtt*sqrt(tmpvar)/
+     x                  dble(q6ninc(iq)*q6nn(iq))
+      end do
+      
+c     Tidy up
+      
+      deallocate(xdf,stat=ierr(1))
+      deallocate(ydf,stat=ierr(2))
+      deallocate(zdf,stat=ierr(3))
+
+      deallocate(dstlst,stat=ierr(4))
+      
+      deallocate(solvx4,stat=ierr(5))
+      deallocate(solvy4,stat=ierr(6))
+      deallocate(solvz4,stat=ierr(7))
+      deallocate(solvrmag4,stat=ierr(8))
+      deallocate(solvimag4,stat=ierr(9))
+      deallocate(solvrsq4 ,stat=ierr(10))
+      deallocate(solvlist4,stat=ierr(11)) 
+      deallocate(solvtype4,stat=ierr(12))
+      
+      deallocate(solvx6,stat=ierr(13))
+      deallocate(solvy6,stat=ierr(14))
+      deallocate(solvz6,stat=ierr(15))
+      deallocate(solvrmag6,stat=ierr(16))
+      deallocate(solvimag6,stat=ierr(17))
+      deallocate(solvrsq6 ,stat=ierr(18))
+      deallocate(solvlist6,stat=ierr(19)) 
+      deallocate(solvtype6,stat=ierr(20))
+      if (any(ierr/=0)) call Mfrz_Error(2536,0.d0) 
+      
+      deallocate(buff1,stat=ierr(1))
+      deallocate(buff2,stat=ierr(2))    
+      if (any(ierr/=0)) call Mfrz_Error(2537,0.d0)
+
+      return
+      
+      end Subroutine Compute_Steinhardt
+      
+      Subroutine Compute_Steinhardt_Forces(imcon,natms,engord,virord)
+
+c---------------------------------------------------------------------
+c     
+c     Computes forces from nq4 Q4 and nq6 Q6 global order parameters.
+c
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley October 2008
+c     
+c---------------------------------------------------------------------
+      
+      use config_module
+      use site_module
+      use setup_module,   only : mxlist
+      use utility_module, only : images
+      implicit none
+      
+c     Arguments
+      
+      integer,intent(in) :: imcon,natms
+      
+      real(8),intent(inout) :: engord,virord
+      
+c     sqrt(pi/13) , sqrt(pi/9) , 1/3
+      
+      real(8),parameter :: rpibtt = 0.491590249d0
+      real(8),parameter :: rpibn  = 0.590817950d0
+      real(8),parameter :: third  = 1.0d0/3.0d0
+      
+c     Prefactors for spherical harmonics with l = 6
+      
+      real(8),parameter :: ypre6m6 =  0.48308411358006625446748d0
+      real(8),parameter :: ypre6m5 =  1.67345245810009801701312d0
+      real(8),parameter :: ypre6m4 =  0.35678126285399802686271d0
+      real(8),parameter :: ypre6m3 =  0.65139048586771575166665d0
+      real(8),parameter :: ypre6m2 =  0.32569524293385787583333d0
+      real(8),parameter :: ypre6m1 =  0.41197551630114082055201d0
+      real(8),parameter :: ypre6m0 =  0.06356920226762842462964d0
+      real(8),parameter :: ypre6p1 = -0.41197551630114082055201d0
+      real(8),parameter :: ypre6p2 =  0.32569524293385787583333d0
+      real(8),parameter :: ypre6p3 = -0.65139048586771575166665d0
+      real(8),parameter :: ypre6p4 =  0.35678126285399802686271d0
+      real(8),parameter :: ypre6p5 = -1.67345245810009801701312d0
+      real(8),parameter :: ypre6p6 =  0.48308411358006625446748d0
+      
+c     Prefactors for speherical harmonics with l = 4
+      
+      real(8),parameter :: ypre4m4 =  0.44253269244498261159038d0
+      real(8),parameter :: ypre4m3 =  1.25167147089835228968013d0
+      real(8),parameter :: ypre4m2 =  0.33452327177864460416856d0
+      real(8),parameter :: ypre4m1 =  0.47308734787878004013351d0
+      real(8),parameter :: ypre4m0 =  0.10578554691520430930396d0
+      real(8),parameter :: ypre4p1 = -0.47308734787878004013351d0
+      real(8),parameter :: ypre4p2 =  0.33452327177864460416856d0
+      real(8),parameter :: ypre4p3 = -1.25167147089835228968013d0
+      real(8),parameter :: ypre4p4 =  0.44253269244498261159038d0
+      
+c     Maximum no. of entries in solvation list
+      
+      integer :: maxneigh
+      
+c     Solvation shell information - Q4
+      
+      real(8),allocatable,dimension(:) :: solvx4,solvy4,solvz4
+      real(8),allocatable,dimension(:) :: solvrmag4,solvimag4,solvrsq4
+      integer,allocatable,dimension(:) :: solvlist4,solvtype4
+      integer :: isolvmax4
+      
+c     Solvation shell information - Q6
+      
+      real(8),allocatable,dimension(:) :: solvx6,solvy6,solvz6
+      real(8),allocatable,dimension(:) :: solvrmag6,solvimag6,solvrsq6
+      integer,allocatable,dimension(:) :: solvlist6,solvtype6
+      integer :: isolvmax6
+      
+c     Prefactors arising from derivative of bias potential
+
+      real(8),allocatable,dimension(:) :: q4prefactor,q6prefactor
+      
+c     Separation vectors and powers thereof
+      
+      real(8),allocatable,dimension(:) :: xdf,ydf,zdf
+      real(8) :: x,y,z
+      real(8) :: x2,y2,z2,x3,y3,z3
+      real(8) :: x4,y4,z4,x5,y5,z5
+      real(8) :: x6,y6,z6
+      real(8) :: invrc,invrs,invrq
+
+c     list of separation vectors
+      integer :: numdst
+      integer,allocatable,dimension(:) :: dstlst
+      
+c     Comms buffers
+      
+      real(8),allocatable,dimension(:) :: buff1,buff2
+      
+c     Temporaries
+
+      real(8) :: tmpsq,f_ij,df_ij,ReYlm,ImYlm,tmpvar,invrN
+      real(8) :: fx,fy,fz,fx2,fy2,fz2,prefactor2,fx1,fy1,fz1
+      real(8) :: strs1,strs2,strs3,strs4,strs5,strs6,strs7,strs8,strs9
+      
+      integer :: iatm1,iatm0,iatm,isite,istrd,ii,isolv4,isolv6,isolv
+      integer :: idi,idj,limit,nn,k,jatm,jsite,q4type,q6type
+      integer :: itype,jtype,l,m,iq
+      
+      maxneigh = 500         ! Max number of atoms in coordination shell
+      
+      ierr = 0               ! Error flags
+      
+c     DQ - modified 10/12/11, arrays now big enough
+c     to hold maximum number of neighbours plus
+c     maximum number of excluded atoms.
+      allocate(xdf(1:mxlist+mxexcl),stat=ierr(1))
+      allocate(ydf(1:mxlist+mxexcl),stat=ierr(2))
+      allocate(zdf(1:mxlist+mxexcl),stat=ierr(3))
+
+c     DQ - modified 10/12/11, array to hold a list of
+c     all atom entries in the above three arrays
+      allocate(dstlst(1:mxlist+mxexcl),stat=ierr(4))
+      
+      allocate(solvx4(1:maxneigh),stat=ierr(5))
+      allocate(solvy4(1:maxneigh),stat=ierr(6))
+      allocate(solvz4(1:maxneigh),stat=ierr(7))
+      allocate(solvrmag4(1:maxneigh),stat=ierr(8))
+      allocate(solvimag4(1:maxneigh),stat=ierr(9))
+      allocate(solvrsq4 (1:maxneigh),stat=ierr(10))
+      allocate(solvlist4(1:maxneigh),stat=ierr(11)) 
+      allocate(solvtype4(1:maxneigh),stat=ierr(12))
+      
+      allocate(solvx6(1:maxneigh),stat=ierr(13))
+      allocate(solvy6(1:maxneigh),stat=ierr(14))
+      allocate(solvz6(1:maxneigh),stat=ierr(15))
+      allocate(solvrmag6(1:maxneigh),stat=ierr(16))
+      allocate(solvimag6(1:maxneigh),stat=ierr(17))
+      allocate(solvrsq6 (1:maxneigh),stat=ierr(18))
+      allocate(solvlist6(1:maxneigh),stat=ierr(19)) 
+      allocate(solvtype6(1:maxneigh),stat=ierr(20))
+      if (any(ierr/=0)) call Mfrz_Error(2538,0.d0)
+      
+      allocate(buff1(1:18*nq4+26*nq6),stat=ierr(1))
+      allocate(buff2(1:18*nq4+26*nq6),stat=ierr(2))    
+      if (any(ierr/=0)) call Mfrz_Error(2534,0.d0)
+      
+      allocate(q4prefactor(1:nq4),stat=ierr(1))
+      allocate(q6prefactor(1:nq6),stat=ierr(2))
+      if (any(ierr/=0)) call Mfrz_Error(2540,0.d0)
+      
+c     Compute the prefactors associated from dV_aug/d_q4
+      
+      k = 1
+      do iq = 1,nq4
+        invrN = 1.0d0/dble(q4ninc(iq)*q4nn(iq))
+        q4prefactor(iq) = -16.0d0*(rpibn**2)*(invrN**2)*dcolvar(k)/
+     x                    Q4_global(iq)
+        k = k + 1
+      end do
+      
+c     Compute the prefactors associated from dV_aug/d_q6
+      
+      do iq = 1,nq6
+        invrN = 1.0d0/dble(q6ninc(iq)*q6nn(iq))
+        q6prefactor(iq) = -16.0d0*(rpibtt**2)*(invrN**2)*dcolvar(k)/
+     x                    Q6_global(iq)
+        k = k + 1
+      end do
+
+c     write(0,'("DEBUG : q4prefactors = ",5F15.6)')q4prefactor
+      
+c     Set atoms looper over by current rank
+      
+      iatm0 = myrank+1
+      iatm1 = natms
+      istrd = commsize
+      
+      strs1 = 0.0d0
+      strs2 = 0.0d0
+      strs3 = 0.0d0
+      strs4 = 0.0d0
+      strs5 = 0.0d0
+      strs6 = 0.0d0
+      strs7 = 0.0d0
+      strs8 = 0.0d0
+      strs9 = 0.0d0
+      
+      ii = 0
+      do iatm = iatm0,iatm1,istrd
+        
+c --------------------------------------------------------------
+c     Build a list of the required connections to iatm. This  
+c     differs depending on the version of DLPOLY we are using.
+c     First we loop over atoms in the neighbour list of iatm.
+c---------------------------------------------------------------
+        
+        ii = ii + 1
+        isite=ltype(iatm)
+        limit=lentry(ii)
+        
+        nn = 0
+        do k = 1,limit
+          
+          jatm  = list(ii,k)
+          jsite = ltype(jatm)
+          
+          if ( q4site(jsite,isite)+q6site(jsite,isite)==0 ) cycle
+          
+          nn = nn + 1
+
+          dstlst(nn) = jatm
+          
+          xdf(nn)=xxx(jatm)-xxx(iatm)
+          ydf(nn)=yyy(jatm)-yyy(iatm)
+          zdf(nn)=zzz(jatm)-zzz(iatm) 
+          
+        end do
+
+c --------------------------------------------------------------
+c     Next we loop over the excluded atom list of iatm and add 
+c     and pairs needed for computation of the current OP.
+c---------------------------------------------------------------
+
+ccc   DEBUG
+ccc        write(0,'("atom ",I5," has ",I5," excluded interactions")')
+ccc     x       iatm,mtd_nexatm(iatm)
+
+        do k = 1,mtd_nexatm(ii)
+           
+           jatm  = mtd_lexatm(ii,k)
+           jsite = ltype(jatm)
+           
+ccc   DEBUG
+ccc           write(0,'("Interaction with atom ",I5," is excluded. ")')jatm
+           
+           if ( q4site(jsite,isite)+q6site(jsite,isite)==0 ) cycle
+        
+           nn = nn + 1
+           
+           dstlst(nn) = jatm
+           
+           xdf(nn)=xxx(jatm)-xxx(iatm)
+           ydf(nn)=yyy(jatm)-yyy(iatm)
+           zdf(nn)=zzz(jatm)-zzz(iatm) 
+           
+        end do
+        
+ccc   DEBUG
+ccc        write(0,*)
+        
+        numdst = nn
+        
+        call images(imcon,0,1,nn,cell,xdf,ydf,zdf)
+        
+        nn = 0
+        isolvmax4 = 0
+        isolvmax6 = 0
+        isolv4 = 0
+        isolv6 = 0
+        do k = 1,numdst
+          jatm  = dstlst(k)
+          jsite = ltype(jatm)
+          
+          if ( q4site(jsite,isite)+q6site(jsite,isite)==0 ) cycle
+          
+          nn = nn + 1
+          
+          q4type = q4site(jsite,isite)
+          q6type = q6site(jsite,isite)
+          
+          tmpsq = xdf(nn)*xdf(nn)+ydf(nn)*ydf(nn)+zdf(nn)*zdf(nn)
+          if (nq4>0) then
+            
+c     Add to solvation lists if within cut-off 
+            
+            if (  tmpsq < q4cutoff(2,q4type)**2 ) then
+              isolv4 = isolv4 + 1
+              solvlist4(isolv4) = jatm
+              solvrsq4(isolv4)  = tmpsq
+              solvrmag4(isolv4) = sqrt(tmpsq)
+              solvimag4(isolv4) = 1.0d0/solvrmag4(isolv4)
+              solvx4(isolv4)    = xdf(nn)
+              solvy4(isolv4)    = ydf(nn)
+              solvz4(isolv4)    = zdf(nn)
+              solvtype4(isolv4) = q4type
+            end if
+          end if
+          
+          if (nq6>0) then
+            
+c     Add to solvation lists if within cut-off 
+            
+            if (  tmpsq < q6cutoff(2,q6type)**2 ) then
+              isolv6 = isolv6 + 1
+              solvlist6(isolv6) = jatm
+              solvrsq6(isolv6)  = tmpsq
+              solvrmag6(isolv6) = sqrt(tmpsq)
+              solvimag6(isolv6) = 1.0d0/solvrmag6(isolv6)
+              solvx6(isolv6)    = xdf(nn)
+              solvy6(isolv6)    = ydf(nn)
+              solvz6(isolv6)    = zdf(nn)
+              solvtype6(isolv6) = q6type
+            end if
+          end if
+          isolvmax4 = isolv4
+          isolvmax6 = isolv6
+          if ((isolv4>maxneigh) .or. (isolv6>maxneigh))
+     x      call Mfrz_Error(2535,0.d0)
+          
+        end do                  ! end loop over k
+        
+c---------------------------------------------------------
+c---------------------------------------------------------
+c     Compute forces arising from  Q4 order parameters    
+c---------------------------------------------------------
+c---------------------------------------------------------
+        
+        if ( (nq4>0).and.isolvmax4>0 ) then
+          
+          do isolv4 = 1,isolvmax4
+            
+            jatm = solvlist4(isolv4)
+            itype = solvtype4(isolv4)
+            
+            invrc = solvimag4(isolv4)**6
+            invrq = solvimag4(isolv4)**8
+            invrs = solvimag4(isolv4)**4
+            
+            x     = solvx4(isolv4)
+            y     = solvy4(isolv4)
+            z     = solvz4(isolv4)
+            
+            f_ij  =  fc(solvrmag4(isolv4),q4cutoff(1,itype),
+     x                 q4cutoff(2,itype))
+            df_ij = dfc(solvrmag4(isolv4),q4cutoff(1,itype),
+     x                 q4cutoff(2,itype))
+            
+            x2 = x*x
+            y2 = y*y
+            z2 = z*z
+            
+            x3 = x2*x
+            y3 = y2*y
+            z3 = z2*z
+            
+            x4 = x2*x2
+            y4 = y2*y2
+            z4 = z2*z2
+            
+            x5 = x4*x
+            y5 = y4*y
+            z5 = z4*z
+            
+            x6 = x4*x2
+            y6 = y4*y2
+            z6 = z4*z2
+            
+            fx = 0.0d0 
+            fy = 0.0d0 
+            fz = 0.0d0
+            
+c-------------------------------------
+c     Gradient of f_ij w.r.t. r_{j}   
+c-------------------------------------
+            
+            fx2 = df_ij*x*solvimag4(isolv4)
+            fy2 = df_ij*y*solvimag4(isolv4)
+            fz2 = df_ij*z*solvimag4(isolv4)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -4  
+c--------------------------------------------------------
+
+            ReYlm = ypre4m4*invrs*(x4-6.d0*x2*y2+y4)
+            ImYlm = ypre4m4*invrs*(-4.d0*x3*y+4.d0*x*y3)
+            
+c--------------------------------------------------
+c     Force contributions from m = -4 (real part)
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ReQ4bar(-4,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{4,-4}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 =  invrc*ypre4m4*4.d0*x*(4.d0*x2*y2-4.d0*y4+z2*x2-
+     x             3.d0*z2*y2)
+            fy1 = -invrc*ypre4m4*4.d0*y*(4.d0*x4-4.d0*x2*y2+3.d0*
+     x             z2*x2-z2*y2)
+            fz1 = -invrc*ypre4m4*4.d0*z*(x4-6.d0*x2*y2+y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c--------------------------------------------------------
+c     Force contributions from m = -4 (imaginary part) 
+c--------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ImQ4bar(-4,itype)
+            
+c----------------------------------------------
+c     Gradient of Im(Y_{4,-4}) w.r.t r_{j}
+c----------------------------------------------
+
+            fx1 =  invrc*ypre4m4*4.d0*y*(x4-6.d0*x2*y2-3.d0*z2*x2+
+     x             y4+z2*y2)
+            fy1 = -invrc*ypre4m4*4.d0*x*(-6.d0*x2*y2+y4+x4+z2*x2-
+     x             3.d0*z2*y2)
+            fz1 =  invrc*ypre4m4*16.d0*x*y*z*(x2-y2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -3  
+c--------------------------------------------------------
+            
+            ReYlm = ypre4m3*invrs*z*(x3-3.d0*x*y2)
+            ImYlm = ypre4m3*invrs*z*(-3.d0*x2*y+y3)
+            
+c--------------------------------------------------
+c     Force contributions from m = -3 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ReQ4bar(-3,itype)
+            
+c---------------------------------------------
+c     Gradient of Re(Y_{4,-3}) w.r.t r_{j}
+c---------------------------------------------
+            
+            fx1 = -invrc*ypre4m3*z*(x4-12.d0*x2*y2-3.d0*z2*x2+
+     x             3.d0*y4+3.d0*z2*y2)
+            fy1 = -invrc*ypre4m3*2.d0*z*x*y*(5.0d0*x2-3.d0*y2+
+     x             3.d0*z2)
+            fz1 =  invrc*ypre4m3*x*(x2-3.d0*y2)*(x2+y2-3.d0*z2)
+
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c-------------------------------------------------------
+c     Force contributions from m = -3 (imaginary part) 
+c-------------------------------------------------------
+
+            prefactor2 = 2.0d0*q4prefactor(itype)*ImQ4bar(-3,itype)
+            
+c--------------------------------------------------
+c     Gradient of Im(Y_{4,-3}) w.r.t r_{j}
+c--------------------------------------------------
+
+            fx1 =  invrc*ypre4m3*2.d0*z*x*y*(3.d0*x2-5.d0*y2-3.0d0*z2)
+            fy1 = -invrc*ypre4m3*z*(-12.d0*x2*y2+y4+3.d0*x4+3.d0*z2*x2
+     x            -3.d0*z2*y2)
+            fz1 = -invrc*ypre4m3*y*(3.d0*x2-y2)*(x2+y2-3.d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -2  
+c--------------------------------------------------------
+            
+            ReYlm = -ypre4m2*invrs*(x2-y2)*(-6.d0*z2+x2+y2)
+            ImYlm = ypre4m2*invrs*2.d0*(-6.d0*z2+x2+y2)*x*y
+            
+c--------------------------------------------------
+c     Force contributions from m = -2 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ReQ4bar(-2,itype)
+            
+c---------------------------------------------
+c     Gradient of Re(Y_{4,-2}) w.r.t r_{j}
+c---------------------------------------------
+
+            fx1 = -invrc*ypre4m2*4.d0*x*(4.d0*z2*x2+y4-9.d0*z2*y2-
+     x             3.d0*z4+x2*y2)
+            fy1 =  invrc*ypre4m2*4.d0*y*(x4-9.d0*z2*x2+4.d0*z2*y2-
+     x             3.d0*z4+x2*y2)
+            fz1 =  invrc*ypre4m2*4.d0*z*(x2-y2)*(4.d0*x2+4.d0*y2-
+     x             3.d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c-------------------------------------------------------
+c     Force contributions from m = -2 (imaginary part) 
+c-------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ImQ4bar(-2,itype)
+            
+c-----------------------------------------
+c Gradient of Im(Y_{4,-2}) w.r.t r_{j}
+c-----------------------------------------
+            
+            fx1 = -invrc*ypre4m2*2.d0*y*(x4-21.d0*z2*x2+5.d0*z2*y2+
+     x             6.d0*z4-y4)
+            fy1 =  invrc*ypre4m2*2.d0*x*(-y4+21.d0*z2*y2-5.d0*z2*x2
+     x            -6.d0*z4+x4)
+            fz1 = -invrc*ypre4m2*8.d0*z*x*y*(4.d0*x2+4.d0*y2-3.d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -1
+c--------------------------------------------------------
+            
+            ReYlm = -ypre4m1*invrs*z*(-4.d0*z2+3.d0*x2+3.d0*y2)*x
+            ImYlm = ypre4m1*invrs*z*(-4.d0*z2+3.d0*x2+3.d0*y2)*y
+            
+c--------------------------------------------------
+c     Force contributions from m = -1 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ReQ4bar(-1,itype)
+            
+c----------------------------------------
+c Gradient of Re(Y_{4,-1}) w.r.t r_{j}
+c----------------------------------------
+            
+            fx1 =  invrc*ypre4m1*z*(3.d0*x4-21.d0*z2*x2+z2*y2+4.d0*z4-
+     x             3.d0*y4)
+            fy1 =  invrc*ypre4m1*2.d0*z*x*y*(3.d0*x2+3.d0*y2-11.d0*z2)
+            fz1 = -invrc*ypre4m1*x*(-21.d0*x2*z2-21.d0*z2*y2+4.d0*z4+
+     x             3.d0*x4+6.d0*x2*y2+3.d0*y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c-------------------------------------------------------
+c     Force contributions from m = -1 (imaginary part) 
+c-------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q4prefactor(itype)*ImQ4bar(-1,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{4,-1}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -invrc*ypre4m1*2.d0*z*x*y*(3.d0*x2+3.d0*y2-11.d0*z2)
+            fy1 =  invrc*ypre4m1*z*(-3.d0*y4+21.d0*z2*y2-z2*x2-4.d0*z4+
+     x             3.d0*x4)
+            fz1 =  invrc*ypre4m1*y*(-21.d0*z2*x2-21.d0*z2*y2+4.d0*z4+
+     x             3.d0*x4+6.d0*x2*y2+3.d0*y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real spherical harmonics for m = 0                 
+c--------------------------------------------------------
+            
+            ReYlm =  ypre4m0*invrs*(8.d0*z4-24.d0*z2*x2-24.d0*z2*y2+
+     x        3.d0*x4+6.d0*x2*y2+3.d0*y4)
+            
+c--------------------------------------------------
+c     Force contributions from m = 0 (real part)   
+c--------------------------------------------------
+            
+            prefactor2 = q4prefactor(itype)*ReQ4bar(0,itype)
+            
+c-------------------------------------------
+c     Gradient of Re(Y_{4,0}) w.r.t r_{j}
+c-------------------------------------------
+            
+            fx1 =  20.d0*ypre4m0*invrc*z2*(-4.d0*z2+3.d0*x2+3.d0*y2)*x
+            fy1 =  20.d0*ypre4m0*invrc*z2*(-4.d0*z2+3.d0*x2+3.d0*y2)*y
+            fz1 = -20.d0*ypre4m0*invrc*z*(-4.d0*z2*x2-4.d0*z2*y2+3.d0*
+     x             x4+6.d0*x2*y2+3.d0*y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c     Add into global force and stress arrays
+            
+            fxx(jatm) = fxx(jatm) + fx
+            fyy(jatm) = fyy(jatm) + fy
+            fzz(jatm) = fzz(jatm) + fz
+            fxx(iatm) = fxx(iatm) - fx
+            fyy(iatm) = fyy(iatm) - fy
+            fzz(iatm) = fzz(iatm) - fz
+            
+c     Virial
+            
+            virord = virord - (fx*x + fy*y + fz*z)
+            
+c     Stress
+            
+            strs1=strs1+x*fx
+            strs2=strs2+x*fy
+            strs3=strs3+x*fz
+            strs5=strs5+y*fy
+            strs6=strs6+y*fz
+            strs9=strs9+z*fz
+            
+          end do                ! end loop over connection list for iatm
+          
+        end if                  ! end of computing Q4
+        
+c---------------------------------------------------------
+c---------------------------------------------------------
+c     Compute forces arising from  Q6 order parameters        
+c---------------------------------------------------------
+c---------------------------------------------------------
+        
+        if ( (nq6>0).and.isolvmax6>0 ) then
+          
+          do isolv6 = 1,isolvmax6
+            
+            jatm = solvlist6(isolv6)
+            itype = solvtype6(isolv6)
+            
+            invrc = solvimag6(isolv6)**6
+            invrq = solvimag6(isolv6)**8
+            invrs = solvimag6(isolv6)**4
+            
+            x     = solvx6(isolv6)
+            y     = solvy6(isolv6)
+            z     = solvz6(isolv6)
+            
+            f_ij  =  fc(solvrmag6(isolv6),q6cutoff(1,itype),
+     x                 q6cutoff(2,itype))
+            df_ij = dfc(solvrmag6(isolv6),q6cutoff(1,itype),
+     x                 q6cutoff(2,itype))
+            
+            x2 = x*x
+            y2 = y*y
+            z2 = z*z
+            
+            x3 = x2*x
+            y3 = y2*y
+            z3 = z2*z
+            
+            x4 = x2*x2
+            y4 = y2*y2
+            z4 = z2*z2
+            
+            x5 = x4*x
+            y5 = y4*y
+            z5 = z4*z
+            
+            x6 = x4*x2
+            y6 = y4*y2
+            z6 = z4*z2
+            
+            fx = 0.0d0
+            fy = 0.0d0
+            fz = 0.0d0
+            
+c----------------------------------------
+c     Gradient of f_ij w.r.t. r_{j}  
+c----------------------------------------
+            
+            fx2 = df_ij*x*solvimag6(isolv6)
+            fy2 = df_ij*y*solvimag6(isolv6)
+            fz2 = df_ij*z*solvimag6(isolv6)
+            
+c-----------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -6     
+c-----------------------------------------------------------
+            
+            ReYlm      = ypre6m6*invrc*(x6-15.0d0*x4*y2+15.0d0*x2*y4-y6)
+            ImYlm      = ypre6m6*invrc*(-6.0d0*x5*y+20.0d0*x3*y3-6.0d0*
+     x                   x*y5)
+            
+c-----------------------------------------------------
+c     Force contributions from m = -6 (real part)     
+c-----------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ReQ6bar(-6,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,-6}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 =  invrq*ypre6m6*6.0d0*x*(6.0d0*x4*y2-20.0d0*x2*y4+
+     x             6.0d0*y6+z2*x4-10.0d0*z2*x2*y2+5.0d0*z2*y4)
+            fy1 = -invrq*ypre6m6*6.0d0*y*(6.0d0*x6-20.0d0*x4*y2+6.0d0
+     x             *x2*y4+5.0d0*z2*x4-10.0d0*z2*x2*y2+z2*y4)
+            fz1 = -invrq*ypre6m6*6.0d0*z*(x6-15.0d0*x4*y2+15.0d0*x2*
+     x             y4-y6)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c----------------------------------------------------------
+c     Force contributions from m = -6 (Imaginary part)     
+c----------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ImQ6bar(-6,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{6,-6}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -invrq*ypre6m6*6.0d0*y*(-x6+15.0d0*x4*y2-15.0d0*x2*
+     x             y4+5.0d0*z2*x4-10.0d0*z2*x2*y2+y6+z2*y4)
+            fy1 = -invrq*ypre6m6*6.0d0*x*(-15.0d0*x4*y2+15.0d0*x2*y4-
+     x             y6+x6+z2*x4-10.0d0*z2*x2*y2+5.0d0*z2*y4)
+            fz1 =  invrq*ypre6m6*12.0d0*x*y*z*(3.0d0*x4-10.0d0*x2*y2+
+     x             3.0d0*y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c---------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -5   
+c---------------------------------------------------------
+            
+            ReYlm = -ypre6m5*invrc*z*(-x5+10.0d0*x3*y2-5.0d0*x*y4)
+            ImYlm = -ypre6m5*invrc*z*(5.0d0*x4*y-10.0d0*x2*y3+y5)
+            
+c--------------------------------------------------
+c     Force contributions from m = -5 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ReQ6bar(-5,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,-5}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = ypre6m5*invrq*z*(-x6+35.0d0*x4*y2-55.d0*x2*y4+
+     x            5.0d0*z2*x4-30.0d0*z2*x2*y2+5.0d0*y6+5.0d0*z2*y4)
+            fy1 = -2.0d0*ypre6m5*invrq*x*y*z*(13.0d0*x4-30.0d0*x2
+     x        *y2+5.0d0*y4+10.0d0*z2*x2-10.0d0*z2*y2) 
+            fz1 = -ypre6m5*invrq*x*(x4-10.0d0*x2*y2+5.0d0*y4)*
+     x        (-x2-y2+5.0d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c--------------------------------------------------------
+c     Force contributions from m = -5 (Imaginary part)   
+c--------------------------------------------------------
+
+            prefactor2 = 2.0d0*q6prefactor(itype)*ImQ6bar(-5,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{6,-5}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -2.0d0*ypre6m5*invrq*x*y*z*(-5.0d0*x4+30.0d0*x2*y2
+     x            -13.0d0*y4+10.0d0*z2*x2-10.0d0*z2*y2)
+            fy1 = -ypre6m5*invrq*z*(-55.0d0*x4*y2+35.0d0*x2*y4-y6+
+     x             5.0d0*x6+5.0d0*z2*x4-30.0d0*z2*x2*y2+5.0d0*z2*y4)
+            fz1 =  ypre6m5*invrq*y*(5.0d0*x4-10.0d0*x2*y2+y4)*
+     x             (-x2-y2+5.0d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -4  
+c--------------------------------------------------------
+            
+            ReYlm = ypre6m4*invrc*(10.0d0*z2-x2-y2)*(x4-6.0d0*x2*y2+y4)
+            ImYlm = ypre6m4*invrc*(10.0d0*z2-x2-y2)*(-4.0d0*x3*y+4.0d0*
+     x              x*y3)
+            
+c--------------------------------------------------
+c     Force contributions from m = -4 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ReQ6bar(-4,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,-4}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = 2.0d0*ypre6m4*invrq*x*(-8.0d0*x4*y2-13.0d0*z2*x4+
+     x            150.0d0*z2*x2*y2+8.0d0*y6-85.0d0*z2*y4+20.0d0*z4*
+     x            x2-60.0d0*z4*y2)
+            fy1 =-2.0d0*ypre6m4*invrq*y*(-8.0d0*x6+85.0d0*z2*x4+8.0d0
+     x           *x2*y4-150.0d0*z2*x2*y2+13.0d0*z2*y4+60.0d0*z4*x2-
+     x            20.0d0*z4*y2)
+            fz1 =-2.0d0*ypre6m4*invrq*z*(x4-6.0d0*x2*y2+y4)*(-13.0d0
+     x           *x2-13.0d0*y2+20.0d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c--------------------------------------------------------
+c     Force contributions from m = -4 (Imaginary part)   
+c--------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ImQ6bar(-4,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{6,-4}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -4.0d0*ypre6m4*invrq*y*(x6-35.0d0*z2*x4-5.0d0*x2*y4
+     x             +80.0d0*z2*x2*y2+30*z4*x2-9.0d0*z2*y4-10*z4*y2-5.0d0
+     x             *x4*y2+y6)
+            fy1 = -4.0d0*ypre6m4*invrq*x*(5.0d0*x4*y2-80.0d0*z2*x2*y2
+     x            -y6+35.0d0*z2*y4+9.0d0*z2*x4+10.0d0*z4*x2-30.0d0*z4
+     x            *y2-x6+5.0d0*x2*y4)
+            fz1 =  8.0d0*ypre6m4*invrq*z*x*y*(x2-y2)*(-13.0d0*x2-
+     x             13.0d0*y2+20.0d0*z2)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -3  
+c--------------------------------------------------------
+
+            ReYlm = -ypre6m3*invrc*z*(8.0d0*z2-3.0d0*x2-3.0d0*y2)*
+     x               (-x3+3.0d0*x*y2)
+            ImYlm = -ypre6m3*invrc*z*(8.0d0*z2-3.0d0*x2-3.0d0*y2)*
+     x               (3.0d0*x2*y-y3)
+            
+c--------------------------------------------------
+c     Force contributions from m = -3 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ReQ6bar(-3,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,-3}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 =  3.d0*ypre6m3*invrq*z*(x6-11.d0*x4*y2-13.d0*z2*x4-
+     x             9.d0*x2*y4+54.d0*z2*x2*y2+8.d0*z4*x2-5.d0*z2*y4-
+     x             8.d0*z4*y2+3.d0*y6)
+            fy1 = -6.d0*ypre6m3*invrq*z*x*y*(-5.d0*x4-2.d0*x2*y2+14.d0
+     x            *z2*x2+3.d0*y4-22.d0*z2*y2+8.d0*z4)
+            fz1 = -3.d0*ypre6m3*invrq*x*(x2-3.d0*y2)*(-13.d0*z2*x2-
+     x             13.d0*z2*y2+8.d0*z4+x4+2.d0*x2*y2+y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c--------------------------------------------------------
+c     Force contributions from m = -3 (Imaginary part)   
+c--------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ImQ6bar(-3,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{6,-3}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -6.d0*ypre6m3*invrq*z*x*y*(3.d0*x4-2.d0*x2*y2-22.d0
+     x            *z2*x2-5.d0*y4+14.d0*z2*y2+8.d0*z4)
+            fy1 = -3.d0*ypre6m3*invrq*z*(9.d0*x4*y2+11.d0*x2*y4-54.d0
+     x            *z2*x2*y2-y6+13.d0*z2*y4+5.d0*z2*x4+8.d0*z4*x2-8.d0
+     x            *z4*y2-3.d0*x6)
+            fz1 =  3.d0*ypre6m3*invrq*y*(3.d0*x2-y2)*(-13.d0*z2*x2-
+     x             13.d0*z2*y2+8.d0*z4+x4+2.d0*x2*y2+y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -2  
+c--------------------------------------------------------
+            
+            ReYlm =  ypre6m2*invrc*(16.0d0*z4-16.0d0*z2*x2-16.0d0*z2
+     x              *y2+x4+2.0d0*x2*y2+y4)*(x2-y2)
+            ImYlm = -ypre6m2*invrc*2.0d0*(16.0d0*z4-16.0d0*z2*x2-
+     x               16.0d0*z2*y2+x4+2.0d0*x2*y2+y4)*x*y
+            
+c--------------------------------------------------
+c     Force contributions from m = -2 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ReQ6bar(-2,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,-2}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 =  2.d0*ypre6m2*invrq*x*( 19.d0*z2*x4-64.d0*z4*x2-
+     x             49.d0*z2*y4+64.d0*z4*y2+2.d0*x4*y2+4.d0*x2*y4+
+     x             2.d0*y6+16.d0*z6-30.d0*z2*x2*y2)
+            fy1 = -2.d0*ypre6m2*invrq*y*(-49.d0*z2*x4+64.d0*z4*x2+
+     x             19.d0*z2*y4-64.d0*z4*y2+2.d0*x6+4.d0*x4*y2+2.d0*
+     x             x2*y4+16.d0*z6-30.d0*z2*x2*y2)
+            fz1 = -2.d0*ypre6m2*invrq*z*(x2-y2)*(-64.d0*z2*x2-64.d0
+     x            *z2*y2+16.d0*z4+19.d0*x4+38.d0*x2*y2+19.d0*y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c--------------------------------------------------------
+c     Force contributions from m = -2 (Imaginary part)   
+c--------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ImQ6bar(-2,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{6,-2}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -2.d0*ypre6m2*invrq*y*(53.d0*z2*x4+38.d0*z2*x2*
+     x             y2-128.d0*z4*x2-x6-x4*y2+x2*y4+16.d0*z6-15.d0*
+     x             z2*y4+y6)
+            fy1 = -2.d0*ypre6m2*invrq*x*(38.d0*z2*x2*y2+53.d0*z2*
+     x             y4-128.d0*z4*y2+x4*y2-x2*y4-y6+16.d0*z6-15.d0*
+     x             z2*x4+x6)
+            fz1 =  4.d0*ypre6m2*invrq*z*x*y*(-64.d0*z2*x2-64.d0*
+     x             z2*y2+16.d0*z4+19.d0*x4+38.d0*x2*y2+19.d0*y4)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real and imaginary spherical harmonics for m = -1  
+c--------------------------------------------------------
+            
+            ReYlm =  ypre6m1*z*invrc*(8.0d0*z4-20.0d0*z2*x2-20.0d0*z2*y2
+     x               +5.0d0*x4+10.0d0*x2*y2+5.0d0*y4)*x
+            ImYlm = -ypre6m1*z*invrc*(8.0d0*z4-20.0d0*z2*x2-20.0d0*z2*y2
+     x               +5.0d0*x4+10.0d0*x2*y2+5.0d0*y4)*y
+            
+c--------------------------------------------------
+c     Force contributions from m = -1 (real part)  
+c--------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ReQ6bar(-1,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,-1}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 =       ypre6m1*invrq*z*(85.d0*z2*x4+70.d0*z2*x2*y2
+     x            -100.d0*z4*x2-5.d0*x6-5.d0*x4*y2+5.d0*x2*y4-12.d0
+     x            *z4*y2+8.d0*z6-15.d0*z2*y4+5.d0*y6)
+            fy1 = -2.d0*ypre6m1*invrq*z*x*y*(-50.d0*z2*x2-50.d0*z2*
+     x             y2+44.d0*z4+5.d0*x4+10.d0*x2*y2+5.d0*y4)
+            fz1 =      -ypre6m1*invrq*x*(-100.d0*z4*x2-100.d0*z4*y2+
+     x             8.d0*z6+85.d0*z2*x4+170.d0*z2*x2*y2+85.d0*z2*y4-
+     x             5.d0*x6-15.d0*x4*y2-15.d0*x2*y4-5.d0*y6)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+c--------------------------------------------------------
+c     Force contributions from m = -1 (Imaginary part)   
+c--------------------------------------------------------
+            
+            prefactor2 = 2.0d0*q6prefactor(itype)*ImQ6bar(-1,itype)
+            
+c--------------------------------------------
+c     Gradient of Im(Y_{6,-1}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 =  2.d0*ypre6m1*invrq*z*x*y*(-50.d0*z2*x2-50.d0*
+     x             z2*y2+44.d0*z4+5.d0*x4+10.d0*x2*y2+5.d0*y4)
+            fy1 =      -ypre6m1*invrq*z*(70.d0*z2*x2*y2+85.d0*z2
+     x            *y4-100.d0*z4*y2+5.d0*x4*y2-5.d0*x2*y4-5.d0*y6
+     x            -12.d0*z4*x2+8.d0*z6-15.d0*z2*x4+5.d0*x6)
+            fz1 =       ypre6m1*invrq*y*(-100.d0*z4*x2-100.d0*z4
+     x            *y2+8.d0*z6+85.d0*z2*x4+170.d0*z2*x2*y2+85.d0*
+     x             z2*y4-5.d0*x6-15.d0*x4*y2-15.d0*x2*y4-5.d0*y6)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ImYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ImYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ImYlm)
+            
+c--------------------------------------------------------
+c     Real spherical harmonics for m = 0                 
+c--------------------------------------------------------
+            
+            ReYlm = ypre6m0*invrc*(16.0d0*z6-120.0d0*z4*x2-120.0d0
+     x             *z4*y2+90.0d0*z2*x4+180.0d0*z2*x2*y2+90.0d0*z2*y4
+     x             -5.0d0*x6-15.0d0*x4*y2-15.0d0*x2*y4-5.0d0*y6)
+            
+c--------------------------------------------------
+c     Force contributions from m = 0 (real part)       
+c--------------------------------------------------
+            
+            prefactor2 = q6prefactor(itype)*ReQ6bar(0,itype)
+            
+c--------------------------------------------
+c     Gradient of Re(Y_{6,0}) w.r.t r_{j}
+c--------------------------------------------
+            
+            fx1 = -42.d0*ypre6m0*invrq*z2*(8.d0*z4-20.d0*z2*x2-20.d0
+     x            *z2*y2+5.d0*x4+10.d0*x2*y2+5.d0*y4)*x
+            fy1 = -42.d0*ypre6m0*invrq*z2*(8.d0*z4-20.d0*z2*x2-20.d0
+     x            *z2*y2+5.d0*x4+10.d0*x2*y2+5.d0*y4)*y
+            fz1 =  42.d0*ypre6m0*invrq*z*(8.d0*z4*x2+8.d0*z4*y2-20.d0
+     x            *z2*x4-40.d0*z2*x2*y2-20.d0*z2*y4+5.d0*x6+15.d0*x4*
+     x             y2+15.d0*x2*y4+5.d0*y6)
+            
+            fx = fx + prefactor2*(f_ij*fx1 + fx2*ReYlm)
+            fy = fy + prefactor2*(f_ij*fy1 + fy2*ReYlm)
+            fz = fz + prefactor2*(f_ij*fz1 + fz2*ReYlm)
+            
+            
+c     Add into global force and stress arrays
+            
+            fxx(jatm) = fxx(jatm) + fx
+            fyy(jatm) = fyy(jatm) + fy
+            fzz(jatm) = fzz(jatm) + fz
+            fxx(iatm) = fxx(iatm) - fx
+            fyy(iatm) = fyy(iatm) - fy
+            fzz(iatm) = fzz(iatm) - fz
+            
+c     Virial
+            
+            virord = virord - (fx*x + fy*y + fz*z)
+            
+c     Stress
+            
+            strs1=strs1+x*fx
+            strs2=strs2+x*fy
+            strs3=strs3+x*fz
+            strs5=strs5+y*fy
+            strs6=strs6+y*fz
+            strs9=strs9+z*fz
+            
+          end do                ! end loop over connection list for iatm
+          
+        end if                  ! end of computing Q6
+        
+        
+      end do                    ! end loop over iatm
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs1
+      stress(2)=stress(2)+strs2
+      stress(3)=stress(3)+strs3
+      stress(4)=stress(4)+strs2
+      stress(5)=stress(5)+strs5
+      stress(6)=stress(6)+strs6
+      stress(7)=stress(7)+strs3
+      stress(8)=stress(8)+strs6
+      stress(9)=stress(9)+strs9
+      
+c     tidy up
+      
+      ierr = 0
+      
+      deallocate(xdf,stat=ierr(1))
+      deallocate(ydf,stat=ierr(2))
+      deallocate(zdf,stat=ierr(3))
+
+      deallocate(dstlst,stat=ierr(4))
+      
+      deallocate(solvx4,stat=ierr(5))
+      deallocate(solvy4,stat=ierr(6))
+      deallocate(solvz4,stat=ierr(7))
+      deallocate(solvrmag4,stat=ierr(8))
+      deallocate(solvimag4,stat=ierr(9))
+      deallocate(solvrsq4 ,stat=ierr(10))
+      deallocate(solvlist4,stat=ierr(11)) 
+      deallocate(solvtype4,stat=ierr(12))
+      
+      deallocate(solvx6,stat=ierr(13))
+      deallocate(solvy6,stat=ierr(14))
+      deallocate(solvz6,stat=ierr(15))
+      deallocate(solvrmag6,stat=ierr(16))
+      deallocate(solvimag6,stat=ierr(17))
+      deallocate(solvrsq6 ,stat=ierr(18))
+      deallocate(solvlist6,stat=ierr(19)) 
+      deallocate(solvtype6,stat=ierr(20))
+      if (any(ierr/=0)) call Mfrz_Error(2536,0.d0)
+      
+      deallocate(buff1,stat=ierr(1))
+      deallocate(buff2,stat=ierr(2))    
+      if (any(ierr/=0)) call Mfrz_Error(2537,0.d0)
+      
+      deallocate(q4prefactor,stat=ierr(1))
+      deallocate(q6prefactor,stat=ierr(2))
+      if (any(ierr/=0)) call Mfrz_Error(2540,0.d0)
+      
+      return
+      
+      end Subroutine Compute_Steinhardt_Forces
+      
+      Subroutine Compute_Tet_Nlist(imcon,natms)
+      
+c---------------------------------------------------------------------
+c
+c     The existing neighbour list is not known by all nodes and 
+c     therefore we compute a new one from scratch rather than trying
+c     to merge a full neighbour list across all MPI tasks or restore
+c     symmetry.
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley October 2008
+c
+c---------------------------------------------------------------------
+      
+      use config_module
+      use site_module
+      use utility_module, only : images
+      
+      implicit none
+      integer,intent(in) :: imcon,natms
+      integer :: nlast,megatm
+      
+      integer :: iatm0,iatm1,istrd,iatm,jatm,nn,itype,jtype
+      integer :: ninclude,ifi,ii,ztype,nnn,k
+      real(8) :: rsq,rangesq
+      real(8),allocatable,dimension(:) :: xdf,ydf,zdf
+      
+      iatm0 = myrank+1
+      iatm1 = natms
+      istrd = commsize
+      
+      ninclude = maxval(zetaninc)
+      
+      nlast  = natms
+      megatm = natms
+      
+      nnn = int(dble(ninclude*nlast*1.2)/dble(megatm))
+      
+      allocate(xdf(1:nnn),stat=ierr(1))
+      allocate(ydf(1:nnn),stat=ierr(2))
+      allocate(zdf(1:nnn),stat=ierr(3))
+      if (any(ierr/=0)) call Mfrz_Error(2541,0.d0) 
+      
+      ii = 0
+      do iatm = iatm0,iatm1,istrd
+        
+        itype = ltype(iatm)
+        
+        ztype = zetasite(itype)
+        if ( ztype==0 ) cycle
+        
+        nn  = 0                 ! Number of images to compute
+        ii  = ii + 1            ! index for this list
+        ifi = 0                 ! index for entries in this list
+        
+        if (ii>mxninc) call Mfrz_Error(2542,0.d0)
+        
+        do jatm = 1,nlast
+          
+          jtype = ltype(jatm)
+          
+          if ( itype/=jtype ) cycle
+          if ( iatm == jatm ) cycle
+          
+          nn = nn + 1
+          xdf(nn) = xxx(iatm) - xxx(jatm) ! separation vector
+          ydf(nn) = yyy(iatm) - yyy(jatm)
+          zdf(nn) = zzz(iatm) - zzz(jatm)
+          
+        end do
+        
+        if ( nn > nnn ) call Mfrz_Error(2543,0.d0)
+        
+        call images(imcon,0,1,nn,cell,xdf,ydf,zdf)
+        
+        nn = 0
+        do jatm = 1,nlast
+          
+          jtype = ltype(jatm)
+          
+          if ( itype/=jtype ) cycle
+          if ( iatm == jatm ) cycle
+          
+          nn = nn + 1
+          rsq = xdf(nn)*xdf(nn) + ydf(nn)*ydf(nn) + zdf(nn)*zdf(nn)
+          
+          rangesq =  zetacutoff(2,ztype)**2
+          
+          if ( rsq < rangesq ) then
+            
+            ifi = ifi + 1
+            flist(ifi,ii) = jatm      
+            
+          end if
+          
+        end do
+        if ( ifi > mxflist ) call Mfrz_Error(2544,0.d0)
+        nflist(ii) = ifi
+        
+      end do                    ! end loop over iatm
+      
+      deallocate(xdf,stat=ierr(1))
+      deallocate(ydf,stat=ierr(2))
+      deallocate(zdf,stat=ierr(3))
+      if (any(ierr/=0))call Mfrz_Error(2545,0.d0) 
+      
+      return
+      
+      end Subroutine Compute_Tet_Nlist
+      
+      Subroutine Compute_Tetrahedral(imcon,natms)
+      
+c---------------------------------------------------------------------
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley October 2008
+c     
+c---------------------------------------------------------------------
+      
+      use config_module
+      use site_module
+      use utility_module, only : images
+      
+      implicit none
+      integer,intent(in) :: imcon,natms
+      
+      integer :: iatm0,iatm1,istrd,iatm,jatm,nn,itype,jtype
+      integer :: ninclude,ifi,ii,k,ztype,mm,katm,ktype,it
+      real(8) :: f_ij,f_ik,r_ij,r_ik,x,y,z,dot
+      real(8),parameter :: third=1.0d0/3.0d0
+      real(8),allocatable,dimension(:) :: xdf,ydf,zdf
+      real(8),allocatable,dimension(:) :: buff1
+      
+      iatm0 = myrank+1
+      iatm1 = natms
+      istrd = commsize
+      
+      allocate(xdf(1:mxflist),stat=ierr(1))
+      allocate(ydf(1:mxflist),stat=ierr(2))
+      allocate(zdf(1:mxflist),stat=ierr(3))
+      allocate(buff1(1:ntet),stat=ierr(4))
+      if (any(ierr/=0)) call Mfrz_Error(2546,0.d0)
+      
+      zeta_global(:) = 0.0d0
+      
+      ii = 0
+      do iatm = iatm0,iatm1,istrd
+        
+        itype = ltype(iatm)
+        
+c     no tetrahedral contributions from this atom type?
+        
+        ztype = zetasite(itype)
+        if ( ztype == 0 ) cycle
+        
+        ii  = ii + 1            ! index for this list
+        
+        do k = 1,nflist(ii)
+          
+          jatm = flist(k,ii)
+          
+          xdf(k) = xxx(jatm) - xxx(iatm) ! separation vector
+          ydf(k) = yyy(jatm) - yyy(iatm)
+          zdf(k) = zzz(jatm) - zzz(iatm)
+          
+        end do
+        
+        nn = nflist(ii)
+        call images(imcon,0,1,nn,cell,xdf,ydf,zdf)
+        
+        do k = 1,nflist(ii)
+          
+          jatm = flist(k,ii)
+          
+          r_ij = sqrt(xdf(k)*xdf(k) + ydf(k)*ydf(k) + zdf(k)*zdf(k))
+          f_ij = fc(r_ij,zetacutoff(1,ztype),zetacutoff(2,ztype)) 
+          
+          x = xdf(k) ; y = ydf(k) ; z = zdf(k)
+          
+c     loop over all other entries katm
+          
+          do mm = k+1,nflist(ii)
+            
+c     katm also in solvation shell of iatm
+            
+            katm  = flist(mm,ii)
+            
+            r_ik = sqrt(xdf(mm)*xdf(mm) + ydf(mm)*ydf(mm) + 
+     x        zdf(mm)*zdf(mm))
+            f_ik = fc(r_ik,zetacutoff(1,ztype),zetacutoff(2,ztype)) 
+            
+c     The node holding the central atom keeps the contrib
+            
+            dot = (x*xdf(mm) + y*ydf(mm) + z*zdf(mm)) / (r_ij*r_ik) +
+     x            third
+            zeta_global(ztype) = zeta_global(ztype) + f_ij*f_ik*dot*dot
+          end do       
+        end do
+        
+      end do
+      
+      call gdsum(zeta_global(1),ntet,buff1(1:ntet))
+      
+      do it = 1,ntet
+        zeta_global(it) = 1.0d0 - zeta_global(it)/dble(zetaninc(it)*
+     x    zetann(it))
+      end do
+      
+      deallocate(xdf ,stat=ierr(1))
+      deallocate(ydf ,stat=ierr(2))
+      deallocate(zdf ,stat=ierr(3))
+      deallocate(buff1,stat=ierr(4))
+      if (any(ierr/=0)) call Mfrz_Error(2547,0.d0)
+      
+      return
+      
+      end Subroutine Compute_Tetrahedral
+      
+      Subroutine Compute_Tetrahedral_Forces(imcon,natms,engord,virord)
+      
+c---------------------------------------------------------------------
+c     
+c     Author D. Quigley - University of Warwick
+c     Copyright D. Quigley October 2008
+c     
+c---------------------------------------------------------------------
+      
+      use config_module
+      use site_module
+      use utility_module, only : images
+      
+      implicit none
+      integer,intent(in) :: imcon,natms
+      real(8),intent(inout) :: engord,virord
+      
+      integer :: iatm,jatm,katm,iatm0,iatm1,istrd,nn
+      integer :: ii,k,m,itet,itype,jtype,ztype,it
+      
+      real(8),parameter :: third = 1.0d0/3.0d0
+      real(8) :: strs1,strs2,strs3,strs5,strs6,strs9
+      real(8) :: xj,yj,zj,xk,yk,zk,tmpvar,tmpvar2,dot
+      real(8) :: r_ij,r_ik,f_ij,f_ik,df_ij,df_ik
+      real(8) :: invrij,invrik,ctheta
+      real(8) :: fxj,fyj,fzj,fxk,fyk,fzk
+      
+      real(8),dimension(3) :: rij_hat,rik_hat
+      
+      real(8),allocatable,dimension(:) :: xdf,ydf,zdf
+      real(8),allocatable,dimension(:) :: tetprefactor
+      
+      iatm0 = myrank+1
+      iatm1 = natms
+      istrd = commsize
+      
+      allocate(xdf(1:mxflist),stat=ierr(1))
+      allocate(ydf(1:mxflist),stat=ierr(2))
+      allocate(zdf(1:mxflist),stat=ierr(3))
+      allocate(tetprefactor(1:ntet),stat=ierr(4))
+      if (any(ierr/=0)) call Mfrz_Error(2548,0.d0)
+      
+c     Compute the prefactor
+      
+      k = nq4+nq6+1
+      do it = 1,ntet
+        tetprefactor = dcolvar(k)/dble(zetaninc(it)*zetann(it))
+        k = k + 1
+      end do
+      
+c     zero contribution to the stress tensor
+      
+      strs1=0.0d0
+      strs2=0.0d0
+      strs3=0.0d0
+      strs5=0.0d0
+      strs6=0.0d0
+      strs9=0.0d0
+      
+      ii = 0
+      do iatm = iatm0,iatm1,istrd
+        
+        itype = ltype(iatm)
+        
+c     no tetrahedral contributions from this atom type?
+        
+        ztype = zetasite(itype)
+        if ( ztype == 0 ) cycle
+        
+        ii  = ii + 1            ! index for this list
+        
+        do k = 1,nflist(ii)
+          
+          jatm = flist(k,ii)
+          
+          xdf(k) = xxx(jatm) - xxx(iatm) ! separation vector
+          ydf(k) = yyy(jatm) - yyy(iatm)
+          zdf(k) = zzz(jatm) - zzz(iatm)
+          
+        end do
+        
+        nn = nflist(ii)
+        call images(imcon,0,1,nn,cell,xdf,ydf,zdf)
+        
+        do k = 1,nflist(ii)
+          
+          jatm  = flist(k,ii)
+          
+          r_ij  = sqrt(xdf(k)*xdf(k) + ydf(k)*ydf(k) + zdf(k)*zdf(k))
+          f_ij  =  fc(r_ij,zetacutoff(1,ztype),zetacutoff(2,ztype))
+          df_ij = dfc(r_ij,zetacutoff(1,ztype),zetacutoff(2,ztype))
+          
+          xj = xdf(k) ; yj = ydf(k) ; zj = zdf(k)
+          
+          invrij = 1.0d0/r_ij
+          
+          rij_hat(1) = xj*invrij
+          rij_hat(2) = yj*invrij
+          rij_hat(3) = zj*invrij
+          
+          do m = k + 1,nflist(ii)
+            
+            r_ik = sqrt(xdf(m)*xdf(m) + ydf(m)*ydf(m) + zdf(m)*zdf(m))
+            f_ik  =  fc(r_ik,zetacutoff(1,ztype),zetacutoff(2,ztype))
+            df_ik = dfc(r_ik,zetacutoff(1,ztype),zetacutoff(2,ztype))
+            
+            xk = xdf(m) ; yk = ydf(m) ; zk = zdf(m)
+            
+            invrik = 1.0d0/r_ik
+            
+            rik_hat(1) = xk*invrik
+            rik_hat(2) = yk*invrik
+            rik_hat(3) = zk*invrik
+            
+            ctheta = dot_product(rij_hat,rik_hat)
+            dot    = ctheta + third
+            
+            tmpvar  = 2.0d0*dot*f_ij*f_ik*tetprefactor(ztype)*invrij
+            tmpvar2 = tetprefactor(ztype)*dot*dot*df_ij*f_ik
+            
+c     force between atom i and atom j due to second term 
+c     i.e. ( f_ij*f_ik*dot*dot )
+            
+            fxj =  tmpvar*(rik_hat(1) - rij_hat(1)*ctheta) + 
+     x             tmpvar2*rij_hat(1)
+            fyj =  tmpvar*(rik_hat(2) - rij_hat(2)*ctheta) + 
+     x             tmpvar2*rij_hat(2)
+            fzj =  tmpvar*(rik_hat(3) - rij_hat(3)*ctheta) + 
+     x             tmpvar2*rij_hat(3)
+            
+            tmpvar  = 2.0d0*dot*f_ij*f_ik*tetprefactor(ztype)*invrik
+            tmpvar2 = tetprefactor(ztype)*dot*dot*df_ik*f_ij
+            
+c     force between atom i and atom k due to second term 
+c     i.e ( f_ij*f_ik*dot*dot )
+            
+            fxk =  tmpvar*(rij_hat(1) - rik_hat(1)*ctheta) + 
+     x             tmpvar2*rik_hat(1)
+            fyk =  tmpvar*(rij_hat(2) - rik_hat(2)*ctheta) + 
+     x             tmpvar2*rik_hat(2)
+            fzk =  tmpvar*(rij_hat(3) - rik_hat(3)*ctheta) + 
+     x             tmpvar2*rik_hat(3)        
+            
+c     Add in to forces, virial and stress tensor 
+            
+            katm = flist(m,ii)
+            
+            fxx(iatm) = fxx(iatm) + fxj + fxk
+            fyy(iatm) = fyy(iatm) + fyj + fyk
+            fzz(iatm) = fzz(iatm) + fzj + fzk
+            
+            fxx(jatm) = fxx(jatm) - fxj
+            fyy(jatm) = fyy(jatm) - fyj
+            fzz(jatm) = fzz(jatm) - fzj
+            
+            fxx(katm) = fxx(katm) - fxk
+            fyy(katm) = fyy(katm) - fyk
+            fzz(katm) = fzz(katm) - fzk         
+            
+            virord = virord - fxj*xj - fyj*yj - fzj*zj
+            virord = virord - fxk*xk - fyk*yk - fzk*zk
+            
+            strs1 = strs1 + xk*fxk + xj*fxj
+            strs2 = strs2 + xk*fyk + xj*fyj
+            strs3 = strs3 + xk*fzk + xj*fzj
+            strs5 = strs5 + yk*fyk + yj*fyj
+            strs6 = strs6 + yk*fzk + yj*fzj
+            strs9 = strs9 + zk*fzk + zj*fzj
+            
+          end do
+        end do
+      end do
+      
+c     Complete stress tensor
+      
+      stress(1)=stress(1)+strs1
+      stress(2)=stress(2)+strs2
+      stress(3)=stress(3)+strs3
+      stress(4)=stress(4)+strs2
+      stress(5)=stress(5)+strs5
+      stress(6)=stress(6)+strs6
+      stress(7)=stress(7)+strs3
+      stress(8)=stress(8)+strs6
+      stress(9)=stress(9)+strs9
+      
+      
+c     Tidy up
+      
+      deallocate(xdf,stat=ierr(1))
+      deallocate(ydf,stat=ierr(2))
+      deallocate(zdf,stat=ierr(3))
+      if (any(ierr/=0)) call Mfrz_Error(2547,0.d0)
+      
+      return
+      
+      end Subroutine Compute_Tetrahedral_Forces
+      
+      Subroutine Mfrz_Error(kode,arg)
+      
+c---------------------------------------------------------------------
+c     
+c     Author W. Smith Daresbury Laboratory January 2011
+c     Adapted from D. Quigley - University of Warwick
+c     Copyright D. Quigley October 2008
+c     
+c---------------------------------------------------------------------
+      
+      use setup_module,   only : nrite,nhist,nread,nconf,nstats,
+     x                           nrest,nfield,ntable,nevnt
+      
+      implicit none
+      integer,intent(in) :: kode
+      real(8),intent(in) :: arg
+      
+      if(onroot)then
+        
+        if(kode.eq.2500)then
+          
+          write(nrite,"(
+     x      'Error in number of collective variables - '//
+     x      'ncolvar too small?'
+     x      )")
+          
+        elseif(kode.eq.2501)then
+          
+          write(nrite,"(
+     x      'Wang-Landau style recursion not yet implemented'//
+     x      'for ncolvar > 1'             
+     x      )")
+          
+        elseif(kode.eq.2502)then
+          
+          write(nrite,"('Unrecognised Gaussian height scheme')")
+          
+        elseif(kode.eq.2503)then
+          
+          write(nrite,"('Error maxhis exceeded in metadynamics')")
+          
+        elseif(kode.eq.2504)then
+          
+          write(nrite,"(
+     x      'Error allocating comms buffer in compute_bias_potential'
+     x      )")
+          
+        elseif(kode.eq.2505)then
+          
+          write(nrite,"('Error allocating driven array')")
+          
+        elseif(kode.eq.2506)then
+          
+          write(nrite,"('Could not open METACONTROL')")
+          
+        elseif(kode.eq.2508)then
+          
+          write(nrite,"('Comms error in metadynamics setup')")
+          
+        elseif(kode.eq.2509)then
+          
+          write(nrite,"(
+     x      'Cannot bias local and global PE in same run'
+     x      )")
+          
+        elseif(kode.eq.2510)then
+          
+          write(nrite,"('Error allocating local force arrays')")
+          
+        elseif(kode.eq.2511)then
+          
+          write(nrite,"(
+     x      'Error allocating collective variables arrays'
+     x      )")
+          
+        elseif(kode.eq.2512)then
+          
+          write(nrite,"('Error allocating Wang-Landau bins')")
+          
+        elseif(kode.eq.2515)then
+          
+          write(nrite,"(
+     x      'Error allocating Steinhardt parameter arrays'       
+     x      )")
+          
+        elseif(kode.eq.2516)then
+          
+          write(nrite,"('Could not open STEINHARDT')")
+          
+        elseif(kode.eq.2517)then
+          
+          write(nrite,"('Error allocating q4site')")
+          
+        elseif(kode.eq.2518)then
+          
+          write(nrite,"('Error allocating q6site')")
+          
+        elseif(kode.eq.2519)then
+          
+          write(nrite,"('Error deallocating buff')")
+          
+        elseif(kode.eq.2521)then
+          
+          write(nrite,"('Error reading line ',i5,' of STEINHARDT'
+     x      )")nint(arg)
+          
+        elseif(kode.eq.2522)then
+          
+          write(nrite,"(
+     x      'Error allocating Steinhardt parameter arrays'       
+     x      )")
+          
+        elseif(kode.eq.2523)then
+          
+          write(nrite,"('Could not open ZETA')")
+          
+        elseif(kode.eq.2524)then
+          
+          write(nrite,"('Error allocating zetasite')")
+          
+        elseif(kode.eq.2525)then
+          
+          write(nrite,"('Error allocating full neighbour list')")
+          
+        elseif(kode.eq.2527)then
+          
+          write(nrite,"(
+     x      'Number of collective variables incorrect  for specified'//
+     x      'order parameters'
+     x      )")
+          
+        elseif(kode.eq.2529)then
+          
+          write(nrite,"('Error reading line ',i5,' of ZETA'
+     x      )")nint(arg)
+          
+        elseif(kode.eq.2531)then
+          
+          write(nrite,"('Comms error on reading METADYNAMICS')")
+          
+        elseif(kode.eq.2532)then
+          
+          write(nrite,"('Error in fc function - out of range')")
+          write(nrite,"('Value of r was ',1p,e14.6)")arg
+          
+        elseif(kode.eq.2533)then
+          
+          write(nrite,"(
+     x      'Error allocating solvation arrays for metadynamics'
+     x      )")
+          
+        elseif(kode.eq.2534)then
+          
+          write(nrite,"('Error allocating comms buffer arrays')")
+          
+        elseif(kode.eq.2535)then
+          
+          write(nrite,"('Solvation list overrun')")
+          
+        elseif(kode.eq.2536)then
+          
+          write(nrite,"(
+     x      'Error deallocating solvation arrays for metadynamics'
+     x      )")
+          
+        elseif(kode.eq.2537)then
+          
+          write(nrite,"('Error deallocating comms buffer arrays')")
+          
+        elseif(kode.eq.2538)then
+          
+          write(nrite,"(
+     x      'Error allocating solvation arrays for metadynamics'
+     x      )")
+          
+        elseif(kode.eq.2540)then
+          
+          write(nrite,"('Error allocating force prefactor arrays')")
+          
+        elseif(kode.eq.2541)then
+          
+          write(nrite,"(
+     x      'Memory allocation error in compute_tet_nlist'
+     x      )")
+          
+        elseif(kode.eq.2542)then
+          
+          write(nrite,"(
+     x      'Error in metafreeze_module.f90 mxninc too small'
+     x      )")
+          
+        elseif(kode.eq.2543)then
+          
+          write(nrite,"('nnn too small in compute_tet_nlist')")
+          
+        elseif(kode.eq.2544)then
+          
+          write(nrite,"('mxflist too small in metafreeze_module')")
+          
+        elseif(kode.eq.2545)then
+          
+          write(nrite,"(
+     x      'Memory deallocation error in compute_tet_nlist'
+     x      )")
+          
+        elseif(kode.eq.2546)then
+          
+          write(nrite,"(
+     x      'Memory allocation error in compute_tet_nlist'
+     x      )")
+          
+        elseif(kode.eq.2547)then
+          
+          write(nrite,"(
+     x      'Memory deallocation error in compute_tet_nlist'
+     x      )")
+          
+        elseif(kode.eq.2548)then
+          
+          write(nrite,"(
+     x      'Memory allocation error in compute_tet_nlist'
+     x      )")
+          
+        endif
+        
+c     close all i/o channels
+        
+        close (nrite)
+        close (nhist)
+        close (nread)
+        close (nconf)
+        close (nstats)
+        close (nrest)
+        close (nfield)
+        close (ntable)
+        close (nevnt)
+        close (stn)
+        close (zta)
+        close (mtd)
+        
+      endif
+      
+c     shut down communications
+      
+      call gsync()
+      call exitcomms()
+        
+      end Subroutine Mfrz_Error
+      
+      end module metafreeze_module
+      
diff -urN dl_class_1.9.orig/srcmod/metal_module.f dl_class_1.9/srcmod/metal_module.f
--- dl_class_1.9.orig/srcmod/metal_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/metal_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1669 @@
+      module metal_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining metal potential arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use pair_module
+      use parse_module
+      use property_module
+      use setup_module
+      use site_module
+      use utility_module
+      
+      implicit none
+
+      logical lmetab
+      integer, allocatable :: ltpmet(:),lstmet(:)
+      real(8), allocatable :: prmmet(:,:),vmet(:,:,:),dmet(:,:,:)
+      real(8), allocatable :: rho(:),elrcm(:),vlrcm(:),fmet(:,:,:)
+
+      save lmetab,ltpmet,lstmet,prmmet,vmet,dmet,fmet,rho,elrcm,vlrcm
+
+      contains
+      
+      subroutine alloc_met_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=8
+      integer i,fail,idnode
+
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate (ltpmet(mxmet),stat=fail(1))
+      allocate (lstmet(mxmet),stat=fail(2))
+      allocate (prmmet(mxmet,mxpmet),stat=fail(3))
+      allocate (vmet(mxgrid,mxmet,2),stat=fail(4))
+      allocate (dmet(mxgrid,mxmet,2),stat=fail(5))
+      allocate (rho(mxatms),stat=fail(6))
+      allocate (elrcm(0:mxsmet),stat=fail(7))
+      allocate (vlrcm(0:mxsmet),stat=fail(8))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1280)
+      enddo
+
+      end subroutine alloc_met_arrays
+
+      subroutine define_metals
+     x   (safe,lunits,lmols,idnode,ntpmet,ntpatm,rmet,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining metal potentials
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     amended   - w. smith  march 2006
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lunits,lmols
+      character*8 keyword
+      character*8 atom1,atom2
+      character*1 message(80)
+      integer idnode,ntpmet,ntpatm,idum,imet,j
+      integer keypot,numpar,katm1,katm2,keymet,ntab,i,fail,itpmet
+      integer jtpatm
+      real(8) rmet,engunit
+
+      real(8), allocatable :: parpot(:)
+      allocate (parpot(mxpmet),stat=fail)
+
+      ntpmet=intstr(record,lenrec,idum)
+      
+      lmetab=.false.
+      
+      if(idnode.eq.0) then
+        
+        write(nrite,"(/,/,1x,'number of specified metal ',
+     x    'potentials',i10)") ntpmet
+        write(nrite,"(/,/,16x,'atom 1  ','atom 2  ',3x,
+     x    ' key',30x,'parameters'/,/)")
+        
+      endif      
+
+      if(ntpmet.ge.mxmet) call error(idnode,71)
+      if(.not.lunits) call error(idnode,6)
+      if(.not.lmols) call error(idnode,13)
+      
+      do imet=1,mxmet
+        lstmet(imet)=0
+        ltpmet(imet)=0
+      enddo
+      
+      do itpmet=1,ntpmet
+        
+        do i=1,mxpmet
+          parpot(i)=0.d0
+        enddo
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        call copystring(record,message,80)
+        call getword(atom1,record,8,lenrec)
+        call getword(atom2,record,8,lenrec)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+        
+        if(keyword(1:4).eq.'stch') then
+          keypot=1
+          numpar=5
+        else if(keyword(1:4).eq.'fnsc') then
+          keypot=2
+          numpar=7
+        else if(keyword(1:4).eq.'gupt') then
+          keypot=3
+          numpar=5
+        elseif(keyword(1:4).eq.'eam ') then
+          keypot=999
+          lmetab=.true.
+          numpar=0
+        else
+          if(idnode.eq.0) write(nrite,*) message
+          call error(idnode,461)
+        endif
+        
+        if(.not.lmetab)then
+          
+          parpot(1)=dblstr(record,lenrec,idum)
+          parpot(2)=dblstr(record,lenrec,idum)
+          parpot(3)=dblstr(record,lenrec,idum)
+          parpot(4)=dblstr(record,lenrec,idum)
+          parpot(5)=dblstr(record,lenrec,idum)
+          parpot(6)=dblstr(record,lenrec,idum)
+          parpot(7)=dblstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(16x,2a8,2x,a4,3x,1p,9e13.5)") 
+     x      atom1,atom2,keyword(1:4),(parpot(j),j=1,numpar)
+        
+        endif
+        
+        katm1=0
+        katm2=0
+        
+        do jtpatm=1,ntpatm
+
+          if(atom1.eq.unqatm(jtpatm))katm1=jtpatm
+          if(atom2.eq.unqatm(jtpatm))katm2=jtpatm
+          
+        enddo
+        
+        if(katm1.eq.0.or.katm2.eq.0) then
+          call  error(idnode,463)
+        endif
+        
+        keymet=loc2(katm1,katm2)
+        
+c     convert energies to internal unit
+
+        if(keymet.ge.mxmet) call error(idnode,465)
+        
+        parpot(1)=parpot(1)*engunit
+
+        if(keypot.eq.2)then
+
+          parpot(2)=parpot(2)*engunit
+          parpot(3)=parpot(3)*engunit
+          parpot(5)=parpot(5)*engunit
+
+        endif
+
+        if(keypot.eq.3)then
+          parpot(4)=parpot(4)*engunit
+        endif
+
+        if(lstmet(keymet).ne.0) call error(idnode,141)
+        lstmet(keymet)=itpmet
+        ltpmet(itpmet)=keypot
+        if(itpmet.gt.1)then
+          if(keypot.ne.ltpmet(itpmet-1))call error(idnode,72)
+        endif        
+        
+        if(.not.lmetab)then
+          
+          do i=1,numpar
+            prmmet(itpmet,i)=parpot(i)
+          enddo
+          
+        endif
+        
+      enddo
+
+c     check for unspecified atom-atom potentials
+      
+      ntab=(ntpatm*(ntpatm+1))/2
+      
+      if(ntpmet.lt.ntab) then
+        
+        call warning(idnode,110,0.d0,0.d0,0.d0)
+
+        do i=1,ntab
+          if(lstmet(i).eq.0) lstmet(i)=ntpmet+1
+        enddo
+
+c     set zero potential for undefined interactions
+        
+        do i=1,mxmet
+          
+          vmet(1,i,1)=0.d0
+          vmet(1,i,2)=0.d0
+          dmet(1,i,1)=0.d0
+          dmet(1,i,2)=0.d0
+          
+        enddo
+        
+      endif
+
+c     generate metal force arrays
+      
+      call metgen(idnode,ntpatm,rmet)
+      
+      if(lmetab)
+     x  call mettab(ntpatm,idnode,rmet,engunit)
+      
+      deallocate (parpot,stat=fail)
+
+      return
+      end subroutine define_metals
+
+      subroutine metdens
+     x  (idnode,imcon,mxnode,natms,engmet,virden)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating local density in metals
+c     using the verlet neighbour list and sutton-chen potentials
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - w. smith june 1995
+c     amended   - w. smith  march 2006
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe
+      integer idnode,imcon,mxnode,natms,i,j,k,ii,k0,l
+      real(8) engmet,engtmp,virden,rhosqr,rrr,ppp,fk0,fk1,fk2,t1,t2
+      
+      safe=.true.
+      
+c     initialise energy accumulator
+      
+      engmet=0.d0
+      virden=0.d0
+
+c     initialise density array
+      
+      do i=1,natms
+        rho(i)=0.d0
+      enddo
+
+c     calculate local atomic density
+      
+      ii=0
+      
+c     outer loop over atoms
+
+      do i=idnode+1,natms,mxnode
+        
+        ii=ii+1
+        
+c     calculate interatomic distances
+        
+        do k=1,lentry(ii)
+          
+          j=list(ii,k)
+          ilist(k)=j
+          xdf(k)=xxx(i)-xxx(j)
+          ydf(k)=yyy(i)-yyy(j)
+          zdf(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary conditions
+        
+        call images(imcon,0,1,lentry(ii),cell,xdf,ydf,zdf)
+        
+c     square of distances
+        
+        do k=1,lentry(ii)
+          rsqdf(k)=xdf(k)**2+ydf(k)**2+zdf(k)**2
+        enddo
+        
+        if(lmetab)then
+          
+c     calculate EAM density contributions
+          
+          call eamden(safe,i,lentry(ii))
+          
+        else
+          
+c     calculate FS density contributions
+          
+          call fsden(safe,i,lentry(ii))
+          
+        endif
+        
+      enddo
+
+c     global sum of local atomic densities
+      
+      if(mxnode.gt.1)call gdsum(rho,natms,buffer)
+      
+c     calculate embedding energy
+
+      if(lmetab)then
+        
+c     density terms for eam potentials
+        
+        do i=1,natms
+          
+          if(rho(i).gt.0.d0)then
+            
+            k0=ltype(i)
+            rrr=rho(i)-fmet(2,k0,1)
+            l=min(nint(rrr/fmet(4,k0,1)),int(fmet(1,k0,1))-1)
+            if(l.lt.1)then
+              
+              safe=.false.
+              
+            else
+              
+              ppp=(rrr/fmet(4,k0,1))-dble(l)
+              
+c     calculate embedding energy using 3-point interpolation
+              
+              fk0=fmet(l-1,k0,1)
+              fk1=fmet(l,k0,1)
+              fk2=fmet(l+1,k0,1)
+              
+              t1=fk1+(fk1-fk0)*ppp
+              t2=fk1+(fk2-fk1)*ppp
+              if(ppp.lt.0.d0)then
+                engtmp=-(t1+0.5d0*(t2-t1)*(ppp+1.d0))
+              else
+                engtmp=-(t2+0.5d0*(t2-t1)*(ppp-1.d0))
+              endif
+
+              engmet=engmet+engtmp
+
+c     calculate derivative of embedding function wrt density using 3-point
+c     interpolation - store result in rho array
+              
+              fk0=fmet(l-1,k0,2)
+              fk1=fmet(l,k0,2)
+              fk2=fmet(l+1,k0,2)
+              
+              t1=fk1+(fk1-fk0)*ppp
+              t2=fk1+(fk2-fk1)*ppp
+              if(ppp.lt.0.d0)then
+                rho(i)=(t1+0.5d0*(t2-t1)*(ppp+1.d0))
+              else
+                rho(i)=(t2+0.5d0*(t2-t1)*(ppp-1.d0))
+              endif
+            
+            endif
+            
+          endif
+          
+        enddo
+        
+      else
+        
+c     analytical square root of density dependence
+        
+        do i=1,natms
+          
+          if(rho(i).gt.0.d0)then
+            
+            rhosqr=sqrt(rho(i)+elrcm(ltype(i)))
+            engmet=engmet+rhosqr
+            rho(i)=0.5d0/rhosqr
+            virden=virden+vlrcm(ltype(i))/rhosqr
+
+          endif
+          
+        enddo
+        
+      endif
+      
+      engmet=-engmet/dble(mxnode)
+      virden=virden/dble(mxnode)
+      
+c     check interpolation is safe
+      
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)call error(idnode,142)
+      
+      return
+      end subroutine metdens
+
+      subroutine fsden(safe,iatm,ik)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating local atomic density
+c     for FS type metal potentials
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith  june  1995
+c     amended   - w. smith  march 2006
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe
+      integer iatm,jatm,ik,m,k0,l
+      real(8) rdr,ai,aj,ab,rsq,rrr,ppp,t1,t2
+      real(8) vk0,vk1,vk2,density
+      
+c     start of primary loop for density
+
+      ai=dble(ltype(iatm))
+
+      do m=1,ik
+
+c     atomic and potential function indices
+        
+        jatm=ilist(m)
+
+        aj=dble(ltype(jatm))
+        if(ai.gt.aj) then
+          ab=ai*(ai-1.d0)*0.5d0+aj+0.5d0
+        else
+          ab=aj*(aj-1.d0)*0.5d0+ai+0.5d0
+        endif
+
+        k0=lstmet(int(ab))
+        
+        if((ltpmet(k0).ge.1).and.(abs(dmet(1,k0,1)).gt.0.d0))then
+
+c     apply truncation of potential
+          
+          rsq=rsqdf(m)
+
+c     apply cutoff condition
+      
+          if(rsq.le.dmet(3,k0,1)**2)then
+            
+c     interpolation parameters
+
+            rdr=1.d0/dmet(4,k0,1)
+            rrr=sqrt(rsq)-dmet(2,k0,1)
+            l=min(nint(rrr*rdr),int(dmet(1,k0,1))-1)
+            if(l.lt.1)then
+              
+              safe=.false.
+              
+            else
+              
+              ppp=rrr*rdr-dble(l)
+              
+c     calculate density using 3-point interpolation
+              
+              vk0=dmet(l-1,k0,1)
+              vk1=dmet(l,k0,1)
+              vk2=dmet(l+1,k0,1)
+              
+              t1=vk1+ppp*(vk1-vk0)
+              t2=vk1+ppp*(vk2-vk1)
+              if(ppp.lt.0.d0)then
+                density=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+              else
+                density=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+              endif
+              
+              if(ai.gt.aj)then
+                
+                rho(iatm)=rho(iatm)+density*dmet(1,k0,2)
+                rho(jatm)=rho(jatm)+density*dmet(2,k0,2)
+                
+              else
+                
+                rho(iatm)=rho(iatm)+density*dmet(2,k0,2)
+                rho(jatm)=rho(jatm)+density*dmet(1,k0,2)
+                
+              endif
+              
+            endif
+            
+          endif
+        
+        endif
+        
+      enddo
+      
+      return
+      end subroutine fsden
+
+      subroutine eamden(safe,iatm,ik)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating local atomic density
+c     for EAM type metal potentials
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith  june  1995
+c     amended   - w. smith  march 2006
+c     
+c***********************************************************************
+            
+      implicit none
+      logical safe
+      integer iatm,jatm,ik,m,l,ktyp1,ktyp2
+      real(8) rdr,rsq,rrr,ppp,t1,t2
+      real(8) vk0,vk1,vk2,density
+      
+c     start of primary loop for density
+
+      ktyp1=ltype(iatm)
+
+      do m=1,ik
+
+c     first metal atom density
+        
+        jatm=ilist(m)
+        ktyp2=ltype(jatm)
+        
+        if(abs(dmet(1,ktyp2,1)).gt.0.d0)then
+          
+c     apply truncation of potential
+          
+          rsq=rsqdf(m)
+
+          if(rsq.le.dmet(3,ktyp2,1)**2)then
+            
+c     interpolation parameters
+            
+            rdr=1.d0/dmet(4,ktyp2,1)
+            rrr=sqrt(rsq)-dmet(2,ktyp2,1)
+            l=min(nint(rrr*rdr),int(dmet(1,ktyp2,1))-1)
+            if(l.lt.1)then
+              
+              safe=.false.
+              
+            else
+              
+              ppp=rrr*rdr-dble(l)
+              
+c     calculate density using 3-point interpolation
+              
+              vk0=dmet(l-1,ktyp2,1)
+              vk1=dmet(l,ktyp2,1)
+              vk2=dmet(l+1,ktyp2,1)
+              
+              t1=vk1+ppp*(vk1-vk0)
+              t2=vk1+ppp*(vk2-vk1)
+              if(ppp.lt.0.d0)then
+                density=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+              else
+                density=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+              endif
+              
+              rho(iatm)=rho(iatm)+density
+              if(ktyp1.eq.ktyp2)rho(jatm)=rho(jatm)+density
+              
+            endif
+            
+          endif
+
+        endif
+        
+c     second  metal atom density
+            
+        if(ktyp1.ne.ktyp2)then
+          
+          if(abs(dmet(1,ktyp1,1)).gt.0.d0)then
+            
+c     apply truncation of potential
+            
+            if(rsq.le.dmet(3,ktyp1,1)**2)then
+              
+c     interpolation parameters
+              
+              rdr=1.d0/dmet(4,ktyp1,1)
+              rrr=sqrt(rsq)-dmet(2,ktyp1,1)
+              l=min(nint(rrr*rdr),int(dmet(1,ktyp1,1))-1)
+              if(l.lt.1)then
+                
+                safe=.false.
+                
+              else
+                
+                ppp=rrr*rdr-dble(l)
+                
+c     calculate density using 3-point interpolation
+                
+                vk0=dmet(l-1,ktyp1,1)
+                vk1=dmet(l,ktyp1,1)
+                vk2=dmet(l+1,ktyp1,1)
+                
+                t1=vk1+(vk1-vk0)*ppp
+                t2=vk1+(vk2-vk1)*ppp
+                if(ppp.lt.0.d0)then
+                  density=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+                else
+                  density=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+                endif
+                
+                rho(jatm)=rho(jatm)+density
+                
+              endif
+              
+            endif
+            
+          endif
+        
+        endif
+        
+      enddo
+      
+      return
+      end subroutine eamden
+
+      subroutine metfrc(safe,iatm,ik,engmet,virmet)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating metal forces
+c     for EAM and FS potentials using a verlet neighbour list
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith   june 1995
+c     amended   - w. smith  march 2006
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe
+      integer iatm,jatm,ik,m,k0,l,ld,ktyp1,ktyp2
+      real(8) engmet,virmet,strs
+      real(8) rdr,rsq,rrr,ppp,vk0,vk1,vk2,t1,t2,gk0,gk1,gk2
+      real(8) gamma,gamma1,gamma2,gamma3,fx,fy,fz,fi
+      dimension fi(3),strs(6)
+
+CDIR$ CACHE_ALIGN fi
+
+c     initialise potential energy and virial
+      
+      engmet=0.d0
+      virmet=0.d0
+
+c     initialise stress tensor accumulators
+      
+      strs(:)=0.d0
+
+c     store forces for iatm 
+      
+      fi(1)=fxx(iatm)
+      fi(2)=fyy(iatm)
+      fi(3)=fzz(iatm)
+      ktyp1=ltype(iatm)
+      
+c     start of primary loop for forces evaluation
+      
+      do m=1,ik
+        
+c     atomic and potential function indices
+        
+        jatm=ilist(m)
+        ktyp2=ltype(jatm)
+        k0=lstmet(loc2(ktyp1,ktyp2))
+        
+        if((ltpmet(k0).gt.0).and.(abs(vmet(1,k0,1)).gt.0.d0))then
+
+c     apply truncation of potential
+          
+          rsq=rsqdf(m)
+
+          if(rsq.le.vmet(3,k0,1)**2)then
+            
+c     interpolation parameters
+      
+            rdr=1.d0/vmet(4,k0,1)
+            rrr=sqrt(rsq)-vmet(2,k0,1)
+            l=min(nint(rrr*rdr),int(vmet(1,k0,1))-1)
+            if(l.lt.1)then
+              
+              safe=.false.
+              gamma1=0.d0
+              
+            else
+              
+              ppp=rrr*rdr-dble(l)
+              
+c     calculate interaction energy using 3-point interpolation
+              
+              vk0=vmet(l-1,k0,1)
+              vk1=vmet(l,k0,1)
+              vk2=vmet(l+1,k0,1)
+              
+              t1=vk1+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*ppp
+              if(ppp.lt.0.d0)then
+                engmet=engmet+t1+0.5d0*(t2-t1)*(ppp+1.d0)
+              else
+                engmet=engmet+t2+0.5d0*(t2-t1)*(ppp-1.d0)
+              endif
+              
+c     calculate pair forces using 3-point interpolation
+              
+              gk0=vmet(l-1,k0,2)
+              gk1=vmet(l,k0,2)
+              gk2=vmet(l+1,k0,2)
+              
+              t1=gk1+(gk1-gk0)*ppp
+              t2=gk1+(gk2-gk1)*ppp
+              if(ppp.lt.0.d0)then
+                gamma1=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+              else
+                gamma1=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+              endif
+              
+            endif
+            
+c     calculate embedding forces using 3-point interpolation
+
+            if(lmetab)then
+              
+              if(rsq.le.dmet(3,ktyp2,1)**2)then
+                
+                rdr=1.d0/dmet(4,ktyp2,1)
+                rrr=sqrt(rsq)-dmet(2,ktyp2,1)
+                ld=min(nint(rrr*rdr),int(dmet(1,ktyp2,1))-1)
+                if(ld.lt.1)then
+                  
+                  safe=.false.
+                  gamma2=0.d0
+                  
+                else
+                  
+                  ppp=rrr*rdr-dble(ld)
+                  
+                  gk0=dmet(ld-1,ktyp2,2)
+                  gk1=dmet(ld,ktyp2,2)
+                  gk2=dmet(ld+1,ktyp2,2)
+                  
+                  t1=gk1+(gk1-gk0)*ppp
+                  t2=gk1+(gk2-gk1)*ppp
+                  if(ppp.lt.0.d0)then
+                    gamma2=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+                  else
+                    gamma2=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+                  endif
+                
+                endif
+                
+              else
+                
+                gamma2=0.d0
+                
+              endif
+              
+              if(ktyp1.eq.ktyp2)then
+                
+                gamma3=gamma2
+                
+              elseif(rsq.le.dmet(3,ktyp1,1)**2)then
+                
+                rdr=1.d0/dmet(4,ktyp1,1)
+                rrr=sqrt(rsq)-dmet(2,ktyp1,1)
+                ld=min(nint(rrr*rdr),int(dmet(1,ktyp1,1))-1)
+                if(ld.lt.1)then
+                  
+                  safe=.false.
+                  gamma3=0.d0
+                  
+                else
+                  
+                  ppp=rrr*rdr-dble(ld)
+                  gk0=dmet(ld-1,ktyp1,2)
+                  gk1=dmet(ld,ktyp1,2)
+                  gk2=dmet(ld+1,ktyp1,2)
+                  
+                  t1=gk1+(gk1-gk0)*ppp
+                  t2=gk1+(gk2-gk1)*ppp
+                  if(ppp.lt.0.d0)then
+                    gamma3=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+                  else
+                    gamma3=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+                  endif
+                  
+                endif
+                
+              else
+                
+                gamma3=0.d0
+                
+              endif
+                
+              gamma=(gamma1+(gamma2*rho(iatm)+gamma3*rho(jatm)))/rsq
+              
+            else
+              
+              if(safe.and.rsq.le.dmet(3,k0,1)**2)then
+                
+                gk0=dmet(l-1,k0,2)
+                gk1=dmet(l,k0,2)
+                gk2=dmet(l+1,k0,2)
+                
+                t1=gk1+(gk1-gk0)*ppp
+                t2=gk1+(gk2-gk1)*ppp
+                if(ppp.lt.0.d0)then
+                  gamma2=t1+0.5d0*(t2-t1)*(ppp+1.d0)
+                else
+                  gamma2=t2+0.5d0*(t2-t1)*(ppp-1.d0)
+                endif
+                
+              else
+                
+                gamma2=0.d0
+                
+              endif
+              
+              if(ktyp1.gt.ktyp2)then
+                
+                gamma=(gamma1-gamma2*(rho(iatm)*dmet(1,k0,2)+
+     x            rho(jatm)*dmet(2,k0,2)))/rsq
+                
+              else
+                
+                gamma=(gamma1-gamma2*(rho(iatm)*dmet(2,k0,2)+
+     x            rho(jatm)*dmet(1,k0,2)))/rsq
+                
+              endif
+              
+            endif
+            
+c     calculate forces
+            
+            fx=gamma*xdf(m)
+            fy=gamma*ydf(m)
+            fz=gamma*zdf(m)
+            
+            fi(1)=fi(1)+fx
+            fi(2)=fi(2)+fy
+            fi(3)=fi(3)+fz
+            
+            fxx(jatm)=fxx(jatm)-fx
+            fyy(jatm)=fyy(jatm)-fy
+            fzz(jatm)=fzz(jatm)-fz
+            
+c     calculate stress tensor
+            
+            strs(1)=strs(1)+xdf(m)*fx
+            strs(2)=strs(2)+xdf(m)*fy
+            strs(3)=strs(3)+xdf(m)*fz
+            strs(4)=strs(4)+ydf(m)*fy
+            strs(5)=strs(5)+ydf(m)*fz
+            strs(6)=strs(6)+zdf(m)*fz
+            
+c     calculate virial
+            
+            virmet=virmet-gamma*rsq
+            
+          endif
+          
+        endif
+        
+      enddo
+
+c     load temps back to fxx(iatm) etc
+      
+      fxx(iatm)=fi(1)
+      fyy(iatm)=fi(2)
+      fzz(iatm)=fi(3)
+
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+      
+      return
+      end subroutine metfrc
+
+      subroutine metgen(idnode,ntpatm,rmet)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for generating potential energy and 
+c     force arrays for metal potentials
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith june 1995
+c     amended   - w. smith  march 2006
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer i,kmet,mmet,katm1,katm2,ntpatm,imet,nmet
+      integer idnode,nnn,mmm
+      real(8) dlrpot,rmet,rrr,eps,sig,cc0,cc1,cc2,ccc
+      real(8) ddd,bet,cut1,cut2,aaa,rr0,ppp,qqq
+      
+c     define grid resolution for potential arrays
+      
+      dlrpot=rmet/dble(mxgrid-1)
+
+c     construct arrays for metal potentials
+      
+      kmet=0
+      do katm1=1,ntpatm
+
+        do katm2=1,katm1
+
+          kmet=kmet+1
+          imet=lstmet(kmet)
+
+          if(ltpmet(imet).gt.0)then
+
+c     store array specification parameters
+            
+            vmet(1,imet,1)=dble(mxgrid)
+            vmet(2,imet,1)=0.d0
+            vmet(3,imet,1)=rmet
+            vmet(4,imet,1)=dlrpot
+            
+            do i=1,4
+              
+              vmet(i,imet,2)=vmet(i,imet,1)
+              dmet(i,imet,1)=vmet(i,imet,1)
+              dmet(i,imet,2)=0.d0
+              
+            enddo
+
+            if(ltpmet(imet).eq.1)then
+              
+c     sutton-chen potentials
+
+              eps=prmmet(imet,1)
+              sig=prmmet(imet,2)
+              nnn=nint(prmmet(imet,3))
+              mmm=nint(prmmet(imet,4))
+
+              do i=5,mxgrid
+                
+                rrr=dble(i)*dlrpot
+                vmet(i,imet,1)=eps*(sig/rrr)**nnn
+                vmet(i,imet,2)=dble(nnn)*eps*(sig/rrr)**nnn
+                dmet(i,imet,1)=(sig/rrr)**mmm
+                dmet(i,imet,2)=dble(mmm)*(sig/rrr)**mmm
+
+              enddo
+              
+              if(katm1.eq.katm2)then
+
+                dmet(1,imet,2)=(prmmet(imet,1)*prmmet(imet,5))**2
+                dmet(2,imet,2)=(prmmet(imet,1)*prmmet(imet,5))**2
+
+              else
+
+                nmet=lstmet((katm1*(katm1+1))/2)
+                mmet=lstmet((katm2*(katm2+1))/2)
+                dmet(1,imet,2)=(prmmet(nmet,1)*prmmet(nmet,5))**2
+                dmet(2,imet,2)=(prmmet(mmet,1)*prmmet(mmet,5))**2
+
+              endif
+
+            else if(ltpmet(imet).eq.2)then
+              
+c     finnis sinclair potentials
+
+              cc0=prmmet(imet,1)
+              cc1=prmmet(imet,2)
+              cc2=prmmet(imet,3)
+              ccc=prmmet(imet,4)
+              ddd=prmmet(imet,6)
+              bet=prmmet(imet,7)
+              cut1=ccc+4.d0*dlrpot
+              cut2=ddd+4.d0*dlrpot
+
+              do i=5,mxgrid
+                
+                rrr=dble(i)*dlrpot
+                vmet(i,imet,1)=0.d0
+                vmet(i,imet,2)=0.d0
+                dmet(i,imet,1)=0.d0
+                dmet(i,imet,2)=0.d0
+                
+                if(rrr.le.cut1)then
+                  
+                  vmet(i,imet,1)=(cc0+cc1*rrr+cc2*rrr*rrr)*(rrr-ccc)**2
+                  vmet(i,imet,2)=-rrr*(2.d0*(cc0+cc1*rrr+cc2*rrr*rrr)*
+     x              (rrr-ccc)+(cc1+2.d0*cc2*rrr)*(rrr-ccc)**2)
+                  
+                endif
+
+                if(rrr.le.cut2)then
+                  
+                  dmet(i,imet,1)=(rrr-ddd)**2+bet*(rrr-ddd)**3/ddd
+                  dmet(i,imet,2)=-rrr*(2.d0*(rrr-ddd)+
+     x              3.d0*bet*(rrr-ddd)**2/ddd)
+                  
+                endif
+                
+              enddo
+              
+              if(katm1.eq.katm2)then
+
+                dmet(1,imet,2)=prmmet(imet,5)**2
+                dmet(2,imet,2)=prmmet(imet,5)**2
+
+              else
+
+                nmet=lstmet((katm1*(katm1+1))/2)
+                mmet=lstmet((katm2*(katm2+1))/2)
+                dmet(1,imet,2)=prmmet(nmet,5)**2
+                dmet(2,imet,2)=prmmet(mmet,5)**2
+
+              endif
+              
+            else if(ltpmet(imet).eq.3)then
+              
+c     gupta potentials
+
+              aaa=prmmet(imet,1)
+              rr0=prmmet(imet,2)
+              ppp=prmmet(imet,3)
+              qqq=prmmet(imet,5)
+
+              do i=5,mxgrid
+                
+                rrr=dble(i)*dlrpot
+                vmet(i,imet,1)=aaa*exp(-ppp*(rrr-rr0)/rr0)
+                vmet(i,imet,2)=vmet(i,imet,1)*rrr*ppp/rr0
+                dmet(i,imet,1)=exp(-2.d0*qqq*(rrr-rr0)/rr0)
+                dmet(i,imet,2)=2.d0*dmet(i,imet,1)*rrr*qqq/rr0
+                
+              enddo
+              
+              dmet(1,imet,2)=prmmet(imet,4)**2
+              dmet(2,imet,2)=prmmet(imet,4)**2
+
+            else if(.not.lmetab)then
+              
+              call error(idnode,151)
+              
+            endif
+
+          endif
+          
+        enddo
+
+      enddo
+      
+      return
+      end subroutine metgen
+
+      subroutine lrcmetal
+     x  (idnode,imcon,natms,ntpatm,engunit,rmet,volm)
+      
+c*************************************************************************
+c     
+c     DL_POLY subroutine to evaluate long-range corrections to
+c     pressure and energy in a periodic metal system.
+c     
+c     copyright daresbury laboratory
+c     author -  w. smith   june 1995
+c     amended - w. smith  march 2006
+c     
+c***************************************************************************
+      
+      implicit none
+      
+      logical newjob
+      integer idnode,imcon,natms,ntpatm,i,ka,j
+      integer kmet,k0,k1,k2
+      real(8) engunit,rmet,volm,twopi,forpi,eps,sig,nnn,mmm,ccc
+      real(8) elrcm0,elrcm1,elrcm2,vlrcm0,vlrcm1,vlrcm2,aaa,rr0,ppp
+      real(8) zet,qqq,eee
+
+      save newjob
+      data newjob/.true./
+      
+      twopi=2.0d0*pi
+      forpi=4.0d0*pi
+
+c     initalise counter arrays
+      
+      do i=1,mxsmet
+        numtyp(i)=0
+      enddo
+
+c     evaluate species populations in system
+      
+      do i=1,natms
+        
+        ka=ltype(i)
+        numtyp(ka)=numtyp(ka)+1
+        
+      enddo
+      
+c     number densities
+      
+      do i=1,ntpatm
+        dens(i)=dble(numtyp(i))/volm
+      enddo
+      
+c     long range corrections to density, energy and pressure
+      
+      do i=0,mxsmet
+
+        elrcm(i)=0.d0
+        vlrcm(i)=0.d0
+
+      enddo
+      
+      if(imcon.ne.0.and.imcon.ne.6) then
+        
+        kmet=0
+        do i=1,ntpatm
+          
+          do j=1,i
+            
+            elrcm0=0.d0
+            elrcm1=0.d0
+            elrcm2=0.d0
+            vlrcm0=0.d0
+            vlrcm1=0.d0
+            vlrcm2=0.d0
+            
+            kmet=kmet+1
+            k0=lstmet(kmet)
+            
+            if(ltpmet(k0).eq.1) then
+              
+c     sutton-chen potentials
+              
+              eps=prmmet(k0,1)
+              sig=prmmet(k0,2)
+              nnn=prmmet(k0,3)
+              mmm=prmmet(k0,4)
+              ccc=prmmet(k0,5)
+
+              elrcm0=eps*sig**3*(sig/rmet)**(nnn-3.d0)/(nnn-3.d0)
+              vlrcm0=eps*nnn*sig**3*(sig/rmet)**(nnn-3.d0)/(nnn-3.d0)
+              if(i.ne.j) then
+                elrcm0=elrcm0*2.d0
+                vlrcm0=vlrcm0*2.d0
+              endif
+              elrcm(0)=elrcm(0)+twopi*volm*dens(i)*dens(j)*elrcm0
+              vlrcm(0)=vlrcm(0)-twopi*volm*dens(i)*dens(j)*vlrcm0
+              
+              if(i.eq.j) then
+                
+                elrcm1=sig**3*(sig/rmet)**(mmm-3.d0)/(mmm-3.d0)*
+     x            (eps*ccc)**2
+                elrcm(i)=elrcm(i)+forpi*dens(i)*elrcm1
+                
+                vlrcm1=mmm*sig**3*(sig/rmet)**(mmm-3.d0)/(mmm-3.d0)*
+     x            (eps*ccc)**2
+                vlrcm(i)=vlrcm(i)+twopi*dens(i)*vlrcm1
+
+              else
+
+                k1=lstmet((i*(i+1))/2)
+                k2=lstmet((j*(j+1))/2)
+                elrcm1=sig**3*(sig/rmet)**(mmm-3.d0)/(mmm-3.d0)*
+     x            (prmmet(k1,1)*prmmet(k1,5))**2
+                elrcm2=sig**3*(sig/rmet)**(mmm-3.d0)/(mmm-3.d0)*
+     x            (prmmet(k2,1)*prmmet(k2,5))**2
+                elrcm(i)=elrcm(i)+forpi*dens(j)*elrcm1
+                elrcm(j)=elrcm(j)+forpi*dens(i)*elrcm2
+
+                vlrcm1=mmm*sig**3*(sig/rmet)**(mmm-3.d0)/(mmm-3.d0)*
+     x            (prmmet(k1,1)*prmmet(k1,5))**2
+                vlrcm2=mmm*sig**3*(sig/rmet)**(mmm-3.d0)/(mmm-3.d0)*
+     x            (prmmet(k2,1)*prmmet(k2,5))**2
+                vlrcm(i)=vlrcm(i)+twopi*dens(j)*vlrcm1
+                vlrcm(j)=vlrcm(j)+twopi*dens(i)*vlrcm2
+
+              endif
+              
+            else if(ltpmet(k0).eq.3) then
+              
+c     gupta potentials
+              
+              aaa=prmmet(k0,1)
+              rr0=prmmet(k0,2)
+              ppp=prmmet(k0,3)
+              zet=prmmet(k0,4)
+              qqq=prmmet(k0,5)
+              eee=exp(-ppp*(rmet-rr0)/rr0)
+
+              elrcm0=aaa*(rr0/ppp)*(rmet**2+2.d0*rmet*(rr0/ppp)+
+     x          2.d0*(rr0/ppp)**2)*eee
+              vlrcm0=aaa*(rmet**3+3.d0*rmet**2*(rr0/ppp)+
+     x          6.d0*rmet*(rr0/ppp)**2+6.d0*(rr0/rmet)**3)*eee
+              if(i.ne.j) then
+                elrcm0=elrcm0*2.d0
+                vlrcm0=vlrcm0*2.d0
+              endif
+              elrcm(0)=elrcm(0)+twopi*volm*dens(i)*dens(j)*elrcm0
+              vlrcm(0)=vlrcm(0)-twopi*volm*dens(i)*dens(j)*vlrcm0
+              
+              eee=exp(-2.d0*qqq*(rmet-rr0)/rr0)
+
+              if(i.eq.j) then
+                
+                elrcm1=(rmet**2+2.d0*rmet*(0.5d0*rr0/qqq)+
+     x            2.d0*(0.5d0*rr0/qqq)**2)*(0.5d0*rr0/qqq)*eee*zet**2
+                elrcm(i)=elrcm(i)+forpi*dens(i)*elrcm1
+
+                vlrcm1=(rmet**3+3.d0*rmet**2*(0.5d0*rr0/qqq)+
+     x            6.d0*rmet*(0.5d0*rr0/qqq)**2+(0.5d0*rr0/qqq)**3)*
+     x            eee*zet**2
+                vlrcm(i)=vlrcm(i)+twopi*dens(i)*vlrcm1
+
+              else
+
+                elrcm1=(rmet**2+2.d0*rmet*(0.5d0*rr0/qqq)+
+     x            2.d0*(0.5d0*rr0/qqq)**2)*(0.5d0*rr0/qqq)*eee*
+     x            zet**2
+                elrcm2=(rmet**2+2.d0*rmet*(0.5d0*rr0/qqq)+
+     x            2.d0*(0.5d0*rr0/qqq)**2)*(0.5d0*rr0/qqq)*eee*
+     x            zet**2
+                elrcm(i)=elrcm(i)+forpi*dens(j)*elrcm1
+                elrcm(j)=elrcm(j)+forpi*dens(i)*elrcm2
+
+                vlrcm1=(rmet**3+3.d0*rmet**2*(0.5d0*rr0/qqq)+
+     x            6.d0*rmet*(0.5d0*rr0/qqq)**2+(0.5d0*rr0/qqq)**3)*
+     x            eee*zet**2
+                vlrcm2=(rmet**3+3.d0*rmet**2*(0.5d0*rr0/qqq)+
+     x            6.d0*rmet*(0.5d0*rr0/qqq)**2+(0.5d0*rr0/qqq)**3)*
+     x            eee*zet**2
+                vlrcm(i)=vlrcm(i)+twopi*dens(j)*vlrcm1
+                vlrcm(j)=vlrcm(j)+twopi*dens(i)*vlrcm2
+
+              endif
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+      endif
+      
+      if(newjob)then
+        
+        newjob=.false.
+        
+        if(idnode.eq.0)then
+          
+          write(nrite,"(/,/,
+     x      'long range corrections for metal potentials',/)")
+          write(nrite,
+     x      "('short range energy and virial corrections:',
+     x      1p,2e15.6,/)")
+     x    elrcm(0)/engunit,vlrcm(0)/engunit
+          write(nrite,
+     x      "('density dependent energy and virial corrections',/)")
+          
+          do i=1,ntpatm
+            
+            kmet=lstmet((i*(i+1))/2)
+            if(lstmet(kmet).gt.0)then
+              
+              write(nrite,"(25x,a8,1p,2e15.6)")unqatm(i),
+     x          elrcm(i)/engunit,vlrcm(i)/engunit
+              
+            endif
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine lrcmetal
+
+      subroutine mettab(ntpatm,idnode,rmet,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading potential energy and 
+c     force arrays for EAM metal forces only
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith march 2006
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical safe
+      character*8 atom1,atom2,type
+      integer idnode,ntpatm,idum,fail
+      integer imet,katm1,katm2,jtpatm,i,j,k,ktype
+      integer numpot,numpts,ipot
+      real(8) rmet,engunit,start,finish
+      data fail/0/
+      
+c     allocate embedding array
+      
+      allocate(fmet(mxgrid,mxmet,2),stat=fail)
+      if(fail.ne.0)call error(idnode,36)
+      
+c     define zero function for undefined interactions
+      
+      do i=1,mxmet
+        
+        fmet(1,i,1)=0.d0
+        fmet(1,i,2)=0.d0
+        
+      enddo
+      
+      if(idnode.eq.0)open (ntable,file='TABEAM')
+      
+c     skip header record
+      
+      call getrec(safe,idnode,ntable)
+      if(.not.safe)call abort_eamtable_read(idnode,ntable)
+      
+c     read number of potential functions in file
+      
+      call getrec(safe,idnode,ntable)
+      if(.not.safe)call abort_eamtable_read(idnode,ntable)
+      numpot=intstr(record,lenrec,idum)
+      
+      do ipot=1,numpot
+        
+c     read data type, atom labels, number of points, start and end
+        
+        call getrec(safe,idnode,ntable)
+        if(.not.safe)call abort_eamtable_read(idnode,ntable)
+        
+c     indentify data type
+        
+        ktype=1
+        if(findstring('dens',record,idum).or.
+     x    findstring('DENS',record,idum))ktype=2
+        if(findstring('embe',record,idum).or.
+     x    findstring('EMBE',record,idum))ktype=3
+        call getword(type,record,8,lenrec)
+        
+c     identify atom types
+        
+        call getword(atom1,record,8,lenrec)
+        if(ktype.eq.1)then
+          call getword(atom2,record,8,lenrec)
+        else
+          atom2=atom1
+        endif
+        
+c     data specifiers
+        
+        numpts=intstr(record,lenrec,idum)
+        start=dblstr(record,lenrec,idum)
+        finish=dblstr(record,lenrec,idum)
+        
+c     check atom indentities
+        
+        katm1=0
+        katm2=0
+        
+        do jtpatm=1,ntpatm
+          
+          if(atom1.eq.unqatm(jtpatm))katm1=jtpatm
+          if(atom2.eq.unqatm(jtpatm))katm2=jtpatm
+          
+        enddo
+        
+        if(katm1.eq.0.or.katm2.eq.0) then
+          if(idnode.eq.0) 
+     x      write(nrite,'(a)') ' **** '//atom1//' *** '//atom2//' ****'
+          call  error(idnode,81)
+        endif
+        
+c     check array dimensions
+        
+        if(mxbuff.lt.numpts+4)then
+          
+          if(idnode.eq.0)
+     x      write(nrite,*) 'mxbuff must be >=',numpts+4,' in mettab'
+          call error(idnode,28)
+          
+        endif
+        
+c     store working parameters (start shifted for DL_POLY interpolation)
+        
+        buffer(1)=dble(numpts+4)
+        buffer(4)=(finish-start)/dble(numpts-1)
+        buffer(2)=start-5.d0*buffer(4)
+        buffer(3)=finish
+        if(idnode.eq.0)
+     x    write(nrite,"(16x,2a8,2x,a4,3x,1p,4e13.5)") 
+     x    atom1,atom2,type,dble(numpts),start,finish,buffer(4)
+
+c     read potential arrays
+        
+        k=4
+        do j=1,(numpts+3)/4
+          
+          call getrec(safe,idnode,ntable)
+          if(.not.safe)call abort_eamtable_read(idnode,ntable)
+          buffer(k+1)=dblstr(record,lenrec,idum)
+          buffer(k+2)=dblstr(record,lenrec,idum)
+          buffer(k+3)=dblstr(record,lenrec,idum)
+          buffer(k+4)=dblstr(record,lenrec,idum)
+          k=k+4
+          
+        enddo
+        
+c     copy data to internal arrays
+        
+        if(ktype.eq.1)then
+          
+c     check range against specified cutoff
+        
+          if(rmet.lt.finish)call error(idnode,26)
+        
+c     identify potential
+
+          imet=lstmet(loc2(katm1,katm2))
+        
+c     pair potential terms
+          
+          vmet(1,imet,1)=buffer(1)
+          vmet(2,imet,1)=buffer(2)
+          vmet(3,imet,1)=buffer(3)
+          vmet(4,imet,1)=buffer(4)
+          
+          do i=5,mxgrid
+            
+            if(i-4.gt.numpts)then
+              vmet(i,imet,1)=0.d0
+            else
+              vmet(i,imet,1)=buffer(i)*engunit
+              buffer(i)=buffer(i)*engunit
+            endif
+            
+          enddo
+          
+c     calculate derivative of pair potential function
+          
+          call metal_deriv(imet,vmet,buffer)
+          
+c     adapt derivatives for use in interpolation
+      
+          do i=5,numpts+4
+            vmet(i,imet,2)=-(dble(i)*buffer(4)+buffer(2))*
+     x        vmet(i,imet,2)
+          enddo          
+          
+        else if(ktype.eq.2)then
+          
+c     check range against specified cutoff
+        
+          if(rmet.lt.finish)call error(idnode,26)
+        
+c     density  terms
+          
+          dmet(1,katm1,1)=buffer(1)
+          dmet(2,katm1,1)=buffer(2)
+          dmet(3,katm1,1)=buffer(3)
+          dmet(4,katm1,1)=buffer(4)
+          
+          do i=5,mxgrid
+            
+            if(i-4.gt.numpts)then
+              dmet(i,katm1,1)=0.d0
+            else
+              dmet(i,katm1,1)=buffer(i)
+            endif
+            
+          enddo
+          
+c     calculate derivative of density function
+          
+          call metal_deriv(katm1,dmet,buffer)
+          
+c     adapt derivatives for use in interpolation
+      
+          dmet(1,katm1,2)=0.d0
+          dmet(2,katm1,2)=0.d0
+          dmet(3,katm1,2)=0.d0
+          dmet(4,katm1,2)=0.d0
+          do i=5,numpts+4
+            dmet(i,katm1,2)=-(dble(i)*buffer(4)+buffer(2))*
+     x        dmet(i,katm1,2)
+          enddo          
+          
+        else if(ktype.eq.3)then
+          
+c     embedding function arrays
+          
+          fmet(1,katm1,1)=buffer(1)
+          fmet(2,katm1,1)=buffer(2)
+          fmet(3,katm1,1)=buffer(3)
+          fmet(4,katm1,1)=buffer(4)
+          
+          do i=5,mxgrid
+            
+            if(i-4.gt.numpts)then
+              fmet(i,katm1,1)=0.d0
+            else
+              fmet(i,katm1,1)=buffer(i)*engunit
+              buffer(i)=buffer(i)*engunit
+            endif
+            
+          enddo
+          
+c     calculate derivative of embedding function
+          
+          call metal_deriv(katm1,fmet,buffer)
+          
+        endif
+        
+      enddo
+
+      if(idnode.eq.0)close (ntable)
+      
+      if(idnode.eq.0)write(nrite,'(/,/,1x,a)')
+     x  'potential tables read from TABEAM file'
+      
+      return
+      end subroutine mettab
+
+      subroutine metal_deriv(ityp,vvv,buffer)
+
+c**********************************************************************
+c
+c     calculate numerical derivatives of tabulated EAM metal potentials
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith march 2006
+c
+c**********************************************************************
+      
+      implicit none
+      
+      integer ityp,i,npt
+      real(8) vvv,buffer,delmet,aa0,aa1,aa2,aa3,aa4,d1y,d2y,d3y,d4y
+      real(8) f0,f1,f2,f3,f4
+
+      dimension vvv(mxgrid,mxmet,2),buffer(mxbuff)
+      
+c     interpolation parameters
+      
+      vvv(1,ityp,2)=buffer(1)
+      vvv(2,ityp,2)=buffer(2)
+      vvv(3,ityp,2)=buffer(3)
+      vvv(4,ityp,2)=buffer(4)
+      
+c     construct interpolation table
+
+      delmet=buffer(4)
+      npt=nint(buffer(1))-2
+      do i=7,npt
+
+        aa0=buffer(i)
+        f0=buffer(i-2)/aa0
+        f1=buffer(i-1)/aa0
+        f2=1.d0
+        f3=buffer(i+1)/aa0
+        f4=buffer(i+2)/aa0
+        
+c     calculate numerical differences for 5-point interpolation
+        
+        d1y=(f1-f0)
+        d2y=(f2-f1)-(f1-f0)
+        d3y=(f3-f0)+3.d0*(f1-f2)
+        d4y=(f4-f3)+3.d0*(f2-f3)+3.d0*(f2-f1)+(f0-f1)
+        
+c     calculate polynomial coefficients
+        
+        aa0=aa0/delmet
+        aa4=d4y/24.d0
+        aa3=(d3y+12.d0*aa4)/6.d0
+        aa2=(d2y+6.d0*aa3-14.d0*aa4)/2.d0
+        aa1=d1y+3.d0*aa2-7.d0*aa3+15.d0*aa4
+        
+c     calculate derivatives
+        
+        vvv(i,ityp,2)=aa1*aa0
+        
+c     derivatives at extremes of range
+        
+        if(i.eq.7)then
+          
+          vvv(5,ityp,2)=(aa1-4.d0*aa2+12.d0*aa3-32.d0*aa4)*aa0
+          vvv(6,ityp,2)=(aa1-2.d0*aa2+3.d0*aa3-4.d0*aa4)*aa0
+          
+        else if(i.eq.npt)then
+          
+          vvv(npt+1,ityp,2)=(aa1+2.d0*aa2+3.d0*aa3+4.d0*aa4)*aa0
+          vvv(npt+2,ityp,2)=(aa1+4.d0*aa2+12.d0*aa3+32.d0*aa4)*aa0
+          
+        endif
+          
+      enddo
+      
+c     set derivatives to zero beyond end point of function
+      
+      do i=npt+3,mxgrid
+        vvv(i,ityp,2)=0.d0
+      enddo
+      
+      return
+      end subroutine metal_deriv
+
+      subroutine abort_eamtable_read(idnode,ntable)
+
+c***********************************************************************
+c     
+c     dl_poly error exit subroutine for reading TABEAM file
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith   mar 2006
+c     
+c***********************************************************************
+
+      implicit none
+      integer idnode,ntable
+
+      if(idnode.eq.0)close (ntable)
+      
+      call error(idnode,29)
+      
+      end subroutine abort_eamtable_read
+      
+      end module metal_module
diff -urN dl_class_1.9.orig/srcmod/neu_coul_module.f dl_class_1.9/srcmod/neu_coul_module.f
--- dl_class_1.9.orig/srcmod/neu_coul_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/neu_coul_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,731 @@
+      module neu_coul_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining neutral group coulomb terms
+c     copyright - daresbury laboratory
+c     
+c     author  - w. smith     aug 2006
+c     adapted - p.-a. cazade oct 2007 : solvation, free energy etc
+c     adapted - w. smith     jan 2011 : metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use ewald_module
+      use metafreeze_module
+      use pair_module
+      use setup_module
+      use solvation_module
+      
+      contains
+      
+      subroutine coul0neu
+     x  (lsolva,lfree,lexcite,ik,engcpe,vircpe,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic force.
+c     1/r potential, no truncation or damping.
+c     neutral group implementation
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994
+c     adapted for solvation, free energy and excitation
+c     - p.-a. cazade oct 2007
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lexcite,lselect,lskip,idrive,jdrive
+      integer ik,m,iatm,jatm,kkk
+      real(8) engcpe,vircpe,epsq,chgprd,rsq,rrr,coul,reps,fcoul
+      real(8) fx,fy,fz
+      real(8) strs(6),strs_loc(6)
+      
+      lskip=(lfree.or.lexcite)
+      
+c     initialise stress tensor accumulators
+      
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     start of primary loop for forces evaluation
+      
+      reps=r4pie0/epsq
+      do m=1,ik
+        
+c     atomic index and charge product
+        
+        iatm=ilist(m)
+        jatm=jlist(m)
+        
+c     metadynamics local definitions
+
+        if(lmetadyn)then
+
+          idrive=driven(ltype(iatm))
+          jdrive=driven(ltype(jatm))
+
+        endif
+
+        if(lskip)then
+          if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+        endif
+        
+        chgprd=chge(jatm)*chge(iatm)*reps
+        
+        if(abs(chgprd).gt.1.d-10)then
+          
+          rsq=rsqdf(m)
+          rrr=sqrt(rsq)
+          
+c     calculate coulomb energy and force
+          
+          coul=chgprd/rrr
+          fcoul=coul/rsq
+          
+c     set selection control
+          
+          lselect=.true.
+          
+c     set double index
+          
+          if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+          
+          if(lexcite)then
+            
+c     selected excitation option
+            
+            if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+              
+c     reset selection control
+              
+              lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+              
+c     calculate solvation energy
+                  
+              if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+              
+            endif
+            
+          elseif(lfree)then
+            
+c     selected free energy option
+            
+            if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+              
+c     set hamiltonian mixing parameter
+              
+              cou_fre=cou_fre-coul
+              cou_vir=cou_vir+coul
+              coul=lambda1*coul
+              fcoul=lambda1*fcoul
+              
+            elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+              
+c     set hamiltonian mixing parameter
+              
+              cou_fre=cou_fre+coul
+              cou_vir=cou_vir-coul
+              coul=lambda2*coul
+              fcoul=lambda2*fcoul
+              
+            endif
+            
+          endif
+          
+          if(lselect)then
+            
+c     calculate potential energy and virial
+          
+            engcpe=engcpe+coul
+            vircpe=vircpe-coul
+            
+c     calculate solvation energy
+          
+            if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+            
+c     calculate forces
+            
+            fx=fcoul*xdf(m)
+            fy=fcoul*ydf(m)
+            fz=fcoul*zdf(m)
+            
+            fxx(iatm)=fxx(iatm)+fx
+            fyy(iatm)=fyy(iatm)+fy
+            fzz(iatm)=fzz(iatm)+fz
+            
+            fxx(jatm)=fxx(jatm)-fx
+            fyy(jatm)=fyy(jatm)-fy
+            fzz(jatm)=fzz(jatm)-fz
+            
+c     calculate stress tensor
+            
+            strs(1)=strs(1)+xdf(m)*fx
+            strs(2)=strs(2)+xdf(m)*fy
+            strs(3)=strs(3)+xdf(m)*fz
+            strs(4)=strs(4)+ydf(m)*fy
+            strs(5)=strs(5)+ydf(m)*fz
+            strs(6)=strs(6)+zdf(m)*fz
+            
+          endif
+          
+c     metadynamics local definitions
+
+          if(lmetadyn.and.(idrive.or.jdrive))then
+            
+c     local energy and virial
+          
+            eng_loc=eng_loc+coul
+            vir_loc=vir_loc-coul
+            
+c     local forces
+            
+            fxx_loc(iatm)=fxx_loc(iatm)+fx
+            fyy_loc(iatm)=fyy_loc(iatm)+fy
+            fzz_loc(iatm)=fzz_loc(iatm)+fz
+            
+            fxx_loc(jatm)=fxx_loc(jatm)-fx
+            fyy_loc(jatm)=fyy_loc(jatm)-fy
+            fzz_loc(jatm)=fzz_loc(jatm)-fz
+            
+c     local stress tensor
+            
+            strs_loc(1)=strs_loc(1)+xdf(m)*fx
+            strs_loc(2)=strs_loc(2)+xdf(m)*fy
+            strs_loc(3)=strs_loc(3)+xdf(m)*fz
+            strs_loc(4)=strs_loc(4)+ydf(m)*fy
+            strs_loc(5)=strs_loc(5)+ydf(m)*fz
+            strs_loc(6)=strs_loc(6)+zdf(m)*fz
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+
+      return
+      end subroutine coul0neu
+      
+      subroutine coul2neu
+     x  (lsolva,lfree,lexcite,ik,engcpe,vircpe,epsq)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces 
+c     assuming a distance dependant dielectric `constant'.
+c     neutral group implementation
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994
+c     adapted for solvation, free energy and excitation
+c     - p.-a. cazade oct 2007
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lexcite,lselect,lskip,idrive,jdrive
+      integer ik,m,iatm,jatm,kkk
+      real(8) engcpe,vircpe,epsq,fx,fy,fz,chgprd,rrsq,coul,egamma
+      real(8) strs(6),strs_loc(6)
+      
+      lskip=(lfree.or.lexcite)
+      
+c     initialise stress tensor accumulators
+      
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0
+      
+c     start of primary loop for forces evaluation
+      
+      do m=1,ik
+        
+c     atomic index and charge product
+        
+        iatm=ilist(m)
+        jatm=jlist(m)
+        
+c     metadynamics local definitions
+
+        if(lmetadyn)then
+
+          idrive=driven(ltype(iatm))
+          jdrive=driven(ltype(jatm))
+
+        endif
+
+        if(lskip)then
+          if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+        endif
+        
+        chgprd=chge(iatm)*chge(jatm)*r4pie0/epsq
+        
+        if(abs(chgprd).gt.1.d-10)then
+          
+c     calculate potential energy
+          
+          rrsq=1.d0/rsqdf(m)
+          coul=chgprd*rrsq          
+          egamma=2.d0*coul*rrsq
+          
+c     set selection control
+          
+          lselect=.true.
+          
+c     set double index
+          
+          if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+          
+          if(lexcite)then
+            
+c     selected excitation option
+            
+            if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+              
+c     reset selection control
+              
+              lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+              
+c     calculate solvation energy
+                  
+              if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+              
+            endif
+            
+          elseif(lfree)then
+            
+c     selected free energy option
+            
+            if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+              
+c     set hamiltonian mixing parameter
+              
+              cou_fre=cou_fre-coul
+              cou_vir=cou_vir+2.d0*coul
+              coul=lambda1*coul
+              egamma=lambda1*egamma
+              
+            elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+              
+c     set hamiltonian mixing parameter
+              
+              cou_fre=cou_fre+coul
+              cou_vir=cou_vir-2.d0*coul
+              coul=lambda2*coul
+              egamma=lambda2*egamma
+              
+            endif
+            
+          endif
+          
+          if(lselect)then
+            
+c     calculate potential energy and Virial
+            
+            engcpe=engcpe+coul
+            vircpe=vircpe-2.d0*coul
+          
+c     calculate solvation energy
+          
+            if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+            
+c     calculate forces
+            
+            fx=egamma*xdf(m)
+            fy=egamma*ydf(m)
+            fz=egamma*zdf(m)
+            
+            fxx(iatm)=fxx(iatm)+fx
+            fyy(iatm)=fyy(iatm)+fy
+            fzz(iatm)=fzz(iatm)+fz
+            
+            fxx(jatm)=fxx(jatm)-fx
+            fyy(jatm)=fyy(jatm)-fy
+            fzz(jatm)=fzz(jatm)-fz
+            
+c     calculate stress tensor
+            
+            strs(1)=strs(1)+xdf(m)*fx
+            strs(2)=strs(2)+xdf(m)*fy
+            strs(3)=strs(3)+xdf(m)*fz
+            strs(4)=strs(4)+ydf(m)*fy
+            strs(5)=strs(5)+ydf(m)*fz
+            strs(6)=strs(6)+zdf(m)*fz
+            
+          endif
+          
+c     metadynamics local definitions
+
+          if(lmetadyn.and.(idrive.or.jdrive))then
+            
+c     local energy and virial
+
+            eng_loc=eng_loc+coul
+            vir_loc=vir_loc-2.d0*coul
+          
+c     local forces
+            
+            fxx_loc(iatm)=fxx_loc(iatm)+fx
+            fyy_loc(iatm)=fyy_loc(iatm)+fy
+            fzz_loc(iatm)=fzz_loc(iatm)+fz
+            
+            fxx_loc(jatm)=fxx_loc(jatm)-fx
+            fyy_loc(jatm)=fyy_loc(jatm)-fy
+            fzz_loc(jatm)=fzz_loc(jatm)-fz
+            
+c     local stress tensor
+            
+            strs_loc(1)=strs_loc(1)+xdf(m)*fx
+            strs_loc(2)=strs_loc(2)+xdf(m)*fy
+            strs_loc(3)=strs_loc(3)+xdf(m)*fz
+            strs_loc(4)=strs_loc(4)+ydf(m)*fy
+            strs_loc(5)=strs_loc(5)+ydf(m)*fz
+            strs_loc(6)=strs_loc(6)+zdf(m)*fz
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+      return
+      end subroutine coul2neu
+      
+      subroutine coul3neu
+     x  (lsolva,lfree,lexcite,ik,engcpe,vircpe,epsq,rcut,alpha)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic force.
+c     reaction field  potential
+c     Ref: M Neumann, J Chem Phys, 82, 5633, (1985)
+c     adapted for fennell-gezelter coulombic model
+c     by w.smith june 2007
+c     Ref: CJ Fennell and JD Gezelter, J Chem Phys, 
+c     124, 234104, (2006)
+c     adapted for solvation, free energy and excitation
+c               - p.-a. cazade oct 2007
+c     
+c     neutral group implementation
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - t. forester february 1995
+c     stress tensor - t.forester   feb 1995
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lsolva,lfree,lexcite,lselect,lskip,newjob,idrive,jdrive
+      integer ik,m,iatm,jatm,kkk
+      real(8) engcpe,vircpe,rcut,epsq,vcon,fcon,rdr,ppp,erc1,fer1
+      real(8) rcsq,b0,rfld0,rfld1,rfld2,chgprd,rsq,coul,omega,fcoul
+      real(8) fx,fy,fz,rrr,alpha,a1,a2,a3,a4,a5,pp,tt,exp1
+      real(8) strs(6),strs_loc(6)
+
+      save newjob,b0,rfld0,rfld1,rfld2,vcon,fcon
+
+      data a1,a2,a3/0.254829592d0,-0.284496736d0,1.421413741d0/
+      data a4,a5,pp/-1.453152027d0,1.061405429d0,0.3275911d0/
+      data newjob/.true./
+      
+      if(newjob)then
+        
+c     reaction field terms
+        
+        b0=2.d0*(epsq-1.d0)/(2.d0*epsq+1.d0)
+        rfld0=b0/rcut**3
+        rfld1=(1.d0+b0*0.5d0)/rcut
+        rfld2=rfld0*0.5d0
+        
+c     screened coulomb terms
+        
+        tt=1.d0/(1.d0+pp*alpha*rcut)
+        exp1=exp(-(alpha*rcut)**2)
+        erc1=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rcut
+        fer1=(erc1+2.d0*(alpha/sqrpi)*exp1)/(rcut*rcut)
+        vcon=erc1+rfld2*rcut**2-rfld1
+        fcon=rcut*fer1-rfld0*rcut
+        
+      endif
+      
+      lskip=(lfree.or.lexcite)
+      
+c     initialise stress tensor accumulators
+      
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     initialise potential energy and virial
+      
+      engcpe=0.d0
+      vircpe=0.d0     
+      
+c     start of primary loop for forces evaluation
+      
+      do m=1,ik
+        
+c     atomic index and charge product
+        
+        iatm=ilist(m)
+        jatm=jlist(m)
+        
+c     metadynamics local definitions
+
+        if(lmetadyn)then
+
+          idrive=driven(ltype(iatm))
+          jdrive=driven(ltype(jatm))
+
+        endif
+
+        if(lskip)then
+          if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+        endif
+        
+        chgprd=chge(jatm)*chge(iatm)*r4pie0
+        if(abs(chgprd).gt.1.d-10)then
+          
+c     calculate interatomic distance
+          
+          rsq=rsqdf(m)
+          rrr=sqrt(rsq)
+          
+c     error function terms
+          
+          tt=1.d0/(1.d0+pp*alpha*rrr)
+          exp1=exp(-(alpha*rrr)**2)
+          erc1=tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*exp1/rrr
+          fer1=(erc1+2.d0*(alpha/sqrpi)*exp1)/rsq
+          
+c     calculate potential energy
+          
+          omega=erc1-vcon+fcon*(rrr-rcut)
+          coul=chgprd*(omega+rfld2*rsq-rfld1)
+          
+c     calculate forces
+          
+          fcoul=chgprd*(fer1-fcon/rrr-rfld0)
+          
+c     set selection control
+          
+          lselect=.true.
+          
+c     set double index
+          
+          if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+          
+          if(lexcite)then
+            
+c     selected excitation option
+            
+            if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+              
+c     reset selection control
+              
+              lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+              
+c     calculate solvation energy
+                  
+              if(lsolva)cou_exc(kkk)=cou_exc(kkk)+coul
+              
+            endif
+            
+          elseif(lfree)then
+            
+c     selected free energy option
+            
+            if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+              
+c     set hamiltonian mixing parameter
+              
+              cou_fre=cou_fre-coul
+              cou_vir=cou_vir+fcoul*rsq
+              coul=lambda1*coul
+              fcoul=lambda1*fcoul
+              
+            elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+              
+c     set hamiltonian mixing parameter
+              
+              cou_fre=cou_fre+coul
+              cou_vir=cou_vir-fcoul*rsq
+              coul=lambda2*coul
+              fcoul=lambda2*fcoul
+              
+            endif
+            
+          endif
+          
+          if(lselect)then
+            
+c     calculate coulombic energy and virial
+            
+            engcpe=engcpe+coul
+            vircpe=vircpe-fcoul*rsq
+            
+c     calculate solvation energy
+            
+            if(lsolva)cou_sol(kkk)=cou_sol(kkk)+coul
+            
+c     calculate coulombic force
+            
+            fx=fcoul*xdf(m)
+            fy=fcoul*ydf(m)
+            fz=fcoul*zdf(m)
+            
+            fxx(iatm)=fxx(iatm)+fx
+            fyy(iatm)=fyy(iatm)+fy
+            fzz(iatm)=fzz(iatm)+fz
+            
+            fxx(jatm)=fxx(jatm)-fx
+            fyy(jatm)=fyy(jatm)-fy
+            fzz(jatm)=fzz(jatm)-fz
+            
+c     calculate stress tensor
+            
+            strs(1)=strs(1)+xdf(m)*fx
+            strs(2)=strs(2)+xdf(m)*fy
+            strs(3)=strs(3)+xdf(m)*fz
+            strs(4)=strs(4)+ydf(m)*fy
+            strs(5)=strs(5)+ydf(m)*fz
+            strs(6)=strs(6)+zdf(m)*fz
+            
+          endif
+          
+c     metadynamics local definitions
+
+          if(lmetadyn.and.(idrive.or.jdrive))then
+            
+c     local energy and virial
+
+            eng_loc=eng_loc+coul
+            vir_loc=vir_loc-fcoul*rsq
+          
+c     local forces
+            
+            fxx_loc(iatm)=fxx_loc(iatm)+fx
+            fyy_loc(iatm)=fyy_loc(iatm)+fy
+            fzz_loc(iatm)=fzz_loc(iatm)+fz
+            
+            fxx_loc(jatm)=fxx_loc(jatm)-fx
+            fyy_loc(jatm)=fyy_loc(jatm)-fy
+            fzz_loc(jatm)=fzz_loc(jatm)-fz
+            
+c     local stress tensor
+            
+            strs_loc(1)=strs_loc(1)+xdf(m)*fx
+            strs_loc(2)=strs_loc(2)+xdf(m)*fy
+            strs_loc(3)=strs_loc(3)+xdf(m)*fz
+            strs_loc(4)=strs_loc(4)+ydf(m)*fy
+            strs_loc(5)=strs_loc(5)+ydf(m)*fz
+            strs_loc(6)=strs_loc(6)+zdf(m)*fz
+            
+          endif
+
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+      return
+      end subroutine coul3neu
+      
+      end module neu_coul_module
diff -urN dl_class_1.9.orig/srcmod/nlist_builders_module.f dl_class_1.9/srcmod/nlist_builders_module.f
--- dl_class_1.9.orig/srcmod/nlist_builders_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/nlist_builders_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,2216 @@
+      module nlist_builders_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining neighbourlist builder routines
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use exclude_module
+      use pair_module
+      use setup_module
+      use utility_module
+      
+      contains
+      
+      subroutine nlist_driver
+     x  (newlst,lneut,lnsq,loglnk,ltad,natms,idnode,mxnode,imcon,
+     x  nneut,keyfce,rcut,delr,tstep)
+      
+c*********************************************************************
+c     
+c     dl_poly subroutine to select and implement neighbour list 
+c     builders for short range force calculations
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith june 2006
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      logical newlst,lneut,lnsq,loglnk,newjob,ltad
+      integer natms,idnode,mxnode,imcon,nneut,keyfce
+      real(8) rcut,delr,tstep
+      
+      save newjob
+      
+      data newjob/.true./
+      
+c     skip if no pair force calculations required
+      
+      if(keyfce.gt.0)then
+        
+c     test for updating the Verlet list
+        
+        if(ltad)then
+          
+          call vertest2(newlst,idnode,mxnode,natms,imcon,delr,tstep)
+          
+        else
+          
+          call vertest(newlst,idnode,mxnode,natms,delr,tstep)
+          
+        endif
+        
+c     set up nonbonded interaction (verlet) list
+        
+        newlst=(newjob.or.newlst)
+        
+        if(newlst)then
+          
+          if(.not.lneut)then
+            
+            if(lnsq)then 
+              
+c     calculate distant interactions explicitly
+              
+              call parlst_nsq(newlst,natms,idnode,mxnode,imcon,rcut)
+              
+            elseif(loglnk)then
+              
+c     ignore real space distant interactions
+              
+              call parlink
+     x          (newlst,natms,idnode,mxnode,imcon,rcut,delr)
+              
+            else
+              
+              call parlst
+     x          (newlst,natms,idnode,mxnode,imcon,rcut,delr)
+              
+            endif
+            
+          else
+            
+            if(.not.loglnk)then 
+              
+              call parneulst
+     x          (newlst,lneut,nneut,idnode,mxnode,imcon,rcut,
+     x          delr)
+              
+            else
+              
+              call parlinkneu
+     x          (newlst,natms,nneut,idnode,mxnode,imcon,
+     x          rcut,delr)
+              
+            endif
+            
+          endif
+          
+        endif
+        
+      endif
+      
+      newjob=.false.
+      
+      return
+      end subroutine nlist_driver
+      
+      subroutine parlst(newlst,natms,idnode,mxnode,imcon,rcut,delr)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the verlet neighbour
+c     list based on the brode-ahlrichs scheme
+c     frozen atoms taken into account
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w.smith    march 1992
+c     modified  - t.forester october 1993
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lchk,newlst,lfrzi,ldo
+      integer natms,idnode,mxnode,imcon,ibig,last,mpm2
+      integer npm2,idum,i,m,ii,j
+      real(8) rcut,delr,rclim,rsq
+      
+      
+      if(newlst)then
+        
+        ibig=0
+        
+c     check size of work array
+        
+        if(mxxdf.lt.(natms+1)/2)then
+          if(idnode.eq.0) write(nrite,*) 'mxxdf must be greater than ',
+     x      (natms+1)/2
+          call  error(idnode,474)
+        endif
+        
+c     set control variables
+        
+        last=natms
+        lchk=.true.
+        mpm2=natms/2
+        npm2=(natms-1)/2
+        
+c     set cutoff radius
+        
+        rclim=(rcut+delr)**2
+        
+c     construct pair force neighbour list
+        
+        do i=1,msatms
+          
+          lentry(i)=0
+          noxatm(i)=1
+          
+        enddo
+        
+c     outer loop over atoms
+        
+        do m=1,mpm2
+          
+          if(m.gt.npm2)last=mpm2
+          
+c     inner loop over atoms
+          
+          ii=0
+          
+          do i=idnode+1,last,mxnode
+            
+c     calculate atom indices
+            
+            j=i+m
+            if(j.gt.natms)j=j-natms
+            
+            ii=ii+1
+            xdf(ii)=xxx(i)-xxx(j)
+            ydf(ii)=yyy(i)-yyy(j)
+            zdf(ii)=zzz(i)-zzz(j)
+            
+          enddo
+          
+c     apply minimum image convention
+          
+          call images(imcon,0,1,ii,cell,xdf,ydf,zdf)
+          
+c     allocate atoms to neighbour list
+          
+          ii=0
+          
+          do i=idnode+1,last,mxnode
+            
+            lfrzi=(lstfrz(i).ne.0)
+            
+c     calculate atom indices
+            
+            j=i+m
+            if(j.gt.natms)j=j-natms
+            
+            ii=ii+1
+            
+c     reject atoms in excluded pair list
+            
+            if((nexatm(ii).gt.0).and.(lexatm(ii,noxatm(ii)).eq.j))
+     x        then
+              
+              noxatm(ii)=min(noxatm(ii)+1,nexatm(ii))
+              
+c     reject frozen atom pairs
+              
+            else
+              
+              ldo=.true.
+              if(lfrzi)ldo=(lstfrz(j).eq.0)
+              
+              if(ldo)then
+                
+c     calculate interatomic distance
+                
+                if(imcon.eq.6)then
+                  
+                  rsq=xdf(ii)*xdf(ii)+ydf(ii)*ydf(ii)
+                  
+                else
+                  
+                  rsq=xdf(ii)*xdf(ii)+ydf(ii)*ydf(ii)+zdf(ii)*zdf(ii)
+                  
+                endif
+                
+c     running check of neighbour list array capacity
+                
+                if(rsq.lt.rclim)then
+                  
+                  lentry(ii)=lentry(ii)+1
+                  
+                  if(lentry(ii).gt.mxlist)then
+                    
+                    lchk=.false.
+                    ibig=max(lentry(ii),ibig)
+                    
+                  endif
+                  
+c     compile neighbour list array
+                  
+                  if(lchk)then
+                    
+                    list(ii,lentry(ii))=j
+                    
+                  endif
+                  
+                endif
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+c     terminate job if neighbour list array exceeded
+        
+        if(mxnode.gt.1) call gstate(lchk)
+        
+        if(.not.lchk)then
+          
+          call gimax(ibig,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*) ' mxlist must be at least  ',ibig
+            write(nrite,*) ' mxlist is currently ',mxlist
+          endif
+          call error(idnode,110)
+          
+        endif
+        
+c     check all excluded atoms are accounted for
+        
+        do i=1,ii
+          
+          if(nexatm(i).gt.0.and.noxatm(i).ne.nexatm(i))lchk=.false.
+          
+        enddo
+        
+        if(mxnode.gt.1) call gstate(lchk)
+        
+        if(.not.lchk) call error(idnode,160)
+        
+      endif
+      
+      return
+      end subroutine parlst
+      
+      subroutine parlink(newlst,natms,idnode,mxnode,imcon,rcut,delr)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the verlet neighbour
+c     list based on link-cell method.
+c     frozen atoms taken into account
+c     
+c     to be used with the link version of exclude :exclude_link
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1993
+c     author    - t. forester september 1993.
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lchk,newlst,linc,newjob,lfrzi,ldo
+      integer natms,idnode,mxnode,imcon,idum,nix,niy,niz,fail
+      integer i,ibig,irat,nsbcll,ilx,ily,ilz,ncells,ix,iy,iz,j,icell
+      integer ic,ii,kc,ik,jx,jy,jz,jc,ixl
+      real(8) rcut,delr,rcsq,xm,ym,zm,det,xdc,ydc,zdc,tx,ty,tz
+      real(8) cx,cy,cz,sxd,syd,szd,xd,yd,zd,rsq
+      
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      
+      dimension nix(508),niy(508),niz(508)
+      
+      save newjob
+      data newjob/.true./
+      
+      data nix/0,1,0,0,-1,1,0,-1,1,0,-1,1,-1,1,2,0,0,-2,2,-1,1,0,-2,2,0,
+     x 0,-1,1,0,-1,1,-2,2,-2,2,-1,1,-1,1,-1,1,-2,2,0,-2,2,0,-2,2,-2,2,
+     x -1,1,-2,2,-2,2,-1,1,-2,2,-2,2,3,0,0,-3,3,-1,1,0,-3,3,0,0,-1,1,0,
+     x -1,1,-3,3,-3,3,-1,1,-1,1,-1,1,-3,3,-2,2,0,-3,3,0,0,-2,2,0,-2,2,
+     x -3,3,-3,3,-2,2,-1,1,-3,3,-3,3,-1,1,-1,1,-2,2,-2,2,-1,1,-2,2,-3,3,
+     x -3,3,-2,2,-2,2,-2,2,-3,3,0,-3,3,0,-3,3,-3,3,-1,1,-3,3,-3,3,-1,1,
+     x -3,3,-3,3,-2,2,-3,3,-3,3,-2,2,-3,3,-3,3,4,0,0,-4,4,-1,1,0,-4,4,0,
+     x 0,-1,1,0,-1,1,-4,4,-4,4,-1,1,-1,1,-1,1,-4,4,-2,2,0,-4,4,0,0,-2,2,
+     x 0,-2,2,-4,4,-4,4,-2,2,-1,1,-4,4,-4,4,-1,1,-1,1,-2,2,-2,2,-1,1,-2,
+     x 2,-4,4,-4,4,-2,2,-2,2,-2,2,-4,4,-3,3,0,-4,4,0,0,-3,3,0,-3,3,-4,4,
+     x -4,4,-3,3,-1,1,-4,4,-4,4,-1,1,-1,1,-3,3,-3,3,-1,1,-3,3,-4,4,-4,4,
+     x -3,3,-2,2,-4,4,-4,4,-2,2,-2,2,-3,3,-3,3,-2,2,-3,3,-4,4,-4,4,-3,3,
+     x -3,3,-3,3,-4,4,0,-4,4,0,-4,4,-4,4,-1,1,-4,4,-4,4,-1,1,-4,4,-4,4,
+     x -2,2,-4,4,-4,4,-2,2,-4,4,-4,4,-3,3,-4,4,-4,4,-3,3,5,0,0,-5,5,-1,
+     x 1,0,-5,5,0,0,-1,1,0,-1,1,-5,5,-5,5,-1,1,-1,1,-1,1,-5,5,-2,2,0,-5,
+     x 5,0,0,-2,2,0,-2,2,-5,5,-5,5,-2,2,-1,1,-5,5,-5,5,-1,1,-1,1,-2,2,
+     x -2,2,-1,1,-2,2,-5,5,-5,5,-2,2,-2,2,-2,2,-5,5,-3,3,0,-5,5,0,0,-3,
+     x 3,0,-3,3,-5,5,-5,5,-3,3,-1,1,-5,5,-5,5,-1,1,-1,1,-3,3,-3,3,-1,1,
+     x -3,3,-5,5,-5,5,-3,3,-2,2,-5,5,-5,5,-2,2,-2,2,-3,3,-3,3,-2,2,-3,3,
+     x -5,5,-5,5,-3,3,-3,3,-3,3/
+      data niy/  0,0,1,0,1,1,-1,0,0,1,-1,-1,1,1,0,2,0,1,1,2,2,-2,0,0,2,
+     x -1,0,0,1,-2,-2,-1,-1,1,1,2,2,-1,-1,1,1,2,2,-2,0,0,2,-2,-2,2,2,-2,
+     x -2,-1,-1,1,1,2,2,-2,-2,2,2,0,3,0,1,1,3,3,-3,0,0,3,-1,0,0,1,-3,-3,
+     x -1,-1,1,1,3,3,-1,-1,1,1,2,2,3,3,-3,0,0,3,-2,0,0,2,-3,-3,-2,-2,2,
+     x 2,3,3,-3,-3,-1,-1,1,1,3,3,-2,-2,-1,-1,1,1,2,2,-3,-3,-2,-2,2,2,3,
+     x 3,-2,-2,2,2,3,3,-3,0,0,3,-3,-3,3,3,-3,-3,-1,-1,1,1,3,3,-3,-3,3,3,
+     x -3,-3,-2,-2,2,2,3,3,-3,-3,3,3,0,4,0,1,1,4,4,-4,0,0,4,-1,0,0,1,-4,
+     x -4,-1,-1,1,1,4,4,-1,-1,1,1,2,2,4,4,-4,0,0,4,-2,0,0,2,-4,-4,-2,-2,
+     x 2,2,4,4,-4,-4,-1,-1,1,1,4,4,-2,-2,-1,-1,1,1,2,2,-4,-4,-2,-2,2,2,
+     x 4,4,-2,-2,2,2,3,3,4,4,-4,0,0,4,-3,0,0,3,-4,-4,-3,-3,3,3,4,4,-4,
+     x -4,-1,-1,1,1,4,4,-3,-3,-1,-1,1,1,3,3,-4,-4,-3,-3,3,3,4,4,-4,-4,
+     x -2,-2,2,2,4,4,-3,-3,-2,-2,2,2,3,3,-4,-4,-3,-3,3,3,4,4,-3,-3,3,3,
+     x 4,4,-4,0,0,4,-4,-4,4,4,-4,-4,-1,-1,1,1,4,4,-4,-4,4,4,-4,-4,-2,-2,
+     x 2,2,4,4,-4,-4,4,4,-4,-4,-3,-3,3,3,4,4,0,5,0,1,1,5,5,-5,0,0,5,-1,
+     x 0,0,1,-5,-5,-1,-1,1,1,5,5,-1,-1,1,1,2,2,5,5,-5,0,0,5,-2,0,0,2,-5,
+     x -5,-2,-2,2,2,5,5,-5,-5,-1,-1,1,1,5,5,-2,-2,-1,-1,1,1,2,2,-5,-5,
+     x -2,-2,2,2,5,5,-2,-2,2,2,3,3,5,5,-5,0,0,5,-3,0,0,3,-5,-5,-3,-3,3,
+     x 3,5,5,-5,-5,-1,-1,1,1,5,5,-3,-3,-1,-1,1,1,3,3,-5,-5,-3,-3,3,3,5,
+     x 5,-5,-5,-2,-2,2,2,5,5,-3,-3,-2,-2,2,2,3,3,-5,-5,-3,-3,3,3,5,5,-3,
+     x -3,3,3/
+      data niz/0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,0,2,0,0,0,0,1,1,1,1,2,2,2,
+     x 2,1,1,1,1,1,1,1,1,2,2,2,2,0,0,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,
+     x 2,2,2,0,0,3,0,0,0,0,1,1,1,1,3,3,3,3,1,1,1,1,1,1,1,1,3,3,3,3,0,0,
+     x 0,0,2,2,2,2,3,3,3,3,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,
+     x 3,3,2,2,2,2,2,2,2,2,3,3,3,3,0,0,3,3,3,3,1,1,1,1,3,3,3,3,3,3,3,3,
+     x 2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,0,0,4,0,0,0,0,1,1,1,1,4,4,4,4,1,
+     x 1,1,1,1,1,1,1,4,4,4,4,0,0,0,0,2,2,2,2,4,4,4,4,1,1,1,1,1,1,1,1,2,
+     x 2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,2,2,2,2,2,2,2,2,4,4,4,4,0,0,0,0,3,
+     x 3,3,3,4,4,4,4,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,2,
+     x 2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,4,
+     x 4,4,4,0,0,4,4,4,4,1,1,1,1,4,4,4,4,4,4,4,4,2,2,2,2,4,4,4,4,4,4,4,
+     x 4,3,3,3,3,4,4,4,4,4,4,4,4,0,0,5,0,0,0,0,1,1,1,1,5,5,5,5,1,1,1,1,
+     x 1,1,1,1,5,5,5,5,0,0,0,0,2,2,2,2,5,5,5,5,1,1,1,1,1,1,1,1,2,2,2,2,
+     x 2,2,2,2,5,5,5,5,5,5,5,5,2,2,2,2,2,2,2,2,5,5,5,5,0,0,0,0,3,3,3,3,
+     x 5,5,5,5,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,5,5,5,5,5,5,5,5,2,2,2,2,
+     x 2,2,2,2,3,3,3,3,3,3,3,3,5,5,5,5,5,5,5,5,3,3,3,3,3,3,3,3,5,5,5,5/
+      
+      data fail/0/
+      
+c     allocate work arrays
+      
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1890)
+      
+      if(newlst)then
+        
+        if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)
+     x    call error(idnode,300)
+        lchk=.true.
+        ibig=0
+        
+c     zero link arrays
+        
+        do i=1,natms
+          link(i)=0
+        enddo
+        
+c     construct pair force neighbour list
+        
+        do i=1,msatms
+          
+          lentry(i)=0
+          
+        enddo
+        
+c     real space cut off 
+        
+        rcsq=(rcut+delr)**2
+        
+c     create mock cell vector for non-periodic system
+        
+        if(imcon.eq.0.or.imcon.eq.6)then
+          
+c     find maximum x,y,z postions
+          
+          xm=0.d0
+          ym=0.d0
+          zm=0.d0
+          
+          do i=1,natms
+            
+            xm=max(xm,abs(xxx(i)))
+            ym=max(ym,abs(yyy(i)))
+            zm=max(zm,abs(zzz(i)))
+            
+          enddo
+          
+          if(imcon.eq.0)then
+            
+            cell(1)=max(2.d0*xm+rcut+delr,3.d0*(rcut+delr))
+            cell(5)=max(2.d0*ym+rcut+delr,3.d0*(rcut+delr))
+            cell(2)=0.d0
+            cell(3)=0.d0
+            cell(4)=0.d0
+            cell(6)=0.d0
+            cell(7)=0.d0
+            cell(8)=0.d0
+            
+          endif
+          
+          cell(9)=max(2.d0*zm+rcut+delr,3.d0*(rcut+delr),cell(9))
+          
+        endif
+        
+        call dcell(cell,celprp)
+        call invert(cell,rcell,det)
+        
+c     ratio of link cell length to cut off diameter - max value is 5
+        
+c     irat=nint((rcut+delr)/rlink)
+c     irat=min(max(irat,1),5)
+        
+        irat=1
+        
+        
+c     number of subcells
+        
+        if (irat.eq.1)then 
+          
+          nsbcll=14
+          
+        elseif(irat.eq.2)then
+          
+          nsbcll=63
+          
+        elseif(irat.eq.3)then
+          
+          nsbcll=156
+          
+        elseif(irat.eq.4)then
+          
+          nsbcll=307
+          
+        elseif(irat.eq.5)then
+          
+          nsbcll=508
+          
+        endif
+        
+        ilx=int(celprp(7)*dble(irat)/(rcut+delr))
+        ily=int(celprp(8)*dble(irat)/(rcut+delr))
+        ilz=int(celprp(9)*dble(irat)/(rcut+delr))
+        
+c     check there are enough link cells
+        
+        linc=.true.
+        if(ilx.lt.2*irat+1)linc=.false.
+        if(ily.lt.2*irat+1)linc=.false.
+        if(ilz.lt.2*irat+1)linc=.false.
+        if(.not.linc) call error(idnode,305)
+        ncells=ilx*ily*ilz
+        if(ncells.gt.mxcell) call error(idnode,392)
+        
+c     calculate link cell indices
+        
+        do i=1,ncells
+          
+          lct(i)=0
+          
+        enddo
+        
+c     link-cell cutoff for reduced space
+        
+        xdc=dble(ilx)
+        ydc=dble(ily)
+        zdc=dble(ilz)
+        
+c     reduced space coordinates
+        if(newjob)then
+          
+          newjob=.false.
+          call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+          
+          if(mxnode.gt.1)  call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+        endif
+        
+        do i=1,natms
+          
+          tx=xxx(i)
+          ty=yyy(i)
+          tz=zzz(i)
+          
+          uxx(i)=(rcell(1)*tx+rcell(4)*ty+rcell(7)*tz)+0.5d0
+          uyy(i)=(rcell(2)*tx+rcell(5)*ty+rcell(8)*tz)+0.5d0
+          uzz(i)=(rcell(3)*tx+rcell(6)*ty+rcell(9)*tz)+0.5d0
+          
+        enddo
+        
+c     link neighbours 
+        
+        do i=1,natms
+          
+          ix=min(int(xdc*uxx(i)),ilx-1)
+          iy=min(int(ydc*uyy(i)),ily-1)
+          iz=min(int(zdc*uzz(i)),ilz-1)
+          
+          icell=1+ix+ilx*(iy+ily*iz)
+          
+          j=lct(icell)
+          lct(icell)=i
+          link(i)=j
+          
+        enddo
+        
+c     set control variables for loop over subcells
+        
+        ix=1
+        iy=1
+        iz=1
+        
+c     primary loop over subcells
+        
+        do ic=1,ncells
+          
+          ii=lct(ic)
+          if(ii.gt.0)then
+            
+c     secondary loop over subcells
+            
+            ik=0
+            
+            do kc=1,nsbcll
+              
+              i=ii
+              
+              cx=0.d0
+              cy=0.d0
+              cz=0.d0
+              jx=ix+nix(kc)
+              jy=iy+niy(kc)
+              jz=iz+niz(kc)
+              
+c     minimum image convention
+              
+              if(jx.gt.ilx)then
+                
+                jx=jx-ilx
+                cx=1.d0
+                
+              elseif(jx.lt.1)then
+                
+                jx=jx+ilx
+                cx=-1.d0
+                
+              endif
+              
+              if(jy.gt.ily)then
+                
+                jy=jy-ily
+                cy=1.d0
+                
+              elseif(jy.lt.1)then
+                
+                jy=jy+ily
+                cy=-1.d0
+                
+              endif
+              
+              if(jz.gt.ilz)then
+                
+                jz=jz-ilz
+                cz=1.d0
+                
+              elseif(jz.lt.1)then
+                
+                jz=jz+ilz
+                cz=-1.d0
+                
+              endif
+              
+c     index of neighbouring cell
+              
+              jc=jx+ilx*((jy-1)+ily*(jz-1))
+              j=lct(jc)
+              
+c     ignore if empty
+              
+              if(j.gt.0)then
+                
+                do while(i.ne.0)
+                  
+c     test if site is of interest to this node
+                  
+                  if(mod(i-1,mxnode).eq.idnode)then
+                    
+                    
+c     i's index for this processor
+                    ik=((i-1)/mxnode)+1
+                    
+c     test if i is a frozen atom
+                    
+                    lfrzi=(lstfrz(i).ne.0)
+                    
+                    if(ic.eq.jc) j=link(i)
+                    if(j.gt.0)then
+                      
+                      do while(j.ne.0)
+                        
+c     test of frozen atom pairs
+                        
+                        ldo=.true.
+                        if(lfrzi)ldo=(lstfrz(j).eq.0)
+                        
+                        if(ldo)then
+                          
+c     distance in real space : minimum image applied
+                          
+                          sxd=uxx(j)-uxx(i)+cx
+                          syd=uyy(j)-uyy(i)+cy
+                          szd=uzz(j)-uzz(i)+cz
+                          
+                          xd=cell(1)*sxd+cell(4)*syd+cell(7)*szd
+                          yd=cell(2)*sxd+cell(5)*syd+cell(8)*szd
+                          zd=cell(3)*sxd+cell(6)*syd+cell(9)*szd
+                          
+                          if(imcon.eq.6)then
+                            
+                            rsq=xd**2+yd**2
+                            
+                          else
+                            
+                            rsq=xd**2+yd**2+zd**2
+                            
+                          endif
+                          
+c     test of distance
+                          if(rcsq.gt.rsq)then
+                            
+c     test for excluded atom 
+                            
+                            linc=.true.
+                            do ixl=1,nexatm(ik)
+                              
+                              if(lexatm(ik,ixl).eq.j) linc=.false.
+                              
+                            enddo
+                            
+                            if(linc)then
+                              
+                              lentry(ik)=lentry(ik)+1
+                              
+                              if(lentry(ik).gt.mxlist)then
+                                
+                                ibig=max(ibig,lentry(ik))
+                                lchk=.false.
+                                
+                              else
+                                
+                                list(ik,lentry(ik))=j
+                                
+                              endif
+                              
+                            endif
+                            
+                          endif
+                          
+                        endif
+                        
+                        j=link(j)
+                        
+                      enddo
+                      
+                    endif
+                    
+                  endif
+                  
+                  j=lct(jc)
+                  i=link(i)
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+          endif
+          
+          ix=ix+1
+          if(ix.gt.ilx)then
+            
+            ix=1
+            iy=iy+1
+            
+            if(iy.gt.ily)then
+              
+              iy=1
+              iz=iz+1
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+c     terminate job if neighbour list array exceeded
+        
+        if(mxnode.gt.1) call gstate(lchk)
+        
+        if(.not.lchk)then
+          
+          call gimax(ibig,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*) ' mxlist must be >=  ',ibig
+            write(nrite,*) ' mxlist is currenty ',mxlist
+          endif
+          call error(idnode,106)
+          
+        endif
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate (uxx,uyy,uzz,stat=fail)
+      
+      return
+      end subroutine parlink
+      
+      subroutine parneulst(newlst,lneut,nneut,idnode,mxnode,imcon,
+     x  rcut,delr)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the verlet neighbour
+c     list based on the brode-ahlrichs scheme
+c     frozen atoms taken into account
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - t.forester   april   1994
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lchk,newlst,lneut,safe,lfrzi
+      integer nneut,idnode,mxnode,imcon,idum,fail,mpm2,npm2,ibig
+      integer i,ill,ia,im,jmlast,jmwrap,nuei1,nuei2,ii,jm1,jm,jj0,jj2
+      integer j,ii1
+      real(8) rcut,delr,rclim,fi,rrr,rcl1
+      
+      logical, allocatable :: lms(:)
+      dimension fi(3)
+      
+      data fail/0/
+      
+C     DIR$ CACHE_ALIGN fi
+      
+c     allocate work arrays
+      
+      allocate (lms(mxneut),stat=fail)
+      if(fail.ne.0)call error(idnode,1910)
+      
+      if(newlst.and.lneut)then
+        
+c     set control variables
+        
+        safe=.true. 
+        lchk= .true.
+        mpm2=(nneut+2)/2
+        npm2=(nneut+1)/2 
+        
+c     set cutoff radius
+        
+        rcl1=(rcut+delr)
+        rclim=(rcut+delr)**2
+        ibig=0
+        ill=0
+        
+c     construct pair force neighbour list: neutral groups
+        
+        do i=1,msatms
+          
+          lentry(i)=0
+          
+        enddo
+        
+        
+c     outer loop over groups
+        
+        ia=0
+        
+        do im=idnode+1,nneut,mxnode
+          
+          ia=ia+1 
+          if(im.ge.mpm2) mpm2=npm2
+          
+          lms(1)=.false.
+          do j=2,mpm2
+            lms(j)=.true.
+          enddo
+          
+          jmlast=min(nneut,im+mpm2-1)
+          jmwrap=max(0,im+mpm2-1-nneut)
+          
+c     loop over atomic pairs
+          
+          nuei1=neulst(im)
+          nuei2=neulst(im+1)-1
+          
+          do i=nuei1,nuei2
+            
+            fi(1)=xxx(i)
+            fi(2)=yyy(i)
+            fi(3)=zzz(i)
+            lfrzi=(lstfrz(i).eq.0)
+            
+            ii=0
+            jm1=1
+            do jm=im+1,jmlast
+              
+              jm1=jm1+1
+              if(lms(jm1))then
+                
+                jj0=neulst(jm)
+                jj2=neulst(jm+1)-1
+                
+                do j=jj0,jj2
+                  
+                  ii=ii+1
+                  if(ii.le.mxxdf)then
+                    
+                    xdf(ii)=fi(1)-xxx(j)
+                    ydf(ii)=fi(2)-yyy(j)
+                    zdf(ii)=fi(3)-zzz(j)
+                    
+                  else
+                    
+                    ibig=max(ibig,ii)
+                    safe=.false.
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+            do jm=1,jmwrap
+              
+              jm1=jm1+1
+              if(lms(jm1))then
+                
+                jj0=neulst(jm)
+                jj2=neulst(jm+1)-1
+                
+                do j=jj0,jj2
+                  
+                  ii=ii+1
+                  if(ii.le.mxxdf)then
+                    
+                    xdf(ii)=fi(1)-xxx(j)
+                    ydf(ii)=fi(2)-yyy(j)
+                    zdf(ii)=fi(3)-zzz(j)
+                    
+                  else
+                    
+                    safe=.false.
+                    ibig=max(ibig,ii)
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+c     apply minimum image convention
+            
+            ii1=min(ii,mxxdf)
+            call images(imcon,0,1,ii1,cell,xdf,ydf,zdf)
+            
+c     search for those in cutoff
+            
+            ii=0
+            jm1=1
+            do jm=im+1,jmlast
+              
+              jm1=jm1+1
+              if(lms(jm1))then
+                
+                jj0=neulst(jm)
+                jj2=neulst(jm+1)-1
+                
+                do j=jj0,jj2
+                  
+                  ii=ii+1
+                  if(ii.le.mxxdf)then
+                    
+                    if(lms(jm1))then
+                      
+                      if(lfrzi)then
+                        if(abs(zdf(ii)).lt.rcl1)then
+                          if(abs(ydf(ii)).lt.rcl1)then
+                            if(abs(xdf(ii)).lt.rcl1)then
+                              rrr=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+                              if(rrr.lt.rclim) lms(jm1)=.false.
+                            endif
+                          endif
+                        endif
+                        
+                      elseif(lstfrz(j).eq.0)then 
+                        if(abs(zdf(ii)).lt.rcl1)then
+                          if(abs(ydf(ii)).lt.rcl1)then
+                            if(abs(xdf(ii)).lt.rcl1)then
+                              rrr=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+                              if(rrr.lt.rclim) lms(jm1)=.false.
+                            endif
+                          endif
+                        endif
+                        
+                      endif
+                      
+                    endif
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+            do jm=1,jmwrap
+              
+              jm1=jm1+1
+              if(lms(jm1))then
+                
+                jj0=neulst(jm)
+                jj2=neulst(jm+1)-1
+                
+                do j=jj0,jj2
+                  
+                  ii=ii+1
+                  if(ii.le.mxxdf)then
+                    
+                    if(lms(jm1))then
+                      
+                      if(lfrzi)then
+                        
+                        if(abs(zdf(ii)).lt.rcl1)then
+                          if(abs(ydf(ii)).lt.rcl1)then
+                            if(abs(xdf(ii)).lt.rcl1)then
+                              rrr=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+                              if(rrr.lt.rclim) lms(jm1)=.false.
+                            endif
+                          endif
+                        endif
+                        
+                      elseif(lstfrz(j).eq.0)then
+                        
+                        if(abs(zdf(ii)).lt.rcl1)then
+                          if(abs(ydf(ii)).lt.rcl1)then
+                            if(abs(xdf(ii)).lt.rcl1)then
+                              rrr=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+                              if(rrr.lt.rclim) lms(jm1)=.false.
+                            endif
+                          endif
+                        endif
+                        
+                      endif
+                      
+                    endif
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+          enddo
+          
+c     compile neighbour list for ia
+c     with running check of neighbour list array capacity
+          
+          jm1=0
+          do jm=im,jmlast
+            
+            jm1=jm1+1
+            if(.not.lms(jm1))then
+              
+              lentry(ia)=lentry(ia)+1
+              if(lentry(ia).le.mxlist)then
+                
+                list(ia,lentry(ia))=jm
+                
+              else
+                
+                ill=max(ill,lentry(ia))
+                lchk=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+          do jm=1,jmwrap
+            
+            jm1=jm1+1
+            if(.not.lms(jm1))then
+              
+              lentry(ia)=lentry(ia)+1
+              if(lentry(ia).le.mxlist)then
+                
+                list(ia,lentry(ia))=jm
+                
+              else
+                
+                ill=max(ill,lentry(ia))
+                lchk=.false.
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+c     terminate job if neighbour list array exceeded
+        
+        if(mxnode.gt.1) call gstate(lchk)
+        if(.not.lchk)then
+          
+          call gimax(ill,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*) ' mxlist must be at least  ',ill
+            write(nrite,*) ' mxlist is currently ',mxlist
+          endif
+          call error(idnode,108)
+          
+        endif   
+        
+c     terminate job if work arrays exceeded
+        
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then
+          call gimax(ibig,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*)'mxxdf must be at least ',ibig
+            write(nrite,*)'mxxdf is currently ',mxxdf
+          endif
+          call  error(idnode,476)
+        endif
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate(lms,stat=fail)
+      
+      return
+      end subroutine parneulst
+      
+      subroutine parlinkneu
+     x  (newlst,natms,nneut,idnode,mxnode,imcon,rcut,delr)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the verlet neighbour
+c     list based on link-cell method with neutral groups
+c     frozen atoms taken into account
+c     
+c     to be used with the link version of exclude :excludeneu_link
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1996
+c     author    - t. forester january 1996.
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lchk,newlst,linc,newjob,lfrzi,ldo,swop
+      integer natms,nneut,idnode,mxnode,imcon,idum,fail,ibig
+      integer nix,niy,niz,i,irat,nsbcll,ilx,ily,ilz,ncells,ix,iy,iz
+      integer icell,j,ic,ii,kc,jx,jy,jz,jc,ineu,ik,jneu,ineua,jneua
+      integer ika,jneua1,i1,j1
+      real(8) rcut,delr,rcsq,xm,ym,zm,det,xdc,ydc,zdc,tx,ty,tz
+      real(8) cx,cy,cz,sxd,syd,szd,rsq,xd,yd,zd
+      
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      
+      dimension nix(14),niy(14),niz(14)
+      
+      save newjob
+      
+      data newjob/.true./
+      data nix/0,1,0,0,-1,1,0,-1,1,0,-1,1,-1,1/
+      data niy/ 0,0,1,0,1,1,-1,0,0,1,-1,-1,1,1/
+      data niz/0,0,0,1,0,0,1,1,1,1,1,1,1,1/
+      data fail/0/
+      
+c     allocate work arrays
+      
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1900)
+      
+      lchk=.true.
+      ibig=0
+      if(newlst)then
+        
+        if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)
+     x    call error(idnode,300)
+        
+c     zero link arrays
+        
+        do i=1,natms
+          
+          link(i)=0
+          
+        enddo
+        
+c     construct pair force neighbour list
+        
+        do i=1,msatms
+          
+          lentry(i)=0
+          
+        enddo
+        
+c     real space cut off 
+        
+        rcsq=(rcut+delr)**2
+c     
+c     create mock cell vector for non-periodic system
+        
+        if(imcon.eq.0.or.imcon.eq.6)then
+          
+c     find maximum x,y,z postions
+          
+          xm=0.d0
+          ym=0.d0
+          zm=0.d0
+          
+          do i=1,natms
+            
+            xm=max(xm,abs(xxx(i)))
+            ym=max(ym,abs(yyy(i)))
+            zm=max(zm,abs(zzz(i)))
+            
+          enddo
+          
+          if(imcon.eq.0)then
+            
+            cell(1)=max(2.d0*xm+rcut+delr,3.d0*(rcut+delr))
+            cell(5)=max(2.d0*ym+rcut+delr,3.d0*(rcut+delr))
+            cell(2)=0.d0
+            cell(3)=0.d0
+            cell(4)=0.d0
+            cell(6)=0.d0
+            cell(7)=0.d0
+            cell(8)=0.d0
+            
+          endif
+          
+          cell(9)=max(2.d0*zm+rcut+delr,3.d0*(rcut+delr),cell(9))
+          
+        endif
+        
+        call dcell(cell,celprp)
+        call invert(cell,rcell,det)
+        
+c     ratio of link cell length to cut off diameter 
+        
+        irat=1
+        
+c     number of subcells
+        
+        nsbcll=14
+        
+        ilx=int(celprp(7)*dble(irat)/(rcut+delr))
+        ily=int(celprp(8)*dble(irat)/(rcut+delr))
+        ilz=int(celprp(9)*dble(irat)/(rcut+delr))
+c     
+c     check there are enough link cells
+        
+        linc=.false.
+        if(ilx.lt.2*irat+1) linc=.true.
+        if(ily.lt.2*irat+1) linc=.true.
+        if(ilz.lt.2*irat+1) linc=.true.
+        if(linc) call error(idnode,305)
+        
+        ncells=ilx*ily*ilz
+        if(ncells.gt.mxcell)then
+          
+          if(idnode.eq.0) write(nrite,*) 'mxcell must be >= ',ncells
+          call  error(idnode,392)
+          
+        endif
+        
+c     calculate link cell indices
+        
+        do i=1,ncells
+          
+          lct(i)=0
+          
+        enddo
+        
+c     link-cell cutoff for reduced space
+        
+        xdc=dble(ilx)
+        ydc=dble(ily)
+        zdc=dble(ilz)
+        
+c     reduced space coordinates
+        if(newjob)then
+          
+          newjob=.false.
+          call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+          
+          if(mxnode.gt.1)  call merge
+     x      (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+        endif
+        
+        do i=1,natms
+          
+          tx=xxx(i)
+          ty=yyy(i)
+          tz=zzz(i)
+          
+          uxx(i)=(rcell(1)*tx+rcell(4)*ty+rcell(7)*tz)+0.5d0
+          uyy(i)=(rcell(2)*tx+rcell(5)*ty+rcell(8)*tz)+0.5d0
+          uzz(i)=(rcell(3)*tx+rcell(6)*ty+rcell(9)*tz)+0.5d0
+          
+        enddo
+        
+c     link neighbours 
+        
+        do i=1,natms
+          
+          ix=min(int(xdc*uxx(i)),ilx-1)
+          iy=min(int(ydc*uyy(i)),ily-1)
+          iz=min(int(zdc*uzz(i)),ilz-1)
+          
+          icell=1+ix+ilx*(iy+ily*iz)
+          
+          j=lct(icell)
+          lct(icell)=i
+          link(i)=j
+          
+        enddo
+        
+c     set control variables for loop over subcells
+        
+        ix=1
+        iy=1
+        iz=1
+        
+c     primary loop over subcells
+        
+        do ic=1,ncells
+          
+          ii=lct(ic)
+          if(ii.gt.0)then
+            
+c     secondary loop over subcells
+            
+            do kc=1,nsbcll
+              
+              i=ii
+              
+              cx=0.d0
+              cy=0.d0
+              cz=0.d0
+              jx=ix+nix(kc)
+              jy=iy+niy(kc)
+              jz=iz+niz(kc)
+              
+c     minimum image convention
+              
+              if(jx.gt.ilx)then
+                
+                jx=jx-ilx
+                cx=1.d0
+                
+              elseif(jx.lt.1)then
+                
+                jx=jx+ilx
+                cx=-1.d0
+                
+              endif
+              
+              if(jy.gt.ily)then
+                
+                jy=jy-ily
+                cy=1.d0
+                
+              elseif(jy.lt.1)then
+                
+                jy=jy+ily
+                cy=-1.d0
+                
+              endif
+              
+              if(jz.gt.ilz)then
+                
+                jz=jz-ilz
+                cz=1.d0
+                
+              elseif(jz.lt.1)then
+                
+                jz=jz+ilz
+                cz=-1.d0
+                
+              endif
+              
+c     index of neighbouring cell
+              
+              jc=jx+ilx*((jy-1)+ily*(jz-1))
+              j=lct(jc)
+              
+c     ignore if empty
+              
+              if(j.gt.0)then
+                
+                do while(i.ne.0)
+                  
+c     test if site is of interest to this node
+                  
+                  ineu=lstneu(i)
+                  ik=0
+                  
+c     i's  group index for this processor
+                  
+                  if(mod(ineu-1,mxnode).eq.idnode)
+     x              ik=((ineu-1)/mxnode)+1
+                  
+c     test if i is a frozen atom
+                  
+                  lfrzi=(lstfrz(i).ne.0)
+                  
+                  if(ic.eq.jc) j=link(i)
+                  if(j.gt.0)then
+                    
+                    do while(j.ne.0)
+                      
+                      jneu=lstneu(j)
+                      
+c     swop tests for switching of group indices,
+c     ldo for 'doing' interaction
+                      
+                      swop=.false.
+                      ldo=(ik.gt.0)
+                      jneua=jneu
+                      ineua=ineu
+                      ika=ik
+                      
+c     keep only Brode-Ahlrichs pairs
+                      
+                      if(jneua.ge.ineua)then
+                        
+                        if(jneua-ineua.gt.nneut/2)then 
+                          
+                          swop=(mod(jneu-1,mxnode).eq.idnode)
+                          if(swop)then 
+                            ldo=((nneut+ineua-jneua).le.(nneut-1)/2)
+                          else
+                            ldo=.false.
+                          endif
+                          
+                        endif
+                        
+                      elseif(nneut+jneua-ineua.gt.(nneut-1)/2)then
+                        
+                        swop=(mod(jneu-1,mxnode).eq.idnode)
+                        if(swop)then
+                          ldo=((ineua-jneua).le.nneut/2)
+                        else
+                          ldo=.false.
+                        endif
+                        
+                      endif
+                      
+                      if(swop.and.ldo)then
+                        jneua=ineu
+                        ineua=jneu
+                        ika=((jneu-1)/mxnode)+1
+                      endif
+                      
+c     test of frozen atom pairs
+                      
+                      if(lfrzi.and.ldo)ldo=(lstfrz(j).eq.0)
+                      
+c     check we haven't already included this group in the list ...
+                      
+                      jneua1=0
+                      do while
+     x                  (ldo.and.jneua1.lt.min(lentry(ika),mxlist))
+                        
+                        jneua1=jneua1+1
+                        if(list(ika,jneua1).eq.jneua) ldo=.false.
+                        
+                      enddo
+                      
+                      if(ldo)then
+                        
+c     distance in real space : minimum image applied
+                        
+                        sxd=uxx(j)-uxx(i)+cx
+                        syd=uyy(j)-uyy(i)+cy
+                        szd=uzz(j)-uzz(i)+cz
+                        
+                        xd=cell(1)*sxd+cell(4)*syd+cell(7)*szd
+                        yd=cell(2)*sxd+cell(5)*syd+cell(8)*szd
+                        zd=cell(3)*sxd+cell(6)*syd+cell(9)*szd
+                        
+                        rsq=xd*xd+yd*yd+zd*zd
+                        
+c     test of distance
+                        
+                        if(rsq.lt.rcsq)then
+                          
+                          lentry(ika)=lentry(ika)+1
+                          if(lentry(ika).gt.mxlist)then
+                            
+                            ibig=max(ibig,lentry(ika))
+                            lchk=.false.
+                            
+                          else
+                            
+                            list(ika,lentry(ika))=jneua
+                            
+                          endif
+                          
+                        endif
+                        
+                      endif
+                      
+                      j=link(j)
+                      
+                    enddo
+                    
+                  endif
+                  
+                  j=lct(jc)
+                  i=link(i)
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+          endif
+          
+          ix=ix+1
+          if(ix.gt.ilx)then
+            
+            ix=1
+            iy=iy+1
+            
+            if(iy.gt.ily)then
+              
+              iy=1
+              iz=iz+1
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+c     terminate job if neighbour list array exceeded
+        
+        if(mxnode.gt.1) call gstate(lchk)
+        
+        if(.not.lchk)then
+          
+          call gimax(ibig,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*)'mxlist must be at least ',ibig
+            write(nrite,*)'mxlist is currently ',mxlist
+          endif
+          call error(idnode,107)
+          
+        endif
+        
+c     sort list into order ..
+c     use link as a work array
+        
+        ik=0
+        do i=1+idnode,nneut,mxnode
+          
+          ik=ik+1
+          do j=1,lentry(ik)
+            
+            link(j)=list(ik,j)
+            
+          enddo
+          call shellsort(lentry(ik),link)
+          
+c     ensure Brode-Ahlrichs ordering
+          
+          i1=lentry(ik)+1
+          j1=0
+          do j=1,lentry(ik)
+            
+            if(link(j).ge.i)then
+              
+              j1=j1+1
+              list(ik,j1)=link(j)
+              i1=min(i1,j)
+              
+            endif
+            
+          enddo
+          
+          do j=1,i1-1
+            
+            j1=j1+1
+            list(ik,j1)=link(j)
+            
+          enddo
+          
+        enddo
+        
+      endif
+      
+c     deallocate work arrays 
+      
+      deallocate (uxx,uyy,uzz,stat=fail)
+      
+      return
+      end subroutine parlinkneu
+      
+      subroutine parlst_nsq
+     x  (newlst,natms,idnode,mxnode,imcon,rcut)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing the verlet neighbour
+c     list based on the brode-ahlrichs scheme
+c     frozen atom option included
+c     
+c     to be used with multiple_nsq
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester march 1994     
+c     adapted   - w.smith aug 2008 - solvation, excitation etc
+c     
+c     stress tensor : t.forester may 1994
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lchk,newlst
+      integer natms,idnode,mxnode,imcon,ibig,i,last,mpm2
+      integer npm2,m,ii,j,idum
+      real(8) rcut,rclim,rsq,rrr
+      
+      if(newlst)then
+        
+        ibig=0
+        
+c     check size of work array
+        
+        if(mxxdf.lt.(natms+1)/2)then
+          if(idnode.eq.0) write(nrite,*) 'mxxdf must be greater than ',
+     x      (natms+1)/2
+          call  error(idnode,475)
+        endif
+        
+c     set control variables
+        
+        last=natms
+        lchk=.true.
+        mpm2=natms/2
+        npm2=(natms-1)/2
+        
+c     set cutoff radius - ignore border width
+        
+        rclim=(rcut)**2
+        
+c     construct pair force neighbour list
+        
+        do i=1,msatms
+          
+          lentry(i)=0
+          noxatm(i)=1
+          
+        enddo
+        
+c     outer loop over atoms
+        
+        do m=1,mpm2
+          
+          if(m.gt.npm2)last=mpm2
+          
+c     inner loop over atoms
+          
+          ii=0
+          
+          do i=idnode+1,last,mxnode
+            
+c     calculate atom indices
+            
+            j=i+m
+            if(j.gt.natms)j=j-natms
+            
+c     calculate interatomic displacements
+            
+            ii=ii+1
+            xdf(ii)=xxx(i)-xxx(j)
+            ydf(ii)=yyy(i)-yyy(j)
+            zdf(ii)=zzz(i)-zzz(j)
+            
+          enddo
+          
+c     apply minimum image convention
+          
+          call images(imcon,0,1,ii,cell,xdf,ydf,zdf)
+          
+c     allocate atoms to neighbour list
+          
+          ii=0
+          
+          do i=idnode+1,last,mxnode
+            
+c     calculate atom indices
+            
+            j=i+m
+            if(j.gt.natms)j=j-natms
+            
+            ii=ii+1
+            if((nexatm(ii).gt.0).and.(lexatm(ii,noxatm(ii)).eq.j))
+     x        then
+              
+              noxatm(ii)=min(noxatm(ii)+1,nexatm(ii))
+              
+            elseif(lstfrz(i).eq.0.or.lstfrz(j).eq.0)then
+              
+c     reject frozen atoms and calculate interatomic distance
+              
+              rsq=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+              
+c     running check of neighbour list array capacity
+              
+              if(rsq.lt.rclim)then
+                
+                lentry(ii)=lentry(ii)+1
+                
+                if(lentry(ii).gt.mxlist)then
+                  
+                  ibig=max(ibig,lentry(ii))
+                  lchk=.false.
+                  
+                endif
+                
+c     compile neighbour list array
+                
+                if(lchk)then
+                  
+                  list(ii,lentry(ii))=j
+                  
+                endif
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+        enddo
+        
+c     terminate job if neighbour list array exceeded
+        
+        if(mxnode.gt.1)call gstate(lchk)
+        
+        if(.not.lchk)then
+          
+          call gisum(ibig,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*) ' mxlist must be >=  ',ibig
+            write(nrite,*) ' mxlist is currenty ',mxlist
+          endif
+          call error(idnode,109)
+          
+        endif
+        
+c     check all excluded atoms are accounted for
+        
+        do i=1,ii
+          
+          if(nexatm(i).gt.0.and.noxatm(i).ne.nexatm(i))lchk=.false.
+          
+        enddo
+        
+        if(mxnode.gt.1)call gstate(lchk)
+        
+        if(.not.lchk) call error(idnode,160)
+        
+      endif  
+      
+      return
+      end subroutine parlst_nsq
+      
+      subroutine primlst(idnode,mxnode,natms,imcon,rprim)
+      
+c*********************************************************************
+c     
+c     dlpoly routine to split interaction list into primary and 
+c     secondary neighbours for use with multiple timestep method
+c     
+c     copyright daresbury laboratory
+c     author - t. forester february 1993
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      integer idnode,mxnode,natms,imcon,ii,k,j,i
+      real(8) rprim,rprim2,rsq
+      
+      rprim2=rprim*rprim
+      ii=0
+      
+      do i=1+idnode,natms,mxnode
+        
+        ii=ii+1
+        
+        do j=1,lentry(ii)
+          
+          k=iabs(list(ii,j))
+          xdf(j)=xxx(i)-xxx(k)
+          ydf(j)=yyy(i)-yyy(k)
+          zdf(j)=zzz(i)-zzz(k)
+          
+        enddo           
+        
+c     apply minimum image convention
+        
+        call images(imcon,0,1,lentry(ii),cell,xdf,ydf,zdf)
+        
+c     assign atoms as primary or secondary
+        
+        
+        do j=1,lentry(ii)
+          
+c     calculate interatomic distance
+          
+          rsq=xdf(j)**2+ydf(j)**2+zdf(j)**2
+          
+          if(rsq.lt.rprim2)then
+            
+c     compile primary neighbour list array  : -ve indices
+            
+            list(ii,j)=-iabs(list(ii,j))
+            
+          else
+            
+c     compile secondary neighbour list array : +ve indices
+            
+            list(ii,j)=iabs(list(ii,j))
+            
+          endif
+          
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine primlst
+      
+      subroutine prneulst(newlst,imcon,idnode,mxnode,nneut,rprim)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to partition neutral group list into 
+c     primary and secondary groups
+c     loops over group ineu
+c     
+c     replicated data version
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester april 1994
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newlst,lchk,ldo
+      integer imcon,idnode,mxnode,nneut,ineu,ia,jj,ibig,ii
+      integer jj0,jneu,j,i,idum
+      real(8) rprim,rclim,xi,yi,zi,rrr
+      
+      lchk=.true.
+      
+      if(newlst)then
+        
+c     set primary cutoff limit
+        
+        rclim=rprim*rprim
+        
+c     set list to negative - signal for seconary shell
+        
+        ia=0
+        do ineu=idnode+1,nneut,mxnode
+          
+          ia=ia+1
+          
+          do jj=1,lentry(ia)
+            
+            list(ia,jj)=-abs(list(ia,jj))
+            
+          enddo
+          
+        enddo
+        
+c     loop over neutral group ineu sites
+        
+        lchk=.true.
+        ibig=0
+        
+        ia=0
+        do ineu=idnode+1,nneut,mxnode
+          
+          ia=ia+1
+          
+          ii=0
+          do i=neulst(ineu),neulst(ineu+1)-1
+            
+            xi=xxx(i)
+            yi=yyy(i)
+            zi=zzz(i)
+            
+            do jj=1,lentry(ia)
+              
+              jneu=-list(ia,jj)
+              jj0=neulst(jneu)
+              
+              if(ineu.eq.jneu) jj0=i+1
+              
+c     loop over jneu sites
+              
+              do j=jj0,neulst(jneu+1)-1
+                
+                ii=ii+1
+                if(ii.le.mxxdf)then
+                  xdf(ii)=xi-xxx(j)
+                  ydf(ii)=yi-yyy(j)
+                  zdf(ii)=zi-zzz(j)
+                else
+                  lchk=.false.
+                  ibig=ii
+                endif
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+c     apply minimum image convention
+          
+          ii=min(ii,mxxdf)
+          call images(imcon,0,1,ii,cell,xdf,ydf,zdf)
+          
+c     allocate groups to primary or secondary shell
+c     on basis of closest atom-atom interactions
+          
+          ii=0
+          do i=neulst(ineu),neulst(ineu+1)-1
+            
+            do jj=1,lentry(ia)
+              
+              jneu=list(ia,jj)
+              ldo=(jneu.lt.0)
+              if(ldo)then
+                jneu=-jneu
+                jj0=neulst(jneu)
+                if(ineu.eq.jneu) jj0=i+1
+                
+c     loop over jneu sites
+                
+                do j=jj0,neulst(jneu+1)-1
+                  
+                  if(ldo)then 
+                    
+                    ii=min(ii+1,mxxdf)
+                    
+                    if(abs(xdf(ii)).lt.rprim)then
+                      if(abs(ydf(ii)).lt.rprim)then
+                        if(abs(zdf(ii)).lt.rprim)then
+                          
+c     calculate interatomic distance
+                          
+                          rrr=xdf(ii)**2+ydf(ii)**2+zdf(ii)**2
+                          
+c     put in primary list if found any interaction close enough
+                          
+                          if(rrr.le.rclim)then
+                            ldo=.false.
+                            list(ia,jj)=jneu
+                          endif
+                          
+                        endif
+                      endif
+                    endif
+                    
+                  endif
+                  
+                enddo
+                
+              endif
+              
+            enddo
+            
+          enddo
+          
+        enddo
+        
+        if(mxnode.gt.1) call gstate(lchk)
+        if(.not.lchk)then
+          
+          call gimax(ibig,1,idum)
+          if(idnode.eq.0)then
+            write(nrite,*) 'mxxdf must be at least ',ibig
+            write(nrite,*) 'mxxdf is currently     ',mxxdf
+          endif
+          call  error(idnode,477)
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine prneulst
+      
+      subroutine vertest(newlst,idnode,mxnode,natms,delr,tstep)
+      
+c*********************************************************************
+c     
+c     DL_POLY subroutime to test for updating of Verlet list
+c     replicated data version
+c     
+c     copyright daresbury laboratory 1993
+c     author -       t. forester may 1993
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      logical newlst,newjob
+      integer idnode,mxnode,natms,i,j,k,moved,ibuff,fail
+      real(8) rmax,dr,delr,tstep
+      
+      real(8), allocatable :: xold(:),yold(:),zold(:)
+      
+      save newjob,xold,yold,zold
+      
+      data newjob/.true./,fail/0/
+      
+      if((natms+mxnode-1)/mxnode.gt.msatms) call error(idnode,112)
+      
+      if(newjob)then
+        
+c     set up initial arrays 
+        
+        allocate (xold(msatms),yold(msatms),zold(msatms),stat=fail)
+        if(fail.ne.0)call error(idnode,1930)
+        
+        j=0
+        do i=idnode+1,natms,mxnode
+          
+          j=j+1
+          xold(j)=0.d0
+          yold(j)=0.d0
+          zold(j)=0.d0
+          
+        enddo
+        
+        newjob=.false.
+        newlst=.true.
+        
+      else
+        
+c     integrate velocities 
+        
+        j=0
+        do i=idnode+1,natms,mxnode
+          
+          j=j+1
+          xold(j)=xold(j)+vxx(i)
+          yold(j)=yold(j)+vyy(i)
+          zold(j)=zold(j)+vzz(i)
+          
+        enddo
+        
+c     maximum displacement 
+        
+        rmax=(delr/2.d0)**2
+        
+c     test atomic displacements
+        
+        moved=0
+        
+        do k=1,j
+          
+          dr=tstep**2*(xold(k)**2+yold(k)**2+zold(k)**2)
+          if(dr.gt.rmax) moved=moved+1
+          
+        enddo
+        
+c     global sum of moved atoms
+        
+        if(mxnode.gt.1) call gisum(moved,1,ibuff)
+        
+c     test for new verlet list
+        
+        newlst=(moved.ge.2)
+        
+c     update stored positions
+        
+        if(newlst)then
+          
+          do k=1,j
+            
+            xold(k)=0.d0
+            yold(k)=0.d0
+            zold(k)=0.d0
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine vertest
+      
+      subroutine vertest2(newlst,idnode,mxnode,natms,imcon,delr,tstep)
+      
+c*********************************************************************
+c     
+c     DL_POLY subroutime to test for updating of Verlet list
+c     replicated data version (version 2)
+c     
+c     copyright daresbury laboratory
+c     author -       w.smith    2007
+c     
+c*********************************************************************
+      
+      implicit none
+      
+      logical newlst,newjob
+      integer idnode,mxnode,natms,imcon,i,j,k,moved,ibuff,fail
+      real(8) rmax,dr,delr,tstep
+      
+      real(8), allocatable :: xold(:),yold(:),zold(:)
+      real(8), allocatable :: xdif(:),ydif(:),zdif(:)
+      
+      save newjob,xold,yold,zold
+      
+      data newjob/.true./,fail/0/
+      
+      if((natms+mxnode-1)/mxnode.gt.msatms) call error(idnode,112)
+      
+c     set up initial arrays 
+      
+      allocate (xdif(msatms),ydif(msatms),zdif(msatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1930)
+      
+      if(newjob)then
+        
+        allocate (xold(msatms),yold(msatms),zold(msatms),stat=fail)
+        if(fail.ne.0)call error(idnode,1930)
+        
+        j=0
+        do i=idnode+1,natms,mxnode
+          
+          j=j+1
+          xold(j)=xxx(i)
+          yold(j)=yyy(i)
+          zold(j)=zzz(i)
+          
+        enddo
+        
+        newjob=.false.
+        newlst=.true.
+        
+      else
+        
+c     calculate atomic shifts
+        
+        j=0
+        do i=idnode+1,natms,mxnode
+          
+          j=j+1
+          xdif(j)=xxx(i)-xold(j)
+          ydif(j)=yyy(i)-yold(j)
+          zdif(j)=zzz(i)-zold(j)
+          
+        enddo
+        
+c     minimum image calculation
+        
+        call images(imcon,0,1,j,cell,xdif,ydif,zdif)
+        
+c     maximum displacement 
+        
+        rmax=(delr/2.d0)**2
+        
+c     test atomic displacements
+        
+        moved=0
+        
+        do k=1,j
+          
+          dr=(xdif(k)**2+ydif(k)**2+zdif(k)**2)
+          if(dr.gt.rmax)moved=moved+1
+          
+        enddo
+        
+c     global sum of moved atoms
+        
+        if(mxnode.gt.1) call gisum(moved,1,ibuff)
+        
+c     test for new verlet list
+        
+        newlst=(moved.ge.2)
+        
+c     update stored positions
+        
+        if(newlst)then
+          
+          j=0
+          do i=idnode+1,natms,mxnode
+            
+            j=j+1
+            xold(j)=xxx(i)
+            yold(j)=yyy(i)
+            zold(j)=zzz(i)
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     deallocate arrays
+      
+      deallocate(xdif,ydif,zdif,stat=fail)
+      
+      return
+      end subroutine vertest2
+      
+      end module nlist_builders_module
diff -urN dl_class_1.9.orig/srcmod/optimiser_module.f dl_class_1.9/srcmod/optimiser_module.f
--- dl_class_1.9.orig/srcmod/optimiser_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/optimiser_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,1144 @@
+      module optimiser_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining structural optimiser routines
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use utility_module
+      
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: ggx(:),ggy(:),ggz(:)
+      real(8), allocatable :: hhx(:),hhy(:),hhz(:)
+      real(8), allocatable :: oxx(:),oyy(:),ozz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      
+      save hhx,hhy,hhz
+      
+      contains
+      
+      subroutine optimisation_selector
+     x  (loptim,stropt,lzero,idnode,mxnode,natms,imcon,ntcons,
+     x  nscons,ngrp,ntfree,keystr,keytol,engcfg,tstep,opttol)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for selecting and running a nominated 
+c     structure optimisation algorithm using energy minimisation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith june 2006
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical loptim,stropt,lzero
+      integer idnode,mxnode,natms,imcon,nscons,ngrp,ntfree,keystr
+      integer keytol,ntcons
+      real(8) engcfg,tstep,opttol,hnorm,grad0,grad1,ff1,sgn
+      
+      save grad0,grad1,ff1,sgn,hnorm
+
+      stropt=.false.
+      
+      if(loptim)then
+        
+c     conjugate gradient structure optimisation
+        
+        call strucopt
+     x    (stropt,keystr,keytol,idnode,mxnode,natms,ntcons,nscons,
+     x    imcon,ngrp,ntfree,tstep,opttol,engcfg,hnorm,grad0,grad1,
+     x    ff1,sgn)
+        
+      else if(lzero)then
+        
+c     zero kelvin structure optimisation 
+        
+        call zero_kelvin
+     x    (stropt,idnode,mxnode,imcon,natms,ngrp,ntfree,opttol)
+        
+      endif
+      
+      return
+      end subroutine optimisation_selector
+
+      subroutine zero_kelvin
+     x  (stropt,idnode,mxnode,imcon,natms,ngrp,ntfree,opttol)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for zero Kelvin temperature optimization
+c     if velocity.Force < 0 then velocity is set to zero in 
+c     preparation for integration of equations of motion
+c     
+c     parallel replicated data version : block data
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester     march 1994
+c     amended t.forester    dec 1994 : block data
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical stropt
+      integer idnode,mxnode,imcon,natms,ngrp,ntfree,fail,i
+      integer iatm0,iatm1,igrp1,igrp2,ifre1,ifre2,jr,ig,j,id
+      real(8) dot,fsq,fcomx,fcomy,fcomz,trx,try,trz,tax,tay,taz
+      real(8) rot,ggg,opttol
+      
+      dimension rot(9)
+
+      data fail/0/
+
+c     allocate work arrays
+
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1920)
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     check for convergence of forces 
+      
+      ggg=0.d0
+      do i=iatm0,iatm1
+        ggg=ggg+fxx(i)**2+fyy(i)**2+fzz(i)**2
+      enddo
+      
+      if(mxnode.gt.1)then
+        buffer(1)=ggg
+        call gdsum(buffer(1),1,buffer(2))
+        ggg=buffer(1)
+      endif
+      
+c     check convergence condition for forces
+      
+      if(opttol.ge.abs(ggg)/dble(natms))then
+        
+        stropt=.true.
+        return
+        
+      endif
+
+      if(ngrp.eq.0) then
+
+c     take component of velocity in direction of force
+        
+        do i=iatm0,iatm1
+
+          dot=vxx(i)*fxx(i)+vyy(i)*fyy(i)+vzz(i)*fzz(i)
+          if(dot.lt.0.d0) then
+
+            vxx(i)=0.d0
+            vyy(i)=0.d0
+            vzz(i)=0.d0
+
+          else
+
+c     take component of velocity in direction of force
+
+            fsq=(fxx(i)**2+fyy(i)**2+fzz(i)**2)
+            fsq=dot/max(1.d-10,fsq)
+            vxx(i)=fxx(i)*fsq
+            vyy(i)=fyy(i)*fsq
+            vzz(i)=fzz(i)*fsq
+
+          endif
+          
+        enddo
+        
+      else
+
+c     block indices for groups and free atoms
+
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+
+        do j=ifre1,ifre2
+
+c     reset atomic velocities 
+          
+          i=lstfre(j)
+          
+          dot=vxx(i)*fxx(i)+vyy(i)*fyy(i)+vzz(i)*fzz(i)
+          if(dot.lt.0.d0) then
+
+            vxx(i)=0.d0
+            vyy(i)=0.d0
+            vzz(i)=0.d0
+
+          else
+
+c     take component of velocity in direction of force
+
+            fsq=(fxx(i)**2+fyy(i)**2+fzz(i)**2)
+            fsq=dot/max(1.d-10,fsq)
+            vxx(i)=fxx(i)*fsq
+            vyy(i)=fyy(i)*fsq
+            vzz(i)=fzz(i)*fsq
+            
+          endif
+          
+        enddo
+
+        jr=0
+        do ig=igrp1,igrp2
+
+c     reset rigid body velocites (linear and angular)
+          
+          fcomx=0.d0
+          fcomy=0.d0
+          fcomz=0.d0
+
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+
+c     forces on com
+            
+            fcomx=fcomx+fxx(i)
+            fcomy=fcomy+fyy(i)
+            fcomz=fcomz+fzz(i)
+            
+          enddo
+          
+          dot=gvxx(ig)*fcomx+gvyy(ig)*fcomy+gvzz(ig)*fcomz
+          if(dot.lt.0.d0) then
+
+            gvxx(ig)=0.d0
+            gvyy(ig)=0.d0
+            gvzz(ig)=0.d0
+
+          else
+
+c     take component of velocity in direction of force
+
+            fsq=(fcomx**2+fcomy**2+fcomz**2)
+            fsq=dot/max(1.d-10,fsq)
+            gvxx(ig)=fcomx*fsq
+            gvyy(ig)=fcomy*fsq
+            gvzz(ig)=fcomz*fsq
+
+          endif
+
+        enddo
+
+c     site to com distances
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          do j=1,numgsit(lstgtp(ig))
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            xxt(jr)=xxx(i)-gcmx(ig)
+            yyt(jr)=yyy(i)-gcmy(ig)
+            zzt(jr)=zzz(i)-gcmz(ig)
+            
+          enddo
+          
+        enddo
+
+c     minimum images
+        
+        call images(imcon,0,1,jr,cell,xxt,yyt,zzt)
+
+c     calculate torques in lab frame
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          trx=0.d0
+          try=0.d0
+          trz=0.d0
+          
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+            trx=trx+yyt(jr)*fzz(i)-zzt(jr)*fyy(i)
+            try=try+zzt(jr)*fxx(i)-xxt(jr)*fzz(i)
+            trz=trz+xxt(jr)*fyy(i)-yyt(jr)*fxx(i)
+            
+          enddo
+          
+          rot(1)=q0(ig)**2+q1(ig)**2-q2(ig)**2-q3(ig)**2
+          rot(2)=2.d0*(q1(ig)*q2(ig)-q0(ig)*q3(ig))
+          rot(3)=2.d0*(q1(ig)*q3(ig)+q0(ig)*q2(ig))
+          rot(4)=2.d0*(q1(ig)*q2(ig)+q0(ig)*q3(ig))
+          rot(5)=q0(ig)**2-q1(ig)**2+q2(ig)**2-q3(ig)**2
+          rot(6)=2.d0*(q2(ig)*q3(ig)-q0(ig)*q1(ig))
+          rot(7)=2.d0*(q1(ig)*q3(ig)-q0(ig)*q2(ig))
+          rot(8)=2.d0*(q2(ig)*q3(ig)+q0(ig)*q1(ig))
+          rot(9)=q0(ig)**2-q1(ig)**2-q2(ig)**2+q3(ig)**2
+
+c     transform to body fixed frame
+          
+          tax=(trx*rot(1)+try*rot(4)+trz*rot(7))*rotinx(id,2)
+          tay=(trx*rot(2)+try*rot(5)+trz*rot(8))*rotiny(id,2)
+          taz=(trx*rot(3)+try*rot(6)+trz*rot(9))*rotinz(id,2)
+          
+          dot=omx(ig)*tax+omy(ig)*tay+omz(ig)*taz
+          if(dot.le.0.d0) then
+
+            omx(ig)=0.d0
+            omy(ig)=0.d0
+            omz(ig)=0.d0
+
+          else
+
+c     take component of velocity in direction of torque
+            
+            fsq=(tax**2+tay**2+taz**2)
+            fsq=dot/max(1.d-10,fsq)
+            omx(ig)=tax*fsq
+            omy(ig)=tay*fsq
+            omz(ig)=taz*fsq
+            
+          endif
+          
+        enddo
+        
+      endif
+      
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,stat=fail)
+      
+      return
+      end subroutine zero_kelvin
+
+      subroutine strucopt
+     x  (stropt,keystr,keytol,idnode,mxnode,natms,ntcons,nscons,
+     x  imcon,ngrp,ntfree,tstep,opttol,fnew,hnorm,grad0,grad1,
+     x  ff1,sgn)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for optimising molecular structures
+c     based on conjugate gradient method
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    dec 2005
+c     
+c     note. basis of minimisation criterion :
+c           keytol=0 : absolute force
+c           keytol=1 : absolute energy
+c           keytol=2 : absolute displacement
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=8
+      
+      logical stropt,newjob,engchk
+      integer keystr,keytol,idnode,mxnode,natms,i,j,k
+      integer iatm0,iatm1,fail,ngrp,ntcons,nscons,jr
+      integer imcon,ig,jf,id,ntfree,igrp1,igrp2,ifre1,ifre2
+      real(8) hnorm,grad0,grad1,grad2,ff1,stride,tstep,step
+      real(8) ggg,fnew,fff,gam2,sgn,opttol,dischk
+            
+      dimension fail(nnn)
+            
+      save iatm0,iatm1,igrp1,igrp2,engchk,ifre1,ifre2,newjob
+      
+      data newjob/.true./,engchk/.false./
+      
+c     define initial data
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      if(newjob)then
+        allocate(hhx(mxatms),hhy(mxatms),hhz(mxatms),stat=fail(1))
+      endif        
+      allocate(ggx(mxatms),ggy(mxatms),ggz(mxatms),stat=fail(2))
+      allocate(oxx(mxatms),oyy(mxatms),ozz(mxatms),stat=fail(3))
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(4))
+      if(ngrp.gt.0)then
+        
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(6))
+        
+      endif
+      if(ntcons.gt.0)then
+        
+        if(ngrp.eq.0)
+     x    allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(dxx(mxatms),dyy(mxatms),dzz(mxatms),stat=fail(7))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(8))
+        
+      endif
+      
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1925)
+      enddo
+        
+      if(newjob)then
+        
+c     define atoms for this node
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+        newjob=.false.
+        
+      endif
+      
+c     step length for relaxation
+      
+      if(ntcons.gt.0)then
+        step=tstep**2
+      else
+        step=10.d0*tstep**2
+      endif
+      
+c     current system configuration energy
+      
+      fff=fnew
+      
+c     initialise conjugate gradient position arrays
+      
+      do i=1,natms
+        
+        oxx(i)=xxx(i)
+        oyy(i)=yyy(i)
+        ozz(i)=zzz(i)
+        ggx(i)=0.d0
+        ggy(i)=0.d0
+        ggz(i)=0.d0
+        
+      enddo
+      
+c     define constraint bonds
+      
+      if(ntcons.gt.0)then
+        
+c     calculate constraint bond vector
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+c     calculate pseudo forces for constraint bonds
+        
+        call pseudo_shake(nscons,natms,mxnode,fff)
+        
+        do i=1,natms
+          
+          ggx(i)=fxx(i)+ggx(i)
+          ggy(i)=fyy(i)+ggy(i)
+          ggz(i)=fzz(i)+ggz(i)
+          
+        enddo
+      
+      else
+        
+        do i=1,natms
+          
+          ggx(i)=fxx(i)
+          ggy(i)=fyy(i)
+          ggz(i)=fzz(i)
+          
+        enddo
+        
+      endif
+      
+c     calculate pseudo forces for rigid bodies
+      
+      if(ngrp.gt.0)call torque_split
+     x  (ngrp,idnode,mxnode,imcon,ggx,ggy,ggz,txx,tyy,tzz,
+     x  uxx,uyy,uzz,dtx,dty,dtz) 
+
+c     determine magnitude of 3N force vector
+      
+      ggg=0.d0
+      
+      if(ngrp.eq.0)then
+        
+        do i=iatm0,iatm1
+          ggg=ggg+ggx(i)**2+ggy(i)**2+ggz(i)**2
+        enddo
+        
+      else
+        
+        do jf=ifre1,ifre2
+          
+          i=lstfre(jf)
+          ggg=ggg+ggx(i)**2+ggy(i)**2+ggz(i)**2
+          
+        enddo
+        
+        jr=0
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            ggg=ggg+ggx(i)**2+ggy(i)**2+ggz(i)**2
+            
+          enddo
+        
+        enddo
+        
+      endif
+      
+      if(mxnode.gt.1)then
+        buffer(1)=ggg
+        call gdsum(buffer(1),1,buffer(2))
+        ggg=buffer(1)
+      endif
+      ggg=sqrt(ggg)
+      
+c     check convergence condition for forces
+      
+      if(keytol.eq.0.and.opttol.ge.abs(ggg)/dble(natms))stropt=.true.
+      
+      if(keystr.eq.0) then
+        
+c     set original search direction
+        
+        ff1=fff
+        hnorm=ggg
+        grad0=ggg
+        grad1=ggg
+        
+        if(ngrp.eq.0)then
+          
+          do i=iatm0,iatm1
+            
+            hhx(i)=ggx(i)
+            hhy(i)=ggy(i)
+            hhz(i)=ggz(i)
+            oxx(i)=oxx(i)+step*hhx(i)
+            oyy(i)=oyy(i)+step*hhy(i)
+            ozz(i)=ozz(i)+step*hhz(i)
+            
+          enddo
+          
+        else
+          
+          do jf=ifre1,ifre2
+            
+            i=lstfre(jf)
+            hhx(i)=ggx(i)
+            hhy(i)=ggy(i)
+            hhz(i)=ggz(i)
+            
+          enddo
+          
+          jr=0
+          do ig=igrp1,igrp2
+            
+            id=lstgtp(ig)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              hhx(i)=ggx(i)
+              hhy(i)=ggy(i)
+              hhz(i)=ggz(i)
+              
+            enddo
+            
+          enddo
+          
+          call turn_rigid_body
+     x      (igrp1,igrp2,ifre1,ifre2,step,hhx,hhy,hhz,
+     x      uxx,uyy,uzz,txx,tyy,tzz,oxx,oyy,ozz)
+          
+        endif
+        
+        keystr=1
+        sgn=1.d0
+        
+      elseif(keystr.eq.1)then
+        
+c     check convergence condition for energy
+
+        if(engchk.and.keytol.eq.1.and.
+     x    opttol.ge.abs(fff-ff1))stropt=.true.
+        engchk=.false.
+        
+c     line search along chosen direction
+        
+        ff1=fff
+        grad2=grad1
+        grad1=0.d0
+        do i=iatm0,iatm1
+          grad1=grad1+hhx(i)*ggx(i)+hhy(i)*ggy(i)+hhz(i)*ggz(i)
+        enddo
+        if(mxnode.gt.1)then
+          buffer(1)=grad1
+          call gdsum(buffer(1),1,buffer(2))
+          grad1=buffer(1)
+        endif
+        grad1=sgn*grad1/hnorm
+        
+c     linear extrapolation to minimum
+        
+        stride=sgn*step
+        if(grad1.lt.0.d0)then
+          
+          keystr=2
+          stride=sgn*step*grad1/(grad2-grad1)
+          
+        endif
+        
+        if(ngrp.eq.0)then
+          
+          do i=iatm0,iatm1
+            
+            oxx(i)=oxx(i)+stride*hhx(i)
+            oyy(i)=oyy(i)+stride*hhy(i)
+            ozz(i)=ozz(i)+stride*hhz(i)
+            
+          enddo
+          
+        else
+
+          call turn_rigid_body
+     x      (igrp1,igrp2,ifre1,ifre2,stride,hhx,hhy,hhz,
+     x      uxx,uyy,uzz,txx,tyy,tzz,oxx,oyy,ozz)
+          
+        endif
+        
+      elseif(keystr.eq.2)then
+        
+c     construct conjugate search vector
+        
+        ff1=fff
+        gam2=(ggg/grad0)**2
+        hnorm=0.d0
+        grad0=ggg
+        grad1=0.d0
+        do i=iatm0,iatm1
+          
+          hhx(i)=ggx(i)+gam2*hhx(i)
+          hhy(i)=ggy(i)+gam2*hhy(i)
+          hhz(i)=ggz(i)+gam2*hhz(i)
+          hnorm=hnorm+hhx(i)**2+hhy(i)**2+hhz(i)**2
+          grad1=grad1+hhx(i)*ggx(i)+hhy(i)*ggy(i)+hhz(i)*ggz(i)
+          
+        enddo
+        if(mxnode.gt.1)then
+          
+          buffer(1)=hnorm
+          buffer(2)=grad1
+          call gdsum(buffer(1),2,buffer(3))
+          hnorm=buffer(1)
+          grad1=buffer(2)
+          
+        endif
+        hnorm=sqrt(hnorm)
+        grad1=grad1/hnorm
+        sgn=sign(1.d0,grad1)
+        grad1=sgn*grad1
+        stride=sgn*step
+
+        if(ngrp.eq.0)then
+          
+          do i=iatm0,iatm1
+            
+            oxx(i)=oxx(i)+stride*hhx(i)
+            oyy(i)=oyy(i)+stride*hhy(i)
+            ozz(i)=ozz(i)+stride*hhz(i)
+            
+          enddo
+        
+        else
+
+          call turn_rigid_body
+     x      (igrp1,igrp2,ifre1,ifre2,stride,hhx,hhy,hhz,
+     x      uxx,uyy,uzz,txx,tyy,tzz,oxx,oyy,ozz)
+          
+        endif
+
+        engchk=.true.
+        keystr=1
+        
+      endif 
+      
+c     merge coordinate arrays
+      
+      if(mxnode.gt.1)then
+        
+        if(ngrp.eq.0)then
+          
+          call merge
+     x      (idnode,mxnode,natms,mxbuff,oxx,oyy,ozz,buffer)
+          
+        else
+          
+          call merge1
+     x      (idnode,mxnode,natms,lstme,oxx,oyy,ozz,buffer)
+          
+        endif
+        
+      endif
+      
+c     reassign atomic positions and calculate max displacement
+      
+      dischk=0.d0
+      do i=1,natms
+        
+        dischk=max(dischk,(xxx(i)-oxx(i))**2+
+     x    (yyy(i)-oyy(i))**2+(zzz(i)-ozz(i))**2)
+
+        xxx(i)=oxx(i)
+        yyy(i)=oyy(i)
+        zzz(i)=ozz(i)
+        
+      enddo
+      
+c     check convergence condition for position
+
+      if(keytol.eq.2.and.keystr.gt.0.and.
+     x  opttol.ge.sqrt(dischk))stropt=.true.
+      
+c     deallocate working arrays
+      
+      deallocate(ggx,ggy,ggz,dtx,dty,dtz,oxx,oyy,ozz,stat=fail(1))
+      if(ngrp.gt.0)then
+        deallocate(txx,tyy,tzz,uxx,uyy,uzz,stat=fail(2))
+      endif
+      if(ntcons.gt.0)then
+        
+        deallocate(dxx,dyy,dzz,xxt,yyt,zzt,stat=fail(3))
+        if(ngrp.eq.0)deallocate(txx,tyy,tzz,stat=fail(4))
+        
+      endif
+      
+      return
+      end subroutine strucopt
+      
+      subroutine pseudo_shake(nscons,natms,mxnode,fff)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine treating rigid bonds as stiff harmonic bonds
+c     suitable for conjugate gradient minimisation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    may 2006
+c     
+c***********************************************************************
+      
+      implicit none
+
+      real(8), parameter :: harm=1.d6
+
+      integer i,j,k,natms,nscons,mxnode
+      real(8) fff,engbnd,dis,rrr,gamma
+      
+c     calculate energy and force
+      
+      engbnd=0.d0
+      
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+        
+        dis=prmcon(listcon(k,1))
+        rrr=sqrt(dxx(k)**2+dyy(k)**2+dzz(k)**2)
+        engbnd=engbnd+0.5d0*harm*(rrr-dis)**2
+        gamma=harm*(rrr-dis)/rrr
+        ggx(i)=ggx(i)-dxx(k)*gamma
+        ggy(i)=ggy(i)-dyy(k)*gamma
+        ggz(i)=ggz(i)-dzz(k)*gamma
+        
+        ggx(j)=ggx(j)+dxx(k)*gamma
+        ggy(j)=ggy(j)+dyy(k)*gamma
+        ggz(j)=ggz(j)+dzz(k)*gamma
+        
+      enddo
+      
+c     global sum of pseudo forces
+
+      call global_sum_forces(natms,mxnode,ggx,ggy,ggz)
+      if(mxnode.gt.1)then
+        buffer(1)=engbnd
+        call gdsum(buffer(1),1,buffer(2))
+        engbnd=buffer(1)
+      endif
+      fff=fff+engbnd
+      
+      return
+      end subroutine pseudo_shake
+
+      subroutine torque_split
+     x  (ngrp,idnode,mxnode,imcon,ggx,ggy,ggz,txx,tyy,tzz,
+     x  uxx,uyy,uzz,dtx,dty,dtz) 
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for resolving torques into equivalent atomic
+c     forces suitable for conjugate gradient minimisation
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    may 2006
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,j,ig,id,jr,jrs,ngrp,igrp1,igrp2,idnode,imcon,mxnode
+
+      real(8) fmx,fmy,fmz,tqx,tqy,tqz,trq,txx,tyy,tzz
+      real(8) ggx,ggy,ggz,tmp,taq,scale
+      real(8) uxx,uyy,uzz,dtx,dty,dtz
+
+      dimension ggx(mxatms),ggy(mxatms),ggz(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension uxx(mxatms),uyy(mxatms),uzz(mxatms)
+      dimension dtx(mxatms),dty(mxatms),dtz(mxatms)
+      
+c     group block indices
+        
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+      
+c     calculate centres of mass of rigid bodies
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     working com is first site in group
+        
+        i=lstrgd(jr+1)
+        txx(ig)=xxx(i)
+        tyy(ig)=yyy(i)
+        tzz(ig)=zzz(i)
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          uxx(jr)=xxx(i)-txx(ig)
+          uyy(jr)=yyy(i)-tyy(ig)
+          uzz(jr)=zzz(i)-tzz(ig)
+          
+        enddo
+        
+      enddo
+      
+c     minimum image from working com
+      
+      call images(imcon,0,1,jr,cell,uxx,uyy,uzz)
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+        gcmx(ig)=0.d0
+        gcmy(ig)=0.d0
+        gcmz(ig)=0.d0
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          gcmx(ig)=gcmx(ig)+weight(i)*uxx(jr)
+          gcmy(ig)=gcmy(ig)+weight(i)*uyy(jr)
+          gcmz(ig)=gcmz(ig)+weight(i)*uzz(jr)
+          
+        enddo
+        
+c     final centre of mass
+        
+        gcmx(ig)=gcmx(ig)/gmass(id)+txx(ig)
+        gcmy(ig)=gcmy(ig)/gmass(id)+tyy(ig)
+        gcmz(ig)=gcmz(ig)/gmass(id)+tzz(ig)
+        
+      enddo
+      
+c     calculate atom displacements from rigid body com
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+        
+c     resolve rigid body forces and torques to orthogonal atomic basis 
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+c     calculate net force on rigid body          
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+ggx(i)
+          fmy=fmy+ggy(i)
+          fmz=fmz+ggz(i)
+          
+        enddo
+        fmx=fmx/dble(numgsit(id))
+        fmy=fmy/dble(numgsit(id))
+        fmz=fmz/dble(numgsit(id))
+
+c     calculate torque on rigid body
+        
+        jr=jrs
+        tqx=0.d0
+        tqy=0.d0
+        tqz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx=tqx+dty(jr)*ggz(i)-dtz(jr)*ggy(i)
+          tqy=tqy+dtz(jr)*ggx(i)-dtx(jr)*ggz(i)
+          tqz=tqz+dtx(jr)*ggy(i)-dty(jr)*ggx(i)
+          
+        enddo
+        
+c     magnitude of torque
+        
+        trq=sqrt(tqx**2+tqy**2+tqz**2)
+        
+c     construct unit vectors for new site forces
+        
+        jr=jrs
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          txx(i)=dty(jr)*tqz-tqy*dtz(jr)
+          tyy(i)=dtz(jr)*tqx-tqz*dtx(jr)
+          tzz(i)=dtx(jr)*tqy-tqx*dty(jr)
+          tmp=sqrt(txx(i)**2+tyy(i)**2+tzz(i)**2)
+          if(tmp.gt.1.d-10)then
+            
+            txx(i)=txx(i)/tmp
+            tyy(i)=tyy(i)/tmp
+            tzz(i)=tzz(i)/tmp
+          
+          else
+            
+            txx(i)=0.d0
+            tyy(i)=0.d0
+            tzz(i)=0.d0
+            
+          endif
+          
+        enddo
+        
+c     construct unit vectors for site location
+        
+        jr=jrs
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          uxx(i)=(tyy(i)*tqz-tqy*tzz(i))/trq
+          uyy(i)=(tzz(i)*tqx-tqz*txx(i))/trq
+          uzz(i)=(txx(i)*tqy-tqx*tyy(i))/trq
+          
+        enddo
+        
+c     scale unit vectors to working lengths
+        
+        jr=jrs
+        taq=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          tmp=dtx(jr)*uxx(i)+dty(jr)*uyy(i)+dtz(jr)*uzz(i)
+          taq=taq+tmp**2
+          txx(i)=tmp*txx(i)
+          tyy(i)=tmp*tyy(i)
+          tzz(i)=tmp*tzz(i)
+          uxx(i)=tmp*uxx(i)
+          uyy(i)=tmp*uyy(i)
+          uzz(i)=tmp*uzz(i)
+          
+        enddo
+        
+c     calculate force scale factor
+        
+        scale=trq/taq
+        
+c     final site forces
+        
+        jr=jrs
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          txx(i)=scale*txx(i)
+          tyy(i)=scale*tyy(i)
+          tzz(i)=scale*tzz(i)
+          ggx(i)=fmx
+          ggy(i)=fmy
+          ggz(i)=fmz
+          
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine torque_split
+
+      subroutine turn_rigid_body
+     x  (igrp1,igrp2,ifre1,ifre2,step,hhx,hhy,hhz,
+     x  uxx,uyy,uzz,txx,tyy,tzz,oxx,oyy,ozz)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for updating positions of atoms in a rigid body
+c     during a conjugate gradient minimisation
+c     
+c     copyright daresbury laboratory
+c     author w.smith       may  2006
+c     
+c     note: coz=cos(theta)-1
+c           zin=sin(theta)/theta
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,j,jr,jf,ig,id,igrp1,igrp2,ifre1,ifre2
+      real(8) step,hhx,hhy,hhz,uxx,uyy,uzz,txx,tyy,tzz
+      real(8) oxx,oyy,ozz,uuu,ttt,the2,coz,zin
+
+      dimension hhx(mxatms),hhy(mxatms),hhz(mxatms)
+      dimension oxx(mxatms),oyy(mxatms),ozz(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension uxx(mxatms),uyy(mxatms),uzz(mxatms)
+      
+c     update free atom positions
+
+      do jf=ifre1,ifre2
+        
+        i=lstfre(jf)
+        oxx(i)=oxx(i)+step*hhx(i)
+        oyy(i)=oyy(i)+step*hhy(i)
+        ozz(i)=ozz(i)+step*hhz(i)
+        
+      enddo
+      
+c     update rigid body atoms
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          uuu=uxx(i)**2+uyy(i)**2+uzz(i)**2
+          if(uuu.gt.1.d-10)then
+            
+            ttt=txx(i)**2+tyy(i)**2+tzz(i)**2
+            the2=(ttt/uuu)*step**2
+            
+            coz=-the2*(1.d0-the2*(1.d0-the2*(1.d0-the2*(1.d0-the2*(1.d0-
+     x        the2/132.d0)/90.d0)/56.d0)/30.d0)/12.d0)/2.d0
+            zin=-the2*(1.d0-the2*(1.d0-the2*(1.d0-the2*(1.d0-the2*(1.d0-
+     x        the2/156.d0)/110.d0)/72.d0)/42.d0)/20.d0)/6.d0+1.d0
+            
+            oxx(i)=oxx(i)+coz*uxx(i)+step*(hhx(i)+zin*txx(i))
+            oyy(i)=oyy(i)+coz*uyy(i)+step*(hhy(i)+zin*tyy(i))
+            ozz(i)=ozz(i)+coz*uzz(i)+step*(hhz(i)+zin*tzz(i))
+            
+          else
+            
+            oxx(i)=oxx(i)+step*hhx(i)
+            oyy(i)=oyy(i)+step*hhy(i)
+            ozz(i)=ozz(i)+step*hhz(i)
+            
+          endif
+          
+        enddo
+        
+      enddo
+
+      return
+      end subroutine turn_rigid_body
+      
+      end module optimiser_module
diff -urN dl_class_1.9.orig/srcmod/pair_module.f dl_class_1.9/srcmod/pair_module.f
--- dl_class_1.9.orig/srcmod/pair_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/pair_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,46 @@
+      module pair_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining atom pair data
+c     copyright - daresbury laboratory
+c     author    - w. smith    mar 2004
+c     
+c***********************************************************************
+
+      use setup_module
+      use error_module
+
+      implicit none
+
+      integer, allocatable :: ilist(:),jlist(:)
+      real(8), allocatable :: xdf(:),ydf(:),zdf(:)
+      real(8), allocatable :: rsqdf(:)
+
+      save ilist,jlist,xdf,ydf,zdf,rsqdf
+
+      contains
+
+      subroutine alloc_pair_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=6
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      allocate (ilist(mxxdf),stat=fail(1))
+      allocate (jlist(mxxdf),stat=fail(2))
+      allocate (xdf(mxxdf),stat=fail(3))
+      allocate (ydf(mxxdf),stat=fail(4))
+      allocate (zdf(mxxdf),stat=fail(5))
+      allocate (rsqdf(mxxdf),stat=fail(6))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1940)
+      enddo
+
+      end subroutine alloc_pair_arrays
+
+      end module pair_module
diff -urN dl_class_1.9.orig/srcmod/parse_module.f dl_class_1.9/srcmod/parse_module.f
--- dl_class_1.9.orig/srcmod/parse_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/parse_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,585 @@
+      module parse_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining parsing arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    jan 2004
+c     
+c***********************************************************************
+
+      integer, parameter :: lenrec=150
+      character*1 record(lenrec)
+      save record
+
+      contains
+
+      subroutine getrec(safe,idnode,ifile)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine to read a character string on one node
+c     and broadcast it to all other nodes
+c     
+c     copyright daresbury laboratory 1994
+c     author w.smith december 1994
+c     
+c*********************************************************************
+
+      implicit none
+      
+      logical safe
+
+      character*150 line
+      integer export,import,idnode,ifile,i
+      dimension export(lenrec),import(lenrec)
+      
+      safe=.true.
+      
+      call gsync()
+      
+      if(idnode.eq.0)then
+        
+        read(ifile,'(a150)',end=100)line
+
+        do i=1,lenrec
+
+          record(i)=line(i:i)
+          export(i)=ichar(line(i:i))
+          
+        enddo
+        
+        call gstate(safe)
+        call gisum(export,lenrec,import)
+        
+        return
+        
+  100   safe=.false.
+        
+        call gstate(safe)
+        
+      else
+        
+        call gstate(safe)
+        if(.not.safe)return
+
+        do i=1,lenrec
+
+          export(i)=0
+
+        enddo
+
+        call gisum(export,lenrec,import)
+        
+        do i=1,lenrec
+          
+          record(i)=char(export(i))
+          
+        enddo
+        
+        return
+        
+      endif
+      
+      end subroutine getrec
+
+      integer function intstr(word,len,lst)
+
+c***********************************************************************
+c     
+c     dl_poly function for extracting integers from a 
+c     character string
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith may 1994.
+c     
+c     parameters:
+c     word   - input character string
+c     len    - working length of character string
+c     lst    - location of space character at end of
+c     integer string
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical flag,count,final
+      character*1 n,word,ksn
+      integer lst,len,j,isn
+
+      dimension n(0:9),word(len)
+      data n/'0','1','2','3','4','5','6','7','8','9'/
+
+      isn=1
+      lst=0
+      ksn='+'
+      intstr=0
+      flag=.false.
+      final=.false.
+      count=.false.
+      
+      do while(lst.lt.len.and.(.not.final))
+
+        lst=lst+1
+        flag=.false.
+
+        do j=0,9
+          
+          if(n(j).eq.word(lst))then
+            
+            intstr=10*intstr+j
+            count=.true.
+            flag=.true.
+            
+          endif
+          
+        enddo
+
+        if(count.and.(.not.flag))final=.true.
+        if(flag.and.ksn.eq.'-')isn=-1
+        ksn=word(lst)
+
+      enddo
+
+      intstr=isn*intstr
+
+      do j=lst,len
+        word(j-lst+1)=word(j)
+      enddo
+      do j=len-lst+2,len
+        word(j)=' '
+      enddo
+
+      return
+      end function intstr
+
+      real(8) function dblstr(word,len,lst)
+
+c***********************************************************************
+c     
+c     dl_poly function for extracting double precisions from a 
+c     character string. 
+c     modified from dl_poly function intstr
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith may 1994.
+c     modified  - t. forester april 1994
+c     
+c     parameters:
+c     word   - input character string
+c     len    - working length of character string
+c     lst    - location of space character at end of
+c     double precision string
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 n,word,ksn,dot,d,e
+      logical flag,ldot,start,final
+      integer len,lst,iexp,idum,i,j,fail
+      real(8) sn,ten,one
+      dimension n(0:9),word(len)
+      character*1, allocatable :: work(:)
+
+      data n/'0','1','2','3','4','5','6','7','8','9'/
+      data dot/'.'/
+      data d/'d'/
+      data e/'e'/
+      
+      allocate(work(len),stat=fail)
+
+      lst=0
+      sn=1.d0
+      ksn='+'
+      ten=10.d0
+      one=1.d0
+      
+      dblstr=0.d0
+      iexp=0
+      idum=0
+      start=.false.
+      ldot=.false.
+      final=.false.
+
+      do while(lst.lt.len.and.(.not.final))
+        
+        lst=lst+1
+        flag=.false.
+        
+        do j=0,9
+          
+          if(n(j).eq.word(lst))then
+            
+            dblstr=ten*dblstr+one*dble(j)
+            flag=.true.
+            start=.true.
+            
+          endif
+          
+        enddo
+        
+        if(dot.eq.word(lst))then
+          
+          flag=.true.
+          ten=1.d0
+          ldot=.true.
+          start=.true.
+          
+        endif
+
+        if(flag.and.ksn.eq.'-') sn=-1.d0
+        if(ldot) one=one/10.d0
+        ksn=word(lst)
+        if(ksn.eq."D")ksn="d"
+        if(ksn.eq."E")ksn="e"
+        
+        if(start)then
+          
+          if(d.eq.ksn.or.e.eq.ksn)then
+            
+            do i=1,len-lst
+              work(i)=word(i+lst)
+            enddo
+            iexp=intstr(work,len-lst,idum)
+            final=.true.
+
+          endif
+
+          if(.not.flag)final=.true.
+          
+        endif
+        
+      enddo
+      
+      dblstr=sn*dblstr*(10.d0**iexp)
+      lst=lst+idum
+      
+      do j=lst,len
+        word(j-lst+1)=word(j)
+      enddo
+      do j=len-lst+2,len
+        word(j)=' '
+      enddo
+
+      deallocate(work,stat=idum)
+
+      return
+      end function dblstr
+
+      subroutine strip(string,imax)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to strip blanks from start of a string
+c     maximum length is 255 characters
+c     
+c     copyright daresbury laboratory 1993
+c     author   t.forester       july 1993
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer i,imax,j
+      character*1 string(imax)
+      
+      do i=1,imax
+
+        if(string(1).eq.' ')then
+
+          do j=1,imax-1
+
+            string(j)=string(j+1)
+
+          enddo
+
+          string(imax)=' '
+
+        endif
+
+      enddo
+
+      return
+      end subroutine strip
+
+      subroutine lowcase(string,length)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to lowercase a string of up to 255 characters.
+c     Transportable to non-ASCII machines
+c     
+c     copyright daresbury laboratory 1993
+c     author    t. forester     july 1993
+c     
+c***********************************************************************
+
+      implicit none
+
+      character*1 string(*)
+      character*1 letter
+      integer i,length
+
+      do i=1,min(255,length)
+
+        letter=string(i)
+
+        if(letter.eq.'A')then
+          letter='a'
+        else if(letter.eq.'B')then
+          letter='b'
+        else if(letter.eq.'C')then
+          letter='c'
+        else if(letter.eq.'D')then
+          letter='d'
+        else if(letter.eq.'E')then
+          letter='e'
+        else if(letter.eq.'F')then
+          letter='f'
+        else if(letter.eq.'G')then
+          letter='g'
+        else if(letter.eq.'H')then
+          letter='h'
+        else if(letter.eq.'I')then
+          letter='i'
+        else if(letter.eq.'J')then
+          letter='j'
+        else if(letter.eq.'K')then
+          letter='k'
+        else if(letter.eq.'L')then
+          letter='l'
+        else if(letter.eq.'M')then
+          letter='m'
+        else if(letter.eq.'N')then
+          letter='n'
+        else if(letter.eq.'O')then
+          letter='o'
+        else if(letter.eq.'P')then
+          letter='p'
+        else if(letter.eq.'Q')then
+          letter='q'
+        else if(letter.eq.'R')then
+          letter='r'
+        else if(letter.eq.'S')then
+          letter='s'
+        else if(letter.eq.'T')then
+          letter='t'
+        else if(letter.eq.'U')then
+          letter='u'
+        else if(letter.eq.'V')then
+          letter='v'
+        else if(letter.eq.'W')then
+          letter='w'
+        else if(letter.eq.'X')then
+          letter='x'
+        else if(letter.eq.'Y')then
+          letter='y'
+        else if(letter.eq.'Z')then
+          letter='z'
+        endif
+
+        string(i)=letter
+
+      enddo
+
+      return
+      end subroutine lowcase
+
+      subroutine copystring(oldstr,newstr,length)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to copy one string into another
+c     
+c     copyright daresbury laboratory
+c     author    w. smith    jan 2004
+c     
+c***********************************************************************
+
+      implicit none
+
+      character*1 newstr(*),oldstr(*)
+      integer i,length
+
+      do i=1,length
+
+        newstr(i)=oldstr(i)
+
+      enddo
+
+      return
+      end subroutine copystring
+
+      logical function findstring(seek,string,here)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to find an explicit string in an input record
+c     note: variable `seek' is a character string while variable
+c    `string' is a character*1 array i.e. code is application specific
+c
+c     copyright daresbury laboratory
+c     author    w.smith   jan   2004
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer i,n,m,here
+      character*(*) seek
+      character*1 string(lenrec)
+
+      m=lenrec
+      n=len(seek)
+      findstring=.false.
+
+      here=0
+      do while(here.le.m-n.and.(.not.findstring))
+
+        findstring=.true.
+
+        do i=1,n
+          if(seek(i:i).ne.string(here+i))findstring=.false.
+        enddo
+
+        here=here+1
+
+      enddo
+
+      return
+      end function findstring
+
+      subroutine striptext(string,length,nwords)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to strip leading text from a data record
+c     
+c     copyright daresbury laboratory
+c     author   w.smith jan 2004
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical final
+      integer length,nwords,i,j,k
+      character*1 string(length)
+      
+      do k=1,nwords
+
+        i=0
+        final=.false.
+        
+        do while(.not.final.and.i.lt.length)
+          
+          i=i+1
+          
+          if(string(1).eq.' ')then
+            
+            final=.true.
+            
+          else
+            
+            do j=1,length-1
+              
+              string(j)=string(j+1)
+              
+            enddo
+            
+            string(length)=' '
+            
+          endif
+          
+        enddo
+        
+      enddo
+
+      return
+      end subroutine striptext
+
+      subroutine getword(word,string,len1,len2)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to fetch an 8 character word from a string
+c     while ignoring leading blanks
+c
+c     copyright daresbury laboratory
+c     author   w.smith jan 2004
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical final
+      character*8 word
+      integer len1,len2,i,j,k
+      character*1 wrdseq(len1),string(len2)
+      
+      do i=1,len1
+        wrdseq(i)=' '
+      enddo
+
+      i=0
+      k=0
+      final=.false.
+      
+      do while(.not.final.and.i.lt.len2)
+        
+        i=i+1
+        
+        if(string(1).eq.' ')then
+          
+          if(k.gt.0)final=.true.
+          
+        else
+          
+          k=k+1
+          wrdseq(k)=string(1)
+          if(k.eq.len1)final=.true.
+
+        endif
+        
+        do j=1,len2-1
+          
+          string(j)=string(j+1)
+          
+        enddo
+        
+        string(len2)=' '
+          
+      enddo
+      
+      word=mkwd8(wrdseq)
+
+      return
+      end subroutine getword
+
+      character*8 function mkwd8(string)
+
+c***********************************************************************
+c     
+c     DL_POLY routine to make an 8 character word from a string
+c
+c     copyright daresbury laboratory
+c     author   w.smith nov 2006
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer i
+      character*1 string(*)
+      
+      do i=1,8
+         mkwd8(i:i)=string(i)
+      enddo
+      
+      return
+      end function mkwd8
+      
+      end module parse_module
+
+
diff -urN dl_class_1.9.orig/srcmod/pass_tools.f dl_class_1.9/srcmod/pass_tools.f
--- dl_class_1.9.orig/srcmod/pass_tools.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/pass_tools.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,318 @@
+      subroutine passcon
+     x     (lshmov,idnode,mxnode,natms,nscons,lashap,lishap,listme,
+     x     listin,listot,listcon,lstfrz)
+      
+c*********************************************************************
+c     
+c     dl_poly subroutine for passing information about bond 
+c     constraints between nodes
+c     
+c     parallel replicated data version assuming direct node-node
+c     connection (i.e. this version may be intel specific)
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith august 1992.
+c     MPI version t.forester may 1995
+c     CPP version - w.smith may 1995
+c     
+c***********************************************************************
+
+      use setup_module
+      use error_module
+
+      implicit none
+
+      include "comms.inc"
+
+      logical safe,lshmov
+      integer idnode,mxnode,natms,nscons,lashap,lishap,listme,ierr
+      integer listin,listot,listcon,lstfrz,i,j,k,jdnode,idum
+
+      dimension listme(mxatms),listin(mxatms),listot(mxatms)
+      dimension lishap(mxlshp),lashap(mxproc),listcon(mxcons,3)
+      dimension lstfrz(mxatms)
+
+      integer status(MPI_STATUS_SIZE), request
+
+CMPIU define MPI_SEND MPI_SEND_
+CMPIU define MPI_IRECV MPI_IRECV_
+CMPIU define MPI_WAIT MPI_WAIT_
+
+      if(mxproc.lt.mxnode)call error(idnode,102)
+      
+      safe=.true.
+
+      do i=1,natms
+         
+         listme(i)=0
+         
+      enddo
+      
+      do k=1,nscons
+         
+         i=listcon(k,2)
+         j=listcon(k,3)
+         listme(i)=listme(i)+1
+         listme(j)=listme(j)+1
+         
+      enddo
+      
+      if(mxnode.gt.1)then
+         
+         j=0
+         call gsync()
+         do k=1,mxnode-1
+            
+            jdnode=mod(idnode+mxnode-k,mxnode)
+
+            call MPI_IRECV(listin,natms,MPI_INTEGER,
+     x        MPI_ANY_SOURCE,Passcon_tag+k,MPI_COMM_WORLD,request,ierr)
+            
+            call MPI_SEND(listme,natms,MPI_INTEGER,jdnode,
+     x           Passcon_tag+k,MPI_COMM_WORLD,ierr)
+
+            call MPI_WAIT(request,status,ierr)
+
+            do i=1,natms
+               
+               if((listme(i).gt.0).and.(listin(i).gt.0.and.
+     x              lstfrz(i).eq.0))then
+                  
+                  j=j+1
+                  if(j.gt.mxlshp)then
+
+                     safe=.false.
+
+                  else
+
+                     lishap(j)=i
+
+                  endif
+                  
+               endif
+               
+            enddo
+            
+            lashap(k)=j
+            
+         enddo
+         
+      endif
+
+c     check for global error condition
+
+      if(mxnode.gt.1) call gstate(safe)
+
+      if(.not.safe)call error(idnode,103)
+
+      if(mxnode.gt.1) then
+         call gisum(j,1,idum)
+         if(idnode.eq.0) write(nrite,'(/,a,14x,i10)')
+     x     ' shared atoms from passcon',j/2
+         lshmov = (j.gt.0)
+      endif
+
+c     keep record of all atoms subject to constraints
+      
+      do i=1,natms
+         
+         if(listme(i).gt.0)then
+            
+            listot(i)=1
+            
+         else
+            
+            listot(i)=0
+            
+         endif
+         
+      enddo
+      
+      if(mxnode.gt.1)call gisum(listot,natms,listin)
+      
+      return
+      end
+
+      subroutine passpmf
+     x  (idnode,mxnode,natms,nspmf,listpm,listin,lstpmt,lstpmf,npmf)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for passing information about PMF
+c     constraints between nodes
+c     
+c     parallel replicated data version assuming direct node-node
+c     connection (i.e. this version may be intel specific)
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - t.forester august 1995.
+c     
+c***********************************************************************
+
+      use setup_module
+      use error_module
+
+      implicit none
+
+      integer idnode,mxnode,natms,nspmf,listpm,listin,lstpmt,lstpmf
+      integer npmf,i,j,k
+
+      dimension listpm(mxpmf),listin(mxatms),lstpmt(mxpmf)
+      dimension lstpmf(mxspmf,mspmf),npmf(2)
+
+      if(mxproc.lt.mxnode)call error(idnode,102)
+      if(mxpmf.lt.natms) call error(idnode,490)
+
+      do i=1,natms
+        
+        listpm(i)=0
+        
+      enddo
+      
+      do k=1,nspmf
+        
+        do j = 1,npmf(1)+npmf(2)
+
+          i=lstpmf(j,k)
+          listpm(i)= 1
+          
+        enddo
+
+      enddo
+c     
+c     keep record of all atoms subject to pmf constraints
+      
+      do i=1,natms
+        
+        if(listpm(i).gt.0)then
+          
+          lstpmt(i)=1
+          
+        else
+          
+          lstpmt(i)=0
+          
+        endif
+        
+      enddo
+      
+      if(mxnode.gt.1)call gisum(lstpmt,natms,listin)
+      
+      return
+      end
+
+      subroutine passquat
+     x  (lcnb,idnode,mxnode,natms,ngrp,nscons,ntpmls,listin,
+     x  listcon,lstrgd,lstout,lstcsit,lstgtp,nummols,numgrp,numgsit)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for passing information about rigid body 
+c     atoms involved in bond constraints between nodes
+c     
+c     parallel replicated data version assuming direct node-node
+c     connection
+c     
+c     copyright - daresbury laboratory 1995
+c     author    - t. forester december 1995.
+c     
+c***********************************************************************
+      
+      use setup_module
+      use error_module
+
+      implicit none
+
+      include "comms.inc"
+
+      logical lcnb,safe
+      integer idnode,mxnode,natms,ngrp,nscons,ntpmls,listin
+      integer listcon,lstrgd,lstout,lstcsit,lstgtp,nummols,numgrp
+      integer numgsit,igrp1,igrp2,i,jr,igrp,itmols,imols,lgrp,id
+      integer jj,ik,j,k
+      
+      dimension listin(mxatms)
+      dimension listcon(mxcons,3),lstcsit(2*mxcons)
+      dimension lstout(mxatms),lstrgd(mxgatm)
+      dimension nummols(mxtmls),numgrp(mxtmls),numgsit(mxungp)
+      dimension lstgtp(mxgrp)
+
+      integer status(MPI_STATUS_SIZE)
+      
+      if(mxproc.lt.mxnode)call error(idnode,102)
+      
+c     block indices for groups
+      
+      igrp1 = (idnode*ngrp)/mxnode + 1
+      igrp2 = ((idnode+1)*ngrp)/mxnode
+      
+c     locate site indices of atoms in constraints
+
+      do i = 1,natms
+        listin(i) = 0
+      enddo
+
+c     loop over molecule types
+
+      jr = 0 
+      igrp = 0
+      do itmols=1,ntpmls
+
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+
+c     construct rigid body site list: each processor has a different copy
+          
+          do lgrp=1,numgrp(itmols)
+            
+            igrp=igrp+1
+            
+            if((igrp.ge.igrp1).and.(igrp.le.igrp2)) then
+                
+              id = lstgtp(igrp)
+              do jj = 1,numgsit(id)
+                  
+                jr = jr +1
+                i = lstrgd(jr)
+                listin(i) = jj
+
+              enddo
+            endif
+          enddo
+        enddo
+      enddo
+
+      if(mxnode.gt.1) call gisum(listin,natms,lstout)
+
+      safe = .true.
+      ik = 0
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+        if(listin(i).ne.0) then
+          ik = ik + 1
+          lstcsit(ik) = listin(i)
+          safe = .false.
+        endif
+
+        if(listin(j).ne.0) then
+          ik = ik + 1
+          lstcsit(ik) = listin(j)
+          safe = .false.
+        endif
+
+      enddo
+
+c     lcnb flags bodies connected by constraints
+
+      if(mxnode.gt.1) call gstate(safe)
+      lcnb = (.not.safe)
+      
+      return
+      end
+
+
+
diff -urN dl_class_1.9.orig/srcmod/Plumed/biasexchange.c dl_class_1.9/srcmod/Plumed/biasexchange.c
--- dl_class_1.9.orig/srcmod/Plumed/biasexchange.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/biasexchange.c	2015-11-07 17:37:19.282601139 +0100
@@ -0,0 +1,52 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+/* the random number sequence is the same across replicas, so no need for
+   one replica to decide the exchanges... */ 
+void bias_exchange_traj(int nrepl, int *seed, int *ind)
+{
+#ifdef PLUMED_GROMACS
+  int stat, i, j;
+
+  for(i=0;i<nrepl;i++) {
+    stat=1;
+    while(stat) {
+      stat=0;
+      ind[i] = rando(seed)*nrepl;
+      for(j=0;j<i;j++) if(ind[i]==ind[j]) stat=1;
+    }
+  }
+#endif
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/dafed.c dl_class_1.9/srcmod/Plumed/dafed.c
--- dl_class_1.9.orig/srcmod/Plumed/dafed.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/dafed.c	2015-11-07 17:37:19.286601255 +0100
@@ -0,0 +1,380 @@
+/*
+* dafed.c
+*
+*  This file is an addition to plumed for d-AFED
+*      Author: Michel Cuendet
+*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information.
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as
+*  published by the Free Software Foundation, either version 3 of
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+#include <math.h>
+
+
+
+// =====================================================================================
+void PREFIX initialize_ggmt(
+		struct ggmt_s *ggmt,				// Generalized Gaussian Moments Thermostat structure
+		double T0,						// reference temperature
+		double tau,					// time constant
+		double  delta_t				// external MD time step
+	) {
+
+	/* We assume that temperature and tau and n_respa are given */
+	ggmt->kT0	= mtd_data.boltz * T0;
+	ggmt->Q1	= ggmt->kT0 * tau * tau;
+	ggmt->Q2	= 8.0/3.0 * pow(ggmt->kT0,3) *tau *tau ;
+
+	ggmt->dt[0]  = delta_t /((double)ggmt->n_respa_ggmt);
+   /* Weights for the Suzuki-Yoshida decomposition : */
+   /* These correspond to the delta t_j from Liu et al. (2000) */
+	ggmt->dt[1]  = (1.0 / (2.0 - pow(2.0,(1.0/3.0)))) * ggmt->dt[0]  ;
+	ggmt->dt[2]  = ggmt->dt[0] -  2.0*ggmt->dt[1];
+	ggmt->dt[3]  = ggmt->dt[1];
+
+	ggmt->eta1	= 1.0;
+	ggmt->eta2	= 1.0;
+	ggmt->v1	= -sqrt( ggmt->kT0 / ggmt->Q1 );
+	ggmt->v2	= -sqrt( ggmt->kT0 / ggmt->Q2 );
+
+
+}
+
+// =====================================================================================
+void PREFIX initialize_dafed(struct dafed_s *daf, real dt)
+	{ 												// dt is taken as real from mtd_data
+
+	  // This is called after reading the input.
+	  // daf.s is initialized later to the value of colvar.ss0[i_c]
+	  daf->vs = -sqrt(mtd_data.boltz * daf->temperature / daf->mass );
+	  daf->dt_respa = dt;  // In the current implementation, RESPA is done in the MD loop.
+	  daf->f = 0.0;
+	  daf->do_initialize_s = 1;
+	  daf->do_skip_integration = 0;
+	  daf->thermo_work = 0.0;
+	  daf->dafed_work = 0.0;
+	  daf->do_jacobian_force = 0;
+	  daf->jacobian_force = 0.0;
+	  daf->dWold = 0.0;
+
+	  initialize_ggmt(&(daf->ggmt), daf->temperature, daf->tauthermo, daf->dt_respa);
+
+}
+
+// =====================================================================================
+void PREFIX get_kt(struct dafed_s *daf, double *d) {
+  *d = pow(daf->vs,2) * daf->mass;
+}
+
+// =====================================================================================
+void PREFIX integrate_ggmt(struct dafed_s *daf) {
+
+		// This corresponds to the integration over HALF an external time step
+		// This routine has to be called twice per step
+
+       struct ggmt_s *th = &(daf->ggmt);
+	   int iii, jjj;
+	   double aa=0.0, bb=0.0;
+	   double kt;
+	   double G1,G2;
+	   double dt2, dt4, dt8;
+
+	   get_kt(daf, &kt);				   // kt is equivalent to (p^2 / m)
+
+	   // Loop over the RESPA integration steps
+	   for (iii = 1; iii <= th->n_respa_ggmt; iii++) {
+		 // Loop over the three therms of the Suzuki-Yoshida decomposition :
+	     for (jjj = 1; jjj <= 3; jjj++) {
+
+	       dt2 = 0.5*th->dt[jjj];   // half time step
+	       dt4 = 0.25*th->dt[jjj];	// quarter time step
+	       dt8 = 0.125*th->dt[jjj]; // 1/8 time step
+
+	       G1   = (kt - th->kT0)/(th->Q1);
+	       G2   = (pow(kt,2)/(3.0) - pow(th->kT0,2))/(th->Q2);
+	       th->v1 += dt4 * G1;
+	       th->v2 += dt4 * G2;
+
+	       aa         = exp(-dt8 * (th->v1 + th->kT0*th->v2));
+	       daf->vs   *= aa;
+	       get_kt(daf, &kt);
+
+	       bb         = kt*th->v2/(3.0);
+	       daf->vs   *= sqrt(1.0/(1.0 + dt2 * bb));
+
+	       daf->vs   *= aa;
+	       get_kt(daf, &kt);
+
+	       th->eta1 += dt2 * th->v1;
+	       th->eta2 += dt2 * th->v2*(th->kT0 + kt);
+
+	       aa         = exp(-dt8 * (th->v1 + th->kT0*th->v2));
+	       daf->vs   *= aa;
+	       get_kt(daf, &kt);
+
+	       bb         = kt*th->v2/(3.0);
+	       daf->vs   *= sqrt(1.0/(1.0 + dt2 * bb));
+
+	       daf->vs   *= aa;
+	       get_kt(daf, &kt);
+
+	       G1   = (kt - th->kT0)/(th->Q1);
+	       G2   = (pow(kt,2)/(3.0) - pow(th->kT0,2))/(th->Q2);
+	       th->v1 += dt4 * G1;
+	       th->v2 += dt4 * G2;
+
+	     }
+
+
+	   }
+}
+
+// =====================================================================================
+real PREFIX energy_ggmt(struct ggmt_s ggmt) {
+	real ener;
+
+	/* In the cas of DAFED, number of particles =1, dimention = 1 always */
+	ener = 0.5* (  ggmt.Q1*pow(ggmt.v1,2)  +
+				   ggmt.Q2*pow(ggmt.v2,2) )  +
+				   ggmt.kT0*(ggmt.eta1 + ggmt.eta2);
+	return ener;
+}
+
+// =====================================================================================
+
+void PREFIX print_dafed(struct dafed_s *daf,FILE *cv_file, int i_c)
+  {
+		double potential;
+		double energy;
+		double temperature;
+		double transferred_work;
+		double delta;
+
+		delta =  daf->colvar - daf->s;
+		if (daf->do_periodicity) {
+				if (delta > 0.5 * daf->periodicity_gap ) delta = delta - daf->periodicity_gap;
+				if (delta < - 0.5 * daf->periodicity_gap ) delta = delta + daf->periodicity_gap;
+		}
+
+		potential =  0.5*daf->kappa * pow(delta ,2);
+		energy = 0.5*daf->mass * pow(daf->vs,2) +
+						  potential +
+						  energy_ggmt(daf->ggmt);
+
+		temperature = pow(daf->vs,2) * daf->mass / mtd_data.boltz;
+
+		// What we want is not the accumulated work which pertains to the system H_phys + V
+		// But we want the work W transferred to the physical system, which pertains to H_phys
+		// Where H_phys is the energy of the physical system + thermostat
+		// and V is the potential 0.5*kappa*(q-s)^2
+		// For a discussion of this (in the context of steered MD), see
+		// Schurr and Fujimoto, J. Phys. Chem. B 107. 14007 (2003)
+		// This way, both H-W and H_dafed+W should be conserved
+		transferred_work = daf->dafed_work - potential;
+
+  		 // fprintf(cv_file,"      d-AFED %d ",i_c+1);
+  		 fprintf(cv_file," %10.5e",daf->s);
+  		 fprintf(cv_file," %10.5f",temperature);
+  		 fprintf(cv_file," %10.5e",energy);
+  		 fprintf(cv_file," %13.8e",transferred_work);
+  		 // fprintf(cv_file," %15f",daf->thermo_work);
+
+  }
+
+// =====================================================================================
+void PREFIX read_dafed_state()
+{
+		int i_c;
+		FILE *file;
+		double time;
+
+
+		if (!logical.do_dafed)
+			plumed_error("CANNOT READ d-AFED STATE IF NO d-ADFED CV IS DEFINED");
+
+		file = fopen(dafed_control.in_file, "r");
+		if(!file) {										// not exist
+		           char buf[1024];
+		           sprintf(buf,"Cannot read d-AFED state file %s for reading !",dafed_control.in_file);
+		           plumed_error(buf);
+		   }
+
+		fscanf(file, "%lf\n",&time);
+
+		for(i_c=0;i_c<colvar.nconst;i_c++){
+			  if (logical.dafed[i_c]) {
+				    fscanf(file, "%lf %lf %lf %lf %lf %lf\n",
+				    		&(dafed[i_c].s),
+				    		&(dafed[i_c].vs),
+				    		&(dafed[i_c].ggmt.eta1),
+				    		&(dafed[i_c].ggmt.v1),
+				    		&(dafed[i_c].ggmt.eta2),
+				    		&(dafed[i_c].ggmt.v2));
+
+				    fprintf(mtd_data.fplog, "|- DAFED CV %d : READ RESTART VALUES \n",i_c+1);
+				    fprintf(mtd_data.fplog, "|- \t s \t %.15e\n",dafed[i_c].s);
+				    fprintf(mtd_data.fplog, "|- \t vs \t %.15e\n",dafed[i_c].vs);
+				    fprintf(mtd_data.fplog, "|- \t eta1 \t %.15e\n",dafed[i_c].ggmt.eta1);
+				    fprintf(mtd_data.fplog, "|- \t v1 \t %.15e\n",dafed[i_c].ggmt.v1);
+				    fprintf(mtd_data.fplog, "|- \t eta2 \t %.15e\n",dafed[i_c].ggmt.eta2);
+				    fprintf(mtd_data.fplog, "|- \t v2 \t %.15e\n",dafed[i_c].ggmt.v2);
+			  }
+		}
+		fclose(file);
+}
+
+// =====================================================================================
+void PREFIX write_dafed_state()
+{
+		int i_c;
+		char stringa[500];
+		FILE *file;
+
+		sprintf(stringa, "%s.old", dafed_control.out_file);
+		if(mtd_data.ionode) rename(dafed_control.out_file, stringa);
+
+		file = fopen((mtd_data.ionode?dafed_control.out_file:"/dev/null"), "w");
+		// Here we use the same construct as for the COLVAR file, where all nodes write to /dev/null except the ionode.
+		if(!file) {										// not exist
+		           char buf[1024];
+		           sprintf(buf,"Cannot open d-AFED state file %s for writing !",dafed_control.out_file);
+		           plumed_error(buf);
+		   };
+
+		fprintf(file, "%10.3f\n", mtd_data.time);
+		for(i_c=0;i_c<colvar.nconst;i_c++){
+			  if (logical.dafed[i_c]) {
+				    fprintf(file, "%20.16e %20.16e %20.16e %20.16e %20.16e %20.16e\n",
+				    		dafed[i_c].s,
+				    		dafed[i_c].vs,
+				    		dafed[i_c].ggmt.eta1,
+				    		dafed[i_c].ggmt.v1,
+				    		dafed[i_c].ggmt.eta2,
+				    		dafed[i_c].ggmt.v2);
+			  }
+		}
+		fclose(file);
+}
+
+
+// =====================================================================================
+void PREFIX dafed_engine(real *this_colvar)
+{											  // this_colvar is taken as real from colvar.ss0
+	int i,i_c;
+	double kt;
+	double dW;
+	double delta;
+	struct dafed_s *daf;
+	int do_write=0;
+
+	for(i_c=0;i_c<colvar.nconst;i_c++){
+	  if (logical.dafed[i_c]) {
+
+		    daf = &dafed[i_c];
+
+		    if (daf->do_initialize_s) {
+				daf->s = (double)this_colvar[i_c];
+				daf->do_initialize_s =0;
+			}
+
+			daf->colvar = (double)this_colvar[i_c];
+
+			if (daf->do_skip_integration) {
+				// This is if we have just read a restart file
+				daf->f = - daf->kappa * ( daf->colvar  - daf->s);
+				daf->do_skip_integration = 0;
+			}else{
+
+			  //for(i=1;i<=daf->n_respa;i++) {
+			  // In the current implementation, RESPA is done in the MD loop
+
+			  // integrate from 0 to dt/2
+				integrate_ggmt(daf);
+				// We want the force FROM the colvar ON s -> change sign
+				daf->vs +=  0.5 * daf->dt_respa * (-daf->f + daf->jacobian_force) / daf->mass ;
+				daf->s +=  daf->dt_respa * daf->vs;
+				if (daf->do_periodicity) {
+					if (daf->s < daf->periodicity_low) daf->s = daf->s + daf->periodicity_gap;
+					if (daf->s > daf->periodicity_high) daf->s = daf->s - daf->periodicity_gap;
+				}
+
+			  // Integrate the thermostat work : (for now only a simple rectangular scheme)
+				// In principle here we have kt and v1, v2 at dt/2
+				get_kt(daf, &kt);
+				daf->thermo_work -= 0.5*daf->dt_respa  *
+							kt*( daf->ggmt.v1 +  daf->ggmt.v2*(daf->ggmt.kT0 + kt/3.0) );
+
+			  // calculate the force.
+				// This is the DAFED force at full time step t
+				// (i.e. after the last RESPA iteration is completed)
+				// This is the force FROM s ON the colvar -> minus sign
+				delta = daf->colvar  - daf->s ;
+				if (daf->do_periodicity) {
+					if (delta > (0.5 * daf->periodicity_gap) ) delta = delta - daf->periodicity_gap;
+					if (delta < (- 0.5 * daf->periodicity_gap) ) delta = delta + daf->periodicity_gap;
+				}
+				daf->f = - daf->kappa * delta;
+
+				if ( daf->do_jacobian_force ) {
+					daf->jacobian_force = - 2.0 * 300.0 * 0.00831451 / daf->s ;
+				}
+
+			  // integrate from dt/2 to dt
+				// We want the force FROM the colvar ON s -> change sign
+				daf->vs +=  0.5 * daf->dt_respa * (-daf->f + daf->jacobian_force) / daf->mass ;
+				integrate_ggmt(daf);
+
+			  // Integrate the thermostat work : (for now only a simple rectangular scheme)
+				// In principle here we have kt and v1, v2 at full dt
+				get_kt(daf, &kt);
+				daf->thermo_work -= 0.5*daf->dt_respa  *
+								kt*( daf->ggmt.v1 +  daf->ggmt.v2*(daf->ggmt.kT0 + kt/3.0) );
+
+			 // Integrate DAFED work : (triangle scheme)
+				dW = daf->dt_respa * daf->f * daf->vs;
+				daf->dafed_work += 0.5 * ( dW + daf->dWold);
+				daf->dWold = dW;
+			  //}
+			} // if skip
+	  } // if
+	} // for
+
+	if (dafed_control.write_freq == -1)
+		do_write = (logical.not_same_step)&&(!firstTime)&&(dafed_control.do_cpt);
+	else if (dafed_control.write_freq > 0)
+		do_write = (logical.not_same_step)&&(!firstTime)&&(!(colvar.it%dafed_control.write_freq));
+
+	if (do_write) write_dafed_state();
+
+}
+
+
diff -urN dl_class_1.9.orig/srcmod/Plumed/hills.c dl_class_1.9/srcmod/Plumed/hills.c
--- dl_class_1.9.orig/srcmod/Plumed/hills.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/hills.c	2015-11-07 17:37:19.289601342 +0100
@@ -0,0 +1,1251 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+// This routine calculates, from the variaton of a collective variable, the width
+// of the gaussian hills along the CV direction.
+
+void PREFIX hills_adapt()
+{
+  real fluct, step;
+  real Mss02, M2ss0;
+  int i_c;
+
+  for(i_c=0;i_c<colvar.nconst;i_c++){
+   if(colvar.adapt[i_c].on){ 
+// Time for recording fluctuations???
+    if((logical.not_same_step) && colvar.it%colvar.adapt[i_c].stride==0 && !firstTime ){
+      colvar.Mss0[i_c] += colvar.ss0[i_c];
+      colvar.M2ss0[i_c] += colvar.ss0[i_c]*colvar.ss0[i_c];
+    }
+// Time for evaluating width???    
+    if((logical.not_same_step) && colvar.it%colvar.adapt[i_c].block==0 && !firstTime ){
+      step = (real) colvar.adapt[i_c].stride / colvar.adapt[i_c].block;      
+      M2ss0 = colvar.M2ss0[i_c]*step;
+      Mss02 = colvar.Mss0[i_c]*colvar.Mss0[i_c]*step*step;  
+      if(M2ss0>Mss02) fluct = sqrt(M2ss0-Mss02);
+      else fluct = 0.;
+      colvar.delta_r[i_c] = colvar.adapt[i_c].widthmultiplier*fluct;
+      if(colvar.delta_r[i_c] > colvar.adapt[i_c].sup) colvar.delta_r[i_c] = colvar.adapt[i_c].sup;
+      if(colvar.delta_r[i_c] < colvar.adapt[i_c].inf) colvar.delta_r[i_c] = colvar.adapt[i_c].inf;
+      colvar.M2ss0[i_c] = 0.;
+      colvar.Mss0[i_c] = 0.;
+    }
+   }
+  }
+}
+
+//------------------------------------------------------------------------------------------
+
+void PREFIX hills_push(struct mtd_data_s *mtd_data,real ww, real* ss,real* delta)
+{
+  int icv,ncv;
+  static FILE *file=NULL;
+  real inv_ss0[nconst_max];
+  int done,wall;
+  static int first=1;
+  int nactive;
+// INVERSION VARS
+  int j, i_c;
+  real tmps,tmp,tmpd,tmpF1,tmpF2,tmpF3,smooth_func;  
+// END INVERSION VARS
+
+  ncv=colvar.nconst;
+  if(hills.n_hills+10>hills.ntothills) hills_reallocate(mtd_data); 
+
+  hills.ww[hills.n_hills] = ww;
+  for(icv=0;icv<ncv;icv++) hills.ss0_t[hills.n_hills][icv] = ss[icv];	// new hill center
+  for(icv=0;icv<ncv;icv++) colvar.delta_s[hills.n_hills][icv] = delta[icv];       // new hill width
+
+
+
+
+// PRINT
+  if(!file) file = fopen((mtd_data->ionode?mtd_data->hilfilen:"/dev/null"), "a");
+   
+// header: list active CVs (useful e.g. for bias-exchange post-processing)
+  if(first) {
+    if(strlen(colvar.hills_label)>0){ 
+      nactive=0;
+      for(i_c=0;i_c<colvar.nconst;i_c++){ if(colvar.on[i_c]) nactive++; }
+      fprintf(file, "#! ACTIVE %d",nactive);
+      if(nactive>0) {
+        for(i_c=0;i_c<colvar.nconst;i_c++){ if(colvar.on[i_c]) fprintf(file, " %d",i_c+1); }
+      }
+      fprintf(file, " %s",colvar.hills_label); 
+      fprintf(file,"\n");
+    }
+    first=0;
+  }
+
+  fprintf(file, "%10.3f   ", mtd_data->time);
+  for(icv=0;icv<ncv;icv++) if(colvar.on[icv]) fprintf(file, "%14.9f   ", hills.ss0_t[hills.n_hills][icv]);
+  for(icv=0;icv<ncv;icv++) if(colvar.on[icv]) fprintf(file, "%14.9f   ", colvar.delta_s[hills.n_hills][icv]);
+  if(logical.welltemp){
+   fprintf(file, "%14.9f   %4.3f \n", hills.ww[hills.n_hills]*colvar.wfactor/(colvar.wfactor-1.0)/mtd_data->eunit,colvar.wfactor);
+  } else {
+   fprintf(file, "%14.9f   %4.3f \n", hills.ww[hills.n_hills]/mtd_data->eunit,0.0);
+  } 
+  
+  hills.n_hills++;                              // hills added
+// flush all the time standalone: not a big deal... 
+#ifdef STANDALONE 
+  fclose(file);
+#endif
+  if(!logical.do_walkers) hills.read=hills.n_hills;
+
+// WALLS
+  wall = 0;
+
+  for(icv=0;icv<ncv;icv++) {
+    inv_ss0[icv] = colvar.ss0[icv];
+    if(logical.ureflect[icv] && colvar.ss0[icv]>(cvw.upper[icv]-colvar.delta_r[icv]) && 
+       colvar.ss0[icv]<cvw.upper[icv] && colvar.on[icv]) { inv_ss0[icv] = 2.*cvw.upper[icv]-colvar.ss0[icv]; wall=1;}
+    else if(logical.lreflect[icv] && colvar.ss0[icv]<(cvw.lower[icv]+colvar.delta_r[icv]) && 
+       colvar.ss0[icv]>cvw.lower[icv] && colvar.on[icv]) { inv_ss0[icv] = 2.*cvw.lower[icv]-colvar.ss0[icv]; wall=1;}
+  }
+
+  if(wall) {
+    hills.ww[hills.n_hills] = hills.ww[hills.n_hills-1];
+    fprintf(file, "%10.3f   ", mtd_data->time);
+    for(icv=0;icv<ncv;icv++) {
+      hills.ss0_t[hills.n_hills][icv] = inv_ss0[icv];      // new hill center
+      if(colvar.on[icv]) fprintf(file, "%10.5f   ", hills.ss0_t[hills.n_hills][icv]);
+    }
+    for(icv=0;icv<ncv;icv++) {
+      colvar.delta_s[hills.n_hills][icv] = colvar.delta_r[icv];       // new hill width
+      if(colvar.on[icv]) fprintf(file, "%10.5f   ", colvar.delta_s[hills.n_hills][icv]);
+    }
+    wall=0;
+    fprintf(file, "%10.5f\n", hills.ww[hills.n_hills]);
+    hills.n_hills++;                              // hills added
+  }
+
+// INVERSION
+
+  if (logical.do_inversion) {
+    for(i_c=0;i_c<ncv;i_c++) {
+      if(colvar.on[i_c]) {
+        tmps=colvar.delta_r[i_c];
+        tmp=colvar.ss0[i_c];
+        for (j=0;j<2;j++) { // loop on 2 limits
+          if (logical.invert[i_c][j]) {
+            tmpd=fabs(colvar.inv_limit[i_c][j]-colvar.ss0[i_c]);
+            smooth_func=1/(1+pow(tmpd/(colvar.inv_inv[i_c]*colvar.inv_ref[i_c]*tmps),10));
+            if ( tmpd <= colvar.inv_ref[i_c]*tmps ) { // just mirror ...
+              colvar.ss0[i_c]=2*colvar.inv_limit[i_c][j]-tmp;
+
+              // ADD REFLECTED HILLS 
+              if(hills.n_hills+10>hills.ntothills) hills_reallocate(mtd_data);
+              hills.ww[hills.n_hills] = ww;
+              for(icv=0;icv<ncv;icv++) hills.ss0_t[hills.n_hills][icv] = colvar.ss0[icv];   // new hill center
+              for(icv=0;icv<ncv;icv++) colvar.delta_s[hills.n_hills][icv] = delta[icv];       // new hill width
+              // PRINT
+              if(!file) file = fopen((mtd_data->ionode?mtd_data->hilfilen:"/dev/null"), "a");
+
+              fprintf(file, "%10.3f   ", mtd_data->time);
+              for(icv=0;icv<ncv;icv++) if(colvar.on[icv]) fprintf(file, "%14.9f   ", hills.ss0_t[hills.n_hills][icv]);
+              for(icv=0;icv<ncv;icv++) if(colvar.on[icv]) fprintf(file, "%14.9f   ", colvar.delta_s[hills.n_hills][icv]);
+              if(logical.welltemp){
+               fprintf(file, "%14.9f   %4.3f \n", hills.ww[hills.n_hills]*colvar.wfactor/(colvar.wfactor-1.0)/mtd_data->eunit,colvar.wfactor);
+              } else {
+               fprintf(file, "%14.9f   %4.3f \n", hills.ww[hills.n_hills]/mtd_data->eunit,0.0);
+              }
+
+              hills.n_hills++;                              // hills added
+
+// flush all the time standalone: not a big deal...
+#ifdef STANDALONE
+  fclose(file);
+#endif
+
+              
+              // END ADD REFLECTED HILLS    
+              
+              colvar.ss0[i_c]=tmp; // back to current position
+            } else if ( smooth_func > 0.01 ) { // inversion condition
+              hills_force();
+              tmpF1=hills.Vhills; // F in current position
+              colvar.ss0[i_c]=colvar.inv_limit[i_c][j];
+              hills_force();
+              tmpF2=hills.Vhills; // F on the border
+              colvar.ss0[i_c]=2.*colvar.inv_limit[i_c][j]-tmp;
+              hills_force();
+              tmpF3=hills.Vhills; // F on symmetric position
+              if(hills.n_hills+10>hills.ntothills) hills_reallocate(mtd_data);
+              hills.ww[hills.n_hills] = (2.*tmpF2-tmpF1-tmpF3)*smooth_func;
+              if (fabs(hills.ww[hills.n_hills]) > colvar.inv_maxww[i_c]*ww) {
+                hills.ww[hills.n_hills] = (colvar.inv_maxww[i_c]*ww*fabs(hills.ww[hills.n_hills]))/hills.ww[hills.n_hills];
+              }
+    
+              // ADD INVERTED HILLS
+
+              for(icv=0;icv<ncv;icv++) hills.ss0_t[hills.n_hills][icv] = colvar.ss0[icv];   // new hill center
+              for(icv=0;icv<ncv;icv++) colvar.delta_s[hills.n_hills][icv] = delta[icv];       // new hill width
+              // PRINT
+              if(!file) file = fopen((mtd_data->ionode?mtd_data->hilfilen:"/dev/null"), "a");
+
+              fprintf(file, "%10.3f   ", mtd_data->time);
+              for(icv=0;icv<ncv;icv++) if(colvar.on[icv]) fprintf(file, "%14.9f   ", hills.ss0_t[hills.n_hills][icv]);
+              for(icv=0;icv<ncv;icv++) if(colvar.on[icv]) fprintf(file, "%14.9f   ", colvar.delta_s[hills.n_hills][icv]);
+              if(logical.welltemp){
+               fprintf(file, "%14.9f   %4.3f \n", hills.ww[hills.n_hills]*colvar.wfactor/(colvar.wfactor-1.0)/mtd_data->eunit,colvar.wfactor);
+              } else {
+               fprintf(file, "%14.9f   %4.3f \n", hills.ww[hills.n_hills]/mtd_data->eunit,0.0);
+              }
+
+              hills.n_hills++;                              // hills added
+
+// flush all the time standalone: not a big deal...
+#ifdef STANDALONE
+  fclose(file);
+#endif
+
+              // END ADD INVERTED HILLS 
+              
+              colvar.ss0[i_c]=tmp; // back to current position
+            }
+          } // check inversion active
+        } // loop on 2 limits
+      } // check active
+    } // loop on CVs, end of inversion
+  }
+
+// END INVERSION
+
+
+// FLUSH FILE
+  fflush(file);
+  if(logical.do_walkers){
+// we close it for multiple walkers calculation, so as to allow other processes to read it
+    fclose(file);
+    file=NULL;
+  }
+
+}
+
+// This routine add the gaussian hills
+void PREFIX hills_add(struct mtd_data_s *mtd_data)
+
+{
+  int icv,irep;
+  real* all_ww;
+  real** all_ss;
+  real** all_delta;
+  real  this_ww;
+  real  this_ss[nconst_max];
+  real  this_delta[nconst_max];
+  int ineighbour,distance;
+  int nrep,ncv;
+  int myrep;
+  static int last_hill_at_this_step;
+  static int first=1;
+
+  if(first) last_hill_at_this_step=colvar.it;
+  first=0;
+
+  ncv=colvar.nconst;
+
+  if(hills.max_height>0.0) hills.wwr=hills.rate*(colvar.it-last_hill_at_this_step)*mtd_data->dt;
+
+// ADD THE HILL
+  if(logical.welltemp) {
+/* since hills are added after the calculation of the bias potential, we can reuse
+   the stored Vhills to decide the hills height*/
+    this_ww = hills.wwr*exp(-hills.Vhills/(mtd_data->boltz*(colvar.wfactor-1.0)*colvar.simtemp));
+  } else this_ww = hills.wwr;	// new hill height 
+  for(icv=0;icv<ncv;icv++) this_ss[icv]    = colvar.ss0[icv];    	// new hill center
+  for(icv=0;icv<ncv;icv++) this_delta[icv] = colvar.delta_r[icv];       // new hill width
+
+  if(hills.max_height>0.0 && this_ww<hills.max_height && (colvar.it-last_hill_at_this_step)<hills.max_stride) return;
+  last_hill_at_this_step=colvar.it;
+
+  
+
+// add hill to the array
+  if(! (logical.remd && colvar.ptmetad_neighbours>0) ) hills_push(mtd_data,this_ww,this_ss,this_delta);
+
+// NEIGHBOURS HILLS for parallel tempering
+  if(logical.remd && colvar.ptmetad_neighbours>0){
+    nrep=mtd_data->nrepl;
+    myrep=mtd_data->repl;
+    all_ww=float_1d_array_alloc(nrep);
+    all_ss=float_2d_array_alloc(nrep,ncv);
+    all_delta=float_2d_array_alloc(nrep,ncv);
+    for(irep=0;irep<nrep;irep++)                          all_ww[irep]=0.0;
+    for(irep=0;irep<nrep;irep++) for(icv=0;icv<ncv;icv++) all_ss[irep][icv]=0.0;
+    for(irep=0;irep<nrep;irep++) for(icv=0;icv<ncv;icv++) all_delta[irep][icv]=0.0;
+// first broadcast on the master node of each replica
+    if(mtd_data->ionode){
+      all_ww[myrep]=this_ww;
+      for(icv=0;icv<ncv;icv++) all_ss[myrep][icv]=this_ss[icv];
+      for(icv=0;icv<ncv;icv++) all_delta[myrep][icv]=this_delta[icv];
+      plumed_intersum(mtd_data,nrep, & all_ww[0]);
+      plumed_intersum(mtd_data,nrep*ncv, & all_ss[0][0]);
+      plumed_intersum(mtd_data,nrep*ncv, & all_delta[0][0]);
+    }
+// then broadcast inside each replica
+    plumed_sum(mtd_data,nrep, & all_ww[0]);
+    plumed_sum(mtd_data,nrep*ncv, & all_ss[0][0]);
+    plumed_sum(mtd_data,nrep*ncv, & all_delta[0][0]);
+    for(ineighbour=0;ineighbour<nrep;ineighbour++){
+      distance=myrep-ineighbour;
+      if(distance<0) distance=-distance;
+      if(distance<=colvar.ptmetad_neighbours){
+        this_ww=all_ww[ineighbour]*exp(-0.5*distance*distance/(colvar.ptmetad_sigma*colvar.ptmetad_sigma));;
+        for(icv=0;icv<ncv;icv++)this_ss[icv]=all_ss[ineighbour][icv];
+        for(icv=0;icv<ncv;icv++)this_delta[icv]=all_delta[ineighbour][icv];
+        hills_push(mtd_data,this_ww,this_ss,this_delta);
+      }
+    }
+    free_1dr_array_alloc(all_ww);
+    free_2dr_array_alloc(all_ss,nrep);
+    free_2dr_array_alloc(all_delta,nrep);
+  }
+
+// After hill addition, update mtd_data.Vbias
+  hills.Vhills=hills_engine(colvar.ss0,colvar.ff_hills);
+}
+
+//-----------------------------------------------------------------------------------------------
+
+real PREFIX hills_engine_dp(int ih,real* ss0,real* dp){
+  int icv,ncv;
+  real dp2,diff;
+  ncv=colvar.nconst;
+  dp2 = 0.;
+  for(icv=0;icv<ncv;icv++)if(colvar.on[icv]){
+    dp[icv] = (ss0[icv]-hills.ss0_t[ih][icv])/colvar.delta_s[ih][icv];       // (cv(now)-hil(ih))/sigma
+    if(colvar.type_s[icv]==5 || (  colvar.type_s[icv]==34 &&  colvar.type[icv]==2 )) {
+      diff = ss0[icv]-hills.ss0_t[ih][icv];
+      if(diff>M_PI) diff-=2.*M_PI;
+      else if(diff<-M_PI) diff+=2.*M_PI;
+      dp[icv] = diff/colvar.delta_s[ih][icv];
+    }
+    dp2 += dp[icv]*dp[icv];                  // sum dp*dp
+  }
+  dp2 = 0.5*dp2;
+  return dp2;
+};
+
+real PREFIX hills_engine(real* ss0,real* force){
+/* this routine calculate hills forces and energy in an arbitrary point.
+   let us try to use it anywhere it is needed, so as to avoid errors and double coding.
+   in particular, ADD HERE VARIABLES NEEDING PBC
+   In GROMACS, DL_POLY, and AMBER it is parallel, and should be called
+   with the same arguments by all the processes belongin to a replica
+*/
+
+  int dp2index;
+  real dp2, dp[nconst_max], VhillsLast, diff;
+  real Vbias;
+
+  int nh,ncv;
+  int ih,icv;
+
+  int npe,rank;
+
+  int nhstart; /* first hill belonging to this process */
+  int nhstride; /* stride for hills belonging to this process */
+
+  nh=hills.n_hills;
+  ncv=colvar.nconst;
+
+  if(logical.parallel_hills){
+    npe=plumed_comm_size(&mtd_data);
+    rank=plumed_comm_rank(&mtd_data);
+  }else{
+    npe=1;
+    rank=0;
+  };
+
+  if(logical.do_grid){
+/*
+   when grid are used, it is better NOT to parallelize on hill index.
+   in fact, since grid are based on a non-linear spline, splitting the hills among different processors
+   leads to slighlty different forces, which means non reproducibility in parallel calculations.
+   moreover, the advantage of this parallelization is only when restarting (usually one hill at a time is added)
+*/
+    nhstart=0;
+    nhstride=1;
+  }else{
+    nhstart=rank;
+    nhstride=npe;
+  };
+
+  Vbias=0.0;
+  if(force) for(icv=0;icv<ncv;icv++) force[icv]=0.0;
+
+// This loop is parallelized
+// if logical.debug_grid is set, the actual force is calculated with the hills, but
+// in a debug file we write the actual and the grid force and energy
+  for(ih=nhstart;ih<nh;ih+=nhstride){
+    if(logical.do_grid && ih>=grid.nhills && ih < hills.read) grid_addhills(&grid,hills.ww[ih],hills.ss0_t[ih],colvar.delta_s[ih],rank,npe);
+    if(!logical.do_grid || logical.debug_grid || ih >= hills.read) {
+     
+      dp2=hills_engine_dp(ih,ss0,dp);
+      if(dp2<DP2CUTOFF){
+        dp2index =  dp2*GTAB/DP2CUTOFF;
+        VhillsLast = hills.ww[ih]*hills.exp[dp2index];
+        Vbias += VhillsLast;
+        if(force) for(icv=0;icv<ncv;icv++) if(colvar.on[icv]) {
+          if(logical.interval[icv]) {
+            if((ss0[icv]> cvint.lower_limit[icv] && ss0[icv]<cvint.upper_limit[icv])) force[icv] += dp[icv]/colvar.delta_s[ih][icv]*VhillsLast;  // -dU/dCV
+          } else {
+            force[icv] += dp[icv]/colvar.delta_s[ih][icv]*VhillsLast;  // -dU/dCV
+          }
+        }
+      }
+
+    }
+  }
+
+  if(logical.do_grid) {
+    grid.nhills = hills.read;
+    if(!logical.debug_grid){
+      Vbias+=grid_getstuff(&grid,ss0,force);
+    } else {
+      static FILE *file=NULL;
+      if(!file) {
+        char buf[1024];
+        sprintf(buf,"DEBUG_GRID%i+%i",mtd_data.repl,plumed_comm_rank(&mtd_data));
+        fprintf(stderr,"%s\n",buf);
+        file=fopen(buf,"w");
+        
+      }
+      real VbiasG;
+      real forceG [nconst_max];
+      int i;
+      for(i=0;i<ncv;i++)  forceG[i]=0;
+      VbiasG=grid_getstuff(&grid,ss0,forceG);
+      for(i=0;i<ncv;i++) fprintf(file," %f",ss0[i]);
+      fprintf(file,"   %f %f    ",Vbias,VbiasG);
+      if(force) for(i=0;i<ncv;i++) fprintf(file," %f %f",force[i],forceG[i]);
+      fprintf(file,"\n");
+    }
+  }
+
+/* when using grid, each process knows the whole grid, so there is no need to reduce */
+  if(logical.parallel_hills && ! logical.do_grid){
+    if(force) plumed_sum(&mtd_data,ncv, & force[0]);
+    plumed_sum(&mtd_data,1, & Vbias);
+  }
+  
+  return Vbias;
+};
+
+// This routine calculate the hills contribution
+void PREFIX hills_force()
+{
+  hills.Vhills=hills_engine(colvar.ss0,colvar.ff_hills);
+}
+
+//-----------------------------------------------------------------------------------------------
+
+// This routine read the HILLS file
+void PREFIX read_hills(struct  mtd_data_s *mtd_data, int restart, int first_read)
+{
+  double dummy;
+  real  old_factor;
+  int i, j, nactive, iw;
+  long int line;
+  FILE *file;
+  char *str, stringa[64000];
+  char walkfilen[64000];
+
+  if(restart) hills.first_read=0;
+  
+  /****************************** UPDATING *************************/
+
+  for(iw=0;iw<hills.nwalkers;iw++){                                                             // cycle on walkers
+
+   file=NULL;
+  
+   if(logical.do_walkers) {
+    sprintf(walkfilen, "%s.%i", mtd_data->basefilen, iw);  
+   } else {
+    sprintf(walkfilen, "%s", mtd_data->hilfilen); 
+   }
+
+   file = fopen(walkfilen, "r");
+   if(!file && logical.do_walkers) continue;
+   if(!file && !logical.do_walkers) {										// not exist
+           char buf[1024];
+           sprintf(buf,"Cannot read HILLS file :: %s",mtd_data->hilfilen);
+           plumed_error(buf);
+   }
+   fflush(file); 
+
+   if(!restart && !first_read)fsetpos(file,&(hills.line_counter[iw]));
+ 
+   line = hills.read;
+ 
+   int active_to_ind[nconst_max];
+   nactive=0.; //number of active cvs 
+   for(i=0;i<colvar.nconst;i++){
+      if(colvar.on[i]){active_to_ind[nactive]=i;nactive++;}
+   }
+ 
+   while(1){											// read cycle
+     str = fgets(stringa, 64000, file);
+     if(str == NULL) break;
+ 
+     // reallocate if needed during reading
+     if(line+10>hills.ntothills) hills_reallocate(mtd_data);  
+ 
+     j=0;
+     str =(char *) strtok(stringa," \t");
+     // skip header line
+     if(strcmp(str,"#!")==0||strcmp(str,"#")==0){ continue; }
+     while (str != NULL)
+     {
+       if( j>0 && j <=nactive  ) { 
+           i=active_to_ind[j-1];
+           sscanf(str, "%lf", &dummy);
+           hills.ss0_t[line][i] = (real) dummy; 
+       //    printf("POS %d   %f ",i,  hills.ss0_t[line][i] );
+       }
+       else if( j>nactive && j<= 2*nactive ) { 
+           i=active_to_ind[j-nactive-1];
+           sscanf(str, "%lf", &dummy);
+           colvar.delta_s[line][i] = (real) dummy;							// read the hills dimension
+       //    printf("DELTA %d   %f ",i, colvar.delta_s[line][i]);
+       }
+       else if( j==2*nactive+1 ) { 
+           sscanf(str, "%lf", &dummy);
+           hills.ww[line] = (real) dummy * mtd_data->eunit;                                                              // read the hills height
+       //   printf("WW   %f \n", hills.ww[line]);
+       }
+       else if( j==2*nactive+2 ) {
+           sscanf(str, "%lf", &dummy);
+           old_factor = (real) dummy;
+           if(logical.welltemp && !logical.read_old_bf) hills.ww[line] = hills.ww[line] * (colvar.wfactor-1.0) / colvar.wfactor;
+           if(logical.welltemp && logical.read_old_bf){
+            if(old_factor<1.0) plumed_error("Restarting from a non-welltempered metadynamics. Please remove READ_OLD_BF."); 
+            hills.ww[line] = hills.ww[line] * (old_factor-1.0) / old_factor;
+//            printf("BF   %f \n", old_factor);
+           }
+       }
+       str =(char *) strtok(NULL, " \t");
+       j++;
+     }
+     line++;
+   }
+   
+   fgetpos(file,&(hills.line_counter[iw]));
+ 
+   fclose(file);
+   hills.n_hills = line;
+ 
+   if(restart){
+     fprintf(mtd_data->fplog, "|- RESTARTING HILLS: TOT %li HILLS read from %s\n",hills.n_hills-hills.read,walkfilen);
+   }else{
+     if(hills.n_hills-hills.read>0) 
+      fprintf(mtd_data->fplog, "|- UPDATING HILLS: from %li to %li TOT %li HILLS read from %s \n", hills.read,hills.n_hills-1,hills.n_hills-hills.read,walkfilen);
+   }
+   hills.read=hills.n_hills;
+
+  } // end cycle on walkers
+  
+//  for(i=hills.read;i<hills.n_hills;i++) fprintf(mtd_data->fplog, "UPDATING # %i HILLS %f %f \n",i,hills.ss0_t[i][0],hills.ss0_t[i][1]);
+//  for(i=0;i<hills.n_hills;i++) fprintf(mtd_data->fplog, "AFTER UPDATE # %i HILLS %f %f \n",i,hills.ss0_t[i][0],hills.ss0_t[i][1]);
+  fprintf(mtd_data->fplog,"\n");
+  fflush(mtd_data->fplog);
+}
+
+//------------------------------------------------------------------------------------------
+
+void PREFIX hills_reallocate( struct mtd_data_s *mtd_data) { 
+      int i,j,k;
+      long int oldtot;
+      real  *ww_tmp;
+      real  **ss0_t_tmp;
+      real  **delta_s_tmp; 
+
+      oldtot=hills.ntothills;
+      hills.ntothills+=STACKDIM ;
+
+      fprintf(mtd_data->fplog,"HILLS REALLOCATION--OLD DIMENSION: %li\n",oldtot);
+      // save pointers to old arrays
+      ww_tmp        = hills.ww;
+      ss0_t_tmp     = hills.ss0_t;
+      delta_s_tmp   = colvar.delta_s;
+
+      // reallocate to the new stackdim
+      hills.ww        = float_1d_array_alloc(hills.ntothills);
+      hills.ss0_t     = float_2d_array_alloc(hills.ntothills,colvar.nconst); 
+      colvar.delta_s  = float_2d_array_alloc(hills.ntothills,colvar.nconst);   
+
+      // copy old arrays to new ones
+      // WE COPY THE FULL ARRAY, NOT JUST hills.n_hills.
+      // this is safer, since in reallocation during reading n_hills only set at the end
+      for (i=0;i<oldtot;i++){
+            hills.ww[i]=ww_tmp[i];  
+            for (j=0;j<colvar.nconst;j++) hills.ss0_t[i][j]=ss0_t_tmp[i][j]; 
+            for (j=0;j<colvar.nconst;j++) colvar.delta_s[i][j]=delta_s_tmp[i][j]; 
+      } 
+
+      // free old arrays
+      free_1dr_array_alloc(ww_tmp);
+      free_2dr_array_alloc(ss0_t_tmp,oldtot);
+      free_2dr_array_alloc(delta_s_tmp,oldtot);
+
+      fprintf(mtd_data->fplog,"HILLS REALLOCATION--NEW DIMENSION: %li\n",hills.ntothills);
+}
+//-------------------------------------------------------------------------------------------
+// Calculate total grid dimension, allocate and initialize
+void PREFIX grid_initialize(struct grid_s *grid)
+{
+
+ int i, j, ncv;
+ 
+ grid->one2multi      = NULL;
+ grid->one2multi_full = NULL;
+ grid->size           = 1;
+ ncv                  = grid->ncv;
+ 
+ for(i=0;i<ncv;i++) {
+  grid->lbox[i]  = grid->max[i] - grid->min[i];  
+  grid->dx[i]    = grid->lbox[i] / grid->bin[i];
+  if(grid->period[i]==0){
+   grid->max[i]  += grid->dx[i];
+   grid->lbox[i] += grid->dx[i];
+   grid->bin[i]  += 1;
+  }
+  grid->size    *= grid->bin[i];
+ }
+
+// allocation
+ grid->pot   = float_1d_array_alloc(grid->size);  
+ grid->force = float_2d_array_alloc(grid->size,ncv);
+ grid->one2multi_full=int_2d_array_alloc(grid->size,grid->ncv); 
+// filling one2multi_full
+ grid_create_one2multi(grid->one2multi_full, grid->size, grid->ncv, grid->bin); 
+
+ grid->mem = (ncv+1)*grid->size*sizeof(real)/pow(1024.0,2);
+//fprintf(stderr,"FFF %i\n",plumed_comm_rank(&mtd_data));
+ fprintf(mtd_data.fplog,"|- GRID MEMORY USAGE :: %6.2f MB \n",grid->mem);
+
+ for(j=0;j<grid->size;j++) {
+  grid->pot[j] = 0. ;
+  for(i=0;i<ncv;i++) grid->force[j][i] = 0. ;
+ }
+
+}
+//-------------------------------------------------------------------------------------------
+// Calculate reduced grid dimension. This routine is called once unless
+// the Gaussian sigma (colvar.delta) is modified during the simulation.
+void PREFIX grid_resize_minigrid(struct grid_s *grid, real* delta, real cutoff)
+{
+
+ real mem;
+ int  i, ncv;
+
+// store cutoff for later use
+ grid->cutoff   = cutoff;
+ ncv            = grid->ncv;
+ grid->minisize = 1;
+
+ for(i=0;i<ncv;i++) {
+  grid->minilbox[i] = sqrt(2.*cutoff)*delta[grid->index[i]];      // this is HALF the side of minibox
+  grid->minibin[i]  = floor(2.*grid->minilbox[i]/grid->dx[i])+1;
+  grid->minisize   *= grid->minibin[i];
+ } 
+
+ fprintf(mtd_data.fplog,"|- UPDATING REDUCED GRID: SIZE %d pts on %d ",grid->minisize,grid->size);
+ fprintf(mtd_data.fplog," DIMENSION "); for(i=0;i<ncv-1;i++) fprintf(mtd_data.fplog," %d x",grid->minibin[i]); 
+ fprintf(mtd_data.fplog," %d \n",grid->minibin[ncv-1]);
+
+// deallocate if previously allocated
+ if(grid->one2multi) free_2di_array_alloc(grid->one2multi,grid->minisize);
+// new allocation
+ grid->one2multi = int_2d_array_alloc(grid->minisize,grid->ncv);
+ mem = grid->minisize*grid->ncv*sizeof(int)/pow(1024.0,2);
+ fprintf(mtd_data.fplog,"|- GRID MEMORY USAGE :: %6.2f MB \n", grid->mem+mem);
+
+// create one2multi vector
+ grid_create_one2multi(grid->one2multi, grid->minisize, grid->ncv, grid->minibin);
+
+}
+//-------------------------------------------------------------------------------------------
+// Allocate and create one2multi/one2multi_full vector. 
+// One2multi is needed to work efficiently on the reduced grid:
+// the routine is called once for the minigrid unless the HILLS delta is modified during the simulation.
+// One2multi_full is used when writing or restarting a simulation from a GRID on file
+void PREFIX grid_create_one2multi(int **one2multi, int size, int ncv, int *bin)
+{
+
+ int i, j, k, tmpgrid, index1d;
+
+ if(ncv==1) {
+  for(i=0;i<size;i++) one2multi[i][0] = i;
+ } else {
+  for(i=0;i<size;i++){
+   index1d=i;
+   for(j=ncv-1;j>=0;j--){
+    tmpgrid = 1;
+    for(k=0;k<j;k++) tmpgrid*=bin[k];
+    one2multi[i][j] = index1d/tmpgrid;
+    index1d = index1d%tmpgrid;
+    if(index1d==-1) {
+     one2multi[i][j] -= 1;
+     index1d=tmpgrid;
+    }
+   }
+  } 
+ }
+
+}
+//-------------------------------------------------------------------------------------------
+// add a hills on the grid. Update potential and force
+void PREFIX grid_addhills(struct grid_s *grid, real ww, real* ss, real* delta,int rank,int npe)
+{
+
+ int   i, j, ncv, flag; 
+ real *xx, *dp, dp2, expo; 
+ int  *index_nd, index_1d, dp2index;
+ int *index_1d_para;
+ real *pot_for_para;
+
+ ncv  = grid->ncv;
+
+// allocate temp array
+ xx       = float_1d_array_alloc(ncv);
+ dp       = float_1d_array_alloc(ncv);
+ index_nd = int_1d_array_alloc(ncv); 
+
+// preliminary checks
+// 1) if the HILLS center is inside the grid
+// 2) if the GRID bin size is too large
+// 3) if delta is changed from previous call
+ flag = 0.;
+ for(j=0;j<ncv;j++) {
+  if((ss[grid->index[j]]<grid->min[j] || ss[grid->index[j]]>=grid->max[j]) && !grid->period[j])
+   plumed_error("HILLS outside GRID. Please increase GRID size."); 
+  if(grid->dx[j]>delta[grid->index[j]]/2.0) plumed_error("GRID bin size is too large compared to HILLS sigma."); 
+  if(fabs((grid->oldelta[j]-delta[grid->index[j]])/delta[grid->index[j]])>0.05) flag=1; 
+ }
+// recalculate the dimension of the reduced grid if delta is changed
+ if(flag==1) {
+  grid_resize_minigrid(grid,delta,DP2CUTOFF);
+  for(j=0;j<ncv;j++) grid->oldelta[j] = delta[grid->index[j]];
+ }
+
+// temporary array for parallel computation
+ index_1d_para=int_1d_array_alloc(grid->minisize);
+ pot_for_para=float_1d_array_alloc(grid->minisize*(1+ncv));
+ for(i=0;i<grid->minisize;i++) index_1d_para[i]=0;
+ for(i=0;i<grid->minisize*(1+ncv);i++) pot_for_para[i]=0.0;
+
+// add HILL to the points belonging to the reduced GRID
+ for(i=rank;i<grid->minisize;i+=npe) {
+
+  index_1d_para[i]=-1; // it means "no force on this point"
+
+  flag=0;
+  for(j=0;j<ncv;j++) {
+   xx[j] = ss[grid->index[j]] - grid->minilbox[j] + grid->dx[j] * grid->one2multi[i][j];  
+   if(grid->period[j]) xx[j] -= grid->lbox[j] * rint(xx[j]/grid->lbox[j]);
+   if((xx[j]<grid->min[j] || xx[j]>=grid->max[j]) && !grid->period[j])  flag=1;
+   index_nd[j] = floor((xx[j]-grid->min[j])/grid->dx[j]);
+  }
+  if(flag==1) continue; // out of grid 
+
+// from multidimensional index to mono
+  index_1d=grid_multi2one(grid,index_nd);
+
+// add the gaussian on the GRID
+  dp2 = 0.;
+  for(j=0;j<ncv;j++) {
+   xx[j] = grid->min[j] + grid->dx[j] * index_nd[j];
+   dp[j] = xx[j] - ss[grid->index[j]];
+   if(grid->period[j]) dp[j] -= grid->lbox[j] * rint(dp[j]/grid->lbox[j]); 
+   dp[j] /= delta[grid->index[j]];
+   dp2 += dp[j]*dp[j]; 
+  }
+  dp2 *= 0.5;
+
+  if(dp2<grid->cutoff){                  // always??    
+   dp2index =  dp2*GTAB/DP2CUTOFF;
+   expo     = ww*hills.exp[dp2index];
+   pot_for_para[i*(ncv+1)]=expo;
+   for(j=0;j<ncv;j++) pot_for_para[i*(ncv+1)+1+j]=dp[j]/delta[grid->index[j]]*expo;
+   index_1d_para[i]=index_1d;
+//   grid->pot[index_1d] += expo;
+//   for(j=0;j<ncv;j++) grid->force[index_1d][j] += dp[j]/delta[grid->index[j]]*expo;
+  }
+ 
+ }
+
+ if(npe>1){ 
+   plumed_sum (&mtd_data,grid->minisize*(ncv+1),pot_for_para);
+   plumed_sumi(&mtd_data,grid->minisize,index_1d_para);
+ }
+
+ for(i=0;i<grid->minisize;i++) {
+   if(index_1d_para[i]<0) continue;
+   grid->pot[index_1d_para[i]]+=pot_for_para[i*(ncv+1)];
+   for(j=0;j<ncv;j++) grid->force[index_1d_para[i]][j] += pot_for_para[i*(ncv+1)+1+j];
+ }
+
+// deallocation
+ free_1dr_array_alloc(dp);
+ free_1dr_array_alloc(xx);
+ free_1di_array_alloc(index_nd);
+
+ free_1dr_array_alloc(pot_for_para);
+ free_1di_array_alloc(index_1d_para);
+
+}
+//-------------------------------------------------------------------------------------------
+// from multidimensional index to mono dimensional
+int PREFIX grid_multi2one(struct grid_s *grid, int* index_nd)
+{
+ int i, j, index, tmpgrid;
+
+ index = index_nd[0];
+ 
+ for(i=1;i<grid->ncv;i++) {
+  tmpgrid = 1;
+  for(j=0;j<i;j++) tmpgrid *= grid->bin[j];
+  index += index_nd[i]*tmpgrid;
+ }
+  
+ return index;
+
+}
+//-------------------------------------------------------------------------------------------
+// this routine returns the bias in a certain point and optionally the forces
+real PREFIX grid_getstuff(struct grid_s *grid, real* ss0, real* force)
+{
+
+ real *xx;
+ int  j, *index_nd, index_1d, ncv;
+ real Vbias;
+
+ ncv  = grid->ncv;
+
+// allocate temp array
+ xx       = float_1d_array_alloc(ncv);
+ index_nd = int_1d_array_alloc(ncv);
+
+// first check if the point is inside the GRID
+ for(j=0;j<ncv;j++) {
+  xx[j] = ss0[grid->index[j]];
+  if((xx[j]<grid->min[j] || xx[j]>=grid->max[j]) && !grid->period[j]) plumed_error("You are outside the GRID!. Please increase GRID size.");
+  if(grid->period[j])  xx[j] -= grid->lbox[j] * rint(xx[j]/grid->lbox[j]);
+  index_nd[j] = floor((xx[j]-grid->min[j])/grid->dx[j]);
+ }
+
+// from multidimensional index to mono
+ index_1d=grid_multi2one(grid,index_nd);
+
+ if(!logical.donot_spline){
+   real f;
+   real where[nconst_max];
+   int  stride[nconst_max];
+   real der[nconst_max];
+   for(j=0;j<ncv;j++) where[j]=xx[j]-grid->min[j]-index_nd[j]*grid->dx[j];
+   stride[0]=1;
+   for(j=1;j<ncv;j++) stride[j]=stride[j-1]*grid->bin[j-1];
+   for(j=0;j<ncv;j++) if(grid->period[j]  && index_nd[j]==grid->bin[j]-1) stride[j]*=(1-grid->bin[j]);
+   for(j=0;j<ncv;j++) if(!grid->period[j] && index_nd[j]==grid->bin[j]-1) plumed_error("You are outside the GRID!. Please increase GRID size.");
+   f=spline(ncv,grid->dx,where,& grid->pot[index_1d],&grid->force[index_1d][0],stride,der);
+   Vbias=f;
+   if(force) for(j=0;j<ncv;j++) force[grid->index[j]] -=der[j];
+ } else {
+// getting BIAS and FORCE
+   Vbias = grid->pot[index_1d];
+   if(force) for(j=0;j<ncv;j++) force[grid->index[j]] += grid->force[index_1d][j];
+ }
+
+// free
+ free_1dr_array_alloc(xx);
+ free_1di_array_alloc(index_nd);
+
+ return Vbias;
+}
+//-------------------------------------------------------------------------------------------
+// write GRID to file
+void  PREFIX grid_write_tofile(struct grid_s *grid)
+{
+
+ int      i, j, *index_nd, *bin;
+ real   *xx, *max;
+ FILE     *file=NULL;
+
+// Open grid file for writing 
+ file = fopen(grid->w_file, "w");
+
+// Allocate stuff
+ xx       = float_1d_array_alloc(grid->ncv);
+ max      = float_1d_array_alloc(grid->ncv);
+ index_nd = int_1d_array_alloc(grid->ncv);
+ bin      = int_1d_array_alloc(grid->ncv); 
+
+// if the cv is not periodic we have to subtract 
+// in output 1 to bin size and dx to max
+// to respect our convention
+ for(i=0;i<grid->ncv;i++){
+  if(grid->period[i]==0){
+   bin[i]=grid->bin[i]-1;
+   max[i]=grid->max[i]-grid->dx[i];
+  } else {
+   bin[i]=grid->bin[i];
+   max[i]=grid->max[i];
+  }
+ }
+
+// HEADER
+ fprintf(file,"#! FORCE 1\n");
+ fprintf(file,"#! NVAR %d\n",grid->ncv);
+ fprintf(file,"#! TYPE"); for(i=0;i<grid->ncv;i++) fprintf(file," %d",  colvar.type_s[grid->index[i]]); fprintf(file,"\n");
+ fprintf(file,"#! BIN");  for(i=0;i<grid->ncv;i++) fprintf(file," %d",  bin[i]);                        fprintf(file,"\n");
+ fprintf(file,"#! MIN");  for(i=0;i<grid->ncv;i++) fprintf(file," %lf", grid->min[i]);                  fprintf(file,"\n"); 
+ fprintf(file,"#! MAX");  for(i=0;i<grid->ncv;i++) fprintf(file," %lf", max[i]);                        fprintf(file,"\n");
+ fprintf(file,"#! PBC");  for(i=0;i<grid->ncv;i++) fprintf(file," %d",  grid->period[i]);               fprintf(file,"\n");
+
+// GRID
+ for(i=0;i<grid->size;i++){
+  for(j=0;j<grid->ncv;j++) {
+   xx[j] = grid->min[j] + grid->dx[j] * grid->one2multi_full[i][j];  
+   fprintf(file," %lf ",xx[j]);
+  }
+  fprintf(file," %lf ",grid->pot[i]/mtd_data.eunit);
+  for(j=0;j<grid->ncv;j++) fprintf(file," %lf ",grid->force[i][j]/mtd_data.eunit); fprintf(file,"\n");
+  if(grid->one2multi_full[i][0]==(grid->bin[0]-1)) fprintf(file,"\n");
+ }
+
+// Deallocation
+ free_1dr_array_alloc(xx);
+ free_1dr_array_alloc(max);
+ free_1di_array_alloc(index_nd);  
+ free_1di_array_alloc(bin);
+
+// Final stuff
+ fflush(file);
+ fclose(file);
+
+}
+//-------------------------------------------------------------------------------------------
+// read a GRID from file
+void  PREFIX grid_read_fromfile(struct grid_s *grid, int bias)
+{
+ struct grid_s tmpgrid;
+ int      i, j, with_force=0, isave, line, m;
+ int      header, *index_nd, index_1d;
+ char     str1[30], str2[30], str3[30];
+ char     *str, stringa[800];
+ FILE     *file=NULL;
+ real   *ff, *xx, Vgrid=0., Vp, Vm;
+ double  tmp;
+
+// open grid file for reading
+ file = fopen(grid->r_file, "r");
+ if(!file) plumed_error("Cannot read GRID file!\n");
+
+// read HEADER
+ header = 0;
+ fprintf(mtd_data.fplog,"** READING GRID FROM FILE %s\n",grid->r_file);
+// first you need NVAR for allocation
+ str = fgets(stringa, 800, file);
+ while(1){
+   if(sscanf(str,"%s %s%n",str1,str2,&m)>0){
+    if(strcmp(str1,"#!") == 0){
+     str +=m;
+     if(strcmp(str2,"NVAR") == 0)  {sscanf(str,"%d",&(tmpgrid.ncv)); header +=1;}
+    } else if(strcmp(str1,"#") != 0) break;
+   }
+   str = fgets(stringa, 800, file);
+ }
+ // checking for missing or wrong data 
+ if(header!=1) plumed_error("Missing or wrong data in GRID header!\n");
+// and then parse the rest
+ rewind(file);
+ str = fgets(stringa, 800, file);
+ while(1){
+   if(sscanf(str,"%s %s%n",str1,str2,&m)>0){
+    if(strcmp(str1,"#!") == 0){
+     str +=m;
+     if(strcmp(str2,"FORCE") == 0) {sscanf(str,"%s%n",str3,&m); with_force=atoi(str3); header +=1;str +=m;}
+     if(strcmp(str2,"TYPE") == 0)  {for(i=0;i<tmpgrid.ncv;i++) {sscanf(str,"%s%n",str3,&m); tmpgrid.index[i]  = atoi(str3);str +=m;} header +=1;}
+     if(strcmp(str2,"BIN") == 0)   {for(i=0;i<tmpgrid.ncv;i++) {sscanf(str,"%s%n",str3,&m); tmpgrid.bin[i]    = atoi(str3);str +=m;} header +=1;}
+     if(strcmp(str2,"MIN") == 0)   {for(i=0;i<tmpgrid.ncv;i++) {sscanf(str,"%s%n",str3,&m); tmpgrid.min[i]    = atof(str3);str +=m;} header +=1;}
+     if(strcmp(str2,"MAX") == 0)   {for(i=0;i<tmpgrid.ncv;i++) {sscanf(str,"%s%n",str3,&m); tmpgrid.max[i]    = atof(str3);str +=m;} header +=1;}
+     if(strcmp(str2,"PBC") == 0)   {for(i=0;i<tmpgrid.ncv;i++) {sscanf(str,"%s%n",str3,&m); tmpgrid.period[i] = atoi(str3);str +=m;} header +=1;}
+    } else if(strcmp(str1,"#") == 0) printf("   COMMENT: %s",stringa);
+    else break;
+   }
+   str = fgets(stringa, 800, file);
+ }
+
+// checking for missing or wrong data 
+ if(header!=7) plumed_error("Missing or wrong data in GRID header!\n");
+// compare with  grid.ncv
+ if(grid->ncv!=tmpgrid.ncv) plumed_error("Inconsistency between NVAR on file and in the PLUMED input file\n");
+// compare with grid.index
+ for(i=0;i<tmpgrid.ncv;i++) if(tmpgrid.index[i]!=(colvar.type_s[grid->index[i]])) 
+  plumed_error("Inconsistency between CV TYPES on file and in the PLUMED input file\n"); 
+// printout HEADER 
+ fprintf(mtd_data.fplog,"   NVAR :: %d \n",tmpgrid.ncv);
+ fprintf(mtd_data.fplog,"   BIN  :: "); for(i=0;i<tmpgrid.ncv;i++) fprintf(mtd_data.fplog,"%d ",tmpgrid.bin[i]); fprintf(mtd_data.fplog,"\n");
+ fprintf(mtd_data.fplog,"   MIN  :: "); for(i=0;i<tmpgrid.ncv;i++) fprintf(mtd_data.fplog,"%lf ",tmpgrid.min[i]); fprintf(mtd_data.fplog,"\n");
+ fprintf(mtd_data.fplog,"   MAX  :: "); for(i=0;i<tmpgrid.ncv;i++) fprintf(mtd_data.fplog,"%lf ",tmpgrid.max[i]); fprintf(mtd_data.fplog,"\n");
+ fprintf(mtd_data.fplog,"   PBC  :: "); for(i=0;i<tmpgrid.ncv;i++) if(tmpgrid.period[i]==0) fprintf(mtd_data.fplog,"OFF "); else fprintf(mtd_data.fplog,"ON "); 
+ fprintf(mtd_data.fplog,"\n");
+
+// if reading an external potential we can start initialize something
+// No need if bias==1 since grid is initialized in read_restraint
+ if(bias==0){                           
+  for(i=0;i<grid->ncv;i++){
+   grid->bin[i]    = tmpgrid.bin[i];
+   grid->min[i]    = tmpgrid.min[i];
+   grid->max[i]    = tmpgrid.max[i];
+   grid->period[i] = tmpgrid.period[i];
+  }
+  grid_initialize(grid);
+ }
+
+// copying grid.index into tmpgrid.index
+ for(i=0;i<tmpgrid.ncv;i++) tmpgrid.index[i]=grid->index[i];
+// and initializing tmpgrid
+ grid_initialize(&tmpgrid);
+
+// allocating temp arrays
+ xx       = float_1d_array_alloc(tmpgrid.ncv);
+ ff       = float_1d_array_alloc(tmpgrid.ncv);
+ index_nd = int_1d_array_alloc(tmpgrid.ncv);
+
+// now parsing the grid for potential and forces 
+ line = 0;
+ while(1){                                     
+   if(sscanf(str,"%s %s",str1,str2)>0){
+     j=0;
+     str =(char *) strtok(stringa," \t");
+     while (str != NULL)
+     { 
+      if(j>=0 && j<tmpgrid.ncv) { sscanf(str, "%lf", &tmp); xx[j]=(real)tmp;}
+      if(j==tmpgrid.ncv)       { sscanf(str, "%lf", &tmp); Vgrid = (real)tmp;}
+      if(j>tmpgrid.ncv && j<=2*tmpgrid.ncv && with_force==1) {sscanf(str, "%lf", &tmp); ff[j-tmpgrid.ncv-1]=(real)tmp;}
+      str =(char *) strtok(NULL, " \t");
+      j++;
+     }
+// find multi dimensional index
+     for(i=0;i<tmpgrid.ncv;i++) index_nd[i] = floor((xx[i]+tmpgrid.dx[i]/2.-tmpgrid.min[i])/tmpgrid.dx[i]);
+// and mono-dimensional
+     index_1d=grid_multi2one(&tmpgrid,index_nd);
+     if(index_1d!=line) plumed_warn("GRID on file is not in the usual PLUMED format");
+// Storing potential...
+     tmpgrid.pot[index_1d]=Vgrid*mtd_data.eunit;
+// ...and forces 
+     if(with_force==1) for(i=0;i<tmpgrid.ncv;i++) tmpgrid.force[index_1d][i]=ff[i]*mtd_data.eunit; 
+// new line
+     line++;
+   }
+     str = fgets(stringa, 800, file);
+     if(str == NULL) break;
+ }
+
+// check total size and line
+  if(line!=tmpgrid.size) plumed_error("GRID entries on file are not consistent with the declared dimension \n");
+
+// if derivatives are missing, finite differences... 
+  if(with_force==1) fprintf(mtd_data.fplog,"** FORCE DATA ARE PRESENT ON FILE\n");
+  else {
+   fprintf(mtd_data.fplog,"** NO FORCE DATA ON FILE: FINITE DIFFERENCES\n");
+   for(i=0;i<tmpgrid.size;i++){
+    for(j=0;j<tmpgrid.ncv;j++) index_nd[j] = tmpgrid.one2multi_full[i][j];
+    for(j=0;j<tmpgrid.ncv;j++){
+       isave=index_nd[j]; index_nd[j] += 1;
+       if(index_nd[j]==tmpgrid.bin[j]  && tmpgrid.period[j]==0) {tmpgrid.force[i][j]=0.0; continue;}
+       if(index_nd[j]==tmpgrid.bin[j]  && tmpgrid.period[j]==1) index_nd[j] = 0; 
+       index_1d=grid_multi2one(&tmpgrid,index_nd); 
+       Vp=tmpgrid.pot[index_1d];
+       index_nd[j]=isave; index_nd[j] -= 1;
+       if(index_nd[j]==-1  && tmpgrid.period[j]==0) {tmpgrid.force[i][j]=0.0; continue;}
+       if(index_nd[j]==-1  && tmpgrid.period[j]==1) index_nd[j] = tmpgrid.bin[j]-1;
+       index_1d=grid_multi2one(&tmpgrid,index_nd);
+       Vm=tmpgrid.pot[index_1d]; 
+       index_nd[j]=isave;
+       tmpgrid.force[i][j]=-(Vp-Vm)/2.0/tmpgrid.dx[j];
+    }
+   }
+  }
+
+// Now tmpgrid is complete. Time to clone it to grid.
+// And interpolate if necessary. 
+ grid_clone(&tmpgrid, grid);
+
+// Deallocation
+ free_1dr_array_alloc(ff);
+ free_1dr_array_alloc(xx);
+ free_1di_array_alloc(index_nd);
+ free_2di_array_alloc(tmpgrid.one2multi_full,tmpgrid.size);
+ free_1dr_array_alloc(tmpgrid.pot);
+ free_2dr_array_alloc(tmpgrid.force, tmpgrid.size);
+
+// Final stuff
+ fclose(file);
+ fprintf(mtd_data.fplog,"\n");
+} 
+//-------------------------------------------------------------------------------------------
+void PREFIX grid_clone(struct grid_s *grid1, struct grid_s *grid2)
+{
+
+ int      i, j, just_copy, out_grid;
+ real   xx[nconst_max], ff[nconst_max]; 
+
+// A copy is enough ??
+// - check number of bins
+// - check boundaries
+ just_copy=1;
+ for(i=0;i<grid1->ncv;i++) {
+  if(grid1->bin[i]!=grid2->bin[i]) just_copy=0;
+  if(fabs(grid1->min[i]-grid2->min[i])>0.00001) just_copy=0;
+  if(fabs(grid1->max[i]-grid2->max[i])>0.00001) just_copy=0;
+ }
+
+ fprintf(mtd_data.fplog,"** CLONING GRID "); if(just_copy==0) fprintf(mtd_data.fplog,"AND INTERPOLATING"); fprintf(mtd_data.fplog,"\n");
+
+ if(just_copy==1) for(i=0;i<grid1->size;i++) {
+   grid2->pot[i]=grid1->pot[i]; 
+   for(j=0;j<grid1->ncv;j++) grid2->force[i][j]=grid1->force[i][j];} 
+ else { // Need interpolation
+  for(i=0;i<grid2->size;i++){
+   out_grid = 0;
+   for(j=0;j<grid2->ncv;j++) {
+    ff[grid2->index[j]]=0.0;
+    xx[grid2->index[j]] = grid2->min[j] + grid2->dx[j] * grid2->one2multi_full[i][j];
+    if(xx[grid2->index[j]]<grid1->min[j] || xx[grid2->index[j]]>=grid1->max[j]-grid1->dx[j]) out_grid = 1;
+   } 
+   if(out_grid==1) {grid2->pot[i]=0.0; for(j=0;j<grid2->ncv;j++) grid2->force[i][j]=0.0;} 
+   else{
+    grid2->pot[i]=grid_getstuff(grid1,xx,ff);
+    for(j=0;j<grid2->ncv;j++) grid2->force[i][j]=ff[grid2->index[j]];
+   }
+  }
+ }
+
+}
+//-------------------------------------------------------------------------------------------
+// Interpolation with a (sort of) cubic spline.
+// The function is built as a sum over the nearest neighbours (i.e. 2 in 1d, 4 in 2d, 8 in 3d,...).
+// Each neighbour contributes with a polynomial function which is a product of single-dimensional polynomials,
+// written as functions of the distance to the neighbour in units of grid spacing
+// Each polynomial is proportional to:
+// (1-3x^2+2x^3)  + Q (x-2x^2+x^3)
+// * its value and derivative in +1 are zero
+// * its value in 0 is 1
+// * its derivative in 0 is Q
+// so, Q is chosen as the desired derivative at the grid point divided by the value at the grid point
+// and the final function is multiplied times the value at the grid point.
+//
+// It works perfectly, except when the tabulated function is zero (there is a special case).
+// Maybe one day I will learn the proper way to do splines...
+// Giovanni
+
+real PREFIX spline(int ndim,real *dx,real *where,real *tabf,real *tabder,int* stride,real *der){
+// ndim:   dimensionality
+// dx:     delta between grid points
+// where:  location relative to the floor grid point (always between 0 and dx)
+// tabf:   table with function, already pointed at the floor grid point
+// tabder: table with minus gradients (the fastest running index is the dimension index), already pointed at the floor grid point
+// stride: strides to the next point on the tabf array.
+//         note that, in case of PBC, this stride should corrispond to a backward jump of (N-1) points,
+//         where N is the number of points in the domain. 
+//         also note that the corrisponding strides for tabder can be obtained multipling times ndim
+// der:    in output, the minus gradient.
+
+  int idim;
+  int npoints,ipoint;
+  real X;
+  real X2;
+  real X3;
+  int x0[nconst_max];;
+  real fd[nconst_max];
+  real C[nconst_max];
+  real D[nconst_max];
+  int  tmp,shift;
+  real f;
+
+  npoints=1; for(idim=0;idim<ndim;idim++) npoints*=2; // npoints=2**ndim
+
+// reset
+  f=0;
+  for(idim=0;idim<ndim;idim++) der[idim]=0;
+
+// loop over neighbour points:
+  for(ipoint=0;ipoint<npoints;ipoint++){
+
+// find coordinate of neighbour point (x0) and shift
+    tmp=ipoint;
+    shift=0;
+    for(idim=0;idim<ndim;idim++){
+      x0[idim]=tmp%2; tmp/=2;
+      shift+=stride[idim]*x0[idim];
+    }
+//fprintf(stderr,"%i\n",shift);
+
+// reset contribution from this point:
+    real ff;
+    ff=1.0;
+
+    for(idim=0;idim<ndim;idim++){
+      X=fabs(where[idim]/dx[idim]-x0[idim]);
+      X2=X*X;
+      X3=X2*X;
+      real yy;
+      if(fabs(tabf[shift])<0.0000001) yy=0.0;
+      else yy=tabder[shift*ndim+idim]/tabf[shift];
+                                       // il - e per -derivata
+      C[idim]=(1-3*X2+2*X3) - (x0[idim]?-1:1)*yy*(X-2*X2+X3)*dx[idim];
+      D[idim]=( -6*X +6*X2) - (x0[idim]?-1:1)*yy*(1-4*X +3*X2)*dx[idim]; // d / dX
+      D[idim]*=(x0[idim]?-1:1)/dx[idim]; // chain rule (to where)
+      ff*=C[idim];
+    }
+    for(idim=0;idim<ndim;idim++) {
+      int idim1;
+      fd[idim]=D[idim];
+      for(idim1=0;idim1<ndim;idim1++) if(idim1!=idim) fd[idim]*=C[idim1];
+    }
+    
+    f+=tabf[shift]*ff;
+    for(idim=0;idim<ndim;idim++) der[idim]+=tabf[shift]*fd[idim];
+  }
+  return f;
+};
+
+
+
+
diff -urN dl_class_1.9.orig/srcmod/Plumed/metadyn.c dl_class_1.9/srcmod/Plumed/metadyn.c
--- dl_class_1.9.orig/srcmod/Plumed/metadyn.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/metadyn.c	2015-11-07 17:37:19.293601458 +0100
@@ -0,0 +1,1513 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#define EXTERNALS 1
+#include "metadyn.h"
+#include <assert.h>
+#if defined (PLUMED_GROMACS45)
+#include "gmx_ga2la.h"
+#include "mdrun.h"
+#endif
+
+#if defined (PLUMED_GROMACS)
+void mtd_data_init (int ePBC, real *charge, real *mass, 
+                    int natoms, real dt, int repl_ex_nst, int repl, 
+                    int nrepl, real rte0, real rteio, const t_commrec *mcr, FILE *fplog)
+{
+
+   mtd_data.mcr = mcr;
+   mtd_data.natoms = natoms;
+   mtd_data.pos = float_2d_array_alloc(mtd_data.natoms,3);
+   mtd_data.force = float_2d_array_alloc(mtd_data.natoms,3);
+   mtd_data.vel = NULL;
+   mtd_data.mass = float_1d_array_alloc(mtd_data.natoms);
+   mtd_data.charge = float_1d_array_alloc(mtd_data.natoms);
+
+   int iat,iat_dd;
+   for(iat=0;iat<mtd_data.natoms;iat++){
+     iat_dd=plumed_dd_index(iat);
+     if(iat_dd>=0){
+       mtd_data.mass[iat]=mass[iat_dd];
+       mtd_data.charge[iat]=charge[iat_dd];
+     } else {
+       mtd_data.mass[iat]=0.0;
+       mtd_data.charge[iat]=0.0;
+     }
+   };
+#if defined (PLUMED_GROMACS4) || defined (PLUMED_GROMACS45)
+#if defined (MPI)
+   if (DOMAINDECOMP(mtd_data.mcr)) {
+// for dd, collect mass and charge
+// for pd, atoms are already shared and this is not necessary
+     plumed_sum(&mtd_data,mtd_data.natoms,&mtd_data.mass[0]);
+     plumed_sum(&mtd_data,mtd_data.natoms,&mtd_data.charge[0]);
+   }
+#endif
+#endif
+
+
+   mtd_data.repl_ex_nst = repl_ex_nst;
+   mtd_data.repl = repl;
+   mtd_data.nrepl = nrepl;
+   mtd_data.rte0 = rte0;
+   mtd_data.rteio = rteio;
+   mtd_data.dt = dt;
+   mtd_data.fplog = fplog;
+   mtd_data.eunit = 1.;
+   mtd_data.boltz = BOLTZ;
+#if defined (PLUMED_GROMACS4) || defined (PLUMED_GROMACS45)
+   mtd_data.ePBC = ePBC;
+#endif
+   mtd_data.istep_old = -1;
+   if(!mtd_data.ionode) mtd_data.fplog=fopen("/dev/null","w");
+   logical.not_same_step=1;
+   sprintf(hills.dir, ".");
+}
+
+#if defined (PLUMED_GROMACS4) || defined (PLUMED_GROMACS45)
+// ##### This is for d-AFED checkpointing in gromacs
+// ##### Also set the step to long long int
+#if defined (PLUMED_GROMACS4)
+void plumed_setstep(long long int istep, bool bCPT){
+#else if defined (PLUMED_GROMACS45)
+void plumed_setstep(long long int istep, gmx_bool bCPT){
+#endif
+  mtd_data.istep=istep;
+  dafed_control.do_cpt=bCPT;
+};
+#else
+void plumed_setstep(long long int istep){
+  mtd_data.istep=istep;
+  dafed_control.do_cpt=0;
+};
+#endif
+
+// Routine which finds the local index from the global index, for gromacs domain decomposition
+int plumed_ll_index(int iat_dd){
+  int iat;
+  iat=iat_dd;
+#if defined (MPI)
+#if defined (PLUMED_GROMACS4) || defined (PLUMED_GROMACS45)
+  //if(DOMAINDECOMP(mtd_data.mcr))  iat = mtd_data.mcr->dd->index_gl[iat_dd];
+  if(DOMAINDECOMP(mtd_data.mcr))  iat = mtd_data.mcr->dd->gatindex[iat_dd];
+#endif
+#endif
+  return iat;
+}
+
+// Routine which finds the local index from the global index, for gromacs domain decomposition
+int plumed_dd_index(int iat){
+   int cell_dd,iat_dd;
+   iat_dd=iat;
+#if defined (MPI)
+#if defined (PLUMED_GROMACS45)
+   if (DOMAINDECOMP(mtd_data.mcr)) {
+     if(!ga2la_get_home(mtd_data.mcr->dd->ga2la,iat,&iat_dd)){
+       iat_dd = -1;
+     }
+   };
+#elif defined (PLUMED_GROMACS4)
+   if (DOMAINDECOMP(mtd_data.mcr)) {
+     cell_dd=mtd_data.mcr->dd->ga2la[iat].cell;
+     if(cell_dd!=0) iat_dd=-1;
+     else iat_dd=mtd_data.mcr->dd->ga2la[iat].a;
+   };
+#endif
+#endif
+   return iat_dd;
+};
+
+void meta_force_calculation(int start,int homenr,real (*pos)[3], real (*force)[3], real box[3][3], real energy, real temp)
+{
+   int i;
+   int kk;
+   int iat,iat_dd,cell_dd;
+   int icv, ncv, icv_ene=-1;
+   rvec *pos_cvatoms;
+   int nreqatoms;
+
+   copy_mat(box, mtd_data.cell);
+
+   ncv=colvar.nconst;
+
+   mtd_data.temp_t = temp;
+
+   nreqatoms=0;
+   for(icv=0;icv<ncv;icv++) {
+    if(colvar.type_s[icv]!=35) nreqatoms+=colvar.natoms[icv];
+     else icv_ene = icv;
+   }
+   nreqatoms+=colvar.align_atoms;
+
+// compact array with only positions of atoms involved in metadynamics
+   snew(pos_cvatoms,nreqatoms);
+
+    
+// if ENERGY CV copy GROMACS forces in colvar.myder and the energy in mtd_data.energy
+   if(logical.energy) {
+     plumed_sum(&mtd_data,1,&energy);
+     mtd_data.energy = energy;
+}
+
+// copy relevent atoms on compact array
+// in dd, each process owns part of the atoms: iat_dd provides the mapping, negative means non-local atom
+   kk=0;
+   for(icv=0;icv<ncv;icv++) if(colvar.type_s[icv]!=35) for(i=0;i<colvar.natoms[icv];i++){
+     iat_dd=plumed_dd_index(colvar.cvatoms[icv][i]);
+     if(iat_dd>=start && iat_dd<start+homenr) {
+       pos_cvatoms[kk][0]=pos[iat_dd][0]; pos_cvatoms[kk][1]=pos[iat_dd][1]; pos_cvatoms[kk][2]=pos[iat_dd][2];
+     }else{
+       pos_cvatoms[kk][0]=0.0; pos_cvatoms[kk][1]=0.0; pos_cvatoms[kk][2]=0.0;
+     }
+     kk++;
+   }
+// if an atom is aligned, we also copy it here
+// this is not efficient (if you align all the atoms involved in the CVs, you will send around
+// twice the data as necessary), but still should work
+// (in the future, we have to implement a list of uniq atoms required by plumed, obtained as the
+// union of the sets of atoms required by CV evaluation and alignment)
+   for(i=0;i<colvar.align_atoms;i++){
+     iat_dd=plumed_dd_index(colvar.align_list[i]);
+     if(iat_dd>=start && iat_dd<start+homenr) {
+       pos_cvatoms[kk][0]=pos[iat_dd][0]; pos_cvatoms[kk][1]=pos[iat_dd][1]; pos_cvatoms[kk][2]=pos[iat_dd][2];
+     }else{
+       pos_cvatoms[kk][0]=0.0; pos_cvatoms[kk][1]=0.0; pos_cvatoms[kk][2]=0.0;
+     }
+     kk++;
+   }
+
+// just to double check
+   assert(kk==nreqatoms);
+
+// collect positions
+// (needed for both particle and domain decomposition)
+   if(nreqatoms>0) plumed_sum(&mtd_data,3*nreqatoms,&pos_cvatoms[0][0]);
+
+// scatter the relevant atoms on the large mtd_data.pos array.
+// ( in the future we may consider eliminating the mtd_data.pos array and working directly with pos_cvatoms,
+//   which should be more efficient but will require hacking all the restraint routines.
+//   similarly, a for_cvatoms could be used for forces.)
+   kk=0;
+   for(icv=0;icv<ncv;icv++) if(colvar.type_s[icv]!=35) for(i=0;i<colvar.natoms[icv];i++){
+     iat=colvar.cvatoms[icv][i];
+     mtd_data.pos[iat][0]=pos_cvatoms[kk][0]; mtd_data.pos[iat][1]=pos_cvatoms[kk][1]; mtd_data.pos[iat][2]=pos_cvatoms[kk][2];
+     kk++;
+   }
+   for(i=0;i<colvar.align_atoms;i++){
+     iat=colvar.align_list[i];
+     mtd_data.pos[iat][0]=pos_cvatoms[kk][0]; mtd_data.pos[iat][1]=pos_cvatoms[kk][1]; mtd_data.pos[iat][2]=pos_cvatoms[kk][2];
+     kk++;
+   }
+
+// double check
+   assert(kk==nreqatoms);
+
+// clean local forces
+   for(iat_dd=start;iat_dd<start+homenr;iat_dd++){
+     iat=plumed_ll_index(iat_dd);
+     mtd_data.force[iat][0]=0.0;
+     mtd_data.force[iat][1]=0.0;
+     mtd_data.force[iat][2]=0.0;
+   }
+
+   restraint(&mtd_data);
+
+// add the contribution to the gromacs forces.
+// each process only updates the local atoms
+   for(iat_dd=start;iat_dd<start+homenr;iat_dd++){
+     iat=plumed_ll_index(iat_dd);
+     if(logical.energy) {
+       mtd_data.force[iat][0]+=-colvar.d_0[icv_ene]*force[iat_dd][0];
+       mtd_data.force[iat][1]+=-colvar.d_0[icv_ene]*force[iat_dd][1];
+       mtd_data.force[iat][2]+=-colvar.d_0[icv_ene]*force[iat_dd][2];
+     }
+     force[iat_dd][0] += mtd_data.force[iat][0];
+     force[iat_dd][1] += mtd_data.force[iat][1];
+     force[iat_dd][2] += mtd_data.force[iat][2];
+   }
+ 
+   sfree(pos_cvatoms);
+}
+#elif defined (DRIVER) 
+void mtd_data_init(int atoms, real *mass, real *charge, char *metainp, int pbc, real *box, real ddt)
+{
+ int i;
+ mtd_data.pos       = float_2d_array_alloc(atoms,3);
+ mtd_data.vel       = float_2d_array_alloc(atoms,3);
+ mtd_data.force     = float_2d_array_alloc(atoms,3);
+ mtd_data.charge    = (real *)calloc(atoms,sizeof(real));
+ mtd_data.mass      = (real *)calloc(atoms,sizeof(real));
+ mtd_data.natoms    = atoms;
+ mtd_data.dt        = ddt;
+ mtd_data.istep_old = -1;
+ mtd_data.istep     = 0;  
+ mtd_data.fplog     = stdout;
+ mtd_data.imcon     = pbc;
+ mtd_data.eunit     = 1.;
+ mtd_data.boltz     = 0.001987191;  // kcal/mol/K
+ mtd_data.ionode = 1;
+ logical.not_same_step=1;
+ if(mtd_data.imcon==1){
+  mtd_data.cell[0]=box[0];
+  mtd_data.cell[1]=box[1];
+  mtd_data.cell[2]=box[2]; 
+ } 
+
+ for(i=0;i<mtd_data.natoms;i++) {
+   mtd_data.mass[i]   = mass[i];
+   mtd_data.charge[i] = charge[i];
+ }
+ strcpy(mtd_data.metaFilename, metainp);
+}
+
+void cv_calculation_(real *box, real *pos, int *ncv, real *cv)
+{
+ int i;
+ for(i=0;i<mtd_data.natoms;i++){
+ mtd_data.pos[i][0] = pos[i];
+ mtd_data.pos[i][1] = pos[i + mtd_data.natoms];
+ mtd_data.pos[i][2] = pos[i + 2*mtd_data.natoms];
+ }
+
+ // update cell info
+ if(mtd_data.imcon==1){
+  mtd_data.cell[0]=box[0];
+  mtd_data.cell[1]=box[1];
+  mtd_data.cell[2]=box[2];
+ } 
+
+
+ restraint(&mtd_data);
+ // step increment
+ mtd_data.istep++;
+
+ for(i=0;i<*ncv;i++) cv[i] = colvar.ss0[i];
+}
+#elif STANDALONE  
+void mtd_data_init(int atoms, real *mass, real *charge, int pbc, real *box, real *tstep, int *nstep, real *myboltz, real *ampli,  char *metainp )
+{
+ int i;
+ mtd_data.pos       = float_2d_array_alloc(atoms,3);
+ mtd_data.vel       = float_2d_array_alloc(atoms,3);
+ mtd_data.force     = float_2d_array_alloc(atoms,3);
+ mtd_data.charge    = (real *)calloc(atoms,sizeof(real));
+ mtd_data.mass      = (real *)calloc(atoms,sizeof(real));
+ mtd_data.natoms    = atoms;
+ mtd_data.dt        = (*tstep);
+ mtd_data.istep_old = -1;
+ mtd_data.istep     = (*nstep);  
+ mtd_data.ampli     = (*ampli);  
+ mtd_data.imcon     = pbc;
+ mtd_data.eunit     = 1.;
+ mtd_data.boltz     = (*myboltz);
+ mtd_data.ionode = 1;
+
+ sprintf(hills.dir, ".");
+
+ logical.not_same_step=1;
+ if(mtd_data.imcon==1){
+  mtd_data.cell[0]=box[0];
+  mtd_data.cell[1]=box[1];
+  mtd_data.cell[2]=box[2]; 
+ } 
+ if(mtd_data.istep==0){
+    mtd_data.fplog = fopen("PLUMED.OUT","w");
+ }else {
+    //mtd_data.fplog = fopen("PLUMED.OUT","a");
+    mtd_data.fplog = fopen("/dev/null","w");
+ }
+ for(i=0;i<mtd_data.natoms;i++) {
+   mtd_data.mass[i]   = mass[i];
+   mtd_data.charge[i] = charge[i];
+ }
+ strcpy(mtd_data.metaFilename, metainp);
+}
+
+void cv_calculation_standalone_(real *box, real *pos, real *force , real *ene)
+{
+ int i;
+ for(i=0;i<mtd_data.natoms;i++){
+ mtd_data.pos[i][0] = pos[i];
+ mtd_data.pos[i][1] = pos[i + mtd_data.natoms];
+ mtd_data.pos[i][2] = pos[i + 2*mtd_data.natoms];
+ }
+
+ // update cell info
+ if(mtd_data.imcon==1){
+  mtd_data.cell[0]=box[0];
+  mtd_data.cell[1]=box[1];
+  mtd_data.cell[2]=box[2];
+ } 
+
+
+ restraint(&mtd_data);
+ // step increment
+ mtd_data.istep++;
+
+   for(i=0;i<mtd_data.natoms;i++){
+       force[i                    ] = mtd_data.force[i][0];
+       force[i + mtd_data.natoms  ] = mtd_data.force[i][1];
+       force[i + 2*mtd_data.natoms] = mtd_data.force[i][2];
+   }
+   (*ene)=hills.Vhills/mtd_data.eunit+cvw.Vwall/mtd_data.eunit;
+}
+
+#elif ACEMD
+void mtd_data_init( real *charge, real *mass,
+                    int natoms, real dt, int repl,
+                    int nrepl, real rte0, real rteio, char *metainp, real box[3])
+{
+ int i;
+ mtd_data.pos       = float_2d_array_alloc(natoms,3); 
+ mtd_data.vel       = float_2d_array_alloc(natoms,3);
+ mtd_data.force     = float_2d_array_alloc(natoms,3);
+ mtd_data.charge    = charge;
+ mtd_data.mass      = mass;
+ mtd_data.natoms    = natoms;
+ mtd_data.repl      = repl; 
+ mtd_data.nrepl     = nrepl;
+ mtd_data.rte0      = rte0;
+ mtd_data.rteio     = rteio;
+ mtd_data.dt        = dt; 
+ mtd_data.istep_old = -1;
+ mtd_data.istep     = 0; 
+ mtd_data.imcon     = 1; 
+ mtd_data.eunit     = 1.;
+ mtd_data.boltz     = 0.001987191; //kcal/mol/K
+ mtd_data.ionode = 1;
+ logical.not_same_step=1;
+ sprintf(hills.dir, ".");
+ mtd_data.fplog = fopen("log.file","w");
+ strcpy(mtd_data.metaFilename, metainp); 
+   mtd_data.cell[0]=box[0];
+   mtd_data.cell[1]=box[1];
+   mtd_data.cell[2]=box[2];
+
+}
+
+void meta_force_calculation(struct aceplug_sim_t* s )
+{
+   int i;
+
+   // take step, box from environment
+   mtd_data.istep=s->step;
+   mtd_data.cell[0]=s->box.x;	/* Faux-NPT */
+   mtd_data.cell[1]=s->box.y;
+   mtd_data.cell[2]=s->box.z; 
+
+   for(i=0;i<mtd_data.natoms;i++){
+     mtd_data.pos[i][0] = (double) s->pos[i].x;
+     mtd_data.pos[i][1] = (double) s->pos[i].y;
+     mtd_data.pos[i][2] = (double) s->pos[i].z;
+     //     mtd_data.vel[i][0] = (double) s->vel[i].x;
+     //mtd_data.vel[i][1] = (double) s->vel[i].y;
+     //mtd_data.vel[i][2] = (double) s->vel[i].z;
+   }
+
+   restraint(&mtd_data);
+
+   for(i=0;i<mtd_data.natoms;i++){
+     s->frc[i].x= s->frc[i].x+mtd_data.force[i][0];
+     s->frc[i].y= s->frc[i].y+mtd_data.force[i][1];
+     s->frc[i].z= s->frc[i].z+mtd_data.force[i][2];
+   }
+}
+#elif OPEP
+void mtd_data_init(int pbc, real tstep,int atoms, int repl, int nrepl, real rte0, real rteio, real *mass, char *lpath, char *logfile, char *metainp)
+{
+ int i;
+ mtd_data.pos       = float_2d_array_alloc(atoms,3); 
+ mtd_data.vel       = float_2d_array_alloc(atoms,3);
+ mtd_data.force     = float_2d_array_alloc(atoms,3);
+ mtd_data.charge    = (real *)calloc(atoms,sizeof(real));
+ mtd_data.mass      = (real *)calloc(atoms,sizeof(real));
+ mtd_data.natoms    = atoms;
+ mtd_data.repl      = repl; 
+ mtd_data.nrepl     = nrepl;
+ mtd_data.rte0      = rte0;
+ mtd_data.rteio     = rteio;
+ mtd_data.dt        = tstep; 
+ mtd_data.istep_old = -1;
+ mtd_data.istep     = 0; 
+ mtd_data.imcon     = pbc; 
+ mtd_data.eunit     = 1.;
+ mtd_data.boltz     = 0.001987191; //kcal/mol/K
+ mtd_data.ionode = 1;
+#ifdef MPI
+   mtd_data.comm=MPI_COMM_SELF;
+   if(nrepl==1){
+     mtd_data.intercomm=MPI_COMM_NULL;
+   } else {
+     mtd_data.intercomm=MPI_COMM_WORLD;
+   };
+#endif
+ logical.not_same_step=1;
+ for(i=0;i<mtd_data.natoms;i++) mtd_data.mass[i] = mass[i];
+
+ strcpy(mtd_data.metaFilename, metainp); 
+ if(nrepl==1){
+   strcpy(hills.dir, ".");
+ }else{
+  strcpy(hills.dir, lpath);
+ }
+ strcpy(mtd_data.log, logfile); 
+ mtd_data.fplog = fopen(mtd_data.log,"a"); 
+
+}
+
+void meta_force_calculation_(real *pos, real *force)
+{
+ int i;
+ for(i=0;i<mtd_data.natoms;i++){
+ mtd_data.pos[i][0] = pos[i];
+ mtd_data.pos[i][1] = pos[i + mtd_data.natoms];
+ mtd_data.pos[i][2] = pos[i + 2*mtd_data.natoms];
+ }
+
+ restraint(&mtd_data);
+ // step increment
+ mtd_data.istep++; 
+ 
+ for(i=0;i<mtd_data.natoms;i++){
+ force[i]                     = mtd_data.force[i][0];
+ force[i + mtd_data.natoms]   = mtd_data.force[i][1];
+ force[i + 2*mtd_data.natoms] = mtd_data.force[i][2];
+ }
+}
+
+void share_bias_(int *rep, real *Vbias, real *Vbiasx) 
+{
+ptmetad_vbias(*rep,Vbias,Vbiasx);
+}
+
+void switch_fluct_(int *rep)
+{
+ if(logical.widthadapt) ptmetad_exchfluct(*rep);
+}
+
+void bias_exchange_(int *nrep, int *biaseed, int *ind) 
+{
+if(logical.rpxm) bias_exchange_traj(*nrep,biaseed,ind); 
+}
+
+#elif defined(DL_POLY) || defined(AMBER) || defined(PLUMED_QESPRESSO) || defined(GAT_LJONES)
+void mtd_data_init(int atoms, real dt ,real *mass, real *charge, int *imcon, real *eunit, char *metainp)
+{
+ int i ;
+ mtd_data.pos=float_2d_array_alloc(atoms,3);
+ mtd_data.vel=float_2d_array_alloc(atoms,3);
+ mtd_data.force=float_2d_array_alloc(atoms,3);
+ mtd_data.charge=(real *)calloc(atoms,sizeof(real));
+#ifdef AMBER
+   for (i=0;i<atoms;i++){mtd_data.charge[i]= charge[i]/18.2223; }
+   mtd_data.dt = dt*1000. ; // timestep from ps to fs
+   mtd_data.eunit=1.0;
+   mtd_data.boltz=0.001987191; // kcal/mol/K
+#else
+   for (i=0;i<atoms;i++){mtd_data.charge[i]= charge[i]; }
+   mtd_data.dt = dt ; // the timestep is kept in ps
+   mtd_data.eunit=(*eunit);
+#ifdef PLUMED_QESPRESSO
+   mtd_data.boltz=0.0000063363125;
+#elif DL_POLY
+   mtd_data.boltz=0.831451115; // 10Joule/mol/K
+#elif GAT_LJONES
+   mtd_data.boltz=1.0;    // 1 lennard jones unit
+#endif
+#endif
+ mtd_data.imcon=(* imcon);
+ mtd_data.mass=(real *)calloc(atoms,sizeof(real));
+ for (i=0;i<atoms;i++){mtd_data.mass[i]=mass[i]; }
+ mtd_data.natoms = atoms;
+ mtd_data.repl = -1;
+ mtd_data.istep = 0;
+ mtd_data.istep_old = -1;
+#ifdef MPI
+ mtd_data.intercomm=MPI_COMM_NULL;
+ mtd_data.comm=MPI_COMM_WORLD;
+#endif
+ mtd_data.ionode = (plumed_comm_rank(&mtd_data)==0);
+ if(mtd_data.ionode) mtd_data.fplog = fopen("PLUMED.OUT","w"); 
+ else mtd_data.fplog = fopen("/dev/null","w");
+ strcpy(mtd_data.metaFilename,metainp);
+ sprintf(hills.dir, ".");
+ logical.not_same_step=1;
+};
+
+void meta_force_calculation_(real *cell, int *istep, real *xxx, real *yyy, real *zzz, real *fxx, real *fyy, real *fzz, real *energy)
+{
+ int i, icv_ene;
+ // cell type 
+ // cell size 
+ mtd_data.istep=(* istep); // <---paolo
+#if defined (DL_POLY) || defined (GAT_LJONES)
+ for(i=0;i<9;i++)mtd_data.cell[i]=cell[i]; 
+ for(i=0;i<mtd_data.natoms;i++){
+   mtd_data.pos[i][0] = xxx[i];
+   mtd_data.pos[i][1] = yyy[i];
+   mtd_data.pos[i][2] = zzz[i];
+ }
+#elif AMBER
+ for(i=0;i<3;i++)mtd_data.cell[i]=cell[i]; 
+ for (i=0;i<mtd_data.natoms;i++){
+   mtd_data.pos[i][0]=xxx[i*3+0];
+   mtd_data.pos[i][1]=xxx[i*3+1];
+   mtd_data.pos[i][2]=xxx[i*3+2];
+	//printf("%f %f %f\n",mtd_data.pos[i][0],mtd_data.pos[i][1],mtd_data.pos[i][2]);
+ } 
+ cvcnstr.oldforce=fxx;
+ cvcnstr.oldvel=yyy;
+#elif PLUMED_QESPRESSO
+ for(i=0;i<3;i++)mtd_data.cell[i]=cell[4*i];
+ for(i=0;i<9;i++)if(i!=0&&i!=4&&i!=8&&cell[i]!=0.0)
+    plumed_error("PLUMED+QESPRESSO only supports orthorombic cells");
+ for(i=0;i<mtd_data.natoms;i++){
+   mtd_data.pos[i][0] = xxx[3*i+0];
+   mtd_data.pos[i][1] = xxx[3*i+1];
+   mtd_data.pos[i][2] = xxx[3*i+2];
+ }
+#endif
+
+// in case of ENERGY CV 
+ if(logical.energy){ 
+  for(i=0;i<colvar.nconst;i++) if(colvar.type_s[i]==35) icv_ene = i;
+  mtd_data.energy = *energy/mtd_data.eunit;
+#if defined (DL_POLY) || defined (GAT_LJONES)
+  for(i=0;i<mtd_data.natoms;i++){
+   colvar.myder[icv_ene][i][0] = -fxx[i]/mtd_data.eunit; 
+   colvar.myder[icv_ene][i][1] = -fyy[i]/mtd_data.eunit;
+   colvar.myder[icv_ene][i][2] = -fzz[i]/mtd_data.eunit;
+  }
+#else
+  for(i=0;i<mtd_data.natoms;i++){
+   colvar.myder[icv_ene][i][0] = -fxx[i*3+0]/mtd_data.eunit; 
+   colvar.myder[icv_ene][i][1] = -fxx[i*3+1]/mtd_data.eunit;
+   colvar.myder[icv_ene][i][2] = -fxx[i*3+2]/mtd_data.eunit;
+   //fprintf(mtd_data.fplog,"FORCE %d %lf %lf %lf\n",i,colvar.myder[icv_ene][i][0],colvar.myder[icv_ene][i][1],colvar.myder[icv_ene][i][2]); 
+  }
+#endif
+ }
+
+ restraint(&mtd_data);
+
+// Gareth Tribello - remove this as it is just
+// to check that hills are working correctly
+// #ifdef UNIT_BOLTZ
+//    (*energy)=hills.Vhills + cvw.Vwall + Vext + Vrecon;
+// #endif
+
+#if defined (DL_POLY) || defined (GAT_LJONES)
+ for(i=0;i<mtd_data.natoms;i++){
+   fxx[i]   += mtd_data.force[i][0]; 
+   fyy[i]   += mtd_data.force[i][1];
+   fzz[i]   += mtd_data.force[i][2];
+   //printf("FORCE %d %f %f %f\n",i, mtd_data.force[i][0], mtd_data.force[i][1], mtd_data.force[i][2]);
+ }
+#elif AMBER
+ for(i=0;i<mtd_data.natoms;i++){
+   fxx[i*3+0]   += mtd_data.force[i][0];
+   fxx[i*3+1]   += mtd_data.force[i][1];
+   fxx[i*3+2]   += mtd_data.force[i][2];
+  // fprintf(mtd_data.fplog,"FORCE %d %f %f %f\n",i, mtd_data.force[i][0], mtd_data.force[i][1], mtd_data.force[i][2]);
+ }
+ (*energy)=hills.Vhills + cvw.Vwall + Vext + Vrecon;
+#elif PLUMED_QESPRESSO
+for(i=0;i<mtd_data.natoms;i++){
+   fxx[3*i+0]   += mtd_data.force[i][0];
+   fxx[3*i+1]   += mtd_data.force[i][1];
+   fxx[3*i+2]   += mtd_data.force[i][2];
+   //printf("FORCE %d %f %f %f\n",i, mtd_data.force[i][0], mtd_data.force[i][1], mtd_data.force[i][2]);
+ }
+#endif
+}
+
+#elif defined(PLUMED_CPMD) 
+// here we create Plumed
+Plumed Plumed_simulation;
+// the constructor
+PREFIX Plumed() {};
+void PREFIX mtd_data_init( int atoms, int nsp, int *na, int nsx, int nax, real ddt, int stepnow, real *mass, char *metainp)
+{
+ int i,j,k;
+ mtd_data.pos       = float_2d_array_alloc(atoms,3);
+ mtd_data.vel       = float_2d_array_alloc(atoms,3);
+ mtd_data.force     = float_2d_array_alloc(atoms,3);
+ mtd_data.charge    = (real *)calloc(atoms,sizeof(real));
+ mtd_data.mass      = (real *)calloc(atoms,sizeof(real));
+ mtd_data.natoms    = atoms;
+ mtd_data.dt        = ddt;
+ mtd_data.istep_old = stepnow-1;
+ mtd_data.istep     = stepnow;
+ mtd_data.eunit     = 1.;
+ mtd_data.ionode = 1;
+ mtd_data.boltz     = 0.0000031668114; // hartree/K
+ logical.not_same_step=1;
+ sprintf(hills.dir, ".");
+ mtd_data.fplog = fopen("log.file","w");
+// metainp="plumed.dat";
+ strcpy(mtd_data.metaFilename, metainp);
+ i=0;
+ for(j=0;j<nsp;j++){
+   for(k=0;k<na[j];k++){
+     mtd_data.mass[i]=mass[j];
+     printf("atom %3d mass %7.3f\n",i+1,mtd_data.mass[i]);
+     i++;
+   }
+ }
+ for(i=0;i<mtd_data.natoms;i++) {
+   mtd_data.charge[i] = 0.; // no charges in cpmd
+ }
+}
+
+void PREFIX meta_force_calculation(real *pos, real *force, int *nsp, int *na, int *nsx, int *nax)
+{
+ int i,j,k;
+
+ i=0;
+ for(j=0;j<*nsp;j++){
+   for(k=0;k<na[j];k++){
+     mtd_data.pos[i][0] = pos[0+(k+j*(*nax))*3];
+     mtd_data.pos[i][1] = pos[1+(k+j*(*nax))*3];
+     mtd_data.pos[i][2] = pos[2+(k+j*(*nax))*3];
+     i++;
+   }
+ }
+
+ restraint(&mtd_data);
+ mtd_data.istep++;
+
+ i=0;
+ for(j=0;j<*nsp;j++){
+   for(k=0;k<na[j];k++){
+     force[0+(k+j*(*nax))*3] += mtd_data.force[i][0];
+     force[1+(k+j*(*nax))*3] += mtd_data.force[i][1];
+     force[2+(k+j*(*nax))*3] += mtd_data.force[i][2];
+     i++;
+   }
+ }
+
+}
+
+#if defined(PLUMED_CPMD_NOUNDERSCORE)
+// some IBM-AIX compilers (not all of them) do not want the underscore...
+void init_metadyn(int *atoms, int *nsp, int *na, int *nsx, int *nax, real *ddt, int *stepnow, real *mass)
+#else
+void init_metadyn_(int *atoms, int *nsp, int *na, int *nsx, int *nax, real *ddt, int *stepnow, real *mass)
+#endif
+{
+  printf(" PLUMED| inside wrapper init_metadyn, calling init_metadyn...\n");
+  Plumed_simulation.init_metadyn(atoms, nsp, na, nsx, nax, ddt, stepnow, mass);
+  printf(" PLUMED| ...done\n");
+}
+#if defined(PLUMED_CPMD_NOUNDERSCORE)
+// some IBM-AIX compilers (not all of them) do not want the underscore...
+void meta_force_calculation(real *pos, real *force, int *nsp, int *na, int *nax, int *nsx)
+#else
+void meta_force_calculation_(real *pos, real *force, int *nsp, int *na, int *nax, int *nsx)
+#endif
+{
+  Plumed_simulation.meta_force_calculation(pos, force, nsp, na, nax, nsx);
+}
+
+#elif NAMD
+
+PREFIX GlobalMasterMetaDynamics() :
+    GlobalMasterEasy("metaDynamicsScript")
+{
+// Initialize subclass and get current config
+    easy_init(config);
+}
+
+// easy_init and easy_calc are virtuals of GlobalMasterEasy: must be defined anyway
+void PREFIX easy_init(const char *config) {
+  int i,j,i_c;
+
+// PluMeD initialization 
+  init_metadyn();
+
+// requesting atom to NAMD
+    for(i_c=0;i_c<colvar.nconst;i_c++){
+            for(i=0;i<colvar.natoms[i_c];i++){
+                    j=colvar.cvatoms[i_c][i];
+                    if(requestAtom(j)){
+                     char buf[1024];
+                     sprintf(buf,"ATOM ID %i DOESN'T EXIST",j);
+                     plumed_error(buf);
+                    }
+            }
+    }
+}
+
+void PREFIX  easy_calc() {
+    Vector coord_from;
+    int i,j,i_c;
+
+// getting atom positions
+    for(i_c=0;i_c<colvar.nconst;i_c++){
+            for(i=0;i<colvar.natoms[i_c];i++){
+                    j=colvar.cvatoms[i_c][i];
+                    getPosition(j,coord_from);
+                    mtd_data.pos[j][0]=coord_from.x;
+                    mtd_data.pos[j][1]=coord_from.y;
+                    mtd_data.pos[j][2]=coord_from.z;
+            }
+    }
+
+// CV evaluation
+    restraint(&mtd_data);
+// step increment
+    mtd_data.istep++;
+}
+
+void PREFIX mtd_data_init()
+{
+ int i ;
+ 
+ // simparameters contains: cell,dt,lattice and all attributes coming from the namd input file
+ SimParameters *spar=Node::Object()->simParameters; 
+ // molecule contains atommass, atomcharge,isHydrogen,isOxygen,isWater,bonds_for_atoms,angle_for_atoms methods
+ // and other public attributes numAtoms,numBonds,numDihedrals 
+ mtd_data.natoms=Node::Object()->molecule->numAtoms; 
+ // allocate the common vectors 
+ mtd_data.charge=(real *)calloc(mtd_data.natoms,sizeof(real)); 
+ mtd_data.mass=(real *)calloc(mtd_data.natoms,sizeof(real)); 
+ mtd_data.pos=float_2d_array_alloc(mtd_data.natoms,3);
+ mtd_data.vel=float_2d_array_alloc(mtd_data.natoms,3);
+ mtd_data.force=float_2d_array_alloc(mtd_data.natoms,3);
+ sprintf(hills.dir, ".");
+
+ for(i=0;i<mtd_data.natoms;i++){mtd_data.mass[i]=Node::Object()->molecule->atommass(i);/* printf("ATOMMASS %d %f\n",i,mtd_data.mass[i]);*/};
+ for(i=0;i<mtd_data.natoms;i++){mtd_data.charge[i]=Node::Object()->molecule->atomcharge(i);/*printf("ATOMCHARGE %d %f\n",i,mtd_data.charge[i]);*/};
+ strcpy(mtd_data.metaFilename,spar->metaFilename);
+ mtd_data.fplog = stdout;
+ mtd_data.repl=-1;// always consider it as normal md
+ mtd_data.dt=spar->dt;
+ mtd_data.eunit = 1.;
+ mtd_data.boltz = 0.001987191; // kcal/mol/K
+ mtd_data.ionode = 1;
+ mtd_data.istep_old = -1;
+ mtd_data.istep = 0;
+ logical.not_same_step=1;
+}
+void PREFIX rvec2vec(rvec rv,Vector *v)
+{
+v->x=rv[0];
+v->y=rv[1];
+v->z=rv[2];
+}
+#elif LAMMPS_PLUMED 
+PREFIX Plumed(char *metainp, char *metaout , int *atoms, real *mss, real *chg, real *dt, real myboltz) 
+{
+  printf("Plumed Object being created...\n");
+  init_metadyn(metainp,metaout,atoms,mss,chg,dt,myboltz); 
+  printf("Done!\n");
+};
+void PREFIX mtd_data_init( char *metainp, char *metaout,  int atoms, real *mass, real *charge, real *dt , real myboltz )
+{
+ int i ;
+ mtd_data.pos=float_2d_array_alloc(atoms,3); 
+ mtd_data.vel=float_2d_array_alloc(atoms,3);
+ mtd_data.force=float_2d_array_alloc(atoms,3);
+ mtd_data.charge=(real *)calloc(atoms,sizeof(real));
+ for (i=0;i<atoms;i++){mtd_data.charge[i]= charge[i]; }  
+ mtd_data.mass=(real *)calloc(atoms,sizeof(real));
+ for (i=0;i<atoms;i++){mtd_data.mass[i]=mass[i]; } 
+ mtd_data.fplog = fopen(metaout,"w"); 
+ mtd_data.natoms = atoms;
+ mtd_data.dt = *dt ; // timestep from ps to fs  
+ mtd_data.repl  = -1;
+ mtd_data.eunit = 1.;
+ mtd_data.boltz   = myboltz;  
+ mtd_data.ionode = 1;
+ strcpy(mtd_data.metaFilename,metainp); 
+ sprintf(hills.dir, ".");
+ logical.not_same_step=1;
+ mtd_data.istep_old = -1;
+ mtd_data.istep = 0;
+
+};
+void PREFIX meta_force_calculation(int *allidx, rvec *allpos,rvec *allforce, int allnum  , Domain *domain)
+{
+ int i,j;
+ //printf("----------------------START OF META FORCE-------------------\n");
+ //printf("MTD_DATA NATOMS %d \n",mtd_data.natoms);
+ mtd_data.mydomain=domain;
+ for(i=0;i<allnum;i++){
+   j=allidx[i];
+//   printf("III %d F %f %f %f\n",j,allpos[i][0],allpos[i][1],allpos[i][2]);
+ 
+   mtd_data.pos[j][0]=allpos[i][0];
+   mtd_data.pos[j][1]=allpos[i][1];
+   mtd_data.pos[j][2]=allpos[i][2];
+
+ } 
+ restraint(&mtd_data);
+ // step increment
+ mtd_data.istep++;   
+ for(i=0;i<allnum;i++){
+   j=allidx[i];
+   allforce[i][0]=mtd_data.force[j][0];
+   allforce[i][1]=mtd_data.force[j][1];
+   allforce[i][2]=mtd_data.force[j][2];
+ } 
+ //printf("----------------------END OF META FORCE-------------------\n");
+};
+void PREFIX sfree(void *ptr)
+{
+  if (ptr == NULL) return;
+  free(ptr);
+};
+#endif
+
+// Vector operation, angle etc etc...
+#if !defined(PLUMED_GROMACS)
+void PREFIX oprod(const rvec a,const rvec b,rvec c)
+{
+  c[0]=a[1]*b[2]-a[2]*b[1];
+  c[1]=a[2]*b[0]-a[0]*b[2];
+  c[2]=a[0]*b[1]-a[1]*b[0];
+}
+real PREFIX iprod(const rvec a,const rvec b)
+{
+  return (a[0]*b[0]+a[1]*b[1]+a[2]*b[2]);
+}
+real PREFIX norm(const rvec a)
+{
+  return sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);
+}
+real PREFIX norm2(const rvec a)
+{
+  return a[0]*a[0]+a[1]*a[1]+a[2]*a[2];
+}
+real PREFIX cos_angle(const rvec a,const rvec b)
+{
+  real   cos;
+  int    m;
+  real aa,bb,ip,ipa,ipb;
+  ip=ipa=ipb=0.0;
+  for(m=0; (m<3); m++) {
+    aa   = a[m];
+    bb   = b[m];
+    ip  += aa*bb;
+    ipa += aa*aa;
+    ipb += bb*bb;
+  }
+  cos=ip/sqrt(ipa*ipb);
+  if (cos > 1.0)
+    return  1.0;
+  if (cos <-1.0)
+    return -1.0;
+  return cos;
+}
+real PREFIX dih_angle(rvec xi, rvec xj, rvec xk, rvec xl,
+               rvec r_ij,rvec r_kj,rvec r_kl,rvec m,rvec n,
+               real *cos_phi,real *sign)
+{
+  real ipr,phi;
+  real mod_rij, mod_rkj, mod_rkl;
+
+  minimal_image(xi, xj, &mod_rij, r_ij);
+  minimal_image(xk, xj, &mod_rkj, r_kj);
+  minimal_image(xk, xl, &mod_rkl, r_kl); 
+
+  oprod(r_ij,r_kj,m);               
+  oprod(r_kj,r_kl,n);               
+  *cos_phi=cos_angle(m,n);          
+  phi=acos(*cos_phi);               
+  ipr=iprod(r_ij,n);                
+  (*sign)=(ipr<0.0)?-1.0:1.0;
+  phi=(*sign)*phi;                 
+                                   
+  return phi;
+}
+void PREFIX clear_rvec(rvec a)
+{
+  a[0]=0.0;
+  a[1]=0.0;
+  a[2]=0.0;
+}
+#endif
+
+// MPI stuff
+void PREFIX plumed_sum(struct mtd_data_s *mtd_data,int nr,real r[]){
+  static real *buf=NULL;
+  static int nalloc=0;
+  int i;
+#ifdef MPI
+  if (nr > nalloc) {
+    nalloc = nr;
+    srenew(buf,nalloc);
+  }
+
+  if(sizeof(real)==sizeof(double)){
+    MPI_Allreduce(r,buf,nr,MPI_DOUBLE,MPI_SUM,mtd_data->comm);
+  } else if(sizeof(real)==sizeof(float)){
+    MPI_Allreduce(r,buf,nr,MPI_FLOAT,MPI_SUM,mtd_data->comm);
+  } else assert(0);
+
+  for(i=0; i<nr; i++)
+    r[i] = buf[i];
+#endif
+};
+
+void PREFIX plumed_sumi(struct mtd_data_s *mtd_data,int nr,int r[]){
+  static int *buf=NULL;
+  static int nalloc=0;
+  int i;
+#ifdef MPI
+  if (nr > nalloc) {
+    nalloc = nr;
+    srenew(buf,nalloc);
+  }
+
+    MPI_Allreduce(r,buf,nr,MPI_INT,MPI_SUM,mtd_data->comm);
+
+  for(i=0; i<nr; i++)
+    r[i] = buf[i];
+#endif
+};
+
+void PREFIX plumed_intersum(struct mtd_data_s *mtd_data,int nr,real r[]){
+  static real *buf=NULL;
+  static int nalloc=0;
+  int i;
+#ifdef MPI
+  if (nr > nalloc) {
+    nalloc = nr;
+    srenew(buf,nalloc);
+  }
+
+  if(sizeof(real)==sizeof(double)){
+    MPI_Allreduce(r,buf,nr,MPI_DOUBLE,MPI_SUM,mtd_data->intercomm);
+  } else if(sizeof(real)==sizeof(float)){
+    MPI_Allreduce(r,buf,nr,MPI_FLOAT,MPI_SUM,mtd_data->intercomm);
+  } else assert(0);
+
+  for(i=0; i<nr; i++)
+    r[i] = buf[i];
+#endif
+};
+
+int PREFIX plumed_comm_size(struct mtd_data_s *mtd_data){
+#ifdef MPI
+  int size;
+  MPI_Comm_size(mtd_data->comm,&size);
+  return size;
+#else
+  return 1;
+#endif
+};
+int PREFIX plumed_comm_rank(struct mtd_data_s *mtd_data){
+#ifdef MPI
+  int rank;
+  MPI_Comm_rank(mtd_data->comm,&rank);
+  return rank;
+#else
+  return 0;
+#endif
+};
+
+real PREFIX rando_gaussian(int *ig)
+{
+  real x1,x2,w,y1,y2;
+  do{
+    x1=2.0*rando(ig)-1.0;
+    x2=2.0*rando(ig)-1.0;
+    w=x1*x1+x2*x2;
+  }while(w>=1);
+  w = sqrt( (-2.0 * log( w ) ) / w );
+  y1=x1*w;
+  y2=x2*w;
+  return y1;
+// NOTE  y2 is waisted
+};
+
+// random number
+#if !defined(PLUMED_GROMACS)
+real PREFIX rando(int *ig)
+     /* generate a random number. */
+{
+  int  irand;
+
+  int  m    = 100000000;
+  real rm   = 100000000.0;  /* same number as m, but real format */
+  int  m1   = 10000;
+  int  mult = 31415821;
+
+  real r;
+  int  irandh,irandl,multh,multl;
+
+  irand = abs(*ig) % m;
+
+  /* multiply irand by mult, but take into account that overflow
+   * must be discarded, and do not generate an error.
+   */
+  irandh = irand / m1;
+  irandl = irand % m1;
+  multh  = mult / m1;
+  multl  = mult % m1;
+  irand  = ((irandh*multl+irandl*multh) % m1) * m1 + irandl*multl;
+  irand  = (irand + 1) % m;
+
+  /* convert irand to a real random number between 0 and 1. */
+  r = (irand / 10);
+  r = r * 10 / rm;
+  if ((r <= 0) || (r > 1))
+    r = 0.0;
+  *ig = irand;
+
+  return r;
+}
+#endif
+// different init_metadyn
+#if defined (PLUMED_GROMACS)
+void init_metadyn(int natoms, int ePBC, real *charge, real *mass, 
+                  real dt, int repl_ex_nst, plumed_repl_ex repl_ex,
+                  const t_commrec *mcr, FILE *fplog)
+#elif defined (NAMD)
+void PREFIX init_metadyn()
+#elif defined (ACEMD)
+void init_metadyn(int natoms, real *charge, real *mass, 
+                  real dt, int repl, int nrepl, 
+                  real rte0, real rteio, char *metainp, real box[3])
+#elif defined (OPEP)
+void init_metadyn_(int *atoms, real *ddt, int *pbc_opep, 
+                   int *repl, int *nrepl,real *rte0, real *rteio, real *mass,
+                   char *lpath, char *logfile, char *metainp, int ll, int mm, int jj) 
+#elif defined (DL_POLY) || defined (AMBER) || defined (PLUMED_QESPRESSO) || defined (GAT_LJONES)
+  void init_metadyn_(int *atoms, real *ddt, real *mass, real *charge, int *imcon, real *eunit, char *metainp, int pp) 
+#elif defined (PLUMED_CPMD)
+void PREFIX init_metadyn(int *atoms, int *nsp, int *na, int *nsx, int *nax, real *ddt, int *stepnow, real *mass)
+//#elif defined (RECON_DRIVER)
+//void init_metadyn_(int *atoms, real *ddt, real *mass, real *charge, int *pbc, real *box, char *metainp, int* ncv, double *periods, real *width, real *height, real *sizeParam, int ll)
+#elif defined (DRIVER)
+void init_metadyn_(int *atoms, real *mass, real *charge, int *pbc, real *box, real *ddt ,char *metainp, int* ncv, int ll )
+#elif defined (STANDALONE)
+void init_metadyn_(int *atoms, real *mass, real *charge, int *pbc, real *box, real *tstep, int *nstep, real *myboltz, real* ampli, char *metainp, int ll)
+#elif defined (LAMMPS_PLUMED)
+void PREFIX init_metadyn( char *metainp, char *metaout, int *atoms, real *mass, real *charge, real *ddt ,real myboltz)
+#endif
+{
+  int i;
+  long int j;
+  real k;
+  char stringa[800];
+  FILE *fp;
+
+#if defined (PLUMED_GROMACS)
+#if defined (GMX_THREADS)
+  fprintf(stderr, "ERROR: PLUMED DOES NOT SUPPORT THE MULTI THREADING VERSION OF GROMACS!!\n");
+  fprintf(stderr, "ERROR: IF YOU WANT A SCALAR VERSION PLEASE RECONFIGURE GROMACS WITH THE\n");
+  fprintf(stderr, "ERROR: OPTIONS --disable-threads OTHERWISE COMPILE IT BY USING MPI\n");
+  fflush(stderr);
+  exit(1);
+#endif
+  int repl,nrepl;
+  real rte0,rteio;
+  mtd_data.ionode = 1;
+#ifdef MPI
+#if defined (PLUMED_GROMACS4) || defined (PLUMED_GROMACS45)
+  if(mcr && !MASTER(mcr)) mtd_data.ionode = 0;
+#else
+/* NOTE: in gromacs3, when using replica exchange, only 1 node is MASTER
+   since we need one ionode per replica, there is a special case for replica exchange */
+  if(mcr && !MASTER(mcr) && !repl_ex_nst>0) mtd_data.ionode = 0;
+#endif
+#endif
+  if(mcr && mtd_data.ionode){
+      repl=(repl_ex_nst>0?replica_exchange_get_repl(repl_ex):-1);
+      nrepl=(repl_ex_nst>0?replica_exchange_get_nrepl(repl_ex):1);
+      rte0=(repl_ex_nst>0?replica_exchange_get_temp(repl_ex,0):0);
+      rteio=(repl_ex_nst>0?replica_exchange_get_temp(repl_ex,repl):0);
+  } else {
+      repl=0;
+      nrepl=0;
+      rte0=0.;
+      rteio=0.;
+  };
+#ifdef MPI
+// these are done here since they are needed for the plumed_sum calls
+// we have to find a more consistent way to do it
+#if defined(PLUMED_GROMACS4) || defined(PLUMED_GROMACS45)
+  if(mcr && PAR(mcr)) {
+    if(mcr->dd) mtd_data.comm=mcr->dd->mpi_comm_all;
+    else mtd_data.comm=mcr->mpi_comm_mysim;
+  } else mtd_data.comm=MPI_COMM_SELF;
+  if(mtd_data.ionode && mcr && mcr->ms) mtd_data.intercomm=mcr->ms->mpi_comm_masters;
+  else mtd_data.intercomm=MPI_COMM_NULL;
+#endif
+  if(mcr && PAR(mcr)){
+    plumed_sumi(&mtd_data,1,&repl);
+    plumed_sumi(&mtd_data,1,&nrepl);
+    plumed_sum(&mtd_data,1,&rte0);
+    plumed_sum(&mtd_data,1,&rteio);
+  }
+#endif
+  mtd_data_init (ePBC, charge, mass, natoms, dt, repl_ex_nst, repl, nrepl, 
+                 rte0, rteio, mcr, fplog);
+#elif NAMD
+  mtd_data_init();
+#elif ACEMD
+  mtd_data_init(  charge, mass, natoms, dt, repl, nrepl, 
+		  rte0, rteio, metainp,box);
+#elif OPEP
+  mtd_data_init(*pbc_opep,*ddt,*atoms,*repl,*nrepl,*rte0,*rteio,mass,lpath,logfile,metainp);
+#elif defined (DL_POLY) || defined (AMBER) || defined (PLUMED_QESPRESSO) || defined (GAT_LJONES)
+  mtd_data_init( *atoms , *ddt , mass, charge , imcon, eunit, metainp);
+#elif defined (PLUMED_CPMD)
+  char *metainp="plumed.dat";
+  mtd_data_init( *atoms, *nsp, na, *nsx, *nax, *ddt, *stepnow, mass, metainp);
+//#elif RECON_DRIVER
+//  mtd_data_init( *atoms, mass, charge, metainp, *pbc, box, *ddt);
+#elif DRIVER
+  mtd_data_init( *atoms, mass, charge, metainp, *pbc, box, *ddt);
+#elif STANDALONE 
+  mtd_data_init( *atoms, mass, charge, *pbc, box, tstep, nstep, myboltz, ampli, metainp );
+#elif LAMMPS_PLUMED 
+   mtd_data_init(metainp, metaout, (*atoms), mass, charge, ddt, myboltz );
+#endif
+
+  read_restraint(&mtd_data);             // read META_INP
+
+  if(colvar.nconst==0) return;                          // no CVs, no party!
+  firstTime = 1;                                        // it is the first step!
+  hills.ntothills = 0;
+  sprintf(mtd_data.colfilen, "COLVAR");
+  sprintf(mtd_data.dump_filen, "PLUMED_DUMP.xtc");
+  sprintf(mtd_data.hilfilen, "%s/HILLS", hills.dir);
+  if(logical.remd){                                     // in replica exchange case
+    if(mtd_data.repl!=-1) {
+      sprintf(mtd_data.colfilen, "%s/COLVAR%i", hills.dir, mtd_data.repl);
+      sprintf(mtd_data.dump_filen, "%s/PLUMED_DUMP%i.xtc", hills.dir, mtd_data.repl);
+      sprintf(mtd_data.hilfilen, "%s/HILLS%i",  hills.dir, mtd_data.repl);
+      if(logical.read_grid)   sprintf(grid.r_file,"%s%i",  grid.r_file, mtd_data.repl);
+      if(logical.write_grid)  sprintf(grid.w_file,"%s%i",  grid.w_file, mtd_data.repl);
+      if(logical.do_external) sprintf(extpot.r_file,"%s%i",  extpot.r_file, mtd_data.repl);
+#if defined (PLUMED_GROMACS4) || defined (PLUMED_GROMACS45)
+    } else if(mtd_data.mcr->ms->nsim>1) {
+      sprintf(mtd_data.colfilen, "%s/COLVAR%i", hills.dir, mtd_data.mcr->ms->sim);
+      sprintf(mtd_data.dump_filen, "%s/PLUMED_DUMP%i.xtc", hills.dir, mtd_data.mcr->ms->sim);
+      sprintf(mtd_data.hilfilen, "%s/HILLS%i",  hills.dir, mtd_data.mcr->ms->sim);
+      if(logical.read_grid)   sprintf(grid.r_file,"%s%i",  grid.r_file, mtd_data.mcr->ms->sim);
+      if(logical.write_grid)  sprintf(grid.w_file,"%s%i",  grid.w_file, mtd_data.mcr->ms->sim);
+      if(logical.do_external) sprintf(extpot.r_file,"%s%i",  extpot.r_file, mtd_data.mcr->ms->sim);
+#endif
+    }
+  }
+  if(logical.do_walkers){
+    sprintf(mtd_data.basefilen, "%s/HILLS",  hills.dir);
+    sprintf(mtd_data.hilfilen, "%s/HILLS.%i", hills.dir, hills.idwalker);
+  }
+#ifdef STANDALONE 
+// restore printout
+    if(mtd_data.istep!=0){
+            fclose(mtd_data.fplog);
+            mtd_data.fplog = fopen("PLUMED.OUT","a");
+            firstTime = 0;                                        // it is the first step!
+            if(logical.do_hills){
+                    FILE *file;
+                    // if the file exists then restart
+                        file = fopen(mtd_data.hilfilen, "r");
+                        if(file!=NULL){
+                                 logical.restart_hills = 1;
+                        }  else {
+                                 logical.restart_hills = 0;
+                        }
+            }
+    } else {
+            firstTime=1;
+    }
+    fflush(mtd_data.fplog);
+#endif
+  if(logical.do_external) grid_read_fromfile(&extpot, 0);    // reading external potential from file
+  if(logical.do_hills){
+    hills.ntothills = STACKDIM ;// dimesion of hills vector
+    hills.ss0_t     = float_2d_array_alloc(hills.ntothills,colvar.nconst); 
+    hills.ww        = float_1d_array_alloc(hills.ntothills);
+    colvar.delta_s  = float_2d_array_alloc(hills.ntothills,colvar.nconst);
+    if(logical.read_grid)  grid_read_fromfile(&grid, 1);      // reading GRID from file 
+    if(logical.restart_hills) {
+      read_hills(&mtd_data,1,hills.first_read);    	// if restart
+    } else {                                           	// if not restart, backup old file
+#if STANDALONE 
+     if(hills.nwalkers==1 &&  firstTime==1 ){
+#endif
+      sprintf(stringa, "%s.old", mtd_data.hilfilen);
+      if(mtd_data.ionode) rename(mtd_data.hilfilen, stringa);
+      sprintf(stringa, "%s.old", mtd_data.colfilen);
+      if(mtd_data.ionode) rename(mtd_data.colfilen, stringa);
+#if STANDALONE 
+     }
+#endif
+    }
+    for(j=0;j<GTAB;j++) {
+      k = (real) DP2CUTOFF/GTAB*j;
+      hills.exp[j] = exp(-k);
+    }  
+  }else{
+  // evtl move the old colvar file
+      if (firstTime==1 && !logical.append && !logical.restart_abmd){
+        sprintf(stringa, "%s.old", mtd_data.hilfilen);
+        if(mtd_data.ionode) rename(mtd_data.hilfilen, stringa);
+        sprintf(stringa, "%s.old", mtd_data.colfilen);
+        if(mtd_data.ionode) rename(mtd_data.colfilen, stringa);
+      }
+  }
+
+#ifdef DRIVER
+  (*ncv)=colvar.nconst;
+#endif
+
+#ifdef STANDALONE
+  if(mtd_data.newcolvarfmt &&  firstTime==1  ) init_print_colvar_enercv();
+#else
+  if(mtd_data.newcolvarfmt) init_print_colvar_enercv();
+#endif
+}
+
+void PREFIX minimal_image(rvec pos1, rvec pos2, real *mod_rij, rvec rij)
+{
+#if defined (NAMD)
+Vector Vect1,Vect2,rij_v;
+rvec2vec(pos1,&Vect1);
+rvec2vec(pos2,&Vect2);
+rij_v=Node::Object()->simParameters->lattice.delta(Vect1,Vect2);
+*mod_rij=rij_v.length();
+rij[0]=rij_v.x;
+rij[1]=rij_v.y;
+rij[2]=rij_v.z;
+#elif defined (PLUMED_GROMACS)
+ pbc_dx(&mtd_data.metapbc, pos1, pos2, rij);
+ *mod_rij = sqrt(rij[0]*rij[0] + rij[1]*rij[1] + rij[2]*rij[2]);
+#elif defined (OPEP)
+real rin;
+int i;
+for(i=0;i<3;i++){
+ rin = pos1[i] - pos2[i];
+ if(mtd_data.imcon==1) {
+  rij[i] = pbc_mic_(&rin);
+ } else {
+  rij[i] = rin;
+ }
+}
+*mod_rij = sqrt(rij[0]*rij[0] + rij[1]*rij[1] + rij[2]*rij[2]);
+#elif defined (DL_POLY) || defined (GAT_LJONES)
+  int zero,one;
+  zero=0;
+  one=1;
+  rij[0]=pos1[0]-pos2[0];   
+  rij[1]=pos1[1]-pos2[1];   
+  rij[2]=pos1[2]-pos2[2];   
+  images_(&(mtd_data.imcon),&zero,&one,&one,mtd_data.cell,&rij[0],&rij[1],&rij[2]); 
+  *mod_rij=sqrt(pow(rij[0],2)+pow(rij[1],2)+pow(rij[2],2));
+#elif LAMMPS_PLUMED
+  rij[0]=pos1[0]-pos2[0];   
+  rij[1]=pos1[1]-pos2[1];   
+  rij[2]=pos1[2]-pos2[2];   
+  (mtd_data.mydomain)->minimum_image(rij[0],rij[1],rij[2]);  
+  *mod_rij=sqrt(pow(rij[0],2)+pow(rij[1],2)+pow(rij[2],2));
+#elif defined (PLUMED_CPMD)
+  rij[0]=pos1[0]-pos2[0];
+  rij[1]=pos1[1]-pos2[1];
+  rij[2]=pos1[2]-pos2[2];
+#if defined(PLUMED_CPMD_NOUNDERSCORE)
+  pbc_cpmd_plumed(&rij[0],&rij[1],&rij[2]);
+#else
+  pbc_cpmd_plumed_(&rij[0],&rij[1],&rij[2]);
+#endif
+  *mod_rij=sqrt(pow(rij[0],2)+pow(rij[1],2)+pow(rij[2],2));
+#elif defined (ACEMD) || defined (DRIVER) || defined (AMBER) || defined (STANDALONE) || defined (PLUMED_QESPRESSO) 
+  int i;
+  real sqrt_four_third=1.15470053837925152901;
+  for(i=0;i<3;i++) rij[i] = pos1[i] - pos2[i];
+  if(mtd_data.imcon==0){ 
+// no pbc
+  }else if(mtd_data.imcon==1){ 
+// orthorhombic cell
+    for(i=0;i<3;i++) rij[i] -= mtd_data.cell[i]*rint(rij[i]/mtd_data.cell[i]);
+#ifdef AMBER
+  }else if(mtd_data.imcon==2) {
+// truncated octahedron, corresponding to a bcc lattice
+// in AMBER convention, mtd_data.cell[0] is the length of the lattice vector
+// a is defined so as the bcc lattice is (a/2,a/2,a/2) (-a/2,-a/2,a/2) (a/2,-a/2,-a/2)
+    real a=sqrt_four_third*mtd_data.cell[0];
+    real inva=1.0/a;
+    for(i=0;i<3;i++) rij[i]-=a*rint(inva*rij[i]);
+    if((fabs(rij[0])+fabs(rij[1])+fabs(rij[2]))>0.75*a)
+      for(i=0;i<3;i++)if(rij[i]>0) rij[i]-=0.5*a; else rij[i]+=0.5*a;
+#endif
+  } else {
+    plumed_error("UNSUPPORTED CELL");
+  }
+*mod_rij = sqrt(rij[0]*rij[0] + rij[1]*rij[1] + rij[2]*rij[2]);
+#endif
+}
+void PREFIX EXIT()
+{
+#ifdef NAMD
+CkExit();
+#else
+exit(1);
+#endif
+} 
+
+real  **** PREFIX float_4d_array_alloc(int ii,int jj,int kk,int ll){
+  real ****xx;
+  real *ptr;
+  int i,j,k;
+  ptr=(real *)calloc(ii*jj*kk*ll,sizeof(real));
+  xx=(real ****)calloc(ii,sizeof(real ***));
+  for (i=0;i<ii;i++){
+    xx[i]=(real ***)calloc(jj,sizeof(real **));
+    for(j=0;j<jj;j++){
+      xx[i][j]=(real **)calloc(kk,sizeof(real *));
+      for(k=0;k<kk;k++)xx[i][j][k]= & ptr[ll*(kk*(i*jj+j)+k)];
+    }
+  }
+  return xx;
+};
+
+real  *** PREFIX float_3d_array_alloc(int ii,int jj,int kk){
+  real ***xx;
+  real *ptr;
+  int i,j;
+  ptr=(real *)calloc(ii*jj*kk,sizeof(real));
+  xx=(real ***)calloc(ii,sizeof(real **));
+  for (i=0;i<ii;i++){
+    xx[i]=(real **)calloc(jj,sizeof(real *));
+    for(j=0;j<jj;j++) xx[i][j]= & ptr[kk*(i*jj+j)];
+  };
+  return xx;
+};
+
+real  ** PREFIX float_2d_array_alloc(int ii,int jj){
+  real **xx;
+  real *ptr;
+  int i;
+  ptr=(real *)calloc(ii*jj,sizeof(real));
+  xx=(real **)calloc(ii,sizeof(real *));
+  for (i=0;i<ii;i++)xx[i]=& ptr[jj*i];
+  return xx;
+};
+
+real  * PREFIX float_1d_array_alloc(int ii){
+  real *xx;
+  xx=(real *)calloc(ii,sizeof(real));
+  return xx;
+};
+
+
+int  ** PREFIX int_2d_array_alloc(int ii,int jj){
+  int **xx;
+  int *ptr;
+  int i;
+  ptr=(int *)calloc(ii*jj,sizeof(int));
+  xx=(int **)calloc(ii,sizeof(int *));
+  for (i=0;i<ii;i++) xx[i]= & ptr[jj*i];
+  return xx;
+};
+
+int  * PREFIX int_1d_array_alloc(int ii){
+  int *xx;
+  xx=(int *)calloc(ii,sizeof(int));
+  return xx;
+};
+
+int PREFIX free_4dr_array_alloc(real ****xx,int ii,int jj,int kk){
+  int i,j;
+  assert(xx[0][0][0]); free(xx[0][0][0]);
+  for(i=0;i<ii;i++){
+    for(j=0;j<jj;j++){
+      assert(xx[i][j]);
+      free(xx[i][j]);
+    }
+    assert(xx[i]); free(xx[i]);
+  }
+  free(xx);
+  return 0;
+};
+
+int PREFIX free_3dr_array_alloc(real ***xx,int ii,int jj){
+  int i;
+  assert(xx[0][0]); free(xx[0][0]);
+  for (i=0;i<ii;i++) {
+    assert(xx[i]); free(xx[i]);
+  }
+  assert(xx); free(xx);
+  return 0;
+};
+
+int PREFIX free_2dr_array_alloc(real **xx,int ii){
+  assert(xx[0]); free(xx[0]);
+  assert(xx); free(xx);
+  return 0;
+};
+
+int PREFIX free_1dr_array_alloc(real *xx){
+  free(xx);
+  return 0;
+};
+
+int PREFIX free_2di_array_alloc(int **xx,int ii){
+  assert(xx[0]); free(xx[0]);
+  assert(xx); free(xx);
+  return 0;
+};
+
+int PREFIX free_1di_array_alloc(int *xx){
+  assert(xx); free(xx);
+  return 0;
+};
+
+void PREFIX realquicksort ( real *v , int *ind , int left , int right ) {
+        int i,last;
+        if(left>=right)return;
+        swap(v,ind,left,(left+right)/2);
+        last=left;
+        for(i=left+1;i<=right;i++){
+           if ( v[i]<v[left] ) swap(v,ind,++last,i);
+        }
+        swap(v,ind,left,last);
+        realquicksort(v,ind,left,last-1 );
+        realquicksort(v,ind,last+1,right);
+}
+void PREFIX swap (real *v,int *ind,int i,int j){
+        real temp;
+        int tempi;
+        temp=v[i];
+        v[i]=v[j];
+        v[j]=temp;
+        tempi=ind[i];
+        ind[i]=ind[j];
+        ind[j]=tempi;
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/metadyn.h dl_class_1.9/srcmod/Plumed/metadyn.h
--- dl_class_1.9.orig/srcmod/Plumed/metadyn.h	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/metadyn.h	2015-11-07 17:37:19.412604911 +0100
@@ -0,0 +1,1522 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#ifndef EXTERNALS
+#if defined NAMD
+   #define MYEXT 
+#elif defined LAMMPS_PLUMED
+   #define MYEXT 
+#elif defined PLUMED_CPMD
+   #define MYEXT
+#else
+   #define MYEXT extern
+#endif   
+#else
+   #define MYEXT
+#endif
+
+#ifdef RECONMETAD 
+  #include "recon_cbind.h"
+#endif
+
+// common header files
+#include <stdio.h>
+#include <time.h>
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+#include <ctype.h>
+#ifdef HAVE_MATHEVAL
+#include <matheval.h> 
+#endif
+
+// NAMD header files and definitions
+#if defined (NAMD)
+#define PREFIX GlobalMasterMetaDynamics::
+#include "ComputeHomePatches.h"
+#include "GlobalMaster.h"
+#include "GlobalMasterEasy.h"
+#include "NamdTypes.h"
+#include "SimParameters.h"
+#include "Molecule.h"
+#include "Node.h"
+#include "Vector.h" 
+#include "signal.h"
+
+// GROMACS header files and definitions
+#elif defined (PLUMED_GROMACS4) || defined (PLUMED_GROMACS45)
+#define PLUMED_GROMACS
+#define PREFIX
+#include "config.h"
+#include "typedefs.h"
+#include "smalloc.h"
+#include "pbc.h"
+#include "vec.h"
+#include "physics.h"
+#include "network.h"
+#include "nrnb.h"
+#include "bondf.h"
+#include "random.h"
+#include "repl_ex.h"
+
+#ifdef PLUMED_GROMACS45
+#include "sighandler.h"
+#include "xtcio.h"
+#ifdef GMX_LIB_MPI
+#define MPI
+#endif
+#else
+#ifdef GMX_MPI
+#define MPI
+#endif
+#endif
+
+//ACEMD header files and definitions
+#elif defined (ACEMD)
+#define PREFIX
+#include <aceplug.h>
+
+//LAMMPS header files and definitions
+#elif defined (LAMMPS_PLUMED)
+#include "domain.h"
+using namespace LAMMPS_NS;
+#define PREFIX Plumed::
+
+//CPMD
+#elif defined (PLUMED_CPMD)
+#define PREFIX Plumed::
+
+// Fortran codes (no header needed)
+#else
+#define PREFIX
+#endif
+
+// Eventually, we include the mpi header
+#ifdef MPI
+#include "mpi.h"
+#endif
+
+// This is needed because of the inconsistency in the definition of gmx_repl_ex_t in versions 3 and 4
+#if defined (PLUMED_GROMACS4) || defined (PLUMED_GROMACS45)
+    typedef gmx_repl_ex_t plumed_repl_ex;
+#endif
+
+// here we provide alternatives of gromacs macros for the other codes
+#if ! defined (PLUMED_GROMACS)
+typedef double real;
+typedef double rvec[3];
+#define REAL_EPS 1.11022302E-16
+// double precision accuracy 
+#if defined (PLUMED_AIXXLF)
+#define snew(ptr,nelem) (ptr)= (nelem==0 ? NULL : (__typeof__(ptr)) calloc(nelem,sizeof(*(ptr))))
+#define srenew(ptr,nelem) (ptr)= (__typeof__(ptr)) realloc(ptr,(nelem)*sizeof(*(ptr)))
+#else
+#define snew(ptr,nelem) (ptr)= (nelem==0 ? NULL : (typeof(ptr)) calloc(nelem,sizeof(*(ptr))))
+#define srenew(ptr,nelem) (ptr)= (typeof(ptr)) realloc(ptr,(nelem)*sizeof(*(ptr)))
+#endif
+#else
+// gromacs "real" precision accuracy 
+#define REAL_EPS GMX_REAL_EPS
+#endif
+// use gromacs and lammps proprietary sfree
+#if !defined   (PLUMED_GROMACS) && !defined (LAMMPS_PLUMED)
+#define sfree(ptr) if(ptr != NULL)free(ptr)   
+#endif
+
+
+// common global structures and definitions
+#define nconst_max 200					// fixed maximum number of COLVARS
+#define DP2CUTOFF 6.25					// sigma^2 considered for gaussian
+#define GTAB 1000000					// mesh for exponential tablature
+#ifndef M_PI
+#define M_PI 3.14159265
+#endif
+#ifndef M_2PI
+#define M_2PI 6.2831853 
+#endif
+// path dimensions
+#define MAXATOMS_PATH 900
+#define NMAX_PATH 10 
+#define MAXFRAMES_PATH 52 
+#define MAXATOMS_RMSD 900
+#define MAXCHARS_PATH 40
+// cmap 
+#define MAXDIM_CMAP 5000
+#define MAXNUM_GROUP  10
+#define MAXATOM_GROUP 30
+// stackdimension for hills
+#define STACKDIM  10000 
+// verlet list
+#define MAXNN 2000
+
+// Structure containing the parsed input file
+typedef struct {
+  int     nlines;     // number of lines
+  int*    nwords;     // number of words (in each line)
+  char*** words;      // words in each line (+ an extra empty word as a terminator(
+  int     ngroups;    // number of group definitions found
+  char**  groupnames; // names of groups
+  int*    natoms;     // number of members (for each group)
+  int**   atoms;      // members (for each group)
+} t_plumed_input;
+
+// structure for gradient projections
+// linked list
+struct  coupling_ll {
+        int *at1,*at2,nat1,nat2;
+        struct coupling_ll  *next_elem;
+};
+// couple of cv containing the linked list
+struct  el_couple {
+    int cv1,cv2;
+    struct coupling_ll *first_elem;
+};
+struct el_diagonal {
+    struct coupling_ll *first_elem;
+    real *accm;
+    real *acct;
+};
+struct proj_grad_s {
+  int *list;
+  int  nlist; 
+  int nvar,ncouples;
+  struct el_couple *couple;
+  struct  el_diagonal *diagonal;
+  real  **matrix;
+  real  **invmatrix;
+  real  volume;
+  real  *averages;
+  real  *prec;
+  char dumpfile[200];
+  char log[1000];
+  real w_stride;
+};
+// pdb struct for pdb parsing
+struct pdb {
+	int natoms,*index, *resid;
+	real *x,*y,*z,*occ,*beta;
+	char **name, **resname,**chain;
+};
+
+// use this for generic rmsd container and general path variables
+// all dynamical allocatable for ease of use
+struct rmsd_container_t {
+	// this keeps the label and the original file
+	struct pdb *mypdb;
+	int ndisplace;
+	int nalign;
+	int natoms;
+	int dummy;
+	int dref;
+	int dref_freq;
+	char dreffile[200];
+	int *index;
+	real *x,*y,*z;
+	real *align; //[MAXATOMS_PATH];    // for each atom is >0 if used for alignment, else 0
+	real *displace; //[MAXATOMS_PATH]; // for each atom is >0 if used for displacement, else 0
+	real walign;
+	real wdisplace;
+	int *lalign;
+	int *ldisplace;
+	int simple; 
+	FILE *fpdreffile;
+};
+
+// common NAMD/GROMACS interface
+struct mtd_data_s
+{
+   int  natoms;
+   real **pos;
+   real **vel;
+   real **force;
+   real *charge;
+   real *mass;
+   real temp_t; 
+   int  repl;
+   int  nrepl;
+   int  repl_ex_nst;  
+   real rte0;
+   real rteio;
+   real time;
+   real time_offset;
+   FILE *fplog;
+   char metaFilename[120];
+   real dt;
+   long long int  istep;					// #### This needs to be long long for long RESPA runs !
+   long long int  istep_old;				// #### This needs to be long long for long RESPA runs !
+   real eunit;
+   real boltz;
+   int  ionode;                                        // this is true only in the master node
+   real energy;
+   int  newcolvarfmt;
+   char   colfilen[800];					// COLVAR and ENERCV files
+   char   hilfilen[800];					// HILLS file
+   char   basefilen[800];				// BASENAME file
+   char   dump_filen[800];                               // file for atoms dumping
+#if !defined (PLUMED_GROMACS45)
+   int    dump_file;                                     // unit
+#else
+   t_fileio* dump_file;
+#endif
+   int    dump_stride;                                   // stride
+   int    dump_atoms;                                   // list of dumped atoms
+   int*   dump_list;                                    // list of dumped atoms
+#ifdef MPI
+// communicators for parallel PLUMED
+   MPI_Comm comm;       // INTRA replica
+   MPI_Comm intercomm;  // INTER replica (for bias-exchange and ptmetad)
+#endif
+
+// code-specific definitions
+#if defined (PLUMED_GROMACS)
+   const t_commrec *mcr;  
+   real cell[3][3];
+   t_pbc  metapbc;
+#if defined (PLUMED_GROMACS4) || defined (PLUMED_GROMACS45)
+   int  ePBC;
+#endif
+
+#elif defined (OPEP)
+   char log[120];
+   int imcon;
+
+#elif defined (DL_POLY) || defined (GAT_LJONES)
+   int imcon;
+   real cell[9];
+
+#elif defined (ACEMD) || defined (AMBER) || defined (DRIVER) || defined (STANDALONE) || defined (PLUMED_QESPRESSO)
+   int  imcon;
+   real cell[3];
+
+#elif defined (LAMMPS_PLUMED)
+   Domain *mydomain;
+#endif
+#ifdef STANDALONE 
+   real ampli;
+#endif
+
+  
+};
+
+struct logical_s
+{
+  int    do_hills;					// hills on/off
+  int    widthadapt;
+  int    do_inversion;                                  // do inversion condition 
+  int    invert[nconst_max][2];                         // inversion condition
+  int    restart_hills;					// restart meta 
+  int    append;                                        // append on COLVAR 
+  int    restart_abmd;                                 	// restart abmd
+  int    upper[nconst_max];				// upper walls
+  int    lower[nconst_max];				// lower walls
+  int    interval[nconst_max];                          // fahimeh 
+  int    do_walls;						// #### any walls ?
+  int    steer[nconst_max];				// steering cv on/off
+  int    dafed[nconst_max];				// d-AFED cv on/off ####
+  int    do_dafed;					// d_AFED main switch ###
+  int    do_constraint;					// constraint main switch ###
+  int    tamd;                                          // tamd/dafed on/off
+  int    abmd[nconst_max];				// abmd cv on/off
+  int    cnstr[nconst_max];				// constraint cv on/off
+  int    always[nconst_max];				// if one in (hills, walls, steering, abmd, constraint) is on then is 1 else is 0
+  int    remd;						// replica exchange parallel tempering
+  int    rpxm;						// replica exchange metadynamics
+  int    hrex;                                          // Hamiltonian replica-exchange
+  int    commit;					// committors analysis
+  int    print;						// do COLVAR 
+  int    norescale;
+  int    welltemp;
+  int    lreflect[nconst_max];
+  int    ureflect[nconst_max];
+  int    debug;
+  int    not_same_step;
+  int    meta_inp;
+  int    parallel_hills;                                // hills sum is parallelized
+  int    debug_derivatives;
+  int    enable_untested_features;
+  int    do_grid;
+  int    read_grid;
+  int    write_grid;
+  int    donot_spline;
+  int    debug_grid;
+  int    do_walkers;
+  int    puckering;
+  int    path;
+  int    energy;
+  int    read_old_bf;
+  int    do_external;
+  int    do_alphabetarmsd;
+  int    do_sprint;
+  int    do_steerplan;
+  int    do_pca;
+  int    nlist[nconst_max];
+};
+
+struct adapt
+{
+  int    block;
+  int    stride;
+  int    on;
+  real   inf;
+  real   sup;
+  real   widthmultiplier;                               // Hills width adapt
+};
+
+struct colvar_s
+{
+  int nbespoke;                                      // # of Bespoke CVs
+#ifdef CVS
+  // int    bespoke_eps;                                   // The exponent used to calculate the bespoke cvs
+  // int    bespoke_nneigh;                                // The number of neighbours used to calculate bespoke cvs
+  int    bespoke_ncv;                                   // # number of CVs in each bespoke CV (these should all be the same)
+  int    *bespoke_cvlist;                               // The CVs used to calculate each bespoke collective coordinate                         
+#endif
+  int    nconst;					// # CVs
+  int    nt_print;					// step for printing colvar and enercv
+  int    it;						// PluMeD step counter
+  real   delta_r [nconst_max];				// Hills width along CVs
+  real   inv_limit[nconst_max][2];                      // Limits used in inversion
+  real   inv_ref[nconst_max];                           // Reflection interval used in the inversion
+  real   inv_inv[nconst_max];                           // Inversion interval
+  real   inv_maxww[nconst_max];                         // Inversion gaussian height upper limit (colvar.inv_maxww*hills.wwr)
+  real   **delta_s;					// Hills width along CVs in time
+  struct adapt adapt[nconst_max];                             // adaptive width structure
+  real   ff_hills[nconst_max];				// force due to hills
+  int    on      [nconst_max];				// hills on/off on a CV
+  int    type_s  [nconst_max];				// colvar type (DIST, ...)
+  // Parameters for histogram colvars
+  int    histo_ncv[nconst_max];                         // The number of cvs used to make each histogram
+  int    *histo_cvlist[nconst_max];                     // The list of cvs used to make the histogram
+  real   histo_low[nconst_max];                         // The lower bound of the histogram bead  
+  real   histo_high[nconst_max];                        // The upper bound of the histogram bead
+  real   histo_width[nconst_max];                       // The widths of the Gaussians used to make histograms
+  // Parameters for rdf colvars
+  int    rdfNorm [nconst_max];                          // Are we normalizing according to the volume of the bin?
+  int    rdflab  [nconst_max];                          // Which rdf is this bead from
+  real   rdfBeadLower[nconst_max];                      // Lower bound for bin 
+  real   rdfBeadUpper[nconst_max];                      // Upper bound for bin
+  real   rdfBeadWidth[nconst_max];                      // Width of bin
+  // End of rdf colvar params
+  int    doTrig  [nconst_max];                          // Used by torsion so that we can use sines and cosines of torsions GAT 
+  int    nn      [nconst_max];				// used by for numerator exponent
+  int    mm      [nconst_max];				// used by for denominator exponent
+  real   r_0     [nconst_max];				// used by for binding distance
+  real   d_0     [nconst_max];				// used by for binding distance
+  real   beta    [nconst_max];				// used by mindist
+  int    intpar  [nconst_max][21];                      // array of integers (general use)
+  rvec   realpar [nconst_max][21];                      // array of reals (general use)
+  rvec   vecpar  [nconst_max][21];                       // array of vecors (general use)
+  real   *map0   [nconst_max]; 				// inter e intra contact starting maps
+  real   *map1   [nconst_max];                          // inter e intra contact starting maps
+  int    groups  [nconst_max];				// energy groups id, other id
+  int    type    [nconst_max];				// type id (beta sheet, alpha elicas, none, ecc..)
+  rvec   *myder  [nconst_max];				// derivatives
+  real   ss0     [nconst_max];                          // CVs value 
+  real   Mss0    [nconst_max];				// Hills width adapt
+  real   M2ss0   [nconst_max];				// Hills width adapt
+  real   wtemp;	         				// well tempered temperature
+  real   simtemp;                                       // simulation temperature
+  real   wfactor;                                       // welltemp factor = wtemp/simtemp
+  int    list[nconst_max][4];                           // structure definition for list 
+  int    natoms  [nconst_max];
+  int    *cvatoms[nconst_max];
+  int    logic[nconst_max];
+  int    cell_pbc[nconst_max];                          // switch for applying pbc (where it applies)
+  int    ptmetad_neighbours;
+  real    ptmetad_sigma;
+  int    align_atoms;
+  int    *align_list;
+  struct rmsd_container_t rmsd_container[nconst_max];  // general rmsd container
+  // projections 
+   struct proj_grad_s  pg;
+  // optimized weights
+  real   *ow_weight  [3*nconst_max];
+  real   hrex_energy;
+  // PCA CV
+  int  pca_align_atoms;					// number of atoms to align with (*)
+  int  *pca_align_list;					// list of atoms to align with (*)
+  rvec *pca_align_coord;				// coordinates of atoms to align with (*)
+  real  *pca_align_mass;				// masses of atoms to align with (*)
+  real  pca_align_totmass;				// total mass of atoms to align with (*)
+							// (*) it is not an array [nconst_max] because only 1 reference
+							// frame is allowed even if there are more PCA CVs
+  struct pcacomp_s *pcacomp[nconst_max];		// pca vector components structure 
+  int pca_diff		[nconst_max];			// DIFF keyword flag
+  int pca_align		[nconst_max];			// NOALIGN keyword flag
+  int pca_upstride	[nconst_max];			// UPSTRIDE keyword flag
+  real old_d[3][3];					// saves the rotation matrix for efficiency
+  real old_dd_dr1[3][3][3][MAXATOMS_RMSD];		// and its derivatives!
+
+  char  hills_label[50];                                // a label associated to the hills file, shown in headers
+};
+
+struct hills_s
+{
+  real     wwr;						// Hill height
+  real     rate;					// Hill deposition rate
+  real     max_height;    				// Maximum height of added hills (0 means NO maximum)
+  int      max_stride;    				// Maximum stride between hills (0 means NO maximum)
+  real     *ww;						// Hill height history
+  long int n_hills;					// Hills added
+  int      nt_hills;					// Period in step to add hills
+  int      nr_hills;					// Period in step to read hills
+  real     **ss0_t;					// Hills center history
+  char     dir[800];					// HILLS place
+  long int ntothills;					// max number of hills
+  real     exp[GTAB];					// table for exponential
+  long int read;
+  fpos_t   *line_counter;
+  int      first_read;
+  int      nwalkers;
+  int      idwalker;
+  real   Vhills;					// Hills potential
+};
+
+struct wall
+{
+  real   upper   [nconst_max];				// upper limit where start the wall
+  real   lower   [nconst_max];				// lower limit
+  real   lsigma  [nconst_max];				// lower force constant
+  real   sigma   [nconst_max];				// upper force constant
+  real   fwall   [nconst_max];				// force due to wall
+  int    uexp    [nconst_max];				// upper softwall exponent
+  int    lexp    [nconst_max];				// lower softwall exponent
+  real   ueps    [nconst_max];				// redux factor for upper wall 
+  real   leps    [nconst_max];				// redux factor for lower wall 
+  real   uoff    [nconst_max];                          // offset for upper wall
+  real   loff    [nconst_max];                          // offset for lower wall     
+  int    st_inv  [nconst_max];
+  real   Vwall;						// Wall potential
+};
+
+struct interval_s
+{
+  real   upper_limit   [nconst_max];                          // fahimeh 
+  real   lower_limit   [nconst_max];                          // fahimeh    
+};
+
+struct steer {
+ real    pos     [nconst_max];				// position of umbrella
+ real    delta   [nconst_max];				// increment of umbrella along cv
+ real    spring  [nconst_max];				// elastic constant of umbrella
+ real    max     [nconst_max];				// limit
+ real    start   [nconst_max];				// start position
+ real    slope   [nconst_max];                          // additional linear potential slope*(s-pos)
+ real    annealing[nconst_max];                         // if the temperature changes the constants are rescaled as constant=factor/temp_now
+ int     sign    [nconst_max];
+ int     impose_start [nconst_max];                      // logical for imposing a starting point
+ real 	  old_force [nconst_max];                       // #### Old value of the force for work integration
+ double  work   [nconst_max];				// #### Work of the steering potential
+} ;
+
+struct tamd {
+ real    pos     [nconst_max];                          // position of the restraint
+ real    spring  [nconst_max];                          // strength of the restraint (from sigma)
+ real    tau;                                           // relaxation time
+ real    simtemp;                                       // T
+ real    wfactor;                                       // T'/T
+ real    wtemp;                                         // T'/T
+ int     seed;
+ real    starttemp;                                     // temperature for pos initialization
+ real    drift;
+};
+
+struct constraint {
+ real    pos     [nconst_max];				// position of umbrella
+ real    delta   [nconst_max];				// tolerance
+ real    spring  [nconst_max];				// elastic constant of umbrella
+ int     maxiter [nconst_max]; 
+ real    force   [nconst_max];				// force due to constraint 
+ real    lambdadt2 [nconst_max];				// force due to constraint 
+ real    energy [nconst_max];				// force due to constraint 
+ int    verbose [nconst_max];				// verbosity 
+ // some other stuff connected with coordinate
+ real ***posc,***newposc,***velc,***oldposc,***startder;
+ int *go;
+ real *oldcv; 
+ // amber interface for old force
+#if defined (AMBER) || defined (STANDALONE)
+ real   *oldforce; 
+ real   *oldvel; 
+#endif
+} ;
+
+// verlet list 
+struct  nlist_s{
+  real rcut;
+  real rskin;
+//  int  step;
+  int  *nn;
+  int  **ni;
+  real **base;
+};
+
+struct abmd {
+ real    exp     [nconst_max];                          // ideal destination
+ real    spring  [nconst_max];                          // elastic constant 
+ real    min     [nconst_max];                          // best value reached
+ real    now     [nconst_max];                          // start position
+} ;
+
+struct grid_s {
+ real       min      [nconst_max];                      // GRID inferior limit
+ real       max      [nconst_max];                      // GRID superior limit
+ real       lbox     [nconst_max];                      // GRID bin size
+ real       oldelta  [nconst_max];                      // store old HILLS delta 
+ real       dx       [nconst_max];                      // GRID spacing 
+ real       minilbox [nconst_max];                      // redux GRID bin size 
+ real       *pot                 ;                      // array for meta bias
+ real       **force              ;                      // array for forces
+ real       cutoff               ;                      // store genereal DP2CUTOFF
+ real       mem                  ;                      // memory info
+ int        bin      [nconst_max];                      // number of bins in total GRID
+ int        minibin  [nconst_max];                      // number of bins in redux GRID
+ int        period   [nconst_max];                      // periodic ?
+ int        index    [nconst_max];                      // to map back the id of active CV
+ int        size                 ;                      // size of total GRID 
+ int        minisize             ;                      // size of redux GRID
+ int        **one2multi          ;                      // from 1d index to multidimensional for redux GRID
+ int        **one2multi_full     ;                      // same for full GRID
+ int        ncv                  ;                      // number of ACTIVE CVs 
+ int        w_stride             ;                      // stride for GRID writing on file
+ long int   nhills               ;                      // Total number of HILLS put on GRID
+ char       r_file[800]          ;                      // GRID file to read from
+ char       w_file[800]          ;                      // GRID file to write to
+} ;
+
+struct commit_s {
+ int    ncv                 ;                          // number of ACTIVE CVs 
+ int    index   [nconst_max];                          // to map back the id of active CV
+ real   Amin    [nconst_max];                          // A state for committors analysis
+ real   Amax    [nconst_max];                          // ""
+ real   Bmin    [nconst_max];                          // B ""
+ real   Bmax    [nconst_max];                          // ""
+} ;
+
+struct stopwhen_s {                // truncate the run and dump the checkpoint (for ffs) only in gromacs  
+ int  actmin[nconst_max];   // is it active on the minimum
+ int  actmax[nconst_max];   // is it active on the maximum 
+ real  min[nconst_max];      // value min  
+ real  max[nconst_max];      // value max
+};
+
+// d-AFED ########## -----------------------------------------------------------
+struct ggmt_s {
+ /* This is a second-order Generalized Gaussian Moments Thermostat */
+ /* Static parameters */
+ double   Q1;			// thermostat mass1
+ double   Q2;			// thermostat mass2
+ double   kT0;			// reference temperature times the Boltzmann factor
+ double   dt[4];		// sub-time steps for internal RESPA and the Suzuki-Yoshida factorization
+ int   	   n_respa_ggmt;	// number of iterations for internal RESPA (default 1)
+ /* Dynamic variables */
+ double		v1;		// velocity1
+ double		v2;		// velocity2
+ double 	eta1;		// position1
+ double		eta2;		// position2
+};
+
+// dafed_s is different from steer :
+// steer is an structure of arrays
+// dafed will be defined as an array of structures
+struct dafed_s {
+ /* Static parameters */
+ double	 temperature ;		// temperature for meta-variable
+ double	 mass   ;		// mass of meta-variable
+ double kappa   ;		// coupling constant
+ double tauthermo  ;		// time constant for meta-thermostat
+ int     n_respa;		// Number of RESPA integration steps between two MD steps
+ double	 dt_respa;		// sub-time step for DAFED RESPA
+ double periodicity_low ;               // lower limit for periodic boundary conditions on s
+ double periodicity_high;               // upper limit for periodic boundary conditions on s
+ double periodicity_gap;                // upper limit for periodic boundary conditions on s
+ /* Switches */
+ int	 do_initialize_s;		// if we set initial conditions
+ int	 do_skip_integration;   // if we skip the first DAFED integration step after reading restart
+ int     do_periodicity;                // if we use periodic boundary conditions on s
+ /* Dynamic variables */
+ double	 colvar;		// collective variable in double precision.
+ double s      ;		// position of meta-variable
+ double vs	;		// velocity of meta-variable
+ double	 f ;			// DAFED force
+ struct ggmt_s	 ggmt	;	// Generalized Gaussian Moments Thermostat
+ double	 dafed_work;		// Work of meta_variable on physical system
+ double dWold;			// Old work element for trapeze integration
+ double	 thermo_work;		// Thermostat work
+ int 	 do_jacobian_force;	// Apply force compensating the Jacobian
+ double jacobian_force;		// The value of the Jacobian force
+};
+
+struct dafed_control_s {
+ int   n_respa;				// Number of RESPA integration steps between two MD steps
+ int   write_freq;			// write frequency. zero: do not write.
+		 					// -1 write at same time as state.cpt files
+ int   do_cpt;				// switch to detect when gromacs writes cpt file
+ int   restart; 			// read the restart file?
+ char  in_file[800];		// filename for reading
+ char  out_file[800];		// filename for writing
+};
+
+// ########## -----------------------------------------------------------
+
+struct mathfunction_s{
+// if you have it not defined then creates a fake struct 
+     void *f, **f_prim;    
+     char fline[200]; 
+     int  *indcvs;    
+     real  *valcvs;    
+     char **names;
+     int  count;
+};
+
+
+struct rmsd_inpack{
+       int natoms;
+       real r0[3][MAXATOMS_RMSD];
+       real r1[3][MAXATOMS_RMSD];
+       real mass[MAXATOMS_RMSD];
+       real totmass;
+};
+
+struct rmsd_outpack{
+       real r0p[3][MAXATOMS_RMSD];//centered reference  frame
+       real r1p[3][MAXATOMS_RMSD];//centered running frame  
+       real cmr0[3]; //center of mass of reference frame
+       real cmr1[3]; //center of mass of running frame
+       real err;
+       real derr_dr0[3][MAXATOMS_RMSD];
+       real derr_dr1[3][MAXATOMS_RMSD];
+       real dderr_dr1_dr1[3][MAXATOMS_RMSD][3][MAXATOMS_RMSD];
+       real dderr_dr0_dr0[3][MAXATOMS_RMSD][3][MAXATOMS_RMSD];
+       real dderr_dr1_dr0[3][MAXATOMS_RMSD][3][MAXATOMS_RMSD];
+       real dderr_dr0_dr1[3][MAXATOMS_RMSD][3][MAXATOMS_RMSD];
+       real d[3][3];
+       real dd_dr0[3][3][3][MAXATOMS_RMSD];
+       real dd_dr1[3][3][3][MAXATOMS_RMSD];
+};
+//
+// a dynamic structure for the workarrays
+// 
+struct rmsd_workstruct_s{
+	int maxsize,natoms;
+	real **r0,**r1;
+	real *align,*displace;
+	real walign,wdisplace;
+	int *lalign,*ldisplace;
+	int nalign,ndisplace,simple;
+	real **r0p ; //[3][MAXATOMS_RMSD];//centered reference  frame
+	real **r1p ; //[3][MAXATOMS_RMSD];//centered running frame  
+	real **r0p_rotated ; // rotated frames
+	real **r1p_rotated ; // 
+	real cmr0[3]; //center of mass of reference frame
+	real cmr1[3]; //center of mass of running frame
+	real err;
+	real **derr_dr0; //[3][MAXATOMS_RMSD];
+	real **derr_dr1; //[3][MAXATOMS_RMSD];
+	real d[3][3];
+	real dinv[3][3];
+	real ****dd_dr0; //[3][3][3][MAXATOMS_RMSD];
+	real ****dd_dr1; //[3][3][3][MAXATOMS_RMSD];
+	// optional for 2nd der
+	int maxsize_secondder;
+	real ****dderr_dr1_dr1; //[3][MAXATOMS_RMSD][3][MAXATOMS_RMSD];
+	real ****dderr_dr0_dr0; //[3][MAXATOMS_RMSD][3][MAXATOMS_RMSD];
+	real ****dderr_dr1_dr0; //[3][MAXATOMS_RMSD][3][MAXATOMS_RMSD];
+	real ****dderr_dr0_dr1; //[3][MAXATOMS_RMSD][3][MAXATOMS_RMSD];
+	// work arrays for rmsd 
+	real ****dm_r1_store; //[4][4][3][MAXATOMS_RMSD];
+	real ****dm_r0_store;// [4][4][3][MAXATOMS_RMSD];
+	real **array_3_n; //[3][MAXATOMS_RMSD];
+	//real **derr_dr1_tmp; //[3][MAXATOMS_RMSD];
+	//real **derr_dr0_tmp; //[3][MAXATOMS_RMSD];
+	real ****dd_dr_temp; //[3][3][3][MAXATOMS_RMSD];	
+};
+
+struct rmsd_mini_outpack{
+     real r0p[3][MAXATOMS_RMSD];//centered reference  frame
+     real r1p[3][MAXATOMS_RMSD];//centered running frame  
+     real cmr0[3]; //center of mass of reference frame
+     real cmr1[3]; //center of mass of running frame
+     real err;
+     real derr_dr0[3][MAXATOMS_RMSD];
+     real derr_dr1[3][MAXATOMS_RMSD];
+     real d[3][3];
+     real dd_dr0[3][3][3][MAXATOMS_RMSD];
+     real dd_dr1[3][3][3][MAXATOMS_RMSD];
+};
+// For path in contact map space
+struct group_struct{
+       int number;
+       int numatom[MAXNUM_GROUP];
+       int index[MAXNUM_GROUP][MAXATOM_GROUP];
+       int index_to_list[MAXNUM_GROUP][MAXATOM_GROUP];
+       real rcm[MAXNUM_GROUP][3];
+};
+struct cmap_pack {
+       int index1[MAXDIM_CMAP];
+       int index2[MAXDIM_CMAP];       
+       int index_from1[MAXDIM_CMAP];
+       int index_from2[MAXDIM_CMAP];
+       int atoms;
+       int list[MAXATOMS_PATH];
+       int nn[MAXDIM_CMAP];
+       int nd[MAXDIM_CMAP];
+       int number;
+       int gnumber;
+       real r0[MAXDIM_CMAP];
+       real weight[MAXDIM_CMAP];
+       real cutoff[MAXDIM_CMAP];
+       real cmap[MAXFRAMES_PATH][MAXDIM_CMAP];
+       int logical_group;
+       struct group_struct group;
+       };
+struct cmap_inpack{
+       real r0[MAXATOMS_PATH][3];
+       real cmap[MAXDIM_CMAP];
+};
+struct cmap_outpack{
+       real err;
+       real derr_dr0[3][MAXATOMS_PATH];
+       real derr_dcm[MAXDIM_CMAP];
+};
+struct coordinates_frameset {
+        int natoms;
+        int resid[MAXATOMS_PATH],atmnum[MAXATOMS_PATH];
+        char resname[MAXATOMS_PATH][MAXCHARS_PATH];
+        char label[MAXATOMS_PATH][MAXCHARS_PATH];
+        real pos[MAXATOMS_PATH][3];
+        char residue[MAXATOMS_PATH];
+        int frameset_to_coord[MAXATOMS_PATH]; // for each atoms in the frameset provides the corresponding index on running coord
+        int frameset_to_align[MAXATOMS_PATH]; // for each atoms in the frameset provides the corresponding index used alignment(-1 if not involved in rmsd) 
+        int align_to_coord[MAXATOMS_PATH];
+        int align_to_frameset[MAXATOMS_PATH];
+        int ndisplace;
+        int nalign;
+        real align[MAXATOMS_PATH];    // for each atom is >0 if used for alignment, else 0
+        real displace[MAXATOMS_PATH]; // for each atom is >0 if used for displacement, else 0
+        real walign;
+        real wdisplace;
+        int simple; 
+};
+struct jac_index_s{
+	int elem1,elem2,cv1,cv2,natom1,natom2,pos1,pos2;
+};
+// this is the final unti that contains all the single datas
+struct hybrid_elem{
+		// which cv
+        int cvtype,cvindex;
+		//
+       	// distance: distance is only one float, but requires the full list of atoms so to copy the derivative 
+		//
+        real    *ref_dist;    // reference dist for this frame: would work for all scalars 
+        int		nder;        // ref number of atoms in the derivative 
+        int     *backtable;  // ref intdex of the atoms in the derivative (back transfer of forces)         
+	    rvec    *myder ;	//    derivatives: contains the number of atoms involved
+		int		ncv ; //one single call can calculate many cv (as rmsd)
+		int		contains_pdb;
+		struct  pdb *pdb;		// dynamic pdb structure
+		// 
+		rvec	**cvder;	// one cv per variable. Also needed for Jacobian
+		int		*natoms_per_cv;
+		int		**list_per_cv;
+		char    remarkfield[100];
+		// only to be allocated if needed
+		real    **diff_der1,**diff_der2,**diff_der3;	
+		int		has_diff_alloc,has_jac_alloc;
+};
+struct hybrid_frameset{
+       	// this should contain all the required data (possibly dynamically allocated)
+       	// for all the structures needed in the hybrid frameset definition
+        // one frame may contain many structures
+		int    hbd_nelem;        //numbr of calls to cv calculators
+		int    hbd_totalatoms;   // total number of atoms involved
+		int    hbd_totcvs;		 // total number of cvs
+		int    fixed;			 // flag: is it fixed?
+        struct hybrid_elem **hbd_elem; // dynamic structure to allocate the element
+        int    *backtable;
+        rvec   *myder;
+		// the tracking structure for the jacobian (only used by the running frame)
+		struct jac_index_s *jac_index;
+		int	   jac_index_length,has_jac_alloc;
+}; 
+
+struct sz_data {
+        int    number;
+        real lambda;
+        struct coordinates_frameset **frameset;
+        struct hybrid_frameset **hbd_frameset;
+        struct hybrid_frameset  *hbd_running; //assumin that the number of atoms in each reference  stays constant
+        char   names[MAXCHARS_PATH];
+        int grad_on,umb_on,mass_on,targeted_on,sqrt_on,norot_on,nocenter_on,indexing_type;
+        real gradmax,gradmin,gradk;
+        int umblagsteps,umbblocksize,umbstride,umbcount,umbpermanency,countperm;
+        real umbtolerance;
+        real ****umb_block;// dimensions:  3,natoms,nframes,nblock
+        real ***umb_avg;// dimensions:  3,natoms,nframes
+        real ***umb_map_block;// dimensions:  tot_con,nframes,nblock
+        real **umb_map_avg;// dimensions:  tot_con,nframes
+        // if you use debug routine for derivative respect to the path-> I want to keep it safe in the struct
+        real ***dpath_dr;
+        // just allocated whenever preprocesed with  
+        struct cmap_pack my_cmap_pack;
+        char   path_type[10];
+        int nneigh,*lneigh,neigh,neigh_time;
+        // hybrid path
+        int *lhybrid,nhybrid,*lcvhybrid; 
+        real **mathybrid;
+		real ***mathybrid_blocks;
+		int do_blocks;
+		real **myinverse;
+        // bernd ensing path on the fly evolution 
+        int  iforce; // switch on force and evolution
+        int  ievol; // switch on force and evolution
+        int  reset; //reseting wcount (weights) to zero
+        real fadefactor;       
+        real **disp;
+        real *wcount;
+        char evol_path[100];
+        FILE *fp_evol;
+		int debug_metrics;
+		int intraframe_dist;
+		char intraframe_dist_inputfile[100];
+		char intraframe_dist_outputfile[100];
+		int intraframe_diff;
+	    char intraframe_diff_outputfile[100];
+
+};
+
+
+struct couplingmatrix_s{
+	struct sz_data mysz;
+	int dumpfreq;
+	int is_on;
+	char filename[100];
+	FILE *fp;
+};
+
+// reference distance matrices for CVs alpharmsd, antibetarmsd, parabetarmsd
+struct ref_dist_mat_s{
+  real alpha[30][30];
+  real alpha_pairs;
+  real antibeta[30][30];
+  real antibeta_pairs;
+  real parabeta[2][30][30];
+  real parabeta_pairs[2];
+};
+
+// data for sprint CVs
+struct sprint_data_s{
+  int nat;
+  int icv;
+  int step;
+  real *lambda;
+  real **cm;
+  real ***grad;
+};
+
+// steerplan
+
+struct steeronecv_s{
+        real k,pos;
+        // take from endpoint 
+        int  ncv,wildcardpos,wildcardk;
+        // type central=0;positive=1;negative=2; 
+        int type;
+};
+
+struct steeraction_s{
+        struct steeronecv_s  *activecv; 
+        real t;
+};
+
+struct steeractual_s{
+       real v,k,x0,kv,force,energy;
+       int type,nowhere;
+};
+
+// steerplan.action[stage].cv 
+struct steerplan_s {
+  int current_stage,totstages;
+  struct steeraction_s *actions;
+  struct steeractual_s *actualcv;
+  real nextstage_time;
+  int ncvs; 
+  int isactive[nconst_max];
+  char log[600]; 
+}; 
+
+// pca CV
+struct pcacomp_s {
+        int a1;                 // atom 1 (read, fixed)
+        rvec coeff;             // coefficient (read, fixed)
+};
+
+// camshift stuff
+struct cam_shift_s {
+  char cam_data[nconst_max][128];
+  char cam_ff[nconst_max][64];
+  int  disu[nconst_max];
+  int  num[nconst_max];
+  int  mumo[nconst_max];
+  double grains[nconst_max];
+};
+
+
+// NAMD CLASS DEFINITION AND PECULIAR METHODS
+#ifdef NAMD
+class GlobalMasterMetaDynamics : public GlobalMasterEasy 
+{
+
+ public:
+ GlobalMasterMetaDynamics(); 
+ virtual void easy_init(const char *);
+ void easy_calc(void);
+ void mtd_data_init(  );
+ void init_metadyn( );
+ void rvec2vec(rvec rv,Vector *v);
+#elif LAMMPS_PLUMED
+class Plumed
+{
+ public:
+ Plumed(char *metainp, char *metaout , int *atoms, real *mss, real *chg, real *dt, real myboltz); //constructor
+ void mtd_data_init(char *metainp, char *metaout, int atoms, real *mss, real *chg, real *dt , real myboltz );
+ void init_metadyn( char *metainp, char *metaout, int *atoms, real *mss, real *chg, real *dt , real myboltz);
+ void meta_force_calculation(int *allidx, rvec *allpos,rvec *allforce, int allnum , Domain *domain);
+ void sfree(void *ptr);
+#elif defined(PLUMED_GROMACS)
+ void mtd_data_init (int ePBC, real *charge, real *mass,
+                    int natoms, real dt, int repl_ex_nst, int repl,
+                    int nrepl, real rte0, real rteio, const t_commrec *mcr, FILE *fplog);
+
+ void init_metadyn(int natoms, int ePBC, real *charge, real *mass,
+                  real dt, int repl_ex_nst, plumed_repl_ex repl_ex,
+                  const t_commrec *mcr, FILE *fplog);
+ void ptmetad(real *Epota, real *Epotb, real *Epotba, real *Epotab, int a, int b);
+ void ptmetad_vbias(int,real*,real*);
+ void ptmetad_helper();
+ void ptmetad_exchfluct(int);
+ void bias_exchange_traj(int nrepl, int *seed, int *ind);
+ void meta_force_calculation(int, int, real (*pos)[3], real (*force)[3], real box[3][3], real energy, real temp);
+#if defined (PLUMED_GROMACS4)
+ void plumed_setstep(long long int istep, bool bCPT);
+#elif defined (PLUMED_GROMACS45)
+ void plumed_setstep(long long int istep, gmx_bool bCPT);
+#else
+ void plumed_setstep(int istep);
+#endif
+ int  plumed_dd_index(int iat);
+ int  plumed_ll_index(int iat);
+#if defined (PLUMED_GROMACS4) || defined (PLUMED_GROMACS45)
+#define oprod cprod
+#endif
+#elif OPEP
+ void init_metadyn_(int *atoms, real *ddt, int *pbc_opep,
+                   int *repl, int *nrepl,real *rte0, real *rteio, real *mass,
+                   char *lpath, char *logfile, char *metainp, int ll, int mm, int jj);
+ void meta_force_calculation_(real *pos, real *force);
+ real pbc_mic_(real *rin);
+ void mtd_data_init(int pbc, real tstep,int atoms, int repl, int nrepl, real rte0, real rteio, real *mass, char *lpath, char *logfile, char *metainp);
+ void ptmetad_vbias(int,real*,real*);
+ void share_bias_(int *rep, real *Vbias, real *Vbiasx); 
+ void bias_exchange_(int *nrep, int *biaseed, int *ind);
+ void bias_exchange_traj(int nrepl, int *seed, int *ind);
+ void switch_fluct_(int *rep); 
+ void ptmetad_exchfluct(int);
+#elif ACEMD 
+ void mtd_data_init( real *charge, real *mass,
+                    int natoms, real dt, int repl,
+		     int nrepl, real rte0, real rteio, char *metainp, real *box);
+ void init_metadyn(int natoms, real *charge, real *mass, 
+                   real dt, int repl, int nrepl, 
+                   real rte0, real rteio, char *metainp, real box[3]);
+ void meta_force_calculation(struct aceplug_sim_t* );
+#elif defined(DL_POLY) || defined(AMBER) || defined(PLUMED_QESPRESSO) || defined (GAT_LJONES)
+ void mtd_data_init(int atoms, real dt ,real *mass, real *charge, int *imcon, real *eunit, char *metainp);
+ void meta_force_calculation_(real *cell, int *istep, real *xxx, real *yyy, real *zzz, real *fxx, real *fyy, real *fzz, real *energy);
+ void init_metadyn_(int *atoms, real *ddt, real *mass, real *charge, int *imcon, real *eunit, char *metain, int pp);
+ void images_(int *i,int *j,int *k,int *natoms,real *cell,real *xxx,real *yyy,real *zzz); 
+#elif defined(PLUMED_CPMD)
+// these two are the wrapper rotines, needed to call c++ code from fortran
+#if defined(PLUMED_CPMD_NOUNDERSCORE)
+// some IBM-AIX compilers (not all of them) do not want the underscore...
+extern "C" void init_metadyn(int *atoms, int *nsp, int *na, int *nsx, int *nax, real *ddt, int *now, real *mass);
+extern "C" void meta_force_calculation(real *pos, real *force, int *nsp, int *na, int *nax, int *nsx);
+extern "C" void pbc_cpmd_plumed( real*, real*, real* );
+#else
+extern "C" void init_metadyn_(int *atoms, int *nsp, int *na, int *nsx, int *nax, real *ddt, int *now, real *mass);
+extern "C" void meta_force_calculation_(real *pos, real *force, int *nsp, int *na, int *nax, int *nsx);
+extern "C" void pbc_cpmd_plumed_( real*, real*, real* );
+#endif
+// this is the c++ class containing all plumed (like this there is no name conflict between things in cpmd and things in plumed)
+class Plumed{
+ public:
+ Plumed(); //constructor
+ void mtd_data_init( int atoms, int nsp, int *na, int nsx, int nax, real ddt, int now, real *mass, char *metainp);
+ // these two are inside the class, not visible from outside, called from the wrapper routines above
+ void init_metadyn(int *atoms, int *nsp, int *na, int *nsx, int *nax, real *ddt, int *now, real *mass);
+ void meta_force_calculation(real *pos, real *force, int *nsp, int *na, int *nax, int *nsx);
+//#elif RECON_DRIVER
+// void init_metadyn_(int *atoms, real *ddt, real *mass, real *charge, int *pbc, real *box, char *metainp, int* ncv, double *periods, real *w, real *height, real *sizeParam, int ll);
+// void mtd_data_init(int atoms, real *mass, real *charge, char *metainp, int pbc, real *box, real ddt);
+// void cv_calculation_(real *box, real *pos, int *ncv, real *cv);
+// void ptmetad(real *Epota, real *Epotb, real *Epotba, real *Epotab, int a, int b);
+// void ptmetad_vbias(int,real*,real*);
+// void ptmetad_sharepot(int nrepl, int repl);
+// void bias_exchange_traj(int nrepl, int *seed, int *ind);
+// void ptmetad_exchflut(int repl);
+// void ptmetad_exchfluct(int);
+#elif DRIVER
+#define min(a, b) (((a) < (b)) ? (a) : (b))
+ void init_metadyn_(int *atoms, real *mass, real *charge, int *pbc, real *box, real *ddt ,char *metainp, int* ncv, int ll);
+ void mtd_data_init(int atoms, real *mass, real *charge, char *metainp, int pbc, real *box, real ddt);
+ void cv_calculation_(real *box, real *pos, int *ncv, real *cv);
+ void ptmetad(real *Epota, real *Epotb, real *Epotba, real *Epotab, int a, int b);
+ void ptmetad_vbias(int,real*,real*);
+ void ptmetad_sharepot(int nrepl, int repl);
+ void bias_exchange_traj(int nrepl, int *seed, int *ind);
+ void ptmetad_exchflut(int repl);
+ void ptmetad_exchfluct(int);
+#elif STANDALONE 
+#define min(a, b) (((a) < (b)) ? (a) : (b))
+ void init_metadyn_(int *atoms, real *mass, real *charge, int *pbc, real *box, real *tstep, int *nstep, real *myboltz, real *ampli, char *metainp, int ll);
+ void mtd_data_init(int atoms, real *mass, real *charge, int pbc, real *box,  real *tstep, int *nstep , real* myboltz, real *ampli , char *metainp );
+ void cv_calculation_standalone_(real *box, real *pos, real *force, real *ene);
+#endif
+
+ real rando_gaussian(int *ig);
+#if ! defined (PLUMED_GROMACS)
+// Vector operation (locally reimplemented for codes either than GROMACS)
+ real rando(int *ig);
+ void oprod(const rvec a,const rvec b,rvec c);
+ real iprod(const rvec a,const rvec b);
+ real norm(const rvec a);
+ real norm2(const rvec a);
+ real cos_angle(const rvec a,const rvec b);
+ real dih_angle(rvec xi, rvec xj, rvec xk, rvec xl,
+               rvec r_ij,rvec r_kj,rvec r_kl,rvec m,rvec n,
+               real *cos_phi,real *sign);
+ void clear_rvec(rvec a);
+#endif
+
+// common declarations
+#if defined (PLUMED_GROMACS) && defined (__cplusplus)
+extern "C" {
+#endif
+ void EXIT();
+ void read_restraint(struct mtd_data_s *mtd_data);
+ void read_defaults(  );
+ void plumed_read_input(t_plumed_input* input,FILE* file,FILE* log);
+ void plumed_clear_input(t_plumed_input*);
+ int  plumed_get_group(const char *word,int **atoms,int n,t_plumed_input*,FILE *log);
+ void plumed_error(const char*);
+ void plumed_warn(const char*);
+ int  plumed_atoi(const char* word);
+ double plumed_atof(const char* word);
+ int  plumed_get_words(char* line,char*** words);
+ void plumed_sum    (struct mtd_data_s *mtd_data,int n,real* buffer);
+ void plumed_sumi   (struct mtd_data_s *mtd_data,int n,int* buffer);
+ void plumed_intersum(struct mtd_data_s *mtd_data, int n, real *buffer);
+ int  plumed_comm_size(struct mtd_data_s *mtd_data);
+ int  plumed_comm_rank(struct mtd_data_s *mtd_data);
+ int  seek_word(char **word, const char *wanted);
+ int  seek_word2(char **word, const char *wanted, int is);
+// DAFED routines ########################################################
+  void initialize_ggmt(struct ggmt_s *ggmt,double T,double tau, double delta_t);
+  real energy_ggmt(struct ggmt_s ggmt);
+  void initialize_dafed(struct dafed_s *daf, real dt);
+  void dafed_engine(real *this_colvar);
+  void print_dafed(struct dafed_s *daf, FILE *cv_file, int i_c);
+  void write_dafed_state();
+  void read_dafed_state();
+  void get_kt(struct dafed_s *daf, double *d);
+  void integrate_ggmt(struct dafed_s *daf);
+
+#if defined (PLUMED_GROMACS) && defined (__cplusplus)
+}
+#endif
+// PBS
+ void minimal_image(rvec pos1, rvec pos2, real *mod_rij, rvec rij);
+// HILLS stuff
+ void hills_add(struct mtd_data_s *mtd_data);
+ void hills_push(struct mtd_data_s *mtd_data,real ww, real* ss,real* delta);
+ real hills_engine(real*,real*);
+ real hills_engine_dp(int ih,real* ss0,real* dp);
+ void hills_force();
+ void apply_forces(struct mtd_data_s *mtd_data );
+ void inversion_on_boundaries(struct mtd_data_s *mtd_data,int ncv);
+ real soft_walls_engine(real*,real*);
+ real steer_engine(real*,real*);
+ real abmd_engine(real*,real*);
+ real tamd_engine(real*,real*);
+ real ext_forces_engine(real* ss0, struct grid_s *grid, real* force); 
+ real constraint_engine(real tstep);
+ void stopwhen_engine(); 
+ void steerplan_engine();
+ void steer_cv(int);
+ void init_print_colvar_enercv();
+ void print_colvar_enercv(real time_s);
+ void hills_adapt();
+ void commit_analysis();
+ void read_hills(struct mtd_data_s *mtd_data, int restart, int first_read);
+ void hills_reallocate(struct mtd_data_s *mtd_data);
+// CV routines
+ void restraint(struct mtd_data_s *mtd_data);
+ void test_derivatives(struct mtd_data_s *mtd_data);
+ void poly_restraint_testder(int i_c, struct mtd_data_s *mtd_data);
+ void func_restraint_testder(int i_c, struct mtd_data_s *mtd_data);
+#if defined RECONMETAD
+ void test_recon_derivatives(struct mtd_data_s *mtd_data);
+#endif
+#if defined CVS
+ void bespoke_test_derivatives(struct mtd_data_s *mtd_data); 
+#endif
+ void histogram_testderivatives(int j_c, struct mtd_data_s *mtd_data);
+ void debug_derivatives(struct mtd_data_s *mtd_data,int);
+// reading...
+ int  read_dist          (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_mindist       (char **word,int count,t_plumed_input *input,           FILE *fplog); 
+ int  read_coord         (char **word,int count,t_plumed_input *input,           FILE *fplog); 
+ int  read_angle         (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_torsion       (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_hbonds        (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_dipole        (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_rgyr          (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_waterbridge   (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_path          (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_position      (char **word,int count,t_plumed_input *input,           FILE *fplog); 
+ int  read_elstpot       (char **word,int count,t_plumed_input *input,           FILE *fplog); 
+ int  read_puckering     (char **word,int count,t_plumed_input *input,           FILE *fplog); 
+ int  read_energy        (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_alpharmsd     (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_antibetarmsd  (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_parabetarmsd  (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_cmap          (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_pca           (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_sprint        (char **word,int count,t_plumed_input *input,           FILE *fplog);
+#ifdef CVS
+ int  read_bespoke       (char **word,int count,t_plumed_input *input,           FILE *fplog);
+#endif 
+ int  read_histogram     (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_rdf           (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_adf           (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ int  read_msd           (char **word,int count,t_plumed_input *input,           FILE *fplog);
+// these variables read lines directly from the input, thus they need the iline pointer to increment it
+ int  read_alfabeta      (char **word,int count,t_plumed_input *input,int *iline,FILE *fplog);
+ int  read_dihcor        (char **word,int count,t_plumed_input *input,int *iline,FILE *fplog);
+ int  read_helix         (char **word,int count,t_plumed_input *input,int *iline,FILE *fplog);
+ int  read_steerplan     (char **word,int count,t_plumed_input *input,int *iline,FILE *fplog);
+ int  read_poly          (char **word,int count,t_plumed_input *input,int *iline,FILE *fplog);
+ int  read_func          (char **word,int count,t_plumed_input *input,int *iline, int *nw ,FILE *fplog);
+
+
+ int  load_steerplan     (char *word,struct steerplan_s *steerplan,FILE *fplog);
+ void read_couplingmatrix  ( char **word, t_plumed_input *input,FILE *fplog );
+	void calc_couplingmatrix  ( int i );
+
+// calculating
+#ifdef CVS
+ void bespoke_restraint       (int i_c, struct mtd_data_s *mtd_data);
+#endif
+ void rdf_restraint           (int i_c, int ignore_repeats, struct mtd_data_s *mtd_data);
+ void adf_restraint           (int i_c, int ignore_repeats, struct mtd_data_s *mtd_data);
+ void histogram_restraint     (int i_c, struct mtd_data_s *mtd_data);
+ void dist_restraint          (int i_c, struct mtd_data_s *mtd_data);
+ void pt_from_axis_restraint  (int i_c, struct mtd_data_s *mtd_data);
+ void pt_from_axis_inplane_restraint (int ptype, int i_c, struct mtd_data_s *mtd_data);
+ void proj_on_axis_restraint  (int i_c, struct mtd_data_s *mtd_data);
+ void diffdist_restraint      (int i_c, struct mtd_data_s *mtd_data);
+ void mindist_restraint       (int i_c, struct mtd_data_s *mtd_data);
+ void coord_restraint         (int i_c, struct mtd_data_s *mtd_data);
+ void angle_restraint         (int i_c, struct mtd_data_s *mtd_data);
+ void torsion_restraint       (int i_c, struct mtd_data_s *mtd_data);
+ void alfabeta_restraint      (int i_c, struct mtd_data_s *mtd_data);
+ void hbonds_restraint        (int i_c, struct mtd_data_s *mtd_data);
+ void dipole_restraint        (int i_c, struct mtd_data_s *mtd_data);
+ void radgyr_restraint        (int i_c, struct mtd_data_s *mtd_data);
+ void dihcor_restraint        (int i_c, struct mtd_data_s *mtd_data);
+ void waterbridge_restraint   (int i_c, struct mtd_data_s *mtd_data);
+ void spath_restraint         (int i_c, struct mtd_data_s *mtd_data);
+ void zpath_restraint         (int i_c, struct mtd_data_s *mtd_data);
+ void pathref_findiff         (int i_c, struct mtd_data_s *mtd_data);
+ void position_restraint      (int i_c, struct mtd_data_s *mtd_data);
+ void elstpot_restraint       (int i_c, struct mtd_data_s *mtd_data);
+ void puckering_restraint     (int i_c, struct mtd_data_s *mtd_data);
+ void energy_restraint        (int i_c, struct mtd_data_s *mtd_data);
+ void helix_restraint         (int i_c, struct mtd_data_s *mtd_data);
+ void cmap_restraint          (int i_c, struct mtd_data_s *mtd_data);
+ void alpharmsd_restraint     (int i_c, struct mtd_data_s *mtd_data);
+ void antibetarmsd_restraint  (int i_c, struct mtd_data_s *mtd_data);
+ void parabetarmsd_restraint  (int i_c, struct mtd_data_s *mtd_data);
+ void sbernd_restraint        (int i_c, struct mtd_data_s *mtd_data);
+ void zbernd_restraint        (int i_c, struct mtd_data_s *mtd_data);
+ void pca_restraint           (int i_c, struct mtd_data_s *mtd_data);
+ void poly_restraint          (int i_c, struct mtd_data_s *mtd_data);
+ void func_restraint          (int i_c, struct mtd_data_s *mtd_data);
+ void msd_restraint           (int i_c, struct mtd_data_s *mtd_data);
+ void sprint_restraint        (int i_c, struct mtd_data_s *mtd_data);
+
+ // bernd pathway  
+ void init_bernd_evolution    ( struct sz_data **pmy_sz , int i_c);
+ void do_bernd_evolution      ( struct sz_data *pmy_sz );
+ void reparam_bernd_path      ( struct sz_data *pmy_sz );
+ void dump_frameset_formatted  ( struct sz_data *pmy_sz );
+ void dump_frameset_unformatted( struct sz_data *pmy_sz );
+
+ // v1=v2+dr(v3-v4)
+ void do_step_bernd           (  struct hybrid_frameset *v1,struct hybrid_frameset *v2, real **mat, real dr, struct hybrid_frameset *v3 ,  struct hybrid_frameset *v4 );
+ #if defined (PLUMED_GROMACS) && defined (__cplusplus)
+ extern "C" {
+ #endif
+ int  read_camshift      (char **word,int count,t_plumed_input *input,           FILE *fplog);
+ void camshift_restraint      (int i_c, struct mtd_data_s *mtd_data);
+ void camshiftens_restraint   (int i_c, struct mtd_data_s *mtd_data);
+ #if defined (PLUMED_GROMACS) && defined (__cplusplus)
+ } 
+ #endif
+ real coscut(real r,real r_0, real cut);
+ real dcoscut(real r,real r_0, real cut);
+ real tprod (rvec a,rvec b, rvec c );
+ real generate_R(int i_c,struct mtd_data_s *mtd_data,rvec* R,rvec Rp,rvec Rdp,rvec RpxRdp);
+ real puckering_Zeta (rvec R,rvec RpxRdp,real mod);
+ void puckering_gradZeta(rvec gradZ,int index_i,int index_j,real* z,rvec* R,rvec Rp, rvec Rdp, rvec RpxRdp,real mod);
+ real puckering_Q(real *z);
+ void puckering_gradQ(rvec gradQ, real* z, real Q,rvec*R, rvec Rp, rvec Rdp, rvec RpxRdp,real mod,int index);
+ real puckering_phi(real *z);
+ void puckering_gradphi(rvec gradphi, real* z,rvec*R, rvec Rp, rvec Rdp, rvec RpxRdp,real mod,int index);
+ real puckering_theta(real * z);
+ void puckering_gradtheta(rvec gradtheta, real* z,rvec*R,rvec Rp,rvec Rdp,rvec RpxRdp,real mod,int index);
+// GRID stuff
+real spline(int ndim,real *dx,real *where,real *tabf,real *tabder,int* stride,real *der);
+void grid_initialize(struct grid_s *grid);
+void grid_resize_minigrid(struct grid_s *grid, real* delta, real cutoff);
+void grid_create_one2multi(int **one2multi, int size, int ncv, int *bin);
+void grid_addhills(struct grid_s *grid, real ww, real* ss,real* delta,int rank,int npe);
+real grid_getstuff(struct grid_s *grid, real* ss0,real* force);
+int  grid_multi2one(struct grid_s *grid, int* index_nd);
+void grid_write_tofile(struct grid_s *grid);
+void grid_read_fromfile(struct grid_s *grid, int bias); 
+void grid_clone(struct grid_s *grid1, struct grid_s *grid2);
+// misc routines
+ void cmap_running(int i_c, struct cmap_inpack *inpack, struct cmap_pack *my_cmap_pack);
+ void cmdist_eval(int i_c, int frame,struct cmap_inpack *inpack,struct cmap_outpack *outpack, 
+      struct cmap_pack *my_cmap_pack,int dr1_calc);
+ real pow2(real x);
+ void power(real x,int p,int q,real *xp,real *xq);
+ void read_sz_map(struct sz_data *my_sz, char file_maps[129], char file_maps2[129],
+                        char file_group[129], int read_mapfile, FILE *fplog);
+ int  read_sz_rmsd(struct sz_data *my_sz, FILE *fplog);
+ int  read_sz_hybrid(struct sz_data *my_sz, FILE *fplog);
+ int  read_sz_coord (char *filename, struct coordinates_frameset *p, FILE *fplog);
+// coordination 
+ void coord_newlist(int i_c, struct mtd_data_s *mtd_data);
+ void coord_checklist(int i_c, struct mtd_data_s *mtd_data);
+ void coord_restraint_nlist(int i_c, struct mtd_data_s *mtd_data);
+ void coord_restraint_no_nlist(int i_c, struct mtd_data_s *mtd_data);
+ // hbd copy/read simple
+ int  hbd_read_simple (FILE *myfile, FILE *fplog, const char *string, struct hybrid_elem *, int hasfile);	
+ void  hbd_copy_simple ( struct hybrid_elem *elem ); 
+	void  hbd_dump_simple( struct hybrid_elem *elem , FILE *fp);
+	void  hbd_dump_msd( struct hybrid_elem *elem , FILE *fp);
+
+ //real hbd_vecmvec(struct hybrid_frameset *v1,  struct hybrid_frameset *v2, struct hybrid_frameset *v3, struct hybrid_frameset *v4 ,real **mat , real **dv1dcv,  real **dv2dcv,  real **dv3dcv,  real **dv4dcv, int allo);
+ real hbd_vecmvec_ref(struct hybrid_frameset *v1,  struct hybrid_frameset *v2, 
+								struct hybrid_frameset *v3,  struct hybrid_frameset *v4 ,
+								struct hybrid_frameset *v5,  struct hybrid_frameset *v6 ,							
+								real **mat , real *dv1dcv,  real *dv2dcv,  real *dv3dcv, 
+								real *dv4dcv, real *dv5dcv,  real *dv6dcv, FILE *fplog);
+ real hbd_distanddiff_ref(struct hybrid_frameset *v1,  struct hybrid_frameset *v2, 
+								struct hybrid_frameset *v3,  						
+								real **mat , real *dv1dcv,  real *dv2dcv,  real *dv3dcv,struct hybrid_frameset *d1,  
+								  FILE *fplog);
+void calc_diff_twoframes(struct hybrid_frameset *v1,  struct hybrid_frameset *v2, struct hybrid_frameset *v3,struct hybrid_frameset *d1 );
+void check_hbd_vecmvec_ref(struct hybrid_frameset *r1,struct hybrid_frameset *r2,struct hybrid_frameset *r3,struct hybrid_frameset *r4,struct hybrid_frameset *r5,struct hybrid_frameset *r6,real **matrix, FILE  *fplog);
+void clone_hybrid_frameset(struct hybrid_frameset **sink,struct hybrid_frameset *source,  int need_alloc_diff, FILE *fplog);
+void destroy_hybrid_frameset(struct hybrid_frameset *sink, FILE *fplog);
+void clone_hybrid_elem(struct hybrid_elem **sink,struct hybrid_elem *source,  int need_alloc_diff, FILE *fplog);
+void destroy_hybrid_elem(struct hybrid_elem *sink, FILE *fplog);
+void simple_elem_diff(struct hybrid_elem *diff,struct hybrid_elem  *e1,struct hybrid_elem  *e2,struct hybrid_elem  *e3,  FILE *fplog);
+void msd_elem_diff(struct hybrid_elem *diff,struct hybrid_elem  *e1,struct hybrid_elem  *e2,struct hybrid_elem  *e3, FILE *fplog);
+void check_msd_elem_diff(struct hybrid_elem *diff,struct hybrid_elem *v1, struct hybrid_elem *v2, struct hybrid_elem *v3, FILE *fplog);
+//hbd msd
+int   hbd_read_msd (  FILE *myfile, FILE *fplog, struct hybrid_elem *elem , int hasfile);
+void  hbd_copy_msd ( struct hybrid_elem *elem  ) ;
+// 
+int read_pdb (struct pdb **mypdb, FILE *myfile, FILE *fplog);
+void copy_pdb (struct pdb *pdb1, struct pdb *pdb2, FILE *fplog);
+int allocate_pdb(struct pdb **mypdb,int i);
+int deallocate_pdb(struct pdb *mypdb);
+void readapt_rmsd_work_array(int i, FILE *fplog);
+void readapt_rmsd_work_array_secondder(int i, FILE *fplog);
+void allocate_rmsd_container(struct rmsd_container_t *rmsd_container,int i);
+void copy_pdb_into_rmsd_container(struct pdb, struct rmsd_container_t *rmsd_container, FILE *fplog);
+void msd_calculation_dynamic(struct rmsd_workstruct_s *work,int der_frameref_on, int do_rot, int do_center);
+void msd_core_dynamic_norot(struct rmsd_workstruct_s *work, int do_center);
+void msd_core_dynamic_simple(struct rmsd_workstruct_s *work,int do_center, int do_frameref_der, int do_rotmat_der);
+void msd_core_dynamic_weighted(struct rmsd_workstruct_s *work,int do_center, int do_frameref_der);
+void rmsd_dynamic_findiff_interface(struct rmsd_workstruct_s *work);
+void clean_rmsd_work_array(struct rmsd_workstruct_s *work);
+void calc_projector_test(struct sz_data *pmy_sz);	
+void calc_intraframe_dist( struct sz_data *pmy_sz );
+void calc_intraframe_diff( struct sz_data *pmy_sz );
+void reparam_with_multiple_matrix( struct sz_data *pmy_sz , char *filename);
+void calc_twoframe_dist( struct sz_data *pmy_sz , int first, int second,  char *matrixfile, FILE *fplog);
+void point_to_matrix(int i,struct sz_data *my_sz);
+// int  hbd_copy_target ( struct hybrid_elem *elem ); 
+// real hbd_metrics_target ( struct hybrid_elem *run,  struct hybrid_elem *ref );
+ int  hbd_collect_config ( struct hybrid_frameset *running  );
+ int  hbd_collect_jacobian ( struct hybrid_frameset *running, real ** mathybrid ,  real ** myinverse, FILE *fplog , int absval);
+// int  hbd_metrics ( struct hybrid_frameset *running , struct hybrid_frameset *reference , struct cmap_outpack *outpack, real **mat); 
+ int  hbd_metrics_new ( struct hybrid_frameset *running , struct hybrid_frameset *reference , struct cmap_outpack *outpack, real **mat ,FILE *fplog); 
+ void  test_hbd_metrics_new ( struct hybrid_frameset *running , struct hybrid_frameset *reference , struct cmap_outpack *outpack, real **matrix, FILE  *fplog);
+ void  spath_restraint_testder(int i_c, struct mtd_data_s *mtd_data);
+ void  zpath_restraint_testder(int i_c, struct mtd_data_s *mtd_data);
+ void msd_calculation(struct coordinates_frameset *pframeset,struct cmap_inpack *c_inpack,
+                             struct cmap_outpack *c_outpack,real dmsd_dr1[3][MAXATOMS_PATH],int der_frameref_on, int norot, int nocenter);
+ int  rmsd_pack(struct rmsd_inpack inpack,struct rmsd_outpack *outpack,int iopt,int iopt2);
+ int  rmsd_mini_pack(struct rmsd_inpack inpack,struct rmsd_mini_outpack *outpack,int iopt,int simple, int permissive);
+ int  rmsd_mini_pack_fake(struct rmsd_inpack inpack,struct rmsd_mini_outpack *outpack, int nocenter, int simple);
+ int  rmsd_findiff_interface(struct rmsd_inpack inpack,struct rmsd_mini_outpack *outpack);
+ void mean_rmsd(struct sz_data *pmy_sz, real dCV_dr1[MAXFRAMES_PATH][3][MAXATOMS_PATH],
+                        int i_c, FILE *fplog); 
+ void mean_map(struct sz_data *pmy_sz, real dCV_dcm[MAXFRAMES_PATH][MAXDIM_CMAP],
+                        int i_c, FILE *fplog);
+ void dmsd_calculation(int i_c,struct coordinates_frameset *pframeset,struct cmap_inpack *c_inpack,
+                             struct cmap_outpack *c_outpack,real dmsd_dr1[3][MAXATOMS_PATH]);
+ // stuff for gradient projection
+ void couple2list( struct coupling_ll **atlist ,int *at1,int nat1,int *at2,int nat2);
+ void freecouple2list( struct coupling_ll **atlist);
+ void scancouple( struct coupling_ll *atlist);
+ void setup_projections(struct proj_grad_s * );   
+ void calc_projections(struct proj_grad_s *);   
+// misc
+ void cite_please (const char* re, FILE *fplog);
+ void disclaimer (FILE *fplog);
+ // allocators and destructors
+ real *float_1d_array_alloc(int ii);
+ real **float_2d_array_alloc(int ii,int jj);
+ real ***float_3d_array_alloc(int i,int j,int k);
+ real ****float_4d_array_alloc(int i,int j,int k,int l);
+ int  *int_1d_array_alloc(int ii);
+ int  **int_2d_array_alloc(int ii,int jj);
+ int free_1dr_array_alloc(real *xx); // 1d real
+ int free_2dr_array_alloc(real **xx,int ii); // 2d real
+ int free_3dr_array_alloc(real ***xx,int ii,int jj); // 3d read
+ int free_4dr_array_alloc(real ****xx,int ii,int jj, int kk); //4d real
+ int free_1di_array_alloc(int *xx);  //1d integer
+ int free_2di_array_alloc(int **xx,int ii);  //2d integer
+ // neighbour list tools for quicksorting
+ void realquicksort ( real *v , int *ind , int left , int right ); // quicksort for neighbour list search
+ void swap (real *v,int *ind,int i,int j); // used by quicksort
+ int ql77_driver(real m[][4],real* lambda);
+ void rank3_to_ql77(double in[3][3], double evector[3][3], double evalue[3]);
+ int ql77 (int n,double *x,double *d);	
+ void import_ow(real **weight ,char* filename , int start, int end , int *indexes);
+ int matinverse (real **a, real **id, int n, FILE *fplog);
+ void parse_fixwidth(char *str,int i, int j, char *str2);
+//! RECONMETA INCLUDES  Gareth Tribello
+#ifdef RECONMETAD 
+//   #include "recon_cbind.h"
+   MYEXT int reconOn;
+   MYEXT struct recon_data_s  reconinpt;
+   MYEXT void* myreconObj;
+#endif
+#ifdef CVS
+   MYEXT struct bespoke_data_s bespoke_input;
+   MYEXT void* mybespokeObj;
+#endif
+
+/* COMMON DATA STRUCTURES  */
+    MYEXT struct mtd_data_s    mtd_data;
+    MYEXT struct dafed_s       dafed[nconst_max];		// d-AFED #####
+    MYEXT struct dafed_control_s       dafed_control; // d-AFED #####
+    MYEXT struct steer         cvsteer;
+    MYEXT struct tamd          tamd;
+    MYEXT struct abmd          abmd;
+    MYEXT struct constraint    cvcnstr;
+    MYEXT struct wall          cvw;
+    MYEXT struct logical_s     logical;
+    MYEXT struct colvar_s      colvar;
+    MYEXT struct hills_s       hills;
+    MYEXT struct steerplan_s   steerplan;
+    MYEXT struct nlist_s       nlist[nconst_max];
+    MYEXT int   firstTime;					// first PluMed step
+    MYEXT real   Vrecon;                                        // Reconaissance metadynamics potential
+    MYEXT real   Vext;                                          // External potential
+    MYEXT real   Vconstr;                                       // Constraint potential
+    MYEXT real   Vsteerplan;                                    // Steerplan potential
+    MYEXT real   fext[nconst_max];                              // External forces
+// path stuff
+    MYEXT struct sz_data my_sz_list[NMAX_PATH];
+	MYEXT struct rmsd_workstruct_s rmsd_workstruct;  // a general rmsd container that is allocated/reallocated on the fly
+	MYEXT struct couplingmatrix_s couplingmatrix;
+    MYEXT int ic_to_sz[nconst_max];
+    MYEXT int nsz;
+    MYEXT int kill_me[nconst_max];
+// GRID stuff
+    MYEXT struct grid_s       grid;
+// COMMIT
+    MYEXT struct commit_s   commit;
+// alpha/betarmsd stuff
+    MYEXT struct ref_dist_mat_s  ref_dist_mat;
+// sprint stuff
+    MYEXT struct sprint_data_s sprint_data;
+// external potential
+    MYEXT struct grid_s     extpot;
+// camshift stuff
+    MYEXT struct cam_shift_s cam_shift;
+// stopwhen stuff
+    MYEXT struct stopwhen_s stopwhen;
+// interval staff
+    MYEXT struct interval_s cvint;
+// function stuff
+    MYEXT struct  mathfunction_s      mathfunction[nconst_max];
+
+#if defined(DL_POLY) || defined(AMBER) || defined(PLUMED_QESPRESSO)
+#define min(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+
+#if defined (NAMD) || defined (LAMMPS_PLUMED) || defined (PLUMED_CPMD)
+inline real min(real a, real b) { if(a < b){ return a;}else{b;}; };
+#endif
+
+#ifdef NAMD
+};
+#elif LAMMPS_PLUMED
+};
+#elif PLUMED_CPMD
+// we need this because Plumed is a class
+};
+// this makes the Plumed object global
+extern Plumed Plumed_simulation;
+#endif
+
diff -urN dl_class_1.9.orig/srcmod/Plumed/plumed.inc dl_class_1.9/srcmod/Plumed/plumed.inc
--- dl_class_1.9.orig/srcmod/Plumed/plumed.inc	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/plumed.inc	2015-11-07 16:58:03.516055614 +0100
@@ -0,0 +1,42 @@
+PLUMED_OBJECTS= \
+	Plumed/biasexchange.o \
+	Plumed/dafed.o \
+	Plumed/hills.o \
+	Plumed/metadyn.o \
+	Plumed/ptmetad.o \
+	Plumed/read_restraint.o \
+	Plumed/restraint_adf.o \
+	Plumed/restraint_alfabeta.o \
+	Plumed/restraint_alpharmsd.o \
+	Plumed/restraint_angle.o \
+	Plumed/restraint_antibetarmsd.o \
+	Plumed/restraint.o \
+	Plumed/restraint_cmap.o \
+	Plumed/restraint_coord.o \
+	Plumed/restraint_dihcor.o \
+	Plumed/restraint_dipole.o \
+	Plumed/restraint_dist.o \
+	Plumed/restraint_elstpot.o \
+	Plumed/restraint_energy.o \
+	Plumed/restraint_func.o \
+	Plumed/restraint_hbonds.o \
+	Plumed/restraint_helix.o \
+	Plumed/restraint_histogram.o \
+	Plumed/restraint_mindist.o \
+	Plumed/restraint_parabetarmsd.o \
+	Plumed/restraint_pca.o \
+	Plumed/restraint_poly.o \
+	Plumed/restraint_position.o \
+	Plumed/restraint_puckering.o \
+	Plumed/restraint_rdf.o \
+	Plumed/restraint_rgyr.o \
+	Plumed/restraint_spath.o \
+	Plumed/restraint_sprint.o \
+	Plumed/restraint_torsion.o \
+	Plumed/restraint_waterbridge.o \
+	Plumed/restraint_zpath.o \
+	Plumed/testderivatives.o
+OBJ_RECON=
+HEAD_RECON=
+RECON_LIBS=
+RECON_FLAGS=
\ No newline at end of file
diff -urN dl_class_1.9.orig/srcmod/Plumed/ptmetad.c dl_class_1.9/srcmod/Plumed/ptmetad.c
--- dl_class_1.9.orig/srcmod/Plumed/ptmetad.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/ptmetad.c	2015-11-07 17:37:19.297601574 +0100
@@ -0,0 +1,143 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+#include <assert.h>
+
+// This routine has to be executed on the slave nodes to help ptmetad_vbias.
+// The call to non-local routines (gmx_sum, hills_engine) HAS TO BE IN THE SAME ORDER as in ptmetad_vbias.
+void ptmetad_helper(){
+  real s[nconst_max],s2[nconst_max];
+  int icv,ncv;
+#if defined(PLUMED_GROMACS4) || defined(PLUMED_GROMACS45)
+// only slaves should enter this routine
+  assert(!mtd_data.ionode);
+
+  ncv=colvar.nconst;
+
+  if(PAR(mtd_data.mcr) && logical.parallel_hills) {
+    for(icv=0;icv<ncv;icv++) s[icv]=0.0;
+    for(icv=0;icv<ncv;icv++) s2[icv]=0.0;
+    plumed_sum(&mtd_data,ncv,s);
+    plumed_sum(&mtd_data,ncv,s2);
+// returned values are discarded, since they are relevant only for the master node (which calculates the acceptance)
+    hills_engine(s,NULL);
+    hills_engine(s2,NULL);
+  }
+#endif
+};
+
+void ptmetad_vbias(int newrepl,real*bias,real*biasx){
+#if defined(PLUMED_GROMACS) || defined(OPEP) 
+// only master process enters here; slaves go to ptmetad_helper
+// ATTENTION: non-local calls (hills_engine and gmx_sum) has to be in the same order
+  real local_bias; // bias with my hamiltonian in my replica;
+  real local_biasx; // bias with my hamiltonian in replica newrepl;
+  int icv,irep;
+  int ncv,nrep;
+  int myrep;
+  real **all_ss0;
+
+  ncv=colvar.nconst;
+  nrep=mtd_data.nrepl;
+  myrep=mtd_data.repl;
+
+// if no exchange has to be done (newrepl<0), we set it to myrep.
+// in this way, the bias is computed even when 
+  if(newrepl<0) newrepl=myrep;
+
+// array with positions of all replicas
+  all_ss0=float_2d_array_alloc(nrep,ncv);
+
+// a few assertions for debugging:
+  assert(newrepl<nrep); // inrange
+  assert(myrep>=0); assert(myrep<nrep); // in range
+  assert(colvar.ss0); // allocated
+  assert(all_ss0); // allocated
+
+// sharing current CVs value
+  for(icv=0;icv<ncv;icv++) for(irep=0;irep<nrep;irep++) all_ss0[irep][icv] = 0.;
+  for(icv=0;icv<ncv;icv++)                              all_ss0[myrep][icv] = colvar.ss0[icv];
+  plumed_intersum(&mtd_data,nrep*ncv,& all_ss0[0][0]);
+
+#if defined(PLUMED_GROMACS4) || defined(PLUMED_GROMACS45)
+// sharing the cv values with the slaves in ptmetad_helper()
+   if(logical.parallel_hills) {
+     plumed_sum(&mtd_data,ncv,colvar.ss0);
+     plumed_sum(&mtd_data,ncv,all_ss0[newrepl]);
+   }
+#endif
+
+// calculating the bias, walls and external potential
+  assert(all_ss0[newrepl]);
+  local_bias=hills_engine(colvar.ss0,NULL)+soft_walls_engine(colvar.ss0,NULL)+ext_forces_engine(colvar.ss0,&extpot,NULL)
+             +steer_engine(colvar.ss0,NULL);
+  local_biasx=hills_engine(all_ss0[newrepl],NULL)+soft_walls_engine(all_ss0[newrepl],NULL)+ext_forces_engine(all_ss0[newrepl],&extpot,NULL)
+             +steer_engine(all_ss0[newrepl],NULL);
+
+// we don't need it anymore
+  free_2dr_array_alloc(all_ss0,nrep);
+  
+// sharing the bias
+  for(irep=0;irep<nrep;irep++) bias[irep]=0.;
+  for(irep=0;irep<nrep;irep++) biasx[irep]=0.;
+  bias[myrep]=local_bias;
+  biasx[myrep]=local_biasx;
+  plumed_intersum(&mtd_data,nrep, & bias[0]);
+  plumed_intersum(&mtd_data,nrep, & biasx[0]);
+#endif
+};
+
+// In this implementation, all the replicas have to call this routine;
+void ptmetad_exchfluct(int newrepl)
+{
+#if defined(PLUMED_GROMACS) || defined(OPEP) 
+  int i,j;
+  real **all_Mss0;
+  real **all_M2ss0;
+  all_Mss0=float_2d_array_alloc(mtd_data.nrepl,colvar.nconst);
+  all_M2ss0=float_2d_array_alloc(mtd_data.nrepl,colvar.nconst);
+  for(i=0;i<colvar.nconst;i++) for(j=0;j<mtd_data.nrepl;j++) all_Mss0[j][i] = 0.;
+  for(i=0;i<colvar.nconst;i++) for(j=0;j<mtd_data.nrepl;j++) all_M2ss0[j][i] = 0.;
+  for(i=0;i<colvar.nconst;i++) all_Mss0[i][mtd_data.repl] = colvar.Mss0[i];
+  for(i=0;i<colvar.nconst;i++) all_M2ss0[i][mtd_data.repl] = colvar.M2ss0[i];
+  plumed_intersum(&mtd_data,mtd_data.nrepl*colvar.nconst, & all_M2ss0[0][0]);
+  if(newrepl>=0){
+    for(i=0;i<colvar.nconst;i++) colvar.Mss0[i]=all_Mss0[i][newrepl];
+    for(i=0;i<colvar.nconst;i++) colvar.M2ss0[i]=all_M2ss0[i][newrepl];
+  };
+  free_2dr_array_alloc(all_Mss0,mtd_data.nrepl);
+  free_2dr_array_alloc(all_M2ss0,mtd_data.nrepl);
+#endif
+}
+
diff -urN dl_class_1.9.orig/srcmod/Plumed/read_restraint.c dl_class_1.9/srcmod/Plumed/read_restraint.c
--- dl_class_1.9.orig/srcmod/Plumed/read_restraint.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/read_restraint.c	2015-11-07 17:37:19.305601807 +0100
@@ -0,0 +1,2498 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+#include <assert.h>
+
+void PREFIX read_restraint(struct mtd_data_s *mtd_data)
+{
+  double uno, due, tre, quattro;
+  int i, j, icv, count, exp, iw, nw, ix, iline, tmpc;
+  FILE *file;
+  char metafile[120], **word, tmpmeta[120];
+
+// object containing parsed input
+  t_plumed_input input;
+
+// open PluMeD parameters file  
+  file = fopen(mtd_data->metaFilename, "r");
+  fflush(mtd_data->fplog);
+  if(file==NULL) {
+#if defined (PLUMED_GROMACS4) || defined (PLUMED_GROMACS45)
+    if( (mtd_data->repl==-1)&& (mtd_data->mcr->ms)==0 ){
+      char buf[1024];
+      sprintf(buf, "MISSING PLUMED INPUT FILE %s",mtd_data->metaFilename);
+      plumed_error(buf);
+    } else if(mtd_data->mcr->ms!=0 &&mtd_data->repl==-1) {
+      strcpy(tmpmeta,mtd_data->metaFilename);
+      tmpmeta[strlen(mtd_data->metaFilename) - 4] = '\0';
+      sprintf(tmpmeta+strlen(tmpmeta),"%d",mtd_data->mcr->ms->sim);
+      sprintf(metafile, "%s.dat", tmpmeta);
+      file = fopen(metafile, "r");
+      if(file==NULL) {
+        char buf[1024];
+        sprintf(buf, "MISSING PLUMED INPUT FILE %s",mtd_data->metaFilename);
+        plumed_error(buf);
+      }
+    } else if(mtd_data->repl>-1) {
+      strcpy(tmpmeta,mtd_data->metaFilename);
+      tmpmeta[strlen(mtd_data->metaFilename) - 4] = '\0';
+      sprintf(tmpmeta+strlen(tmpmeta),"%d",mtd_data->repl);
+      sprintf(metafile, "%s.dat", tmpmeta);
+      file = fopen(metafile, "r");
+      if(file==NULL) {
+        char buf[1024];
+        sprintf(buf, "MISSING PLUMED INPUT FILE %s",mtd_data->metaFilename);
+        plumed_error(buf);
+      }
+    }
+#else
+    if(mtd_data->repl==-1){
+      char buf[1024];
+      sprintf(buf, "MISSING PLUMED INPUT FILE %s",mtd_data->metaFilename);
+      plumed_error(buf);
+    } else if(mtd_data->repl>-1) {
+      strcpy(tmpmeta,mtd_data->metaFilename);
+      tmpmeta[strlen(mtd_data->metaFilename) - 4] = '\0';
+      sprintf(tmpmeta+strlen(tmpmeta),"%d",mtd_data->repl);
+      sprintf(metafile, "%s.dat", tmpmeta);
+      file = fopen(metafile, "r");
+      if(file==NULL) {
+        char buf[1024];
+        sprintf(buf, "MISSING PLUMED INPUT FILE %s",mtd_data->metaFilename);
+        plumed_error(buf);
+      }
+    }
+#endif
+  }
+
+// CV counter initialization and calling routine to set the default values for many variables
+  count = 0;
+  iline = 0;
+  read_defaults();
+
+// Initialize everything for reconnaissance metadynamics
+#ifdef RECONMETAD 
+//  reconinpt.monitor=0; 
+  reconinpt.nconst=0; reconinpt.nscales=0;
+  reconinpt.stride=-10; reconinpt.height=-10.0; reconinpt.width=-10.0; 
+  reconinpt.basTol=-10.0; reconinpt.diffconst=-10.0; reconinpt.iSize=-10.0;
+  reconinpt.restart=0; reconinpt.fuzzy=0;
+#endif 
+// And initialize counter for bespoke collective coordinates
+  colvar.nbespoke=0;  
+
+
+//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
+//                               INPUT PARSER
+//.............................................................................
+// first word must be keyword (like COORD), then the parser
+// seeks on the same line for additional input (like SIGMA).
+//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
+  
+  fprintf(mtd_data->fplog, " \n");  
+  fprintf(mtd_data->fplog, "::::::::::::::::: READING PLUMED INPUT :::::::::::::::::\n");
+
+  plumed_read_input(&input,file,mtd_data->fplog);
+// everything is now in the "input" structure, the actual file is not needed anymore
+  fclose(file);
+
+  for(iline=0;iline<input.nlines;iline++){
+
+    nw   = input.nwords[iline];
+    word = input.words[iline];
+
+// empty line
+    if(nw==0) continue;
+
+// explicit comment, to be copied on the log file
+    if(!strcmp(word[0],"NOTE") || !strcmp(word[0],"COMMENT")){
+      fprintf(mtd_data->fplog, "\nCOMMENT: ");
+      for(i=1;i<nw;i++)fprintf(mtd_data->fplog, "%s ", word[i]);
+      fprintf(mtd_data->fplog,"\n");
+// untested features
+    } else if(!strcmp(word[0],"ENABLE_UNTESTED_FEATURES")){
+      fprintf(mtd_data->fplog, "|-##################################################################\n");
+      fprintf(mtd_data->fplog, "|- ENABLE_UNTESTED_FEATURES\n");
+      fprintf(mtd_data->fplog, "|- THIS FLAG ENABLES FEATURES WHICH ARE NOT EXPLAINED IN THE MANUAL\n");
+      fprintf(mtd_data->fplog, "|- AND COULD BE BUGGY\n");
+      fprintf(mtd_data->fplog, "|- USE IT ONLY IF YOU ARE A PLUMED DEVELOPERS\n");
+      fprintf(mtd_data->fplog, "|-##################################################################\n");
+      logical.enable_untested_features=1;
+    } else if(!strcmp(word[0],"NEW_COLVAR_FMT")){
+      fprintf(mtd_data->fplog, "|- NEW COLVAR FMT ENABLED\n");
+      mtd_data->newcolvarfmt=1;
+    } else if(!strcmp(word[0],"OLD_COLVAR_FMT")){
+      fprintf(mtd_data->fplog, "|- OLD COLVAR FMT ENABLED\n");
+      mtd_data->newcolvarfmt=0;
+// committors analysis
+    } else if(!strcmp(word[0],"COMMITMENT")){
+      logical.commit = 1;
+      fprintf(mtd_data->fplog, "|-COMMITMENT ANALYSIS: YOU WILL ONLY MONITOR YOUR CVs MICRODYNAMICS\n");
+      for(iw=1;iw<nw;iw++) if(!strcmp(word[iw],"NCV")){iw++; sscanf(word[iw],"%d",&commit.ncv);}
+      for(iw=1;iw<nw;iw++){
+       if(!strcmp(word[iw],"CV")){
+          iw++; for(i=0;i<commit.ncv;i++) {sscanf(word[iw], "%d", &(commit.index[i])); commit.index[i] -= 1; iw++;};
+          iw--;
+       }     
+      }
+      for(i=0;i<commit.ncv;i++){
+        iline++; // this mimicks a fgets
+        sscanf(input.words[iline][0],"%lf",&uno);
+        sscanf(input.words[iline][1],"%lf",&due);
+        sscanf(input.words[iline][2],"%lf",&tre);
+        sscanf(input.words[iline][3],"%lf",&quattro);
+        ix=commit.index[i];
+        commit.Amin[ix] = (real) uno;
+        commit.Amax[ix] = (real) due;
+        commit.Bmin[ix] = (real) tre;
+        commit.Bmax[ix] = (real) quattro;
+        fprintf(mtd_data->fplog, "|--CV %i: A min %f, max %f -- B min %f, max %f\n", ix+1, commit.Amin[ix], commit.Amax[ix], commit.Bmin[ix], commit.Bmax[ix]);
+      }
+      fprintf(mtd_data->fplog, "\n");
+// Reconnaissance metadynamics
+#ifdef RECONMETAD 
+    } else if(!strcmp(word[0],"RECONNAISSANCE")){
+      reconOn=1;
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"RESTART")){ reconinpt.restart=1; logical.append=1; }
+        else if(!strcmp(word[iw],"CV_LIST")){ iw++; reconinpt.nconst=plumed_get_group(word[iw],&reconinpt.cvlist,0,&input,mtd_data->fplog); }
+//        else if(!strcmp(word[iw],"MONITOR")){ reconinpt.monitor=1; }
+        else{ plumed_error("Unknown option for RECONNAISSANCE keyword"); }
+      }
+    } else if(!strcmp(word[0],"ONIONS")) {
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"HEIGHT")){
+           iw++; sscanf(word[iw],"%lf",&uno); reconinpt.height = (real) uno*mtd_data->eunit;
+        } else if(!strcmp(word[iw],"W_STRIDE")){
+          iw++; sscanf(word[iw],"%i",&reconinpt.stride);
+        } else if(!strcmp(word[iw],"WIDTH")){
+          iw++; sscanf(word[iw],"%lf",&uno); reconinpt.width = (real) uno;
+        } else {
+          plumed_error("Unknown option for ONIONS keyword");
+        }
+      }
+    } else if(!strcmp(word[0],"BASINS")) {
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"BASIN_TOL")){
+           iw++; sscanf(word[iw],"%lf",&uno); reconinpt.basTol = (real) uno;
+        } else if(!strcmp(word[iw],"EXPAND_PARAM")){
+          iw++; sscanf(word[iw],"%lf",&uno); reconinpt.diffconst = (real) uno;
+        } else if(!strcmp(word[iw],"INITIAL_SIZE")){
+          iw++; sscanf(word[iw],"%lf",&uno); reconinpt.iSize = (real) uno;
+        } else {
+          plumed_error("Unknown option for BASINS keyword");
+        }
+      }
+    } else if(!strcmp(word[0],"CLUSTER")) {
+      reconinpt.runFreq[reconinpt.nscales]=-10; reconinpt.storeFreq[reconinpt.nscales]=-10;
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"RUN_FREQ")){
+           iw++; sscanf(word[iw],"%i",&(reconinpt.runFreq[reconinpt.nscales]) );
+        } else if(!strcmp(word[iw],"STORE_FREQ")){
+          iw++; sscanf(word[iw],"%i",&(reconinpt.storeFreq[reconinpt.nscales]) );
+        } else if(!word[iw],"FUZZY"){
+          reconinpt.fuzzy=1;
+        } else {
+          plumed_error("Unknown option for CLUSTER keyword");
+        }
+      }
+      reconinpt.nscales++;
+      //fprintf(mtd_data->fplog,"NUMBER OF CLUSTER SCALES %i \n",reconinpt.nscales);
+#else
+    } else if(!strcmp(word[0],"RECONNAISSANCE")){
+      plumed_error("To run reconMetaD you must patch with lapack and lstdc++ libraries.  Revert and repatch");
+    } else if(!strcmp(word[0],"ONIONS")) {
+      plumed_error("To run reconMetaD you must patch with lapack and lstdc++ libraries.  Revert and repatch");
+    } else if(!strcmp(word[0],"BASINS")) {
+      plumed_error("To run reconMetaD you must patch with lapack and lstdc++ libraries.  Revert and repatch");
+    } else if(!strcmp(word[0],"CLUSTER")) {
+      plumed_error("To run reconMetaD you must patch with lapack and lstdc++ libraries.  Revert and repatch");
+#endif
+// metadynamics
+    } else if(!strcmp(word[0],"HILLS")) {
+      logical.do_hills = 1;
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"HEIGHT")){
+          iw++; sscanf(word[iw],"%lf",&uno); hills.wwr = (real) uno*mtd_data->eunit;
+        } else if(!strcmp(word[iw],"W_STRIDE")){
+          iw++; sscanf(word[iw],"%i",&hills.nt_hills);
+        } else if(!strcmp(word[iw],"R_STRIDE")){
+          iw++; sscanf(word[iw],"%i",&hills.nr_hills);
+        } else if(!strcmp(word[iw],"RESTART")){
+          logical.restart_hills = 1;
+        } else if(!strcmp(word[iw],"RATE")){
+          iw++; sscanf(word[iw],"%lf",&uno); hills.rate = (real) uno;
+        } else if(!strcmp(word[iw],"MAX_HEIGHT")){
+          iw++; sscanf(word[iw],"%lf",&uno); hills.max_height = (real) uno;
+        } else if(!strcmp(word[iw],"MAX_STRIDE")){
+          iw++; sscanf(word[iw],"%i",&hills.max_stride);
+        } else {
+          plumed_error("Unknown option for HILLS keyword");
+        }
+      };
+      if(hills.rate==0.0) hills.rate = hills.wwr/hills.nt_hills/mtd_data->dt;
+      if(hills.wwr==0.0) hills.wwr=hills.rate*hills.nt_hills*mtd_data->dt;
+      fprintf(mtd_data->fplog,"|-HILLS:\n");
+      if(hills.max_height==0.0){
+        fprintf(mtd_data->fplog,"|--HEIGHT %f  WRITING STRIDE %i DEPOSITION RATE %f \n",
+                hills.wwr/mtd_data->eunit, hills.nt_hills, hills.rate/mtd_data->eunit);
+      } else {
+        fprintf(mtd_data->fplog,"|--DEPOSITION RATE %f \n",hills.rate/mtd_data->eunit);
+        fprintf(mtd_data->fplog,"|--MAXIMUM STRIDE BETWEEN HILLS %i \n",hills.max_stride);
+        fprintf(mtd_data->fplog,"|--MAXIMUM HEIGHT               %f \n",hills.max_height);
+      }
+      if(logical.restart_hills) fprintf(mtd_data->fplog,"|-RESTARTING METADYNAMICS!\n");
+      if(hills.nr_hills!=1) fprintf(mtd_data->fplog,"|--READING STRIDE %i\n", hills.nr_hills);
+      fprintf(mtd_data->fplog, "\n");
+// multiple walkers (shared file)
+    } else if(!strcmp(word[0],"MULTIPLE_WALKERS")) {
+      logical.do_walkers = 1; 
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"HILLS_DIR")){
+          iw++; sscanf(word[iw], "%s", hills.dir);
+        } else if(!strcmp(word[iw],"NWALKERS")){
+          iw++; sscanf(word[iw], "%i", &hills.nwalkers); 
+        } else if(!strcmp(word[iw],"ID")){
+          iw++; sscanf(word[iw], "%i", &hills.idwalker);
+        } else if(!strcmp(word[iw],"R_STRIDE")){
+          iw++; sscanf(word[iw], "%i", &hills.nr_hills); 
+        } else {
+          plumed_error("Unknown option for MULTIPLE_WALKERS keyword");
+        }
+      };
+      fprintf(mtd_data->fplog,"|-MULTIPLE WALKERS: NWALKERS %i ID %i\n", hills.nwalkers,hills.idwalker);
+      if(hills.nr_hills!=1) fprintf(mtd_data->fplog,"|--READING STRIDE %i\n", hills.nr_hills);
+      fprintf(mtd_data->fplog,"|--DIRECTORY FOR HILLS I/O %s\n", hills.dir);
+    } else if(!strcmp(word[0],"PRINT")) {
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"W_STRIDE")){
+          iw++; sscanf(word[iw],"%i", &colvar.nt_print);
+        } else if(!strcmp(word[iw],"T_OFFSET")){
+          iw++; sscanf(word[iw],"%lf", &uno); mtd_data->time_offset= uno;  
+        } else if(!strcmp(word[iw],"APPEND")){
+          logical.append = 1;
+        } else {
+          plumed_error("Unknown option for PRINT keyword");
+        }
+      }
+      fprintf(mtd_data->fplog,"|-PRINTING ON COLVAR FILE EVERY %i STEPS\n",colvar.nt_print);
+      fprintf(mtd_data->fplog,"|-INITIAL TIME OFFSET IS %f TIME UNITS\n",mtd_data->time_offset);
+      if(logical.append) fprintf(mtd_data->fplog,"|-APPENDING TO OLD COLVAR\n");
+      logical.print = 1;
+    } else if(!strcmp(word[0],"HILLS_LABEL")) {
+      if( nw==1 ){
+        plumed_error("Missing label after HILLS_LABEL"); 
+      }else{
+        sscanf(word[1],"%s",colvar.hills_label);
+      }
+      fprintf(mtd_data->fplog,"|-USING HILLS_LABEL %s IN HEADERS OF COLVAR AND HILLS FILES\n",colvar.hills_label);
+    } else if(!strcmp(word[0],"DUMP_ATOMS")) {
+#if ! defined (PLUMED_GROMACS)
+        plumed_error("DUMP_ATOMS NOT YET IMPLEMENTED IN THIS CODE");
+#endif
+       int list_found;
+       list_found=0;
+       fprintf(mtd_data->fplog,"|- DUMPING ATOMS\n");
+       for(iw=1;iw<nw;iw++){
+         if(!strcmp(word[iw],"LIST")){
+           list_found=1;
+           iw++; mtd_data->dump_atoms+=plumed_get_group(word[iw],&mtd_data->dump_list,mtd_data->dump_atoms,&input,mtd_data->fplog);
+         } else if(!strcmp(word[iw],"STRIDE")){
+           iw++; sscanf(word[iw],"%i", &mtd_data->dump_stride);
+         } else {
+           plumed_error("Unknown option for DUMP keyword");
+         }
+       }
+       if(!list_found)plumed_error("NEEDED LIST KEYWORD FOR DUMP_ATOMS\n");
+       fprintf(mtd_data->fplog,"|- SET MEMBERS: ");
+       for(i=0;i<mtd_data->dump_atoms;i++){
+         fprintf(mtd_data->fplog," %d ",mtd_data->dump_list[i]+1);if((i+1)%20==0)fprintf(mtd_data->fplog,"\n               ");
+       }fprintf(mtd_data->fplog,"\n\n");
+     } else if(!strcmp(word[0],"ALIGN_ATOMS")) {
+       int list_found;
+       list_found=0;
+       fprintf(mtd_data->fplog,"|- ALIGNING ATOMS\n");
+       for(iw=1;iw<nw;iw++){
+         if(!strcmp(word[iw],"LIST")){
+           list_found=1;
+           iw++; colvar.align_atoms+=plumed_get_group(word[iw],&colvar.align_list,colvar.align_atoms,&input,mtd_data->fplog);
+         } else {
+           plumed_error("Unknown option for ALIGN keyword");
+         }
+       }
+       if(!list_found)plumed_error("NEEDED LIST KEYWORD FOR ALIGN_ATOMS\n");
+       fprintf(mtd_data->fplog,"|- SET MEMBERS: ");
+       for(i=0;i<colvar.align_atoms;i++){
+         fprintf(mtd_data->fplog," %d ",colvar.align_list[i]+1);if((i+1)%20==0)fprintf(mtd_data->fplog,"\n               ");
+       }fprintf(mtd_data->fplog,"\n\n");
+    } else if(!strcmp(word[0],"DEBUG_DERIVATIVES")){
+      logical.debug_derivatives=1;
+    } else if(!strcmp(word[0],"PARALLEL_HILLS")){
+#if ! defined (PLUMED_GROMACS) && ! defined (DL_POLY) && ! defined (AMBER)
+        plumed_error("PARALLEL_HILLS NOT YET IMPLEMENTED IN THIS CODE");
+#endif
+        for(iw=1;iw<nw;iw++){
+          if(!strcmp(word[iw],"ON")){
+            logical.parallel_hills=1;
+          } else if(!strcmp(word[iw],"OFF")){
+            logical.parallel_hills=0;
+          } else {
+            plumed_error("Unknown flag for keyword PARALLEL_HILLS");
+          }
+        }
+        fprintf(mtd_data->fplog, "|-PARALLEL HILLS ");
+        if(logical.parallel_hills) fprintf(mtd_data->fplog, "ON");
+        else                       fprintf(mtd_data->fplog, "OFF");
+        fprintf(mtd_data->fplog, "\n\n");
+    } else if(!strcmp(word[0],"PTMETAD")){
+      #if ! defined (PLUMED_GROMACS) && ! defined (OPEP)
+          plumed_error("PTMETAD: NOT YET IMPLEMENTED IN THIS CODE");
+      #else
+      fprintf(mtd_data->fplog, "|-PARALLEL TEMPERING METADYNAMICS\n");
+      logical.remd = 1;
+      fprintf(mtd_data->fplog, "|--REPLICA 0 TEMPERATURE = %f\n", mtd_data->rte0);
+      fprintf(mtd_data->fplog, "|--REPLICA %i TEMPERATURE = %f\n", mtd_data->repl, mtd_data->rteio);
+      if(mtd_data->repl==-1) {
+        fprintf(mtd_data->fplog, "\n!!!! mdrun not in replica exchange mode, keyword PTMETAD will not be considered !!!!\n");
+        logical.remd = 0;
+      }
+      fprintf(mtd_data->fplog, "\n");
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"NEIGHBOUR")){
+          iw++; sscanf(word[iw],"%i",&colvar.ptmetad_neighbours);
+        } else if(!strcmp(word[iw],"SIGMA")){
+          iw++; sscanf(word[iw],"%lf",&uno); colvar.ptmetad_sigma = (real) uno;
+        } else if(!strcmp(word[iw],"HREX")){
+#if ! defined (PLUMED_GROMACS)
+          plumed_error("HAMILTONIAN REPLICA-EXCHANGE: NOT YET IMPLEMENTED IN THIS CODE");
+#endif
+          fprintf(mtd_data->fplog, "|-HAMILTONIAN REPLICA-EXCHANGE\n");
+          logical.hrex=1;
+        } else if(!strcmp(word[iw],"NORESCALE")){
+          logical.norescale=1;
+          fprintf(mtd_data->fplog, "|--DO NOT RESCALE GAUSSIANS HEIGHT WITH TEMPERATURE\n"); 
+        } else {
+          plumed_error("Unknown flag for keyword PTMETAD");
+        }
+      }
+      if(colvar.ptmetad_neighbours){
+        fprintf(mtd_data->fplog, "|--SIGMA = %lf\n",(double) colvar.ptmetad_sigma);
+        fprintf(mtd_data->fplog, "|--NEIGHBOUR = %i\n",colvar.ptmetad_neighbours);
+      }
+      fprintf(mtd_data->fplog, "\n");
+      #endif
+    } else if(!strcmp(word[0],"BIASXMD")){
+      #if ! defined (PLUMED_GROMACS) && ! defined (OPEP)
+          plumed_error("|-BIASXMD: NOT YET IMPLEMENTED IN THIS CODE");
+      #else
+      fprintf(mtd_data->fplog, "|-BIAS EXCHANGE METADYNAMICS\n");
+      logical.rpxm = 1;
+      logical.remd = 1;
+      if(mtd_data->repl==-1&&!(mtd_data->mcr->ms)) {
+        plumed_error("\n!!!! mdrun not in replica exchange mode, keyword BIASXMD cannot be used !!!!\n");
+        logical.rpxm = 0;
+        logical.remd = 0;
+      }
+      fprintf(mtd_data->fplog, "\n");
+      #endif
+    } else if(!strcmp(word[0],"TAMD") ){
+      // ### Removed because keyword DAFED is reserved.
+      //  || !strcmp(word[0],"DAFED")
+      logical.tamd = 1;
+      int read_biasfactor = 0;
+      int read_cvtemp = 0;
+      int read_simtemp = 0;
+      int read_starttemp = 0;
+      tamd.seed=1234;
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"CVTEMP")){
+          iw++; sscanf(word[iw], "%lf", &uno); tamd.wtemp   = (real) uno; read_cvtemp = 1;
+        } else if(!strcmp(word[iw],"TFACTOR")){
+          iw++; sscanf(word[iw], "%lf", &uno); tamd.wfactor = (real) uno; read_biasfactor = 1;
+        } else if(!strcmp(word[iw],"SIMTEMP")){
+          iw++; sscanf(word[iw], "%lf", &uno); tamd.simtemp = (real) uno; read_simtemp = 1;
+        } else if(!strcmp(word[iw],"STARTTEMP")){
+          iw++; sscanf(word[iw], "%lf", &uno); tamd.starttemp = (real) uno; read_starttemp = 1;
+        } else if(!strcmp(word[iw],"TAU")){
+          iw++; sscanf(word[iw], "%lf", &uno); tamd.tau= (real) uno;
+        } else if(!strcmp(word[iw],"SEED")){
+          iw++; sscanf(word[iw], "%i", &tamd.seed); 
+        } else {
+          plumed_error("Unknown flag for keyword TAMD/DAFED");
+        }
+      }
+      tamd.drift=0.0;
+      if(!read_simtemp)
+        plumed_error("WITH TAMD/DAFED YOU ALWAYS HAVE TO SPECIFY THE \"SIMTEMP \" KEYWORD");
+      if(read_biasfactor==read_cvtemp)
+        plumed_error("WITH TAMD/DAFED YOU HAVE TO SPECIFY EITHER \"CVTEMP \" OR \"TFACTOR \" KEYWORD");
+      if(read_cvtemp)     tamd.wfactor = tamd.wtemp / tamd.simtemp;  
+      if(read_biasfactor) tamd.wtemp   = tamd.wfactor * tamd.simtemp;
+      if(!read_starttemp) tamd.starttemp = tamd.simtemp;
+      fprintf(mtd_data->fplog, "|-TAMD/DAFED WITH TFACTOR %f (CVTEMP = %f) \n", tamd.wfactor,tamd.wtemp);
+      fprintf(mtd_data->fplog, "|-SPRING CONSTANTS CALCULATED FROM SIGMA AND WTEMP OF EACH VARIABLE\n");
+      fprintf(mtd_data->fplog, "|-INITIAL RANDOMIZATION OF RESTRAINTS AT T = %f\n",tamd.simtemp);
+      fprintf(mtd_data->fplog, "\n");
+    } else if(!strcmp(word[0],"WELLTEMPERED")){
+      logical.welltemp = 1;
+      int read_biasfactor = 0;
+      int read_cvtemp = 0;
+      int read_simtemp = 0;
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"CVTEMP")){
+          iw++; sscanf(word[iw], "%lf", &uno); colvar.wtemp   = (real) uno; read_cvtemp = 1;
+        } else if(!strcmp(word[iw],"BIASFACTOR")){
+          iw++; sscanf(word[iw], "%lf", &uno); colvar.wfactor = (real) uno; read_biasfactor = 1;
+        } else if(!strcmp(word[iw],"SIMTEMP")){
+          iw++; sscanf(word[iw], "%lf", &uno); colvar.simtemp = (real) uno; read_simtemp = 1;
+        } else if(!strcmp(word[iw],"READ_OLD_BF")){
+          logical.read_old_bf = 1;
+        } else {
+          plumed_error("Unknown flag for keyword WELLTEMPERED");
+        }
+      }
+      if(!read_simtemp)
+        plumed_error("WITH WELLTEMPERED YOU ALWAYS HAVE TO SPECIFY THE \"SIMTEMP \" KEYWORD");
+      if(read_biasfactor==read_cvtemp)
+        plumed_error("WITH WELLTEMPERED YOU HAVE TO SPECIFY EITHER \"CVTEMP \" OR \"BIASFACTOR \" KEYWORD");
+      if(read_cvtemp)     colvar.wfactor = colvar.wtemp / colvar.simtemp;  
+      if(read_biasfactor) colvar.wtemp   = colvar.wfactor * colvar.simtemp;
+      if (colvar.wfactor<=1.0) {  
+        char buf[1024];
+        sprintf(buf,"WELLTEMPERED: BIASFACTOR less than or equal to 1.0 ( %f ) \n",colvar.wfactor);
+        plumed_error(buf);
+      } 
+      fprintf(mtd_data->fplog, "|-WELL-TEMPERED METADYNAMICS WITH BIASFACTOR %f (CVTEMP = %f) \n", colvar.wfactor,colvar.wtemp);
+      if(logical.read_old_bf) fprintf(mtd_data->fplog, "|--READING OLD BIASFACTOR WHEN RESTARTING \n");
+      fprintf(mtd_data->fplog, "\n");
+   
+    } else if(!strcmp(word[0],"DEBUG")){
+      fprintf(mtd_data->fplog,"|- CV DERIVATIVES DEBUGGING \n"); 
+      logical.debug = 1;
+    } else if(!strcmp(word[0],"DISTANCE")){
+      read_dist(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"MINDIST")){
+      read_mindist(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"COORD")){
+      read_coord(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"ANGLE")){
+      read_angle(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"HBONDS")){
+      read_hbonds(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"TORSION")){
+      read_torsion(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"RGYR")){
+      read_rgyr(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"DIPOLE")){
+      read_dipole(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"DIHCOR")) {
+      read_dihcor(word, count, &input,&iline,mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"WATERBRIDGE")) {
+      read_waterbridge(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"ALPHABETA")) {
+      read_alfabeta(word, count,&input,&iline,mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"S_PATH")) {
+      logical.path = 1;
+      colvar.type_s[count]   = 30;
+      read_path(word, count, &input,mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"Z_PATH")) {
+      logical.path = 1;
+      colvar.type_s[count]   = 31;
+      read_path(word, count, &input,mtd_data->fplog);
+      count++;   
+    } else if(!strcmp(word[0],"TARGETED")) {
+      colvar.type_s[count]   = 31;
+      read_path(word, count, &input,mtd_data->fplog);
+      count++;   
+/* Atom position */      
+    } else if(!strcmp(word[0],"POSITION")) {
+      colvar.type_s[count]   = 32;
+      read_position(word, count, &input, mtd_data->fplog);
+      count++;   
+    } else if(!strcmp(word[0],"ELSTPOT")) {
+      colvar.type_s[count]   = 33;
+      read_elstpot(word, count, &input, mtd_data->fplog);
+      count++;   
+    } else if(!strcmp(word[0],"PUCKERING")) {
+      logical.puckering      =  1;
+      colvar.type_s[count]   = 34;
+      read_puckering(word, count, &input, mtd_data->fplog);
+      count++;   
+    } else if(!strcmp(word[0],"ENERGY")) {
+#if ! defined (PLUMED_GROMACS4) && ! defined (DL_POLY) && ! defined (AMBER) && ! defined (PLUMED_GROMACS45)
+          plumed_error("ENERGY CV: NOT YET IMPLEMENTED IN THIS CODE");
+      #endif
+      logical.energy         =  1;
+      colvar.type_s[count]   = 35;
+      read_energy(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"HELIX")) {
+      colvar.type_s[count]   = 36;
+      read_helix(word, count,&input,&iline,mtd_data->fplog);
+      count++; 
+    } else if(!strcmp(word[0],"ALPHARMSD")) {
+      colvar.type_s[count]   = 37;
+      read_alpharmsd(word, count,&input, mtd_data->fplog);
+      logical.do_alphabetarmsd=1;
+      count++;
+    } else if(!strcmp(word[0],"ANTIBETARMSD")) {
+      colvar.type_s[count]   = 38;
+      read_antibetarmsd(word, count,&input, mtd_data->fplog);
+      logical.do_alphabetarmsd=1;
+      count++;
+    } else if(!strcmp(word[0],"PARABETARMSD")) {
+      colvar.type_s[count]   = 39;
+      read_parabetarmsd(word, count,&input, mtd_data->fplog);
+      logical.do_alphabetarmsd=1;
+      count++;
+    /*} else if(!strcmp(word[0],"CAMSHIFT")) {
+      colvar.type_s[count]   = 40;
+      read_camshift(word, count,&input, mtd_data->fplog);
+      count++;*/
+    } else if (!strcmp(word[0],"PCA")) {
+      logical.do_pca = 1;
+      colvar.type_s[count]   = 42;
+      read_pca(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"CMAP")) {
+      colvar.type_s[count]   = 45;
+      read_cmap(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"POLY")) {
+      colvar.type_s[count]   = 50;
+      read_poly(word, count, &input, &iline, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"FUNCTION")) {
+      colvar.type_s[count]   = 51;
+      read_func(word, count, &input, &iline, &nw,  mtd_data->fplog);
+      count++;
+#ifdef CVS
+    } else if(!strcmp(word[0],"BESPOKE")) {
+      colvar.type_s[count] = 46;
+      read_bespoke(word, count, &input, mtd_data->fplog);
+      count++; colvar.nbespoke++;
+#else   
+    } else if(!strcmp(word[0],"BESPOKE")) {
+      plumed_error("To run bespoke collective coordinates you must patch with lapack and lstc++ libraries.  Revert and repatch");
+#endif
+    } else if(!strcmp(word[0],"RDF")) {
+      colvar.type_s[count] = 47;
+      read_rdf(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"HISTOGRAM")) {
+      colvar.type_s[count] = 49;
+      read_histogram(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"ADF")) {
+      colvar.type_s[count] = 52;
+      read_adf(word, count, &input, mtd_data->fplog);
+      count++;
+    } else if(!strcmp(word[0],"SPRINT")) {
+      colvar.type_s[count]   = 55;
+      read_sprint(word, count,&input, mtd_data->fplog);
+      logical.do_sprint=1;
+      count++;
+    } else if(!strcmp(word[0],"MSD")) {
+		// this is a simple dummy MSD variable whose intent is to be used into 
+		// hybrid path and hypothetical should contain a more advanced path structure
+		colvar.type_s[count] = 53;
+		read_msd(word, count, &input, mtd_data->fplog);
+		count++;
+    } 
+	  else if(!strcmp(word[0],"UWALL")){
+      int read_limit=0;
+      int read_kappa=0;
+// first we select the proper CV
+      iw = seek_word(word,"CV");
+      if(iw>=0){ sscanf(word[iw+1], "%i", &icv);}
+      else{plumed_error("WITH UWALL YOU ALWAYS HAVE TO SPECIFY THE \"CV\" KEYWORD\n");}
+// then we parse the line
+      logical.upper[icv-1]=1;
+      logical.do_walls = 1;   // ### For modified output format
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"CV")) {
+          iw++;  // already read
+        } else if(!strcmp(word[iw],"LIMIT")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvw.upper[icv-1]=(real)uno; read_limit=1;
+        } else if(!strcmp(word[iw],"KAPPA")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvw.sigma[icv-1]=(real)uno*mtd_data->eunit; read_kappa=1;
+        } else if(!strcmp(word[iw],"EXP")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvw.uexp[icv-1]=(real)uno;
+        } else if(!strcmp(word[iw],"EPS")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvw.ueps[icv-1]=(real)uno;
+        } else if(!strcmp(word[iw],"OFF")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvw.uoff[icv-1]=(real)uno;
+        } else {
+          plumed_error("Unknown flag for keyword UWALL");
+        };
+      }
+      if(!read_limit)
+        plumed_error("WITH UWALL YOU ALWAYS HAVE TO SPECIFY THE \"LIMIT\" KEYWORD\n");
+      if(!read_kappa)
+        plumed_error("WITH UWALL YOU ALWAYS HAVE TO SPECIFY THE \"KAPPA\" KEYWORD\n");
+      fprintf(mtd_data->fplog, "|-WALL ON COLVAR %i: UPPER LIMIT = %f, KAPPA = %f, EXPONENT = %i, REDUX = %f, OFFSET = %f \n\n",
+             icv, cvw.upper[icv-1], cvw.sigma[icv-1]/mtd_data->eunit, cvw.uexp[icv-1], cvw.ueps[icv-1], cvw.uoff[icv-1]);
+     } else if(!strcmp(word[0],"LWALL")){
+      int read_limit=0;
+      int read_kappa=0;
+// first we select the proper CV
+      iw = seek_word(word,"CV");
+      if(iw>=0){ sscanf(word[iw+1], "%i", &icv);}
+      else{plumed_error("WITH UWALL YOU ALWAYS HAVE TO SPECIFY THE \"CV\" KEYWORD\n");}
+// then we parse the line
+      logical.lower[icv-1]=1;
+      logical.do_walls = 1;   // ### For modified output format
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"CV")) {
+          iw++;  // already read
+        } else if(!strcmp(word[iw],"LIMIT")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvw.lower[icv-1]=(real)uno; read_limit=1;
+        } else if(!strcmp(word[iw],"KAPPA")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvw.lsigma[icv-1]=(real)uno*mtd_data->eunit; read_kappa=1;
+        } else if(!strcmp(word[iw],"EXP")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvw.lexp[icv-1]=(real)uno;
+        } else if(!strcmp(word[iw],"EPS")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvw.leps[icv-1]=(real)uno;
+        } else if(!strcmp(word[iw],"OFF")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvw.loff[icv-1]=(real)uno;
+        } else {
+          plumed_error("Unknown flag for keyword LWALL");
+        };
+      }
+      if(!read_limit)
+        plumed_error("WITH LWALL YOU ALWAYS HAVE TO SPECIFY THE \"LIMIT\" KEYWORD\n");
+      if(!read_kappa)
+        plumed_error("WITH LWALL YOU ALWAYS HAVE TO SPECIFY THE \"KAPPA\" KEYWORD\n");
+      fprintf(mtd_data->fplog, "|-WALL ON COLVAR %i: LOWER LIMIT = %f, KAPPA = %f, EXPONENT = %i, REDUX = %f, OFFSET = %f \n\n",
+             icv, cvw.lower[icv-1], cvw.lsigma[icv-1]/mtd_data->eunit, cvw.lexp[icv-1], cvw.leps[icv-1], cvw.loff[icv-1]);
+     } else if(!strcmp(word[0],"INTERVAL")){
+      int read_lower_limit=0;
+      int read_upper_limit=0;
+// first we select the proper CV
+      iw = seek_word(word,"CV");
+      if(iw>=0){ sscanf(word[iw+1], "%i", &icv);}
+      else{plumed_error("WITH INTERWAL YOU ALWAYS HAVE TO SPECIFY THE \"CV\" KEYWORD\n");}
+// then we parse the line
+      logical.interval[icv-1]=1;  
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"CV")) {
+          iw++;  // already read
+        } else if(!strcmp(word[iw],"LOWER_LIMIT")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvint.lower_limit[icv-1]=(real)uno; read_lower_limit=1;
+        } else if(!strcmp(word[iw],"UPPER_LIMIT")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvint.upper_limit[icv-1]=(real)uno; read_upper_limit=1;
+        } else {
+          plumed_error("Unknown flag for keyword INTERVAL");
+        };
+      }
+      if(!read_lower_limit)
+        plumed_error("LOWER_LIMIT is missing");
+      if(!read_upper_limit)
+        plumed_error("UPPER_LIMIT is missing");
+      fprintf(mtd_data->fplog, "|-INTERVAL ON COLVAR %i: LOWER_LIMIT = %f, UPPER_LIMIT = %f \n\n",
+             icv, cvint.lower_limit[icv-1], cvint.upper_limit[icv-1]);  
+    } else if(!strcmp(word[0],"STEER")){
+      int read_max=0;
+      int read_delta=0;
+      int read_kappa=0;
+      iw = seek_word(word,"CV");
+      if(iw>=0){ sscanf(word[iw+1], "%i", &icv); cvsteer.impose_start[icv-1] = 0;}
+      else {plumed_error("WITH STEER YOU ALWAYS HAVE TO SPECIFY THE \"CV\" KEYWORD\n");} 
+      for(iw=1;iw<nw;iw++){ 
+        if(!strcmp(word[iw],"CV")){
+          iw++; // already read
+        } else if(!strcmp(word[iw],"FROM")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvsteer.start[icv-1]=(real)uno; cvsteer.impose_start[icv-1]=1;
+        } else if(!strcmp(word[iw],"TO")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvsteer.max[icv-1]=(real)uno; read_max=1;
+        } else if(!strcmp(word[iw],"VEL")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvsteer.delta[icv-1]=(real) fabs(uno); read_delta=1;
+        } else if(!strcmp(word[iw],"KAPPA")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvsteer.spring[icv-1]=(real) uno*mtd_data->eunit; read_kappa=1;
+        } else if(!strcmp(word[iw],"RESTART")){
+          logical.append = 1;
+        } else {
+          plumed_error("Unknown flag for keyword STEER");
+        }
+      }
+      if(!read_max)  plumed_error("WITH STEER YOU ALWAYS HAVE TO SPECIFY THE \"TO\" KEYWORD\n");
+      if(!read_delta)plumed_error("WITH STEER YOU ALWAYS HAVE TO SPECIFY THE \"VEL\" KEYWORD\n");
+      if(!read_kappa)plumed_error("WITH STEER YOU ALWAYS HAVE TO SPECIFY THE \"KAPPA\" KEYWORD\n");
+
+      logical.steer[icv-1]  = 1; 
+      if(cvsteer.impose_start[icv-1]==0){
+        fprintf(mtd_data->fplog, "|-STEERING COLVAR %i TO %f: VELOCITY=%lf cvunit/kstep, SPRING=%lf\n\n", icv,cvsteer.max[icv-1],cvsteer.delta[icv-1],cvsteer.spring[icv-1]/mtd_data->eunit);
+      } else { 
+        fprintf(mtd_data->fplog, "|-STEERING COLVAR %i FROM %f TO %f: VELOCITY=%lf cvunit/kstep, SPRING=%lf\n\n", icv, cvsteer.start[icv-1],cvsteer.max[icv-1],cvsteer.delta[icv-1],cvsteer.spring[icv-1]/mtd_data->eunit);
+      } 
+      if(logical.append) fprintf(mtd_data->fplog,"|-RESTARTING STEERING!\n");
+
+  // DAFED  ########### ---------------------------------------------------------
+  // The dafed structure is different from the steer structure
+  // steer is a structure of arrays, dafed is an array of structures
+    } else if(!strcmp(word[0],"DAFED")){
+  #if defined (PLUMED_GROMACS4) || defined (PLUMED_GROMACS45)
+    	  int read_temperature=0;
+		  int read_mass=0;
+		  int read_kappa=0;
+		  int read_tauthermo=0;
+		  int read_nrespa_ggmt=0;
+		  int n_respa_ggmt;
+
+		  iw = seek_word(word,"CV");
+		if(iw>=0){ sscanf(word[iw+1], "%i", &icv);}
+		else {plumed_error("WITH DAFED YOU ALWAYS HAVE TO SPECIFY THE \"CV\" KEYWORD\n");}
+
+                dafed[icv-1].do_jacobian_force = 0;
+                dafed[icv-1].do_periodicity = 0;
+                dafed[icv-1].periodicity_low = 0.0;
+                dafed[icv-1].periodicity_high = 0.0;
+                dafed[icv-1].periodicity_gap = 0.0;
+
+		for(iw=1;iw<nw;iw++){
+				if(!strcmp(word[iw],"CV")){
+				  iw++; // already read
+				} else if(!strcmp(word[iw],"TEMPERATURE")) {
+				  iw++; sscanf(word[iw], "%lf", &uno); dafed[icv-1].temperature=(real)uno; read_temperature=1;
+				} else if(!strcmp(word[iw],"MASS")) {
+				  iw++; sscanf(word[iw], "%lf", &uno); dafed[icv-1].mass=(real)uno; read_mass=1;
+				} else if(!strcmp(word[iw],"KAPPA")) {
+				  iw++; sscanf(word[iw], "%lf", &uno); dafed[icv-1].kappa=(real)uno*mtd_data->eunit; read_kappa=1;
+				} else if(!strcmp(word[iw],"TAUTHERMO")) {
+				  iw++; sscanf(word[iw], "%lf", &uno); dafed[icv-1].tauthermo=(real)uno; read_tauthermo=1;
+				} else if(!strcmp(word[iw],"N_RESPA_GGMT")) {
+				  iw++; sscanf(word[iw], "%lf", &uno); dafed[icv-1].ggmt.n_respa_ggmt=(int)uno; read_nrespa_ggmt=1;
+                                } else if(!strcmp(word[iw],"PERIODIC")) {
+                                  iw++;
+				  if (!strcmp(word[iw],"MINUS_PI")) {
+					dafed[icv-1].periodicity_low= - M_PI;
+				  }else{
+					sscanf(word[iw], "%lf", &uno);
+					dafed[icv-1].periodicity_low=(real)uno;
+				  }
+				  iw++;
+				  if (!strcmp(word[iw],"PLUS_PI")) {
+				  dafed[icv-1].periodicity_high= + M_PI;
+				  }else if (!strcmp(word[iw],"PLUS_2PI")){
+				  dafed[icv-1].periodicity_high= + 2.0* M_PI;
+				  }else{
+				  sscanf(word[iw], "%lf", &uno);
+				  dafed[icv-1].periodicity_high=(real)uno;
+				}
+				dafed[icv-1].periodicity_gap = dafed[icv-1].periodicity_high - dafed[icv-1].periodicity_low;
+				dafed[icv-1].do_periodicity = 1;
+				} else if(!strcmp(word[iw],"JACOBIAN_FORCE")) {
+				  dafed[icv-1].do_jacobian_force = 1;
+				} else {
+				  plumed_error("Unknown flag for keyword DAFED");
+				}
+		}
+		if(!read_temperature)  plumed_error("WITH DAFED YOU ALWAYS HAVE TO SPECIFY THE \"TEMPERATURE\" KEYWORD\n");
+		if(!read_mass)  plumed_error("WITH DAFED YOU ALWAYS HAVE TO SPECIFY THE \"MASS\" KEYWORD\n");
+		if(!read_kappa)  plumed_error("WITH DAFED YOU ALWAYS HAVE TO SPECIFY THE \"KAPPA\" KEYWORD\n");
+		if(!read_tauthermo)  plumed_error("WITH DAFED YOU ALWAYS HAVE TO SPECIFY THE \"TAUTHERMO\" KEYWORD\n");
+
+		// default values
+		if(!read_nrespa_ggmt) dafed[icv-1].ggmt.n_respa_ggmt=1;
+
+		logical.dafed[icv-1]  = 1;
+		logical.do_dafed  = 1;
+
+		fprintf(mtd_data->fplog, "|- DAFED ON COLVAR %i WITH FOLLOWING PARAMETERS\n",icv);
+		fprintf(mtd_data->fplog, "|-\tTEMPERATURE %f\n",dafed[icv-1].temperature);
+		fprintf(mtd_data->fplog, "|-\tMASS %f\n",dafed[icv-1].mass);
+		fprintf(mtd_data->fplog, "|-\tKAPPA %f\n",dafed[icv-1].kappa);
+		fprintf(mtd_data->fplog, "|-\tTHERMOSTAT TAU %f\n",dafed[icv-1].tauthermo);
+		if (dafed[icv-1].do_jacobian_force) {
+			fprintf(mtd_data->fplog, "|-\tApply JACOBIAN_FORCE\n");
+		}
+
+  #else
+	plumed_error("DAFED is not implemented with MD packages other than Gromacs 4.x");
+  #endif
+    } else if(!strcmp(word[0],"DAFED_CONTROL")){
+
+    	int read_nrespa=0;
+    	for(iw=1;iw<nw;iw++){
+    			if(!strcmp(word[iw],"RESTART")){
+    					  dafed_control.restart = 1;
+    					  iw++; sscanf(word[iw], "%s", &(dafed_control.in_file));
+    					  fprintf(mtd_data->fplog, "|- WILL RESTART WITH d-AFED STATE FROM FILE %s \n",dafed_control.in_file );
+    			} else if(!strcmp(word[iw],"WRITE_STATE")) {
+    					  iw++; sscanf(word[iw], "%lf", &uno); dafed_control.write_freq= (int)uno;
+    					  fprintf(mtd_data->fplog, "|- WILL WRITE d-AFED STATE TO FILE DAFED_STATE EVERY %d STEPS \n",dafed_control.write_freq);
+    			} else if(!strcmp(word[iw],"N_RESPA")) {
+						  iw++; sscanf(word[iw], "%lf", &uno); dafed_control.n_respa=(int)uno; read_nrespa=1;
+						  fprintf(mtd_data->fplog, "|- RESPA STEPS FOR d-AFED %d\n",dafed_control.n_respa);
+    			}
+    	}
+    	strcpy(dafed_control.out_file,"DAFED_STATE");  // Default output file name
+		if(!read_nrespa) dafed_control.n_respa=1;
+
+  // #### -------------------------------------------------------------------------------
+
+    } else if(!strcmp(word[0],"UMBRELLA")){
+      logical.do_walls = 1;   // ### For modified output format
+      int read_kappa=0;
+      int read_slope=0;
+      int read_anneal=0;
+      int read_at=0;
+      iw = seek_word(word,"CV");
+      if(iw>=0){ sscanf(word[iw+1], "%i", &icv); cvsteer.impose_start[icv-1]=1; cvsteer.delta[icv-1]=0.;}
+      else {plumed_error("WITH UMBRELLA YOU ALWAYS HAVE TO SPECIFY THE \"CV\" KEYWORD\n");} 
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"CV")){
+          iw++; // already read
+        } else if(!strcmp(word[iw],"AT")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvsteer.max[icv-1]=cvsteer.start[icv-1]=(real) uno; read_at=1;
+        } else if(!strcmp(word[iw],"KAPPA")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvsteer.spring[icv-1]=(real) uno*mtd_data->eunit; read_kappa=1;
+        } else if(!strcmp(word[iw],"SLOPE")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvsteer.slope[icv-1]=(real) uno*mtd_data->eunit; read_slope=1;
+#if defined (PLUMED_GROMACS4)|| defined (PLUMED_GROMACS45)
+        } else if(!strcmp(word[iw],"ANNEALING")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvsteer.annealing[icv-1]=(real) uno*mtd_data->eunit; read_anneal=1;
+#endif
+        } else if(!strcmp(word[iw],"RESTART")){
+          logical.append = 1;
+        } else {
+          plumed_error("Unknown flag for keyword UMBRELLA");
+        }
+      }
+      if(!(read_kappa||read_slope))plumed_error("WITH UMBRELLA YOU ALWAYS HAVE TO SPECIFY THE \"KAPPA\" OR THE \"SLOPE\" KEYWORD\n");
+      if(!read_at)plumed_error("WITH UMBRELLA YOU ALWAYS HAVE TO SPECIFY THE \"AT\" KEYWORD\n");
+
+      logical.steer[icv-1]  = 1; 
+      fprintf(mtd_data->fplog, "|-UMBRELLA SAMPLING OF COLVAR %i AT %f: SPRING=%lf SLOPE=%lf\n\n",
+              icv,cvsteer.max[icv-1],cvsteer.spring[icv-1]/mtd_data->eunit,cvsteer.slope[icv-1]/mtd_data->eunit);
+      if(logical.append) fprintf(mtd_data->fplog,"|-RESTARTING UMBRELLA SAMPLING!\n");
+      if(read_anneal) fprintf(mtd_data->fplog,"|-UMBRELLA %i DEPEND ON TEMPERATURE AS %lf/T\n",icv-1, cvsteer.annealing[icv-1]/mtd_data->eunit);
+
+    } else if(!strcmp(word[0],"CONSTRAINT")){
+      int read_at=0;
+      iw = seek_word(word,"CV");
+      if(iw>=0){ sscanf(word[iw+1], "%i", &icv); cvcnstr.delta[icv-1]=1.e-5 ; cvcnstr.maxiter[icv-1]=1000 ;  cvcnstr.spring[icv-1]=1.; cvcnstr.verbose[icv-1]=0;}
+      else {plumed_error("WITH CONSTRAINT YOU ALWAYS HAVE TO SPECIFY THE \"CV\" KEYWORD\n");} 
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"CV")){
+          iw++; // already read
+        } else if(!strcmp(word[iw],"AT")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvcnstr.pos[icv-1]=(real) uno; read_at=1;
+        } else if(!strcmp(word[iw],"KAPPA")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvcnstr.spring[icv-1]=(real) uno*mtd_data->eunit; 
+        } else if(!strcmp(word[iw],"DELTA")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvcnstr.delta[icv-1]=(real) uno; 
+        } else if(!strcmp(word[iw],"MAXITER")) {
+          iw++; sscanf(word[iw], "%lf", &uno); cvcnstr.maxiter[icv-1]=(real) uno; 
+        } else if(!strcmp(word[iw],"VERBOSE")) {
+          cvcnstr.verbose[icv-1]=1; 
+        } else {
+          plumed_error("Unknown flag for keyword CONSTRAINT");
+        }
+      }
+      if(!read_at)plumed_error("WITH CONSTRAINT YOU ALWAYS HAVE TO SPECIFY THE \"AT\" KEYWORD\n");
+
+      logical.cnstr[icv-1]  = 1; 
+      fprintf(mtd_data->fplog, "|-CONSTRAINED SAMPLING OF COLVAR %i AT %f: SPRING=%lf\n\n", icv,cvcnstr.pos[icv-1],cvcnstr.spring[icv-1]/mtd_data->eunit);
+      logical.do_constraint=1; 
+    } else if(!strcmp(word[0],"STEERPLAN")){
+         if(logical.do_steerplan==1)
+              plumed_error("ONLY ONE STEERPLAN IS ALLOWED...BUT YOU MAY HAVE MANY CVS IN THERE!!!");
+         logical.do_steerplan=1;    
+         read_steerplan(word, count, &input,  &iline ,mtd_data->fplog);
+    } else if(!strcmp(word[0],"ABMD")){
+      int read_max=0;
+      int read_from=0;
+      int read_kappa=0;
+      iw = seek_word(word,"CV");
+      if(iw>=0){ sscanf(word[iw+1], "%i", &icv); }
+      else {plumed_error("WITH ABMD YOU ALWAYS HAVE TO SPECIFY THE \"CV\" KEYWORD\n");} 
+      for(iw=1;iw<nw;iw++){ 
+        if(!strcmp(word[iw],"CV")){
+          iw++; // already read
+        } else if(!strcmp(word[iw],"RESTART")) {
+          iw++; sscanf(word[iw], "%lf", &uno); abmd.min[icv-1]=(real)uno; read_from=1; logical.restart_abmd=1;
+        } else if(!strcmp(word[iw],"TO")) {
+          iw++; sscanf(word[iw], "%lf", &uno); abmd.exp[icv-1]=(real)uno; read_max=1;
+        } else if(!strcmp(word[iw],"KAPPA")) {
+          iw++; sscanf(word[iw], "%lf", &uno); abmd.spring[icv-1]=(real) uno*mtd_data->eunit; read_kappa=1;
+        } else {
+          plumed_error("Unknown flag for keyword ABMD");
+        }
+      }
+      if(!read_max)  plumed_error("WITH ABMD YOU MUST SPECIFY THE \"TO\" KEYWORD\n");
+      if(!read_kappa)plumed_error("WITH ABMD YOU MUST SPECIFY THE \"KAPPA\" KEYWORD\n");
+
+      logical.abmd[icv-1]  = 1; 
+      if(read_from==0){
+        abmd.min[icv-1] = 9999999999.0;
+        fprintf(mtd_data->fplog, "|-ABMD ON COLVAR %i TO %f: , SPRING=%lf\n\n", icv, abmd.exp[icv-1], abmd.spring[icv-1]/mtd_data->eunit);
+      } else { 
+        fprintf(mtd_data->fplog, "|-ABMD ON COLVAR %i RESTARTING FROM %f TO %f: , SPRING=%lf\n\n", icv, abmd.min[icv-1], abmd.exp[icv-1], abmd.spring[icv-1]/mtd_data->eunit);
+      } 
+      if(logical.restart_abmd) fprintf(mtd_data->fplog,"|-RESTARTING ABMD!\n");
+
+    } else if(!strcmp(word[0],"NOHILLS")){
+      iw = seek_word(word,"CV");
+      if(iw>=0) sscanf(word[iw+1], "%i", &icv);
+      colvar.on[icv-1] = 0;
+      fprintf(mtd_data->fplog, "|-NO HILLS ON COLVAR %i\n", icv);
+    } else if(!strcmp(word[0],"INVERT")){
+      logical.do_inversion = 1;
+      iw = seek_word(word,"CV");
+      if(iw>=0){ sscanf(word[iw+1], "%i", &icv);
+      } else{plumed_error("WITH INVERT YOU ALWAYS HAVE TO SPECIFY THE \"CV\" KEYWORD\n");}
+      fprintf(mtd_data->fplog, "APPLY INVERSION TO FREE ENERGY ON CV %i:\n", icv);
+      iw=seek_word(word,"REFLECTION");
+      if (iw>=0) { sscanf(word[iw+1],"%lf",&uno);
+        colvar.inv_ref[icv-1]= (real) uno;
+      }
+      iw=seek_word(word,"INVERSION");
+      if (iw>=0) { sscanf(word[iw+1],"%lf",&uno);
+        colvar.inv_inv[icv-1]= (real) uno;
+      }
+      if (colvar.inv_inv[icv-1]<colvar.inv_ref[icv-1]) plumed_error("REFLECTION INTERVAL LARGER THAN THE INVERSION ONE");       
+      iw=seek_word(word,"MAXHEIGHT");
+      if (iw>=0) { sscanf(word[iw+1],"%lf",&uno);
+        colvar.inv_maxww[icv-1]= (real) uno;
+      }
+      iw=seek_word(word,"LIMIT1");
+      if (iw>=0) { sscanf(word[iw+1],"%lf",&uno);
+        colvar.inv_limit[icv-1][0]= (real) uno;
+        logical.invert[icv-1][0] = 1;
+        fprintf(mtd_data->fplog, " LIMIT1 = %f\n",colvar.inv_limit[icv-1][0]); }
+      iw=seek_word(word,"LIMIT2");
+      if (iw>=0) { sscanf(word[iw+1],"%lf",&uno);
+        colvar.inv_limit[icv-1][1]= (real) uno;
+        logical.invert[icv-1][1] = 1;
+        fprintf(mtd_data->fplog, " LIMIT2 = %f\n",colvar.inv_limit[icv-1][1]); }
+      if (logical.invert[icv-1][0]==0) {
+        if (logical.invert[icv-1][1]==0) plumed_error("NO LIMITS FOR INVERSION FOUND: SPECIFY AT LIST ONE!");
+      }
+      fprintf(mtd_data->fplog, " REFLECTION INTERVAL (gaussian width units) = %f\n",colvar.inv_ref[icv-1]);
+      fprintf(mtd_data->fplog, " INVERSION INTERVAL (gaussian width units) = %f\n",colvar.inv_inv[icv-1]);
+      fprintf(mtd_data->fplog, " MAX GAUSSIAN HEIGHT FACTOR = %f\n\n",colvar.inv_maxww[icv-1]); 
+    } else if(!strcmp(word[0],"UREFLECT")){
+      iw = seek_word(word,"CV");
+      if(iw>=0) sscanf(word[iw+1], "%i", &icv);
+      iw = seek_word(word,"LIMIT");
+      if(iw>=0) sscanf(word[iw+1], "%lf", &uno);
+      cvw.upper[icv-1] = (real) uno;
+      logical.ureflect[icv-1] = 1;
+      fprintf(mtd_data->fplog, "|-UPPER REFLECTING WALL ON CV %i, AT %f\n\n", icv, cvw.upper[icv-1]);
+    } else if(!strcmp(word[0],"LREFLECT")){
+      iw = seek_word(word,"CV");
+      if(iw>=0) sscanf(word[iw+1], "%i", &icv);
+      iw = seek_word(word,"LIMIT");
+      if(iw>=0) sscanf(word[iw+1], "%lf", &uno);
+      cvw.lower[icv-1] = (real) uno;
+      logical.lreflect[icv-1] = 1;
+      fprintf(mtd_data->fplog, "|-LOWER REFLECTING WALL ON CV %i, AT %f\n\n", icv, cvw.lower[icv-1]);
+    } else if(!strcmp(word[0],"DEBUG_GRID")){
+      logical.debug_grid=1;
+    } else if(!strcmp(word[0],"NOSPLINE")){
+      logical.donot_spline=1;
+      fprintf(mtd_data->fplog, "|- GRID SPLINE TURNED OFF\n");
+    } else if(!strcmp(word[0],"GRID")){
+      int read_cv=0;
+      int read_min=0;
+      int read_max=0;
+      int read_nbin=0;
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"CV")){
+          iw++; sscanf(word[iw], "%i", &icv);  read_cv=1;
+        } else if(!strcmp(word[iw],"MIN")){
+          iw++; sscanf(word[iw], "%s", tmpmeta); uno = plumed_atof(tmpmeta); grid.min[grid.ncv] = (real) uno; read_min=1;
+        } else if(!strcmp(word[iw],"MAX")){
+          iw++; sscanf(word[iw], "%s", tmpmeta); due = plumed_atof(tmpmeta); grid.max[grid.ncv] = (real) due; read_max=1;
+        } else if(!strcmp(word[iw],"NBIN")){
+          iw++; sscanf(word[iw], "%i", &(grid.bin[grid.ncv])); read_nbin=1;
+        } else if(!strcmp(word[iw],"PBC")){
+          grid.period[grid.ncv] = 1;
+        } else {
+          plumed_error("Unknown flag for keyword GRID");
+        }
+      };
+      if(!read_cv) plumed_error("WITH GRID YOU ALWAYS HAVE TO SPECIFY THE \"CV\" KEYWORD\n");
+      if(!read_min) plumed_error("WITH GRID YOU ALWAYS HAVE TO SPECIFY THE \"MIN\" KEYWORD\n");
+      if(!read_max) plumed_error("WITH GRID YOU ALWAYS HAVE TO SPECIFY THE \"MAX\" KEYWORD\n");
+      if(!read_nbin) plumed_error("WITH GRID YOU ALWAYS HAVE TO SPECIFY THE \"NBIN\" KEYWORD\n");
+      fprintf(mtd_data->fplog, "|-GRID ACTIVE ON CV %i NBIN %d MIN %f MAX %f \n", icv, grid.bin[grid.ncv],grid.min[grid.ncv],grid.max[grid.ncv]);
+      if(grid.period[grid.ncv]) fprintf(mtd_data->fplog, "|-- PERIODIC GRID IS ON\n");
+      grid.index[grid.ncv] = icv-1;
+      for(i=0;i<grid.ncv;i++) if(grid.index[i]==grid.index[grid.ncv]) plumed_error("GRID is already ACTIVE for this CV");
+      grid.ncv += 1;
+      logical.do_grid = 1;
+      fprintf(mtd_data->fplog, "\n");
+    } else if(!strcmp(word[0],"WRITE_GRID")){
+      logical.write_grid=1;
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"W_STRIDE")){
+          iw++; sscanf(word[iw], "%i", &(grid.w_stride));
+        } else if(!strcmp(word[iw],"FILENAME")){
+          iw++; sscanf(word[iw], "%s", grid.w_file);
+        }
+      };
+      fprintf(mtd_data->fplog, "|-WRITING GRID ON FILE \n");
+      fprintf(mtd_data->fplog, "|--STRIDE %d FILENAME %s\n\n", grid.w_stride, grid.w_file);
+    } else if(!strcmp(word[0],"READ_GRID")){
+      logical.read_grid=1;
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"FILENAME")){
+          iw++; sscanf(word[iw], "%s", grid.r_file);
+        }
+      };  
+      fprintf(mtd_data->fplog, "|-READING GRID FROM FILE %s \n\n",grid.r_file);
+    } else if(!strcmp(word[0],"PROJ_GRAD")){ 
+       iw = seek_word(word,"CV"); // look for a group
+       if (iw>=0){
+          colvar.pg.nlist=plumed_get_group(word[iw+1],&colvar.pg.list,0,&input,mtd_data->fplog); 
+       } else {
+           plumed_error("WITH PROJ_GRAD YOU ALWAYS HAVE  TO SPECIFY THE \"CV\" KEYWORD\n AND ASSOCIATE A GROUP TO THIS \n");
+       }
+  //     iw = seek_word(word,"DUMPFILE");
+  //     if (iw>=0){
+  //        sscanf(word[iw+1], "%s", pg.dumpfile);
+  //     } else {
+  //        strcpy(pg.dumpfile,"proj_grad.dat")
+  //     }
+  //     iw = seek_word(word,"W_STRIDE"); 
+  //     if (iw>=0){
+  //        sscanf(word[iw+1], "%lf", &uno);pg.w_stride=(real)uno;
+  //     } else {
+  //       pg.w_stride=1.0;
+  //     }
+    } else if(!strcmp(word[0],"EXTERNAL")){
+      if(logical.do_external) plumed_error("ONLY ONE EXTERNAL POTENTIAL ALLOWED");
+      logical.do_external=1;
+      for(iw=1;iw<nw;iw++) if(!strcmp(word[iw],"NCV")){iw++; sscanf(word[iw], "%d", &(extpot.ncv));}
+      for(iw=1;iw<nw;iw++){
+        if(!strcmp(word[iw],"CV")){
+          iw++; for(i=0;i<extpot.ncv;i++) {sscanf(word[iw], "%d", &(extpot.index[i])); extpot.index[i] -= 1; iw++;}; 
+          iw--;
+        } else if(!strcmp(word[iw],"FILENAME")){
+          iw++; sscanf(word[iw], "%s", extpot.r_file);
+        }
+      };
+      fprintf(mtd_data->fplog, "|-EXTERNAL POTENTIAL ON CV ");
+      for(i=0;i<extpot.ncv;i++) fprintf(mtd_data->fplog, " %d ",extpot.index[i]+1);
+      fprintf(mtd_data->fplog, "FROM FILE %s \n\n",extpot.r_file);
+    } else if(!strcmp(word[0],"STOPWHEN")) {
+#if ! defined(PLUMED_GROMACS45)
+      fprintf(mtd_data->fplog, "WARNING: You are not using GROMACS 4.5\n");
+      fprintf(mtd_data->fplog, "WARNING: STOPWHEN will not dump the final configuration properly\n");
+#endif
+      iw = seek_word(word,"CV");
+      if(iw>=0){ sscanf(word[iw+1], "%i", &icv);icv--;
+         fprintf(mtd_data->fplog, "|-STOPWHEN ENABLED ON CV %d: \n",icv+1);
+      }
+      else{plumed_error("WITH STOPWHEN YOU ALWAYS HAVE TO SPECIFY THE \"CV\" KEYWORD\n");}  
+      iw = seek_word(word,"MORETHAN");
+      if(iw>=0){ sscanf(word[iw+1], "%lf",&uno);stopwhen.max[icv]=(real)uno; stopwhen.actmax[icv]=1; 
+         fprintf(mtd_data->fplog, "|-STOPWHEN CV %d IS MORE THAN %lf\n",icv+1,stopwhen.max[icv]);
+      }
+      iw = seek_word(word,"LESSTHAN");
+      if(iw>=0){ sscanf(word[iw+1], "%lf",&uno);stopwhen.min[icv]=(real)uno; stopwhen.actmin[icv]=1; 
+         fprintf(mtd_data->fplog, "|-STOPWHEN CV %d IS LESS THAN %lf\n",icv+1,stopwhen.min[icv]);
+      }
+      if (stopwhen.actmin[icv]==0 && stopwhen.actmax[icv] ==0){
+           fprintf(mtd_data->fplog, "|-STOPWHEN SYNTAX:\n" );
+           fprintf(mtd_data->fplog, "|-    STOPWHEN CV 1  MORETHAN 3.0 LESSTHAN 1.0 \n" );
+           fprintf(mtd_data->fplog, "|-    STOPWHEN CV 1  LESSTHAN 1.0 \n" );
+           fprintf(mtd_data->fplog, "|-     \n" );
+           char buf[1024];
+           sprintf(buf, "STOPWHEN DIED WITH ERRORS: CHECK THE INPUT!!!!!\n");
+           plumed_error(buf);
+      };
+      fprintf(mtd_data->fplog, "\n");
+    } else if(!strcmp(word[0],"COUPLINGMATRIX")) { 
+		read_couplingmatrix  ( word, &input, mtd_data->fplog );
+	} else {
+      char buf[1024];
+      sprintf(buf, "Line %i Unkwown Keyword %s \n", iline+1, word[0]);
+      plumed_error(buf);
+    }
+  }
+// clean input parser
+  plumed_clear_input(&input);
+
+// set the number of collective variables
+  colvar.nconst = count;
+
+// Call reconnaissance metadynamics setup
+#ifdef RECONMETAD 
+#ifndef DRIVER
+   if( reconOn==1 && colvar.nbespoke>0 ){
+      plumed_error("can't do reconnaissance metadynamics with bespoke collective coordinates");
+   } else if( reconOn==1 ){ 
+      // setup a run in which all cvs are used in reconnaissance if not otherwise instructed in input
+      if( reconinpt.nconst==0 ){ 
+        reconinpt.nconst=colvar.nconst; srenew(reconinpt.cvlist, reconinpt.nconst); 
+        for(i=0;i<reconinpt.nconst;++i){ reconinpt.cvlist[i]=i; } 
+      }   
+
+      // transfer the periods 
+      double periods[reconinpt.nconst]; 
+      for(i=0;i<reconinpt.nconst;i++){
+         periods[i]=0.;
+         if( colvar.type_s[reconinpt.cvlist[i]]==5 ){
+            if( colvar.doTrig[reconinpt.cvlist[i]]==0 ){ periods[i]=2.*M_PI; }
+            else{ periods[reconinpt.cvlist[i]]=0.; }
+         }   
+      }    
+ 
+      // and create the reconnaissance metadynamics object
+      create_recon(&myreconObj);
+      double tstep; tstep=mtd_data->dt;
+      setup_recon( periods, tstep, reconinpt, myreconObj, mtd_data->fplog);
+
+      fprintf(mtd_data->fplog, "|- RECONNAISSANCE METADYNAMICS ON COLVARS :");
+      for(i=0;i<reconinpt.nconst;i++){
+        fprintf(mtd_data->fplog," %d ",reconinpt.cvlist[i]+1); if((i+1)%20==0)fprintf(mtd_data->fplog,"\n                    ");
+      }
+      fprintf(mtd_data->fplog,"\n\n");
+   
+   // This is the setup for bespoke collective coordinates ( this might have to be changed in the future so that it works more like the above )
+   } else if( colvar.nbespoke>0 ){
+#else
+   if( colvar.nbespoke>0 ){
+#endif
+      int ncolvar; ncolvar=colvar.nconst-colvar.nbespoke;
+      for(i=ncolvar;i<colvar.nconst;i++){
+        if( colvar.type_s[i]!=46){ plumed_error("BESPOKE COLLECTIVE COORDINATES MUST COME AFTER ALL OTHER COLLECTIVE COORDINATES"); }
+      }
+      double periods[ncolvar];
+      for(i=0;i<ncolvar;i++){
+         periods[i]=0.;
+         if( colvar.type_s[i]==5 ){
+            if( colvar.doTrig[i]==0 ){ periods[i]=2.*M_PI; }
+            else{ periods[i]=0.; }
+         }   
+         if( colvar.type_s[i]==46){ plumed_error("BESPOKE COLLECTIVE COORDINATES MUST COME AFTER ALL OTHER COLLECTIVE COORDINATES"); }
+      }    
+
+#ifdef CVS
+      create_bespoke( ncolvar, colvar.nbespoke, &mybespokeObj);
+      setup_bespoke( bespoke_input, ncolvar, colvar.nbespoke, periods, mybespokeObj, mtd_data->fplog );
+#endif
+   }
+#endif
+
+// unset the SIGMA<0 CVs for hills
+  for(i=0;i<colvar.nconst;i++){
+     if(colvar.delta_r[i]<0.){colvar.on[i]=0;}
+     if(logical.do_hills){
+       if(colvar.on[i]){fprintf(mtd_data->fplog, "|-HILLS ACTIVE ON COLVAR %i\n", i+1);} 
+       else            {fprintf(mtd_data->fplog, "|-NO HILLS     ON COLVAR %i\n", i+1);}
+     }else if(logical.tamd){
+       if(colvar.on[i]){
+         tamd.spring[i]=mtd_data->boltz*tamd.simtemp/(colvar.delta_r[i]*colvar.delta_r[i]);
+         fprintf(mtd_data->fplog, "|-CV %i : TAMD/DAFED WITH SPRING CONSTANT = %lf\n",i+1,tamd.spring[i]);
+       } 
+       else{
+         fprintf(mtd_data->fplog, "|-CV %i : NO TAMD/DAFED\n", i+1);
+       }
+     }
+  }
+
+// check the correctenes of the input parsed
+  if(colvar.nconst > nconst_max) {
+    plumed_error("Too many colvars. Change NCONST_MAX in metadyn.h !!!!!!!!!!!\n");	
+  }
+
+// checking for conflicts in directive keywords
+#ifdef RECONMETAD  
+  if(!logical.do_hills && !logical.commit && !logical.do_dafed && reconOn!=1){
+    //if( reconOn==1 && reconinpt.monitor==1 ){
+    //   fprintf(mtd_data->fplog,"|-ANALYSIS: YOU WILL MONITOR BASIN OCCUPANCIES ONLY\n\n");  
+    //} 
+    // if( reconOn!=1 ){
+    fprintf(mtd_data->fplog, "|-ANALYSIS: YOU WILL ONLY MONITOR YOUR CVs DYNAMICS\n\n");
+    // }
+  }
+#else
+  if(!logical.do_hills && !logical.commit && !logical.do_dafed ){   // ### DAFED
+    fprintf(mtd_data->fplog, "|-ANALYSIS: YOU WILL ONLY MONITOR YOUR CVs DYNAMICS\n\n");
+  }
+#endif
+
+// derivatives debug with ENERGY CV not allowed
+  if(logical.energy && (logical.debug || logical.debug_derivatives)) 
+    plumed_error("DERIVATIVES DEBUG with ENERGY CV not allowed");
+
+  if(logical.welltemp && !logical.do_hills)  plumed_error("WELLTEMPERED must be used with HILLS keyword");
+
+  if(logical.commit && logical.do_hills) plumed_error("KEYWORD 'COMMITMENT' AND 'HILLS' ARE NOT COMPATIBLE");
+
+// in case of parallel rescale hills heigth with temperature
+  if(logical.do_hills&&logical.remd&&(!logical.rpxm)&&(!logical.norescale)) hills.wwr *= mtd_data->rteio/mtd_data->rte0;
+
+// in case of PTMETAD and well-tempered set the right simtemp
+  if(logical.do_hills&&logical.remd&&(!logical.rpxm)&&logical.welltemp) colvar.simtemp = mtd_data->rteio;
+
+// check for untested features
+  if(!logical.enable_untested_features) {
+   if(logical.debug_derivatives) plumed_error("DEBUG_DERIVATIVES NOT ENABLED");
+   if(colvar.ptmetad_neighbours) plumed_error("NEIGHBOUR HILLS NOT ENABLED");
+   if(logical.debug_grid)        plumed_error("DEBUG_GRID NOT ENABLED");
+   if(hills.max_height>0.0)      plumed_error("MAX_HEIGHT NOT ENABLED");
+   if(logical.hrex)              plumed_error("HAMILTONIAN REPLICA-EXCHANGE NOT ENABLED");
+   if(logical.tamd)              plumed_error("TAMD/DAFED NOT ENABLED");
+  }
+
+// GRID and WRITE/READ
+  if(logical.read_grid  && !logical.do_grid) plumed_error("GRID must be active to use READ_GRID\n");
+  if(logical.write_grid && !logical.do_grid) plumed_error("GRID must be active to use WRITE_GRID\n");
+  if(logical.do_walkers &&  logical.read_grid) plumed_error("READ_GRID cannot be used with MULTIPLE_WALKERS\n");
+
+// checking if GRID and HILLS active variables are consistent
+  if(logical.do_grid) {
+   icv = 0;
+   for(i=0;i<colvar.nconst;i++) if(colvar.on[i]) icv++;  
+   if(icv!=grid.ncv) plumed_error("Inconsistency between GRID and HILLS variables. Please, check !!!!!!!!!!!\n"); 
+   for(i=0;i<grid.ncv;i++) if(!colvar.on[grid.index[i]] || grid.index[i]>=colvar.nconst) 
+     plumed_error("Inconsistency between GRID and HILLS variables. Please, check !!!!!!!!!!!\n");
+// in case initialize grid stuff
+   grid_initialize(&grid);
+  }
+ 
+// check EXTERNAL potential CVs
+ if(logical.do_external){
+  if(extpot.ncv>colvar.nconst) plumed_error("Too many CVs for EXTERNAL potential.\n");
+  for(i=0;i<extpot.ncv;i++) if(extpot.index[i]>=colvar.nconst) plumed_error("Check the CVs for EXTERNAL potential. Do they exist?\n");
+ }
+
+// multiple walkers allocation
+  hills.line_counter = (fpos_t *)calloc(hills.nwalkers,sizeof(fpos_t));
+
+// check for needed projection
+  if(colvar.pg.nlist!=0){
+        // make the projection tables
+       fprintf(mtd_data->fplog, "|- FOUND PROJ_GRAD KEYWORD: NCV involved %d\n",colvar.pg.nlist);
+       int j; 
+       fprintf(mtd_data->fplog, "|- WHICH ARE: ");
+       for(j=0;j<colvar.pg.nlist;j++){fprintf(mtd_data->fplog, " %d",colvar.pg.list[j]);}
+       fprintf(mtd_data->fplog, "\n");
+       setup_projections( &(colvar.pg));          
+  }
+// check whether a variable has to be calculated every step or not
+  fprintf(mtd_data->fplog, "|- DIFFERENT COLLECTIVE VARIABLE WILL BE CALCULATED AT DIFFERENT TIMES\n");
+  // set always parameter  
+  // note colvar.on is for activating metadynamics
+  // logical.always is for only calculating cvs  
+  for(i=0;i<colvar.nconst;i++) {
+    if(colvar.on[i]||logical.steer[i]||logical.abmd[i]||logical.upper[i]||logical.lower[i]||logical.cnstr[i]|| steerplan.isactive[i] ||logical.debug_derivatives || stopwhen.actmax[i] || stopwhen.actmin[i]) logical.always[i]=1;
+  }
+
+// check if INTERVAL is used more than once
+  tmpc = 0;
+  for(i=0;i<colvar.nconst;i++) if(logical.interval[i]) tmpc++;
+  if(tmpc>1) plumed_error("INTERVAL CAN BE USED ONLY ON A SINGLE DIMENSION, ON MANY DIMENSIONS ITS BEHAVOUR IS NOT TESTED!\n");
+
+// add histogram variables
+  for(i=0;i<colvar.nconst;i++) { 
+     if(colvar.type_s[i]==49){
+        for(j=0;j<colvar.histo_ncv[i];j++){ logical.always[colvar.histo_cvlist[i][j]]=1; }
+     } 
+  }   
+// add committment variables
+  if(logical.commit)      for(i=0;i<commit.ncv;i++) logical.always[commit.index[i]]=1;
+// add external potential
+  if(logical.do_external) for(i=0;i<extpot.ncv;i++) logical.always[extpot.index[i]]=1;  
+#ifdef RECONMETAD
+  // and reconnaissance metadynamics
+  if( reconOn==1 ){                   // && reconinpt.monitor!=1 ){
+    for(i=0;i<reconinpt.nconst;++i){ logical.always[reconinpt.cvlist[i]]=1; }
+  }
+#endif
+#ifdef CVS
+  // and cvs from which bespoke cvs are calculated
+  for(i=0;i<colvar.bespoke_ncv;i++){ logical.always[colvar.bespoke_cvlist[i]]=1; }
+#endif
+
+// #### d-AFED initialization ----------------------------------------
+  for(i=0;i<colvar.nconst;i++){
+		if (logical.dafed[i]) {
+			initialize_dafed(&dafed[i], mtd_data->dt);
+			if (dafed_control.restart) {
+				dafed[i].do_initialize_s = 0;
+				dafed[i].do_skip_integration = 1;
+			}
+			logical.always[i]=1;
+		}
+  }
+  // This overwrites the default values just initialized above.
+  if (dafed_control.restart){
+ 	  read_dafed_state();
+  }
+// ####----------------------------------------------------------------
+
+  for(i=0;i<colvar.nconst;i++) {
+    if(logical.always[i]) fprintf(mtd_data->fplog, "|--CV %2i WILL BE EVALUATED EACH STEP\n", i+1);
+    else fprintf(mtd_data->fplog, "|--CV %2i WILL BE EVALUATED ONLY WHEN NEEDED (OUTPUT OR EXCHANGE TRIAL)\n", i+1);
+  }
+
+
+// printout PLEASE_CITE
+  cite_please("bono+09cpc",mtd_data->fplog);
+  if(logical.do_hills) cite_please("laio-parr02pnas",mtd_data->fplog);
+  if(logical.remd && !logical.rpxm) cite_please("buss+06jacs",mtd_data->fplog);
+  if(logical.rpxm)       cite_please("pian-laio07jpcb",mtd_data->fplog);
+  if(logical.welltemp)   cite_please("bard+08prl",mtd_data->fplog);
+  if(logical.path)       cite_please("bran+07jcp",mtd_data->fplog);
+  if(logical.puckering)  cite_please("sega+09jcp",mtd_data->fplog);
+  if(logical.do_walkers) cite_please("rait+06jpcb",mtd_data->fplog);
+  if(logical.do_alphabetarmsd) cite_please("pietrucci+09jctc",mtd_data->fplog);
+  if(logical.do_sprint) cite_please("pietrucci+11prl",mtd_data->fplog);
+  if(logical.do_inversion) cite_please("marinell-crespo10",mtd_data->fplog);
+  if (logical.do_dafed) { // d-AFED ####
+	  cite_please("abrams08jpcb",mtd_data->fplog);
+	  cite_please("maragliano06cpl",mtd_data->fplog);
+  }
+  if(logical.do_pca) cite_please("sutto-2010jctc",mtd_data->fplog);
+#ifdef RECONMETAD
+  if(reconOn==1) cite_please("tribello-10pnas",mtd_data->fplog);
+#endif
+  fprintf(mtd_data->fplog,"\n"); 
+
+  disclaimer(mtd_data->fplog);
+// flushing output
+  fflush(mtd_data->fplog);
+
+}
+
+//-----------------------------------------------------------------------------------------------------------------
+
+void PREFIX read_defaults()
+{
+  int icv;
+ 
+  colvar.nt_print 		= 10;
+  colvar.nconst 		= 0;
+  logical.restart_hills 	= 0;
+  logical.append                = 0;
+  logical.restart_abmd	 	= 0;
+  logical.remd 			= 0;
+  logical.hrex 			= 0;
+  colvar.hrex_energy		= 0.0;
+  logical.rpxm			= 0;
+  logical.do_hills 		= 0;
+  logical.commit 		= 0;
+  logical.print 		= 0;
+  logical.widthadapt            = 0;
+  logical.welltemp              = 0;
+  logical.tamd                  = 0;
+  logical.debug                 = 0;
+  logical.parallel_hills        = 0;
+  logical.norescale             = 0;
+#if defined(PLUMED_GROMACS) || defined(DL_POLY) || defined (AMBER)
+  logical.parallel_hills        = 1;
+#endif
+  logical.debug_derivatives     = 0;
+  logical.enable_untested_features = 0;
+  logical.do_grid               = 0;
+  logical.read_grid             = 0;
+  logical.write_grid            = 0;
+  logical.donot_spline          = 0;
+  logical.debug_grid            = 0;
+  logical.do_walkers            = 0;
+  logical.puckering             = 0;
+  logical.path                  = 0;
+  logical.energy                = 0;
+  logical.read_old_bf           = 0;
+  logical.do_external           = 0;
+  logical.do_alphabetarmsd      = 0;
+  logical.do_sprint             = 0;
+  logical.do_steerplan          = 0;
+  logical.do_constraint         = 0;
+  logical.do_dafed		= 0;   // #### d-AFED
+  dafed_control.restart	= 0;   // #### d-AFED checkpointing
+  dafed_control.write_freq	= -1;   // #### d-AFED checkpointing
+  dafed_control.do_cpt	= 0;   // #### d-AFED checkpointing
+  dafed_control.n_respa	= 1;   // #### d-AFED RESPA (default for all non-dafed applications)
+  logical.do_inversion          = 0;
+  logical.do_pca                = 0;
+  sprintf(colvar.hills_label,"\0");
+  hills.wwr 			= 0.;
+  hills.rate			= 0.;
+  hills.max_height              = 0.;
+  hills.max_stride              = 0;
+  hills.n_hills			= 0;
+  hills.nt_hills                = 999999999; 
+  hills.nr_hills                = 1; 
+  hills.read                    = 0;
+  hills.idwalker                = 0;
+  hills.nwalkers                = 1;
+  nsz                           = 0;
+  hills.first_read              = 1;
+  colvar.ptmetad_neighbours     = 0;
+  colvar.ptmetad_sigma          = 0.0;
+  colvar.align_atoms            = 0;
+  colvar.align_list             = NULL;
+  mtd_data.dump_atoms           = 0;
+  mtd_data.dump_list            = 0;
+  mtd_data.dump_stride          = 100;
+  mtd_data.temp_t		= 0.;
+  
+  grid.ncv                      = 0;
+  grid.nhills                   = 0;
+  colvar.pg.list		=NULL;
+  colvar.pg.nlist		=0;
+
+  for(icv=0;icv<nconst_max;icv++){
+    logical.abmd[icv]	 	= 0;
+    logical.steer[icv]          = 0; 
+    logical.dafed[icv]		= 0;   // #### d-AFED
+    logical.cnstr[icv]          = 0; 
+    logical.upper[icv] 		= 0;
+    logical.lower[icv] 		= 0;
+    logical.interval[icv]       = 0;  
+    logical.ureflect[icv]       = 0;
+    logical.lreflect[icv]       = 0;
+    logical.invert[icv][0]      = 0;
+    logical.invert[icv][1]      = 0;
+    logical.always[icv]		= 0;
+    logical.nlist[icv]          = 0;
+    colvar.inv_limit[icv][0]    = -1.e9;
+    colvar.inv_limit[icv][1]    = +1.e9;
+    colvar.inv_ref[icv]         = 1.6;
+    colvar.inv_inv[icv]         = 6;
+    colvar.inv_maxww[icv]       = 4;
+    cvw.sigma[icv] 		= 0.;
+    cvw.upper[icv] 		= 0.;
+    cvw.lower[icv] 		= 0.;
+    cvw.lsigma[icv] 		= 0.;
+    cvw.fwall[icv] 		= 0;
+    cvw.uexp[icv] 		= 4;
+    cvw.lexp[icv] 		= 4;
+    cvw.ueps[icv] 		= 1.;
+    cvw.leps[icv] 		= 1.;
+    cvw.uoff[icv]               = 0.;
+    cvw.loff[icv]               = 0.;
+    cvint.lower_limit[icv]        = 0.;   //fahimeh
+    cvint.upper_limit[icv]        = 0.;   //fahimeh
+    colvar.on[icv] 		= 1;
+    colvar.Mss0[icv]            = 0.;
+    colvar.M2ss0[icv]           = 0.;
+    colvar.type_s[icv]          = 0;
+    colvar.logic[icv]           = 0;
+    colvar.natoms[icv]          = 0;
+    colvar.cell_pbc[icv]        = 0;
+    colvar.delta_r[icv]         = -1.; // default synonim of NOHILLS
+    grid.min[icv]               = 0.;
+    grid.max[icv]               = 0.; 
+    grid.lbox[icv]              = 0.;
+    grid.dx[icv]                = 0.;
+    grid.bin[icv]               = 1;
+    grid.minibin[icv]           = 1;
+    grid.period[icv]            = 0;
+    grid.index[icv]             = 0;
+    grid.oldelta[icv]           = 0.;
+    cvsteer.slope[icv]          = 0.;
+    cvsteer.annealing[icv]      = 0;
+    stopwhen.actmin[icv]        = 0;
+    stopwhen.actmax[icv]        = 0;
+    steerplan.isactive[icv]        = 0;
+  }
+  mtd_data.time_offset=0.;
+  mtd_data.newcolvarfmt=1;
+	// initialize the structure to zero elements
+  rmsd_workstruct.maxsize=0;
+  rmsd_workstruct.maxsize_secondder=0;
+	// initialize the couplingmatrix
+	couplingmatrix.is_on=0;
+
+}
+
+//-----------------------------------------------------------------------------------------------------------------
+
+// seek_word WILL BE REMOVED SOON (as soon as it will be replaced everywhere)
+
+int PREFIX seek_word(char **word, const char *wanted)
+{
+  int i;
+
+  for (i=0;;i++) {
+    if (word[i]==NULL) return -1;
+    if (strcmp(word[i],wanted)==0) return i;
+  }
+  return -1;
+}
+
+// Added By Paolo to progrssively seek in the input string
+int PREFIX seek_word2(char **word, const char *wanted, int is)
+{
+  int i;
+
+  for (i=is;;i++) {
+    if (word[i]==NULL) return -1;
+    if (strcmp(word[i],wanted)==0) return i;
+  }
+  return -1;
+}
+
+void PREFIX cite_please (const char* re, FILE *fplog){
+
+
+ fprintf(fplog, "\n++++ PLEASE READ AND CITE THE FOLLOWING REFERENCE ++++\n"); 
+ if(!strcmp(re,"laio-parr02pnas")){
+    fprintf(fplog, "  A. Laio and M. Parrinello\n");
+    fprintf(fplog, "  Escaping free energy minima\n");
+    fprintf(fplog, "  Proc. Natl. Acad. Sci. USA. 2002 vol. 99 (20) pp. 12562-6\n");
+ } else if(!strcmp(re,"bono+09cpc")){
+    fprintf(fplog, "  M. Bonomi, D. Branduardi, G. Bussi, C. Camilloni, D. Provasi, P. Raiteri, \n");
+    fprintf(fplog, "  D. Donadio, F. Marinelli, F. Pietrucci, R. A. Broglia and M. Parrinello \n");
+    fprintf(fplog, "  PLUMED: a portable plugin for free-energy calculations with molecular dynamics\n");
+    fprintf(fplog, "  Comp. Phys. Comm. 2009 vol. 180 (10) pp. 1961-1972 \n");
+ } else if(!strcmp(re,"pian-laio07jpcb")){
+    fprintf(fplog, "  S. Piana and A. Laio\n");
+    fprintf(fplog, "  A Bias-Exchange Approach to Protein Folding \n");
+    fprintf(fplog, "  J. Phys. Chem. B. 2007 vol. 111 (17) pp. 4553-9\n");
+ } else if(!strcmp(re,"bard+08prl")){
+    fprintf(fplog, "  A. Barducci, G. Bussi and M. Parrinello\n");
+    fprintf(fplog, "  Well-Tempered Metadynamics: A Smoothly Converging and Tunable Free-Energy Method \n");
+    fprintf(fplog, "  Phys. Rev. Lett. 2008 vol. 100 (2) pp. 020603 \n");
+ } else if(!strcmp(re,"buss+06jacs")){
+    fprintf(fplog, "  G. Bussi, F.L. Gervasio, A. Laio and M. Parrinello \n");
+    fprintf(fplog, "  Free-energy landscape for beta hairpin folding from combined parallel tempering and metadynamics\n");
+    fprintf(fplog, "  J. Am. Chem. Soc. 2006 vol. 128 (41) pp. 13435-41 \n");
+ } else if(!strcmp(re,"bran+07jcp")){
+    fprintf(fplog, "  D. Branduardi, F.L. Gervasio and M. Parrinello \n");
+    fprintf(fplog, "  From A to B in free energy space\n");
+    fprintf(fplog, "  Jour. Chem. Phys. 2007 vol. 126 (5) pp. 054103\n");
+ } else if(!strcmp(re,"rait+06jpcb")){
+    fprintf(fplog, "  P. Raiteri, A. Laio, F.L. Gervasio, C. Micheletti and M. Parrinello \n");
+    fprintf(fplog, "  Efficient Reconstruction of Complex Free Energy Landscapes by Multiple Walkers Metadynamics \n"); 
+    fprintf(fplog, "  J. Phys. Chem. B. 2006 vol. 110 (8) pp. 3533-3539 \n");
+ } else if(!strcmp(re,"sega+09jcp")){
+    fprintf(fplog, "  M. Sega, E. Autieri and F. Pederiva\n");
+    fprintf(fplog, "  On the Calculation of Puckering Free Energy Surfaces \n"); 
+    fprintf(fplog, "  J. Chem. Phys. 2009 vol. 130 (22) pp. 225102 \n");
+ } else if(!strcmp(re,"pietrucci+09jctc")){
+    fprintf(fplog, "  F. Pietrucci and A. Laio\n");
+    fprintf(fplog, "  A collective variable for the efficient exploration of protein beta-structures with metadynamics: application to SH3 and GB1\n");
+    fprintf(fplog, "  J. Chem. Theory Comput. 2009 vol. 5(9) pp. 2197 \n");
+ } else if(!strcmp(re,"pietrucci+11prl")){
+    fprintf(fplog, "  F. Pietrucci and W. Andreoni\n");
+    fprintf(fplog, "  Graph theory meets ab initio molecular dynamics: atomic structures and transformations at the nanoscale\n");
+    fprintf(fplog, "  Phys. Rev. Lett. 2011 vol. 107(8) pp. 085504\n");
+ } else if(!strcmp(re,"marinell-crespo10")){
+   fprintf(fplog, "  Y. Crespo, F. Marinelli, F. Pietrucci, A. Laio\n");
+   fprintf(fplog, "  Metadynamics convergence law in a multidimensional system\n");
+   fprintf(fplog, "  Phys. Rev. E 2010 vol. 81(5) pp. 055701 \n");
+ } else if(!strcmp(re,"tribello-10pnas")){
+   fprintf(fplog, "  G. A. Tribello, M. Ceriotti and M. Parrinello\n");
+   fprintf(fplog, "  A self-learning algorithm for based molecular dynamics\n");
+   fprintf(fplog, "  Proc. Natl. Acad. Sci. U.S.A. 2010 vol 107(41) pp. 17509-17514\n");  
+ } else if(!strcmp(re,"sutto-2010jctc")){
+   fprintf(fplog, "  L. Sutto, M. D'Abramo and F.L. Gervasio\n");
+   fprintf(fplog, "  Comparing the Efficiency of Biased and Unbiased Molecular Dynamics\n");
+   fprintf(fplog, "  in Reconstructing the Free Energy Landscape of Met-Enkephalin\n");
+   fprintf(fplog, "  J. Chem. Theory Comput. 2010 vol 6(12) pp.3640-3646\n");  
+ } else if(!strcmp(re,"abrams08jpcb")){         // #### d-AFED
+    fprintf(fplog, "  J. B. Abrams and M. E. Tuckerman\n");
+    fprintf(fplog, "  Efficient and Direct Generation of Multidimentional Free Energy Surfaces via Adiabatic Dynamics without Coordinate Transformations \n");
+    fprintf(fplog, "  J. Phys. Chem. B 2008 vol. 112 pp. 15742-15757 \n");
+ } else if(!strcmp(re,"maragliano06cpl")){      // #### d-AFED
+    fprintf(fplog, "  L. Maragliano and E. Vanden-Eijnden\n");
+    fprintf(fplog, "  A Temperature Accelerated Method for Sampling Free Energy and Determining Reaction Pathways in Rare Events Simulations \n");
+    fprintf(fplog, "  Chem. Phys. Lett. 2006 vol. 426 pp. 168-175 \n");
+ } else {
+    assert(1); // wrong bib name
+ }
+
+ fprintf(fplog, "-------- -------- --- Thank You --- -------- --------\n\n"); 
+};
+
+void PREFIX disclaimer (FILE *fplog){
+
+ fprintf(fplog,"** PLUMED is free software: you can redistribute it and/or modify \n");
+ fprintf(fplog,"** it under the terms of the GNU Lesser General Public License as published by \n");
+ fprintf(fplog,"** the Free Software Foundation, either version 3 of the License, or \n");
+ fprintf(fplog,"** (at your option) any later version. \n\n");
+ fprintf(fplog,"** PLUMED is distributed in the hope that it will be useful,\n");
+ fprintf(fplog,"** but WITHOUT ANY WARRANTY; without even the implied warranty of \n");
+ fprintf(fplog,"** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the \n");
+ fprintf(fplog,"** GNU Lesser General Public License for more details. \n\n");
+ fprintf(fplog,"** You should have received a copy of the GNU Lesser General Public License\n");
+ fprintf(fplog,"** along with PLUMED.  If not, see <http://www.gnu.org/licenses/>.  \n\n");
+ fprintf(fplog,"** For more info, see:  http://www.plumed-code.org \n");
+ fprintf(fplog,"** or subscribe to plumed-users@googlegroups.com \n\n");
+#ifdef NAMD
+ fprintf(fplog,"                              WARNING!! \n");
+ fprintf(fplog,"** Starting from version 2.7, NAMD has its own module for collective  \n");
+ fprintf(fplog,"** variable-based calculations including metadynamics, adaptive biasing \n");
+ fprintf(fplog,"** force method, umbrella sampling and steered molecular dynamics. \n");
+ fprintf(fplog,"** Please, have a look at the NAMD manual for more info. \n\n");
+#endif
+}; 
+
+
+//.................................
+//.. HERE WE HAVE THE NEW PARSER ..
+//.................................
+
+// very long lines allowed
+#define PLUMED_LINEMAX  50000
+
+// split a line into words
+int PREFIX plumed_get_words(char* line,char*** words){
+  char* ww;
+  int i;
+  (*words)=NULL;
+  
+  ww=strtok(line," \t\n"); if(ww==NULL) return 0;
+  srenew(*words,1);
+  (*words)[0]=ww;
+  for(i=1;(ww=strtok(NULL," \t\n"));i++){
+    srenew(*words,i+1);
+    (*words)[i]=ww;
+  };
+  return i;
+};
+
+void PREFIX plumed_error(const char*s){
+  fprintf(stderr,"!!!!! PLUMED ERROR: %s\n",s);
+  fprintf(stderr,"!!!!! ABORTING RUN \n");
+  if(mtd_data.fplog) {
+    fprintf(mtd_data.fplog,"!!!!! PLUMED ERROR: %s\n",s);
+    fprintf(mtd_data.fplog,"!!!!! ABORTING RUN \n");
+    fflush(mtd_data.fplog);
+  };
+  EXIT();
+};
+
+void PREFIX plumed_warn(const char*s){
+  if(mtd_data.fplog) {
+    fprintf(mtd_data.fplog,"|- : %s\n",s);
+    fflush(mtd_data.fplog);
+  };
+};
+
+// parse a word:
+//   if the word ends with postfix, delete the postfix and return 1
+//   otherwise return 0
+// example:
+//   char* word; word=malloc(100); strcpy(word,"pippo->");
+//   plumed_parse_word(word,"<-"); // returns 0 and does not change word
+//   plumed_parse_word(word,"->"); // returns 1 and changes word to "pippo"
+int plumed_parse_word(char* word,const char* postfix){
+  int lword;
+  int lpostfix;
+  lword=strlen(word);
+  lpostfix=strlen(postfix);
+  if(lword<lpostfix) return 0;
+  if(strcmp(& word[lword-lpostfix],postfix)) return 0;
+  word[lword-lpostfix]=0;
+  return 1;
+};
+
+int PREFIX plumed_atoi(const char* word){
+  int n,i;
+  char* buf;
+  n=-1;
+  sscanf(word,"%i%n",&i,&n);
+  if(n!=strlen(word)) {
+    snew(buf,strlen(word)+100);
+    sprintf(buf,"parsing integer %s\n",word);
+    plumed_error(buf);
+  }
+  return i;
+};
+
+double PREFIX plumed_atof(const char* word)
+{
+ double x;
+ int n, found=0; 
+
+ n=-1;
+ sscanf(word,"%lf%n",&x,&n);
+ if(n!=strlen(word)){
+ if(strcmp(word,"pi")==0)    { x=M_PI;      found=1; } 
+ if(strcmp(word,"+pi")==0)   { x=M_PI;      found=1; } 
+ if(strcmp(word,"-pi")==0)   { x=-1.*M_PI;  found=1; }
+ if(strcmp(word,"2pi")==0)   { x=M_2PI;     found=1; }
+ if(strcmp(word,"+2pi")==0)  { x=M_2PI;     found=1; }
+ if(strcmp(word,"-2pi")==0)  { x=-1.*M_2PI; found=1; }
+ if(found==0) plumed_error("Special symbol not recognized. Please, read the manual for accepted symbols.");
+ }
+ return x;
+};
+/*
+ get group takes a word  and looks if it's in <mygroup> format:
+ if it's so it reads the parsed input and looks for a group specified as
+
+ mygroup->       
+   4567 678 678 567 4567
+   67 89 678 34 234
+   5 7
+ mygroup-<       
+
+  IT returns the number of found field for the group ( in the case above 12 ) 
+  it places the member of the group in  a vector vec , starting from position n
+  ( so the new positions will be stored in vec[i] i=n,i<n+j,i++  ) and reallocate the 
+  vector if necessary    
+
+  if the word is not in <mygroup> format, it interprets it as a single number and adds it to the atoms list
+   
+*/
+
+int PREFIX plumed_get_group(const char *word,int **atoms,int n,t_plumed_input* input,FILE *log){
+  int lword,justoneatom,foundgroup,nadd;
+  int* toadd;
+  lword=strlen(word);
+  foundgroup=0;
+// check for group syntax
+  if(lword>2) if(word[0]=='<' && word[lword-1]=='>') foundgroup=1;
+// if not group, just read the atomx index;
+  if(!foundgroup){
+    justoneatom=plumed_atoi(word)-1;
+    nadd=1;
+    toadd=&justoneatom;
+  } else {
+// if group, search for it on the list
+    int igroup;
+    int found;
+    char* groupname;
+    snew(groupname,strlen(word)-1);
+    strncpy(groupname,& word[1],strlen(word)-2);
+    found=0;
+    for(igroup=0;igroup<input->ngroups;igroup++){
+      if(!strcmp(groupname,input->groupnames[igroup])){
+        found=1;
+        break;
+      }
+    }
+    sfree(groupname);
+    if(!found) plumed_error("group not found");
+    nadd=input->natoms[igroup];
+    toadd=input->atoms[igroup];
+  }
+  srenew((*atoms),n+nadd);
+  int i;
+  for(i=0;i<nadd;i++) (*atoms)[i+n]=toadd[i];
+  return nadd;
+  
+};
+
+// routine to parse input file
+// * remove comments
+// * join lines with continuation
+// * find and stores the group definitions
+// * save everything which is not a group in the array input->words[iline][iword]
+//   where iline=0...(input->nlines-1) and iword=0...(input=->nwords[iline)
+// * line numbers are preserved to allow a better error reporting
+void PREFIX plumed_read_input(t_plumed_input* input,FILE* file,FILE* log){
+  char* line;
+  int i;
+  int iline,iword;
+  char** words;
+  int nwords;
+  char* inside_group;
+  int inside_loop,loop_start,loop_end,loop_stride;
+
+// initial values
+  input->nlines=0;
+  input->nwords=NULL;
+  input->words=NULL;
+  input->ngroups=0;
+  input->groupnames=NULL;
+  input->natoms=NULL;
+  input->atoms=NULL;
+
+  inside_group=NULL;
+  inside_loop=0;
+  loop_start=0;
+  loop_end=0;
+
+  snew(line,PLUMED_LINEMAX);
+
+  while(fgets(line,PLUMED_LINEMAX,file)){
+
+   iline=input->nlines;
+   input->nlines++;
+   srenew(input->nwords,input->nlines);
+   input->nwords[iline]=0;
+   srenew(input->words,input->nlines);
+   input->words[iline]=NULL;
+
+// merge lines ending with "backslash" or "ampersand"
+   int linelength;
+   linelength=strlen(line);
+   if(linelength>1) while(line[linelength-2]=='\\' || line[linelength-2]=='&'){
+     if(!fgets(&line[linelength-2],PLUMED_LINEMAX-linelength+2,file))
+       plumed_error("last line is not ending");
+     linelength=strlen(line);
+// append an empty line
+// in this way the line count corresponds to the file (better for error reporting)
+     iline=input->nlines;
+     input->nlines++;
+     srenew(input->nwords,input->nlines);
+     input->nwords[iline]=0;
+     srenew(input->words,input->nlines);
+     input->words[iline]=NULL;
+// AN EXTRA EMPTY WORD IS ADDED TO BE COMPATIBLE WITH OLDER seek_word
+       srenew(input->words[iline],1);
+       input->words[iline][0]=NULL;
+   }
+
+// Remove comments (beginning with sharp or esclamation)
+    for(i=0;line[i];i++) if(line[i]=='#' || line[i]=='!') line[i]=0;
+
+// Split into words:
+    nwords=plumed_get_words(line,&words);
+
+// Check for ENDMETA or ENDPLUMED
+    if(nwords>0) if(!strcmp(words[0],"ENDMETA") || !strcmp(words[0],"ENDPLUMED")) {
+      free(words);
+      break;
+    }
+
+// loop over all the input words
+    for(iword=0;iword<nwords;iword++){
+
+// begin group
+      if(plumed_parse_word(words[iword],"->")){
+        int igroup;
+        if(inside_group) plumed_error("nested groups are not allowed");
+        if(iword>0) plumed_error("a group cannot begin in the middle of a line");
+        igroup=input->ngroups;
+        input->ngroups++;
+//   store group name
+        srenew(input->groupnames,input->ngroups);
+        snew(input->groupnames[igroup],strlen(words[iword])+1);
+        strcpy(input->groupnames[igroup],words[iword]);
+//   initialize its atom list
+        srenew(input->natoms,input->ngroups);
+        input->natoms[igroup]=0;
+        srenew(input->atoms,input->ngroups);
+        input->atoms[igroup]=NULL;
+        inside_group=input->groupnames[igroup];
+
+        fprintf(log,"|- GROUP FOUND: %s\n",inside_group);
+
+//   check if other groups with the same name have been defined
+        for(i=0;i<igroup;i++) if(!strcmp(inside_group,input->groupnames[i]))
+          plumed_error("two groups cannot have the same name");
+
+// end group
+      } else if(plumed_parse_word(words[iword],"<-")){
+        int igroup,iatom;
+        igroup=input->ngroups-1;
+        if(!inside_group) plumed_error("end group without begin group");
+        if(strcmp(inside_group,words[iword])) plumed_error("end group different from begin group");
+        if(inside_loop==1 || inside_loop==2) plumed_error("wrong LOOP syntax");
+// this is for backward compatibility with "LOOP 1 10", without stride
+        if(inside_loop==3){
+          for(i=loop_start;i<=loop_end;i++){
+            iatom=input->natoms[igroup];
+            input->natoms[igroup]++;
+            srenew(input->atoms[igroup],input->natoms[igroup]);
+            input->atoms[igroup][iatom]=i-1;
+          }
+        };
+
+// log the list of members
+        fprintf(log,"|- GROUP MEMBERS: ");
+        for(i=0;i<input->natoms[igroup];i++){
+          if((i+1)%20==0) fprintf(log,"\n|-                ");
+          fprintf(log," %i",input->atoms[igroup][i]+1);
+        }
+        fprintf(log,"\n");
+        inside_group=NULL;
+
+// if we are within a group definition, add atom of check for loop syntax
+      } else if(inside_group) {
+        int i,igroup,iatom;
+        igroup=input->ngroups-1;
+// NOTE: this should be triggered only by a LOOP keyword inside a group definition
+//       it should allow for a hypothetical LOOP keyword in a standard directive
+        if(!strcmp("LOOP",words[iword])){
+          inside_loop=1;
+        } else if(inside_loop==1){
+          loop_start=plumed_atoi(words[iword]);
+          inside_loop=2;
+        } else if(inside_loop==2){
+          loop_end=plumed_atoi(words[iword]);
+          inside_loop=3;
+        } else if(inside_loop==3){
+          loop_stride=plumed_atoi(words[iword]);
+          for(i=loop_start;i<=loop_end;i+=loop_stride){
+            iatom=input->natoms[igroup];
+            input->natoms[igroup]++;
+            srenew(input->atoms[igroup],input->natoms[igroup]);
+            input->atoms[igroup][iatom]=i-1;
+          }
+          inside_loop=0;
+        } else {
+//   add a single atom to the list
+          i=plumed_atoi(words[iword]);
+          iatom=input->natoms[igroup];
+          input->natoms[igroup]++;
+          srenew(input->atoms[igroup],input->natoms[igroup]);
+          input->atoms[igroup][iatom]=i-1;
+        }
+// if we are on a normal line, just copy the word
+      } else {
+        int iw;
+        iw=input->nwords[iline];
+        input->nwords[iline]++;
+        srenew(input->words[iline],input->nwords[iline]);
+// // AN EXTRA EMPTY WORD IS ADDED TO BE COMPATIBLE WITH OLDER seek_word
+          srenew(input->words[iline],input->nwords[iline]+1);
+          input->words[iline][iw+1]=NULL;
+        snew(input->words[iline][iw],strlen(words[iword])+1);
+        strcpy(input->words[iline][iw],words[iword]);
+      };
+    }
+
+// Finally delete word pointer for this line
+    free(words);
+  };
+
+// This buffer is not needed anymore
+  sfree(line);
+  
+// DEBUG
+//  for(iline=0;iline<input->nlines;iline++) for(iword=0;iword<input->nwords[iline];iword++)
+//  fprintf(log,"%i %i : '%s'\n",iline,iword,input->words[iline][iword]);
+};
+
+// Deallocate memory
+void PREFIX plumed_clear_input(t_plumed_input*input){
+  int i,j;
+  for(i=0;i<input->nlines;i++) for(j=0;j<input->nwords[i];j++) sfree(input->words[i][j]);
+  sfree(input->nwords);
+  for(i=0;i<input->nlines;i++) sfree(input->words[i]);
+  sfree(input->words);
+  for(i=0;i<input->ngroups;i++) sfree(input->groupnames[i]);
+  for(i=0;i<input->ngroups;i++) sfree(input->atoms[i]);
+  sfree(input->groupnames);
+  sfree(input->atoms);
+  sfree(input->natoms);
+  input->nlines=0;
+  input->nwords=NULL;
+  input->words=NULL;
+  input->ngroups=0;
+  input->groupnames=NULL;
+  input->natoms=NULL;
+  input->atoms=NULL;
+}
+
+void PREFIX couple2list( struct coupling_ll **first_elem ,int *at1,int nat1,int *at2,int nat2){
+     int i,j,k;
+     struct coupling_ll *newelem,mycouple; 
+     newelem= (struct coupling_ll *)malloc(sizeof( struct coupling_ll)); 
+
+     printf("SUMMARY************************** %p \n",first_elem);
+     // this add the element to the linked list
+     (* newelem).nat1=nat1;   
+     (* newelem).at1=(int *)malloc(nat1*sizeof(int));   
+     for(i=0;i<nat1;i++){ (* newelem).at1[i]=at1[i];}
+     (* newelem).nat2=nat2;   
+     (* newelem).at2=(int *)malloc(nat2*sizeof(int));   
+     for(i=0;i<nat2;i++){ (* newelem).at2[i]=at2[i];}
+
+     // the address of newelem is pointing to first elem
+     (* newelem).next_elem= (*first_elem);
+     // now the pointer first elem is pointing to the new elem  
+     (* first_elem) = newelem; 
+     printf("AT1 "); 
+     for(i=0;i<(**first_elem).nat1;i++){
+          printf(" %d ",(**first_elem).at1[i]);
+     } 
+     printf("\n");
+     printf("AT2 "); 
+     for(i=0;i<(**first_elem).nat2;i++){
+         printf(" %d ",(**first_elem).at2[i]);
+     } 
+     printf("\n");
+     printf("ENDSUMMARY************************** %p \n",first_elem);
+};
+void PREFIX freecouple2list( struct coupling_ll **first_elem ){
+     struct coupling_ll *newelem; 
+        // this add the element to the linked list
+         while( (* first_elem)!=NULL){
+             free((**first_elem).at1);
+             free((**first_elem).at2);
+             newelem= (* first_elem);
+             (* first_elem)=(* newelem).next_elem;
+             free(newelem);
+         }
+};
+void PREFIX scancouple( struct coupling_ll *first_elem ){
+     int i,j,k;
+     struct coupling_ll *ptr; 
+     ptr=first_elem;
+     printf("SCANCOUPLE*************************\n");
+     while(ptr!=NULL){
+        printf("NEWCOUPLE************************* %p\n",ptr);
+        printf("NAT1 %d ",(*ptr).nat1);  
+        //EXIT(); 
+        for(j=0;j<(*ptr).nat1;j++){
+           k=(*ptr).at1[j];
+           printf(" AT %d ",k);
+        }
+        printf("\n") ;
+        if((*ptr).nat2){
+            printf("NAT2 %d ",(*ptr).nat2);  
+            for(j=0;j<(*ptr).nat2;j++){
+               k=(*ptr).at2[j];
+                printf(" AT %d ",k);
+            }
+        }
+        printf("\n");
+        ptr=ptr->next_elem;
+     }   
+     printf("ENDSCANCOUPLE*************************\n");
+ 
+};
+void PREFIX setup_projections(struct proj_grad_s *proj ){
+    int i,j,k,dimension,ncv;
+    int ii,jj,kk,ll,iii,jjj;
+    int nat1,*at1;
+    int nat2,*at2;
+    int *skip; 
+    ncv=proj->nlist;
+    dimension=mtd_data.natoms; // total number of atoms
+    skip=(int *)malloc(dimension*sizeof(int)); 
+    at1=(int *)malloc(dimension*sizeof(int)); 
+    at2=(int *)malloc(dimension*sizeof(int)); 
+
+    proj->matrix=(real **)malloc(colvar.nconst*sizeof(real *));
+    for(i=0;i<colvar.nconst;i++){
+       proj->matrix[i]=(real *)malloc(colvar.nconst*sizeof(real));
+    }
+ 
+    fprintf(mtd_data.fplog,"|-PROJ_GRAD: TOTAL DIMENSION %d\n",dimension);
+    proj->couple=(struct el_couple *)malloc((ncv*(ncv-1)/2)*sizeof( struct el_couple )); //one element for couple         
+    for(i=0;i<(ncv*(ncv-1)/2);i++)(proj->couple[i]).first_elem=NULL; // set each pointer for the linked list  to null 
+    k=0;// progressive for couple counting
+    for(iii=0;iii<proj->nlist-1;iii++){
+      i=proj->list[iii]; 
+      for(jjj=iii+1;jjj<proj->nlist;jjj++){
+          j=proj->list[jjj];
+          proj->couple[k].cv1=i;
+          proj->couple[k].cv2=j;
+          for(ii=0;ii<dimension;ii++){skip[ii]=0;} 
+          for(ii=0;ii<colvar.natoms[i];ii++){
+               nat1=0;nat2=0;
+               kk=colvar.cvatoms[i][ii]; // get the index of atom 
+               if(skip[ii]){
+                   fprintf(mtd_data.fplog,"|-PROJ_GRAD: SKIPPING ATOM %d \n",ii); 
+               }else{  
+                   // find within the  other set  
+                   for(jj=0;jj<colvar.natoms[j];jj++){ // find within the other cv
+                           ll=colvar.cvatoms[j][jj]; 
+          //                 printf("ATOM1 %d ATOM2 %d \n",kk,ll);
+                           if(kk==ll){// found common indexes
+                              at2[nat2]=jj;            
+                              nat2++;
+          //                    printf("ATOM1=ATOM2 \n");
+                           }
+                   } 
+                   if(nat2){ // makes sense only when there is at least one nat2
+                        // find within the  same set ( for additive cv ) and exclude computation 
+                        for(jj=ii;jj<colvar.natoms[i];jj++){ // find within the other cv
+                            ll=colvar.cvatoms[i][jj]; 
+                            if(kk==ll){// found common indexes
+                               at1[nat1]=jj;            
+                               nat1++;
+                               skip[jj]=1;
+                            }
+                        }
+                        // transfer it to the right vectors of the linked list 
+                   }  
+                   if(nat2){
+			couple2list( &((proj->couple[k]).first_elem) ,at1,nat1,at2,nat2);
+		   }	
+               }
+          } 
+          // freecouple2list(&((proj.couple[k]).first_elem) );
+          scancouple((proj->couple[k]).first_elem);
+          // increment couple counter
+
+          k++;
+      }  
+    }
+
+     proj->ncouples=k;
+    // printf("NCOUPLES FOUND %d\n",proj.ncouples);
+     // DIAGONAL CONTRIBUTION
+     fprintf(mtd_data.fplog,"|-PROJ_GRAD: DIAGONAL CONTRIBUTION \n"); 
+     proj->diagonal=(struct el_diagonal *)malloc(ncv*sizeof( struct el_diagonal )); //one element for couple         
+     for(i=0;i<ncv;i++)(proj->diagonal[i]).first_elem=NULL; // set each pointer for the linked list  to null 
+     for(i=0;i<ncv;i++){
+               for(ii=0;ii<dimension;ii++)skip[ii]=0; 
+               // look for all the atoms which  have the same index
+               for(ii=0;ii<colvar.natoms[i];ii++){
+                   nat1=0;nat2=0;
+                   kk=colvar.cvatoms[i][ii]; // get the index of atom 
+                   if(skip[ii]){
+                       fprintf(mtd_data.fplog,"|-PROJ_GRAD: SKIPPING ATOM %d\n",ii); 
+                   }else{  
+                   // find within the  same set ( for additive cv ) and exclude computation 
+                      for(jj=ii;jj<colvar.natoms[i];jj++){ // find within the other cv
+                         ll=colvar.cvatoms[i][jj]; 
+                         if(kk==ll){// found common indexes
+                            at1[nat1]=jj;            
+                            nat1++;
+                            skip[jj]=1;
+                         }
+                      }
+                   }
+                   // transfer it to the right vectors of the linked list 
+                   if(nat1)couple2list( &((proj->diagonal[i]).first_elem) ,at1,nat1,at2,nat2);
+               }
+        //       freecouple2list(&((proj.diagonal[i]).first_elem) );
+               scancouple((proj->diagonal[i]).first_elem);
+     }
+    free(skip);
+    free(at1);
+    free(at2);
+    // now create the header for COLVAR file
+    sprintf(proj->log," XX "); 
+    char cvlog[100];
+    int cv1,cv2; 
+    ncv=proj->nlist;
+    for(i=0;i<ncv;i++){
+        cv1=proj->list[i];
+        for(j=i;j<ncv;j++){
+           cv2=proj->list[j];
+           sprintf(cvlog," NABLACV%d_DOT_NABLACV%d ",cv1+1,cv2+1);
+ 	   strcat(proj->log,cvlog); 
+        } 
+    }
+    return; 
+}
+void PREFIX calc_projections(struct proj_grad_s  *proj ){
+    int ncv,cv1,cv2,i,j,k,ii,jj;
+    real scal,grad;
+    real tmp1x,tmp1y,tmp1z;
+    real tmp2x,tmp2y,tmp2z;
+    struct coupling_ll *ptr;
+    ncv= proj->nlist;
+    for(i=0;i<colvar.nconst;i++){
+        for(j=i;j<colvar.nconst;j++){
+           (proj->matrix[i][j])=0.;
+        }
+    }
+    for(i=0;i<proj->ncouples;i++){// loop over all the couples
+            //printf("COUPLE %d ADDR %d\n",i,proj->couple[i].first_elem);
+            cv1=proj->couple[i].cv1;
+            cv2=proj->couple[i].cv2;
+            scal=0.;
+            // use the linked list to calculate grad(cv1) dot grad(cv2)
+            ptr=proj->couple[i].first_elem;
+            while(ptr!=NULL){
+               tmp1x=0.;tmp1y=0.;tmp1z=0.; 
+               for(j=0;j<(*ptr).nat1;j++){
+                  k=(*ptr).at1[j];
+                  //printf("KK %d \n",k);
+                  tmp1x+=colvar.myder[cv1][k][0];
+                  tmp1y+=colvar.myder[cv1][k][1];
+                  tmp1z+=colvar.myder[cv1][k][2];
+               }
+               tmp2x=0.;tmp2y=0.;tmp2z=0.; 
+               for(j=0;j<(*ptr).nat2;j++){
+                  k=(*ptr).at2[j];
+                  //printf("MM %d \n",k);
+                  tmp2x+=colvar.myder[cv2][k][0];
+                  tmp2y+=colvar.myder[cv2][k][1];
+                  tmp2z+=colvar.myder[cv2][k][2];
+               }
+               scal+=tmp1x*tmp2x+
+                     tmp1y*tmp2y+
+                     tmp1z*tmp2z;
+               ptr=ptr->next_elem;
+            }   
+            proj->matrix[cv1][cv2]=scal; 
+         //   printf("II %d JJ %d VV %f \n",cv1,cv2,scal);
+    }
+    for(i=0;i<ncv;i++){
+               cv1=proj->list[i];
+               grad=0.0;
+               ptr=proj->diagonal[i].first_elem;
+               while(ptr!=NULL){
+                   tmp1x=0.;tmp1y=0.;tmp1z=0.; 
+                   for(j=0;j<(*ptr).nat1;j++){
+                      k=(*ptr).at1[j];
+                      //printf("NN %d \n",k);
+                      tmp1x+=colvar.myder[cv1][k][0];
+                      tmp1y+=colvar.myder[cv1][k][1];
+                      tmp1z+=colvar.myder[cv1][k][2];
+                   }
+                   grad+=tmp1x*tmp1x;
+                   grad+=tmp1y*tmp1y;
+                   grad+=tmp1z*tmp1z;
+                   ptr=ptr->next_elem;
+               }
+               proj->matrix[cv1][cv1]=grad; 
+        //    printf("II %d JJ %d VV %f \n",cv1,cv1,grad);
+     }
+     for(i=0;i<ncv-1;i++){
+        ii=proj->list[i];
+        for(j=i+1;j<ncv;j++){
+           jj=proj->list[j];
+           proj->matrix[jj][ii]=proj->matrix[ii][jj];
+        }
+     }
+ //    printf("MMM \n");
+//        printf("MMM ");
+     sprintf(proj->log," PROJ_GRAD "); 
+     char cvlog[100];
+     for(i=0;i<ncv;i++){
+        ii=proj->list[i];
+        for(j=i;j<ncv;j++){
+           jj=proj->list[j];
+           sprintf(cvlog," %12.6f ",proj->matrix[ii][jj]); 
+           //printf(" %f ",proj->matrix[ii][jj]);
+           strcat(proj->log,cvlog);
+        }
+     }
+     //  printf("\n");
+    return;
+}
+
+int PREFIX read_steerplan(char **word,int count,t_plumed_input *input,int *iline,FILE *fplog) {
+    int i, iw, iw2, iat,j,cvs[100];
+    char string[400],chr[3];
+    int help;
+    help=0;
+    fprintf(fplog,"|-READING STEERPLAN\n");  
+    iw2 = seek_word(word,"STEERPLAN");
+
+    if (iw2 >=0){
+       load_steerplan(word[iw2+1],&steerplan,fplog);             
+    } else{ fprintf(fplog,"|- NEEDED FILE KEYWORD FOR STEERPLAN\n"); help=1;}
+
+    fprintf(fplog,"|-END READING STEERPLAN\n");  
+    return 1;
+};
+
+int PREFIX  load_steerplan  (char *filename,struct steerplan_s *steerplan, FILE *fplog){
+    int i,j,k,l,m,jj,ii,kk,nw,ncvs,*maxcvs,endcv;
+    FILE *fp;  
+    char string[200],*str,**words,string2[200],string3[200];
+    snew(maxcvs,100);
+    for(i=0;i<100;i++)maxcvs[i]=-1; // default: doesn't have any cv
+    fprintf(fplog,"|--LOADING STEERPLAN\n");  
+    // open and verify the file
+    fp=fopen(filename,"r");
+    if (fp == NULL) {
+       char buf[1024];
+       sprintf(buf,"UNSUCCESSFULL OPENING FOR FILE %s",filename);
+       plumed_error(buf);  
+    }
+    j=0;k=0;
+    while(1){
+        newline1:
+        str=fgets(string,200,fp);
+        //first word marks a comment? skip it... 
+        nw=plumed_get_words(string,&words); 
+        if(!strcmp("#",words[0])) goto newline1; 
+        if(nw==0) goto newline1;
+        // find  all the occurrency of CV and define the maximum of cvs involved in the 
+        // steerplan
+        for(i=0;i<nw;i++){
+           if(!strcmp("CV",words[i]) && ( maxcvs[atoi(words[i+1])-1]<0 )  ){ maxcvs[atoi(words[i+1])-1]=k;k++;  }; 
+        } 
+
+        if(str==NULL)break;
+        if (feof(fp))break;
+        j++;
+    }
+    // now k has the number of actions , j has the number of cvs: allocation
+    fclose(fp);
+    // allocate the steerplan
+    steerplan->ncvs=k;
+    // create an  index for used cvs
+    fprintf(mtd_data.fplog,"|--found %d MAXIMUM CVS INVOLVED IN THE STEERPLAN\n",steerplan->ncvs); 
+    (steerplan->totstages)=j;
+    fprintf(mtd_data.fplog,"|--found %d STEERACTIONS\n",steerplan->totstages); 
+    snew(steerplan->actions,steerplan->totstages); 
+    // allocate the for each action allocate the number of cvs 
+    for(i=0;i<steerplan->totstages;i++){
+       snew(steerplan->actions[i].activecv,steerplan->ncvs);  
+    }
+    snew(steerplan->actualcv,steerplan->ncvs);
+    // clean to defaults
+    for(i=0;i<steerplan->totstages;i++){
+        for(j=0;j< steerplan->ncvs;j++){
+                   steerplan->actions[i].activecv[j].k=-1; // signal for unassigned action in this section  
+                   steerplan->actions[i].activecv[j].type=1; 
+                   for(k=0;k<100;k++){ if(maxcvs[k]==j){ steerplan->isactive[k]=1;steerplan->actions[i].activecv[j].ncv=k; break;}} 
+                   steerplan->actions[i].activecv[j].wildcardpos=0; 
+                   steerplan->actions[i].activecv[j].wildcardk=0; 
+        }
+    }
+    // load the steerplan 
+    jj=0;
+    fp=fopen(filename,"r");
+    while(1){
+        newline:
+        str=fgets(string,200,fp);
+        if(str==NULL)break;
+        if (feof(fp))break;
+        i=plumed_get_words(string,&words); 
+        if(!strcmp("#",words[0])) goto newline; 
+        if(i==0)goto newline; 
+//
+// format :
+//  time   CV 1  k pos type CV 2 k pos type CV 3 k pos type
+//
+            steerplan->actions[jj].t=atof(words[0]);
+            // clean to default 
+           // split the number of needed cvs
+            for(j=1;j<i-1;j++){
+              if(!strcmp(words[j],"CV")){
+                   endcv=i; // default is the end of the line
+                   for(k=j+1;k<i;k++){
+                        if(!strcmp(words[k],"CV")){endcv=k; break;};
+                   }
+                   //fprintf(mtd_data.fplog,"|--found atomic from %d to %d \n",j,endcv); 
+                   //parse only this cv directive (too atomized?? )
+                   if(endcv-j==5){
+                       l=atoi(words[j+1])-1;// index of the cv 
+                       // find it in the array  
+                       m=maxcvs[l];//  fprintf(mtd_data.fplog,"|- collocating action %d  cv %d into array pos %d \n",jj,l+1,m); 
+                       steerplan->actions[jj].activecv[m].ncv=l;
+                       if(!strcmp(words[j+2],"*")){
+                          steerplan->actions[jj].activecv[m].wildcardk=1;
+                       } else {
+                          steerplan->actions[jj].activecv[m].k=atof(words[j+2]);
+                       } 
+                       if(!strcmp(words[j+3],"*")){
+                          steerplan->actions[jj].activecv[m].wildcardpos=1;
+                       } else {
+                          steerplan->actions[jj].activecv[m].pos=atof(words[j+3]);
+                       } 
+                       if(!strcmp(words[j+4],"CENTRAL")){
+                          steerplan->actions[jj].activecv[m].type=1;
+                       }else if(!strcmp(words[j+4],"POSITIVE")){
+                          steerplan->actions[jj].activecv[m].type=2;
+                       }else if(!strcmp(words[j+4],"NEGATIVE")){
+                          steerplan->actions[jj].activecv[m].type=3;
+                       }else {
+                           plumed_error("The only types of constraints accepted in the steerplan are CENTRAL POSITIVE NEGATIVE (default is CENTRAL of course)");  
+                       }
+                   }else if(endcv-j==4){
+                       l=atoi(words[j+1])-1;// index of the cv 
+                       // find it in the array  
+                       m=maxcvs[l]; // fprintf(mtd_data.fplog,"|- collocating action %d  cv %d into array pos %d \n",jj,l+1,m); 
+                       steerplan->actions[jj].activecv[m].ncv=l;
+                       if(!strcmp(words[j+2],"*")){
+                          steerplan->actions[jj].activecv[m].wildcardk=1;
+                       } else {
+                          steerplan->actions[jj].activecv[m].k=atof(words[j+2]);
+                       } 
+                       if(!strcmp(words[j+3],"*")){
+                          steerplan->actions[jj].activecv[m].wildcardpos=1;
+                       } else {
+                          steerplan->actions[jj].activecv[m].pos=atof(words[j+3]);
+                       } 
+                       steerplan->actions[jj].activecv[m].type=1;
+                   }else {
+                      fprintf(fplog,"|--WRONG STEERPLAN SYNTAX: it must be something like this \n");  
+                      fprintf(fplog,"#  this is a comment.. just if needeed \n");  
+                      fprintf(fplog,"#  Time  CV n Kspring  Position(wildcard * admitted)  (type CENTRAL/POSITIVE/NEGATIVE, default CENTRAL) CV m Kspring  Position(wildcard * admitted)  (type CENTRAL/POSITIVE/NEGATIVE, default CENTRAL) .... \n");  
+                      fprintf(fplog,"#  \n");  
+                      fprintf(fplog,"0.0 CV 1 1000.0  *  CV 2 0.0 *  CENTRAL\n");  
+                      fprintf(fplog,".....\n");  
+                      fprintf(fplog,".....\n");  
+                      fprintf(fplog,"\n");  
+                      plumed_error("PluMeD dead with errors: check log file"); 
+                   }
+              };
+            }
+       jj++; //action counter
+    }
+    fclose(fp);
+    fprintf(fplog,"|--LOADED STEERPLAN: \n");  
+    for(i=0;i<steerplan->totstages;i++){
+       fprintf(fplog,"|- TIME: %12.6f  ",steerplan->actions[i].t);  
+       for(j=0;j<steerplan->ncvs;j++){
+         if(steerplan->actions[i].activecv[j].wildcardpos){
+          sprintf(string,"*");
+         }else {
+          sprintf(string,"%12.6f",steerplan->actions[i].activecv[j].pos);
+         }
+         if(steerplan->actions[i].activecv[j].wildcardk){
+          sprintf(string2,"*");
+         }else {
+          sprintf(string2,"%12.6f",steerplan->actions[i].activecv[j].k);
+         }
+         if(steerplan->actions[i].activecv[j].type==1){
+          sprintf(string3,"CENTRAL ");
+         }else if(steerplan->actions[i].activecv[j].type==2){ 
+          sprintf(string3,"POSITIVE");
+         }else if(steerplan->actions[i].activecv[j].type==3){ 
+          sprintf(string3,"NEGATIVE");
+         }
+         if(steerplan->actions[i].activecv[j].k<0){
+              fprintf(fplog," CV %3d SKIPPING THIS STAGE... ",(steerplan->actions[i].activecv[j].ncv+1));
+         }else{
+              fprintf(fplog," CV %3d KAPPA %12s POS %12s TYPE %8s",steerplan->actions[i].activecv[j].ncv+1,string2,string,string3);
+         }
+       }
+       fprintf(fplog,"\n");  
+    }
+    // setup colvar header file 
+    // 
+    // the output should be like: 
+    //  STP CV n X val K val T val CV m X val K val T val X val K val     
+    sprintf(steerplan->log," XX "); 
+    for(i=0;i<steerplan->ncvs;i++){
+       int mycv; 
+       mycv=steerplan->actions[0].activecv[i].ncv;
+       char cvlog[100];
+       sprintf(cvlog," XX STPCV%d XX STPX%d XX STPK%d XX STPT%d ",mycv+1,mycv+1,mycv+1,mycv+1);
+       strcat(steerplan->log,cvlog);
+    }
+    
+    fprintf(fplog,"|--END LOADING STEERPLAN\n");  
+    return 1;
+};
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_adf.c dl_class_1.9/srcmod/Plumed/restraint_adf.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_adf.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_adf.c	2015-11-07 17:37:19.308601894 +0100
@@ -0,0 +1,366 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+
+#include "metadyn.h"
+
+#define ADF_CUTOFF 0.0001
+
+void PREFIX adf_restraint(int i_c, int ignore_repeats, struct mtd_data_s *mtd_data) {
+  int i, j, k, n, m, iat, jat, kat, nn, mm, n_c, ix;
+  real lowB, upperB, dertmp, rdist, rNdist, rMdist, num, iden;
+  real dot, theta, dtheta, weight;
+  real mod_rij, mod_rij2, f_ij, df_ij, mod_rik, mod_rik2, f_ik, df_ik, r_0, d_0; 
+  rvec rij, rik; real dijk[3][3], dij[2][3], dik[2][3];
+  int cutflag[ colvar.list[i_c][2] ];
+
+  // We calculate all beads for a given adf in the first call to this routine
+  // so any further calls we just return without doing anything 
+  for(i=0;i<i_c;i++){
+     if( colvar.type_s[i]==52 && colvar.rdflab[i]==colvar.rdflab[i_c] ){
+       if( ignore_repeats==1 ){ return; }   // This flag ensures we calculate each cv separately when debugging derivatives
+     }
+  }
+
+  // Get all the parameters and store them in local variables
+  nn = colvar.nn[i_c]; mm = colvar.mm[i_c];
+  r_0 = colvar.r_0[i_c]; d_0 = colvar.d_0[i_c];
+
+  // Initialize all colvars and derivatives to zero
+  for(k=0;k<colvar.nconst;k++){
+     if( colvar.type_s[k]==52 && colvar.rdflab[k]==colvar.rdflab[i_c] ){
+        colvar.ss0[k]=0.0;
+        for(i=0;i<colvar.natoms[k];i++){ 
+          colvar.myder[k][i][0]=colvar.myder[k][i][1]=colvar.myder[k][i][2]=0.0; 
+        }
+     }  
+  }  
+
+  // Accumulate n(\theta) and its derivative
+  for(i=0;i<colvar.list[i_c][0];i++){  // Loop over central atoms
+     iat = colvar.cvatoms[i_c][i];
+
+     // Loop over second atoms to determine which pairs of atoms can be cutoff
+     n=0;
+     for(k=colvar.list[i_c][0]+colvar.list[i_c][1];k<colvar.natoms[i_c];k++){
+        kat = colvar.cvatoms[i_c][k];
+
+        // Compute the distance between atom i and atom k and the vector connecting the two 
+        if(colvar.cell_pbc[i_c]){ minimal_image(mtd_data->pos[iat], mtd_data->pos[kat], &mod_rik, rik); }
+        else{
+          rik[0] = mtd_data->pos[iat][0]-mtd_data->pos[kat][0];
+          rik[1] = mtd_data->pos[iat][1]-mtd_data->pos[kat][1];
+          rik[2] = mtd_data->pos[iat][2]-mtd_data->pos[kat][2];
+          mod_rik  = sqrt(rik[0]*rik[0]+rik[1]*rik[1]+rik[2]*rik[2]);
+        }
+
+        // Is value of switching function very small
+        cutflag[n]=0;
+        rdist = (mod_rik-d_0)/r_0;
+        if ( rdist>0. ) {  
+           f_ik = ( 1 - pow(rdist,nn) ) / ( 1 - pow(rdist,mm) );
+           if( f_ik<ADF_CUTOFF ){ cutflag[n]=1; }
+        }
+        n++;
+     }
+
+     // Now actually compute all the cvs
+     m=0;
+     for(j=colvar.list[i_c][0];j<colvar.list[i_c][0]+colvar.list[i_c][1];j++){   // Loop over first distance
+        jat = colvar.cvatoms[i_c][j];
+
+        // Cycle if two atoms are the same
+        if( iat==jat ){ continue; }
+
+        // Cycle if we don't need to include this vector (N.B. rdfNorm for adf's indicates whether or not lists 2 and 3 are identical)
+        if( colvar.rdfNorm[i_c]==1 && cutflag[m]==1 ){ continue; } m++;     
+
+        // Compute the distance between atom i and atom j and the vector connecting the two 
+        if(colvar.cell_pbc[i_c]){ minimal_image(mtd_data->pos[iat], mtd_data->pos[jat], &mod_rij, rij); }
+        else{
+          rij[0] = mtd_data->pos[iat][0]-mtd_data->pos[jat][0];
+          rij[1] = mtd_data->pos[iat][1]-mtd_data->pos[jat][1];
+          rij[2] = mtd_data->pos[iat][2]-mtd_data->pos[jat][2];
+          mod_rij  = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+        }
+        mod_rij2 = mod_rij*mod_rij;    // Square of this distance
+
+        // Compute the value of the switching function
+        rdist = (mod_rij-d_0)/r_0;
+        if(rdist<=0.){
+           f_ij = 1; df_ij = 0.; 
+        } else if (rdist>0.999999 && rdist<1.000001){
+           f_ij = nn/mm; df_ij = 0.5*nn*(nn-mm)/mm;
+        } else {
+           rNdist = pow(rdist, nn-1); rMdist = pow(rdist, mm-1);
+           num = 1.-rNdist*rdist;
+           iden = 1./(1.-rMdist*rdist);
+           f_ij = num*iden;
+           df_ij = ((-nn*rNdist*iden)+(f_ij*(iden*mm)*rMdist))/(mod_rij*colvar.r_0[i_c]);
+        }
+
+        if( f_ij<ADF_CUTOFF ) { continue; }
+
+        // Now compute the derivative of the switching function wrt the positions
+        for(ix=0;ix<3;ix++) { dij[0][ix] = df_ij*rij[ix]; dij[1][ix] = -df_ij*rij[ix]; }
+
+        n=0;
+        for(k=colvar.list[i_c][0]+colvar.list[i_c][1];k<colvar.natoms[i_c];k++){ // Loop over the second distance
+           kat = colvar.cvatoms[i_c][k];
+
+           // Cutflag here ensures that we don't include very far away angles in the distribution
+           // See code above
+           if( cutflag[n]==1 || iat==kat || jat==kat ){ continue; } n++;
+
+           // Compute the distance between atom i and atom k and the vector connecting the two 
+           if(colvar.cell_pbc[i_c]){ minimal_image(mtd_data->pos[iat], mtd_data->pos[kat], &mod_rik, rik); }
+           else{
+             rik[0] = mtd_data->pos[iat][0]-mtd_data->pos[kat][0];
+             rik[1] = mtd_data->pos[iat][1]-mtd_data->pos[kat][1];
+             rik[2] = mtd_data->pos[iat][2]-mtd_data->pos[kat][2];
+             mod_rik  = sqrt(rik[0]*rik[0]+rik[1]*rik[1]+rik[2]*rik[2]);
+           }
+           mod_rik2 = mod_rik*mod_rik;  // Square of this distance
+
+           // Compute the value of the switching function
+           rdist = (mod_rik-d_0)/r_0;
+           if(rdist<=0.){
+              f_ij = 1; df_ij = 0.;
+           } else if (rdist>0.999999 && rdist<1.000001){
+              f_ij = nn/mm; df_ij = 0.5*nn*(nn-mm)/mm;
+           } else {
+              rNdist = pow(rdist, nn-1); rMdist = pow(rdist, mm-1);
+              num = 1.-rNdist*rdist;
+              iden = 1./(1.-rMdist*rdist);
+              f_ik = num*iden;
+              df_ik = ((-nn*rNdist*iden)+(f_ik*(iden*mm)*rMdist))/(mod_rik*colvar.r_0[i_c]);
+           }
+
+           // Now compute the derivative of the switching function wrt the positions
+           for(ix=0;ix<3;ix++) { dik[0][ix] = df_ik*rik[ix]; dik[1][ix] = -df_ik*rik[ix]; }
+           
+           // Compute this angle
+           dot = iprod(rij,rik);
+           num = 1 / ( mod_rij*mod_rik );
+           iden = dot*num;     // The cosine of the angle
+           theta = acos( iden );  // The angle
+           dtheta = -num / sqrt( 1. - iden*iden );  // Derivative of the angle
+
+           // The derivative of the angle with respect to the posisitions
+           for(ix=0;ix<3;ix++) {
+              dijk[0][ix] =  dtheta*( -dot/mod_rij2*rij[ix] - dot/mod_rik2*rik[ix] + rij[ix]+rik[ix] );
+              dijk[1][ix] = -dtheta*( -dot/mod_rij2*rij[ix] + rik[ix] );
+              dijk[2][ix] =  dtheta*(  dot/mod_rik2*rik[ix] - rij[ix] );
+           }
+
+           // Compute the weight of this term
+           weight = f_ij*f_ik;
+
+           // Now compute all the cvs
+           for(n_c=0;n_c<colvar.nconst;n_c++){
+              // Cycle if not a rdf bead of this type
+              if( colvar.type_s[n_c]!=52 || colvar.rdflab[n_c]!=colvar.rdflab[i_c] ){ continue; }
+
+              lowB = ( colvar.rdfBeadLower[n_c] - theta ) / ( sqrt(2.0) * colvar.rdfBeadWidth[n_c] ) ;
+              upperB = ( colvar.rdfBeadUpper[n_c] - theta ) / ( sqrt(2.0) * colvar.rdfBeadWidth[n_c] ) ;  
+              dertmp = ( exp( -lowB*lowB ) - exp( -upperB*upperB ) ) / ( sqrt(2.0*M_PI)*colvar.rdfBeadWidth[n_c] );
+
+              iden = 0.5*( erf( upperB ) - erf( lowB ) );
+              colvar.ss0[n_c] += weight*iden; 
+
+              // The derivative of the distribution with respect to the atoms
+              for(ix=0;ix<3;ix++) {
+                 colvar.myder[n_c][i][ix] += weight*dertmp*dijk[0][ix] + iden*f_ik*dij[0][ix] + iden*f_ij*dik[0][ix];
+                 colvar.myder[n_c][j][ix] += weight*dertmp*dijk[1][ix] + iden*f_ik*dij[1][ix];
+                 colvar.myder[n_c][k][ix] += weight*dertmp*dijk[2][ix] + iden*f_ij*dik[1][ix];
+              }
+           }
+        }
+     }
+  }
+
+  // Normalize by dividing by the number of central atoms
+  for(n_c=0;n_c<colvar.nconst;n_c++){
+     if( colvar.type_s[n_c]!=52 || colvar.rdflab[n_c]!=colvar.rdflab[i_c] ){ continue; } 
+     colvar.ss0[n_c] /= (double) colvar.list[i_c][0];
+     for(i=0;i<colvar.natoms[n_c];i++){
+         colvar.myder[n_c][i][0] /= (double) colvar.list[i_c][0];
+         colvar.myder[n_c][i][1] /= (double) colvar.list[i_c][0];
+         colvar.myder[n_c][i][2] /= (double) colvar.list[i_c][0]; 
+     } 
+  }
+
+}
+
+int PREFIX read_adf( char **word, int count, t_plumed_input *input, FILE *fplog ) {
+  int i, iw, j, iat, k, help, rdflab, checkLists, natoms1, natoms2; 
+  double delta = 0.0, upBound, lowBound, width, r_0, d_0;
+
+  help=0; d_0=0;
+
+  // Deal with periodic boundary conditions
+  colvar.cell_pbc[count]=1; // default is PBC
+
+  iw=seek_word(word,"NOPBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 0;}
+  iw=seek_word(word,"PBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 1;} 
+
+  // This is the label for which rdf this bead is from
+  iw = seek_word(word,"RDF_LABEL");
+  if(iw>=0){ sscanf(word[iw+1],"%d",&rdflab); colvar.rdflab[count]=rdflab; }
+  else{ fprintf(fplog,"|- NEEDED RDF_LABEL KEYWORD FOR ANGLE RDF\n"); help=1; }
+
+  // Now we check whether there are other beads from this rdf that have been read in
+  checkLists=-1; for(i=0;i<count;i++){ if( colvar.type_s[i]==52 && colvar.rdflab[i]==rdflab ){ checkLists=i; break; } }
+
+  // Get atoms involved in the rdf
+  iw = seek_word(word,"LIST");
+  if(iw>=0){
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+             j=plumed_get_group(word[iw+2],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][1]=j;
+             j=plumed_get_group(word[iw+3],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][2]=j;
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR ADF\n"); help=1; }
+
+  // Get the parameters for the switching function
+  iw=seek_word(word,"NN");
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.nn[count]); } else { fprintf(fplog,"|- NEEDED NN KEYWORD FOR ADF\n"); help=1;}
+  iw=seek_word(word,"MM");
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.mm[count]);} else { fprintf(fplog,"|- NEEDED MM KEYWORD FOR ADF\n"); help=1;}
+  iw=seek_word(word,"R_0");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &r_0); } else { fprintf(fplog,"|- NEEDED R_0 KEYWORD FOR ADF\n"); help=1;}
+  iw=seek_word(word,"D_0");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &d_0); }
+   
+  // Store the values
+  colvar.r_0[count]      = (real) r_0; 
+  colvar.d_0[count]      = (real) d_0; 
+
+  // Check that the everything is consistent with other rdfs of this type
+  if( checkLists!=-1){
+    
+    // Check the lists
+    if( colvar.natoms[count]!=colvar.natoms[checkLists] ){
+      fprintf(fplog,"|- MISLABELED ADF: ATOM LIST SIZES DO NOT MATCH\n"); help=1;  
+    } else{
+      for(i=0;i<colvar.natoms[count];i++){
+         if( colvar.cvatoms[count][i]!=colvar.cvatoms[checkLists][i] ){
+            fprintf(fplog,"|- MISLABELED ADF: ATOM LISTS DO NOT MATCH\n"); help=1;
+         }
+      }
+    }
+    
+    // Now check the parameters for the switching functions 
+    if( colvar.nn[count]!=colvar.nn[checkLists] ){
+      fprintf(fplog,"|- MISLABELED ADF: NN VALUES DO NOT MATCH\n"); help=1; 
+    }
+    if( colvar.mm[count]!=colvar.mm[checkLists] ){
+      fprintf(fplog,"|- MISLABELED ADF: MM  VALUES DO NOT MATCH\n"); help=1; 
+    }
+    if( colvar.r_0[count]!=colvar.r_0[checkLists] ){
+      fprintf(fplog,"|- MISLABELED ADF: R_0 VALUES DO NOT MATCH\n"); help=1; 
+    }
+    if( colvar.d_0[count]!=colvar.d_0[checkLists] ){
+      fprintf(fplog,"|- MISLABELED ADF: D_0 VALUES DO NOT MATCH\n"); help=1; 
+    }
+  }
+
+  // Check whether or not lists 2 and 3 are the same
+  colvar.rdfNorm[count]=1;
+  natoms2=colvar.list[count][1] - colvar.list[count][0];
+  natoms1=colvar.list[count][1] - colvar.list[count][0];   
+  if( natoms1==natoms2 ){
+    for(i=0;i<natoms1;i++){ 
+       j=colvar.cvatoms[count][colvar.list[count][0]+i]; k=colvar.cvatoms[count][colvar.list[count][1]+i];
+       if( j!=k ){ colvar.rdfNorm[count]=0; break; }
+    }
+  } else{ colvar.rdfNorm[count]=0; }
+
+  // Get the start and end of this particular bead
+  iw = seek_word(word,"RANGE");
+  if(iw>=0){ sscanf(word[iw+1],"%lf",&lowBound); sscanf(word[iw+2],"%lf", &upBound); 
+     colvar.rdfBeadLower[count]=lowBound; colvar.rdfBeadUpper[count]=upBound;
+  } else{ fprintf(fplog,"|- NEEDED RANGE KEYWORD FOR RDF\n"); help=1;}
+
+  // Get the width of this bead
+  iw = seek_word(word,"WIDTH");
+  if(iw>=0){ sscanf(word[iw+1],"%lf",&width); 
+     colvar.rdfBeadWidth[count]=width;
+  } else{ fprintf(fplog,"|- NEEDED WIDTH KEYWORD FOR RDF\n"); help=1;}
+
+  if(help){
+     fprintf(fplog,"\n-ADF CV: WRONG SYNTAX\n");
+     fprintf(fplog,"e.g.:    \n");
+     fprintf(fplog,"ADF RDF_LABEL 1 LIST <gr1> <gr2> <gr2> RANGE 2.0 3.0 WIDTH 1.5 R_0 1.0 D_0 0.0 NN 6 MM 12 \n");
+     fprintf(fplog,"ADF RDF_LABEL 1 LIST <gr1> <gr2> <gr2> RANGE 2.0 3.0 WIDTH 1.5 R_0 1.0 D_0 0.0 NN 6 MM 12 \n");
+     fprintf(fplog,"gr1-> \n");
+     fprintf(fplog,"1 2 3 4  \n");
+     fprintf(fplog,"gr1<- \n");
+     fprintf(fplog,"gr2-> \n");
+     fprintf(fplog,"1 2 3 4  \n");
+     fprintf(fplog,"gr2<- \n");
+     fprintf(fplog,"gr3-> \n");
+     fprintf(fplog,"1 2 3 4  \n");
+     fprintf(fplog,"gr3<- \n");
+     fprintf(fplog,"         \n");
+     plumed_error("PluMed dead with errors: check log file");
+  }
+
+  // Resize derivatives array
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+
+  fprintf(fplog, "%1i-BEAD FROM DISTRIBUTION OF ANGLES ABOUT (1st SET: %i ATOMS) ANGLES ARE BETWEEN (2nd SET: %i ATOMS) AND (3rd SET: %i ATOMS); \n", count+1, colvar.list[count][0], colvar.list[count][1], colvar.list[count][2]);
+  if( colvar.rdfNorm[count]==1 ){ fprintf(fplog, "|--LISTS 2 AND 3 ARE IDENTICAL\n"); }
+  fprintf(fplog, "|--LOWER BOUND %f, UPPER BOUND %f, WIDTH %f \n", colvar.rdfBeadLower[count], colvar.rdfBeadUpper[count], colvar.rdfBeadWidth[count]);
+  fprintf(fplog, "|--PARAMETERS FOR SWITCHING FUNCTION : R_0 %f, D_0 %f, NN %d, MM %d \n", colvar.r_0[count], colvar.d_0[count], colvar.nn[count], colvar.mm[count] );  
+
+  iat=0;
+  fprintf(fplog,"|- 1st SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][0];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 2nd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][1];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 3rd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][2];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+
+  return colvar.natoms[count];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_alfabeta.c dl_class_1.9/srcmod/Plumed/restraint_alfabeta.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_alfabeta.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_alfabeta.c	2015-11-07 17:37:19.316602126 +0100
@@ -0,0 +1,216 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX alfabeta_restraint(int i_c, struct mtd_data_s *mtd_data) 
+{
+  real *psi;
+  real psisum, dpsi, dps, cos_psi;
+  real nv1, nv2, mod_rij;
+  int i,ix, idtc, ndtc;
+  int a0, a1, a2, a3;
+  rvec vp1, vp2;
+  rvec r01, r21, r23;
+  real tnorm, prdt,prdt_sign,pi;
+  real ddotd[9];
+  real dnormd[9];
+  real dcosd[9];
+  real fd1, fd2, fmod;
+
+  ndtc = colvar.type[i_c];
+  snew(psi, ndtc);
+  psisum = 0;
+  pi = acos(-1.0);
+
+  for(idtc=0;idtc<ndtc;idtc++) {
+
+    a0 = colvar.cvatoms[i_c][4*idtc+0];
+    a1 = colvar.cvatoms[i_c][4*idtc+1];
+    a2 = colvar.cvatoms[i_c][4*idtc+2];
+    a3 = colvar.cvatoms[i_c][4*idtc+3];
+
+    minimal_image(mtd_data->pos[a1],mtd_data->pos[a0],&mod_rij,r01);
+    minimal_image(mtd_data->pos[a2],mtd_data->pos[a1],&mod_rij,r21);
+    minimal_image(mtd_data->pos[a3],mtd_data->pos[a2],&mod_rij,r23);
+
+    oprod(r01, r21, vp1);
+    oprod(r21, r23, vp2);
+    nv1 = norm(vp1);
+    nv2 = norm(vp2);
+    tnorm = nv1 * nv2;
+
+    prdt = iprod(vp1, vp2); 
+    prdt_sign = iprod(r01,vp2);
+    prdt_sign /= fabs(prdt_sign);
+
+    cos_psi = prdt / tnorm;   
+    if(fabs(cos_psi) > 1.) cos_psi /= fabs(cos_psi);
+
+    psi[idtc] = prdt_sign * acos(cos_psi);
+    dps = psi[idtc]-colvar.map0[i_c][idtc];
+    psisum += 0.5*(cos(dps)+1.);
+    dpsi = -0.5*sin(dps);
+
+    /* derivatives of the scalar product */
+    ddotd[0] =  r21[1]*vp2[2] - r21[2]*vp2[1];
+    ddotd[1] = -r21[0]*vp2[2] + r21[2]*vp2[0];
+    ddotd[2] =  r21[0]*vp2[1] - r21[1]*vp2[0];
+
+    ddotd[3] = -r21[1]*vp1[2] + r21[2]*vp1[1];
+    ddotd[4] =  r21[0]*vp1[2] - r21[2]*vp1[0];
+    ddotd[5] = -r21[0]*vp1[1] + r21[1]*vp1[0];
+
+    ddotd[6] =  r23[1]*vp1[2] - r01[1]*vp2[2] - r23[2]*vp1[1] + r01[2]*vp2[1];
+    ddotd[7] = -r23[0]*vp1[2] + r01[0]*vp2[2] + r23[2]*vp1[0] - r01[2]*vp2[0];
+    ddotd[8] =  r23[0]*vp1[1] - r01[0]*vp2[1] - r23[1]*vp1[0] + r01[1]*vp2[0];
+
+    /* derivatives of the norm part */
+    fd1 = nv2 / nv1;
+    fd2 = nv1 / nv2;
+
+    dnormd[0] = -ddotd[3] * fd1;
+    dnormd[1] = -ddotd[4] * fd1;
+    dnormd[2] = -ddotd[5] * fd1;
+
+    dnormd[3] = -ddotd[0] * fd2;
+    dnormd[4] = -ddotd[1] * fd2;
+    dnormd[5] = -ddotd[2] * fd2;
+
+    dnormd[6] = ( r23[1]*vp2[2]-r23[2]*vp2[1] )*fd2 + ( r01[2]*vp1[1]-r01[1]*vp1[2] )*fd1;
+    dnormd[7] = (-r23[0]*vp2[2]+r23[2]*vp2[0] )*fd2 + ( r01[0]*vp1[2]-r01[2]*vp1[0] )*fd1;
+    dnormd[8] = ( r23[0]*vp2[1]-r23[1]*vp2[0] )*fd2 + (-r01[0]*vp1[1]+r01[1]*vp1[0] )*fd1;
+
+    for(i=0;i<9;i++)
+        dnormd[i] /= tnorm*tnorm;
+
+         /* derivatives of cosine */
+    for(i=0;i<9;i++)
+        dcosd[i] = ddotd[i]/tnorm - prdt*dnormd[i];
+
+    /* check for numerical inconsistency */
+    if(fabs(psi[idtc])<0.00001 || fabs(psi[idtc]-pi)<0.00001 || fabs(psi[idtc]+pi)<0.00001)
+        fmod = 0.;
+    else
+        fmod = prdt_sign / fabs(sin(psi[idtc]));
+
+    /* atom derivatives */
+    colvar.myder[i_c][4*idtc+0][0] = dcosd[0] * fmod * dpsi;
+    colvar.myder[i_c][4*idtc+0][1] = dcosd[1] * fmod * dpsi;
+    colvar.myder[i_c][4*idtc+0][2] = dcosd[2] * fmod * dpsi;
+
+    colvar.myder[i_c][4*idtc+1][0] = -(dcosd[0]-dcosd[6]) * fmod * dpsi;
+    colvar.myder[i_c][4*idtc+1][1] = -(dcosd[1]-dcosd[7]) * fmod * dpsi;
+    colvar.myder[i_c][4*idtc+1][2] = -(dcosd[2]-dcosd[8]) * fmod * dpsi;
+
+    colvar.myder[i_c][4*idtc+2][0] = -(dcosd[6]-dcosd[3]) * fmod * dpsi;
+    colvar.myder[i_c][4*idtc+2][1] = -(dcosd[7]-dcosd[4]) * fmod * dpsi;
+    colvar.myder[i_c][4*idtc+2][2] = -(dcosd[8]-dcosd[5]) * fmod * dpsi;
+
+    colvar.myder[i_c][4*idtc+3][0] = -dcosd[3] * fmod * dpsi;
+    colvar.myder[i_c][4*idtc+3][1] = -dcosd[4] * fmod * dpsi;
+    colvar.myder[i_c][4*idtc+3][2] = -dcosd[5] * fmod * dpsi;
+
+  }
+
+  colvar.ss0[i_c] = psisum;
+
+
+  sfree(psi);
+}
+
+//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
+
+int PREFIX read_alfabeta(char **word, int count, t_plumed_input *input,int *iline,FILE *fplog)
+{
+  int iat, atnr1, atnr2, atnr3, atnr4, iw;
+  int help;
+  double delta = 0.0;
+  double r_0;
+  char string[400];
+
+  help = 0;
+  
+  iw=seek_word(word,"NDIH");
+  if(iw>=0) {
+       sscanf(word[iw+1],"%i", &colvar.type[count]);
+  } else {
+    fprintf(fplog,"|- NEEDED NDIH KEYWORD FOR ALPHABETA\n");
+    help=1;
+  }
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+
+   if(help){
+         fprintf(fplog,"|- ALPHABETA SYNTAX:\n");
+         fprintf(fplog,"|- NDIH               : number of dihedrals\n");
+         fprintf(fplog,"|- SIGMA              : hills width for this cv\n");
+         fprintf(fplog,"e.g. \n");
+         fprintf(fplog,"ALPHABETA NDIH 1 SIGMA 0.1 \n");
+         fprintf(fplog,"168 170 172 188 3.14\n");
+         plumed_error("PluMeD dead with errors: check log file"); 
+  }
+
+  colvar.type_s[count]   = 6;
+  colvar.natoms[count]   = 4*colvar.type[count]; 
+
+  fprintf(fplog, "\n%1i-ALPHABETA: %i DIHEDRAL; ", count+1, colvar.type[count]);
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n");
+
+  snew(colvar.cvatoms[count], colvar.natoms[count]);
+  snew(colvar.myder[count],   colvar.natoms[count]);
+  snew(colvar.map0[count],    colvar.type[count]);
+
+  for(iat=0;iat<colvar.type[count];iat++){
+    (*iline)++;
+    sscanf(input->words[*iline][0],"%i",&atnr1);
+    sscanf(input->words[*iline][1],"%i",&atnr2);
+    sscanf(input->words[*iline][2],"%i",&atnr3);
+    sscanf(input->words[*iline][3],"%i",&atnr4);
+    sscanf(input->words[*iline][4],"%lf",&r_0);
+    atnr1--;
+    atnr2--;
+    atnr3--;
+    atnr4--;
+    colvar.cvatoms[count][4*iat] = atnr1;
+    colvar.cvatoms[count][4*iat+1] = atnr2;
+    colvar.cvatoms[count][4*iat+2] = atnr3;
+    colvar.cvatoms[count][4*iat+3] = atnr4;
+    colvar.map0[count][iat] = (real) r_0;
+    fprintf(fplog, "|--DIH %i, ATOMS: %i %i %i %i  R_0: %lf \n", iat+1, atnr1+1, atnr2+1, atnr3+1, atnr4+1, r_0);
+  }
+  fprintf(fplog,"\n");
+  return colvar.type[count];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_alpharmsd.c dl_class_1.9/srcmod/Plumed/restraint_alpharmsd.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_alpharmsd.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_alpharmsd.c	2015-11-07 17:37:19.320602242 +0100
@@ -0,0 +1,285 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX alpharmsd_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int firstAtom, secondAtom, i, j, ix;
+  int nn = colvar.nn[i_c], mm = colvar.mm[i_c];
+  rvec rij;
+  real num, iden, mod_rij, rdist, func, dfunc, rNdist, rMdist;
+  real ncoord, r_0 = colvar.r_0[i_c], d_0 = colvar.d_0[i_c];
+  real threshold;
+  threshold=pow(0.00001,1./(nn-mm));
+
+  int ires, nres, iat, add_grad;
+  int atom_list[30];
+  real dist, g[30][3], rmsd;
+
+  nres=colvar.natoms[i_c]/5;
+  ncoord=0.;
+  for (i=0;i<colvar.natoms[i_c];i++) { for (ix=0;ix<3;ix++) { colvar.myder[i_c][i][ix]=0.; } }
+
+  // ires:   0 1 ... = (N CA C O CB) (N CA C O CB) ...
+  // iat:    0 1 2 3 4 5 6 ... = N CA C O CB N CA ...
+  // loop over all segments of 6 residues in the protein chain
+  for (ires=0;ires<nres-5;ires++) { 
+    // copying atom indexes from 6 residues (6*5 atoms) in atom_list
+    i=0;
+    for (iat=ires*5;iat<(ires+6)*5;iat++) { 
+      atom_list[i]=iat;
+//      if(colvar.it==0){printf("ires1 = %d atom_list %d = %d\n",ires,i,colvar.cvatoms[i_c][atom_list[i]]);} // DEBUG
+      i++;
+    }
+    // reset
+    rmsd=0.;
+    for (i=0;i<30;i++) { for (ix=0;ix<3;ix++) { g[i][ix]=0.; } }
+    // rmsd between distance matrices
+    for (i=0;i<29;i++) {
+      firstAtom=colvar.cvatoms[i_c][atom_list[i]];
+      for (j=i+1;j<30;j++) {
+        secondAtom=colvar.cvatoms[i_c][atom_list[j]];
+        // skip covalent bonds
+        if (ref_dist_mat.alpha[i][j]<=0.) continue;
+        if(colvar.cell_pbc[i_c]){
+          minimal_image(mtd_data->pos[firstAtom], mtd_data->pos[secondAtom], &mod_rij, rij);
+        } else {
+          rij[0] = mtd_data->pos[firstAtom][0]-mtd_data->pos[secondAtom][0];
+          rij[1] = mtd_data->pos[firstAtom][1]-mtd_data->pos[secondAtom][1];
+          rij[2] = mtd_data->pos[firstAtom][2]-mtd_data->pos[secondAtom][2];
+          mod_rij = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+        }
+        dist = mod_rij-ref_dist_mat.alpha[i][j];
+//        if(colvar.it==0&&dist>0.2){printf("i j ai aj rij rij0 = %d %d %d %d %8.3f %8.3f\n",i,j,colvar.cvatoms[i_c][atom_list[i]],colvar.cvatoms[i_c][atom_list[j]],mod_rij,ref_dist_mat.alpha[i][j]);} // DEBUG
+        rmsd += dist*dist;
+        // store the atom-dependent part of the gradients
+        for (ix=0;ix<3;ix++) {
+          g[i][ix]+=dist*rij[ix]/mod_rij;
+          g[j][ix]-=dist*rij[ix]/mod_rij;
+        }
+      }
+    }
+    // normalize by the number of off-diagonal elements in the 30*30 matrix 
+    rmsd=sqrt(rmsd/ref_dist_mat.alpha_pairs); 
+//    printf("step = %d  ires = %d  RMSD = %8.3f\n",colvar.it,ires,rmsd); // DEBUG
+    // switching function
+    rdist = (rmsd-d_0)/r_0;
+    add_grad=0;
+    /* analitic limit of the switching function */
+    if(rdist<=0.){
+      ncoord+=1.;
+      dfunc=0.;
+    }else if(rdist>0.999999 && rdist<1.000001){
+      ncoord+=nn/mm;
+      dfunc=0.5*nn*(nn-mm)/mm;
+      add_grad=1;
+    }else if(rdist>threshold){
+      dfunc=0.;
+    }else{
+      rNdist = pow(rdist, nn-1);
+      rMdist = pow(rdist, mm-1);
+      num = 1.-rNdist*rdist;
+      iden = 1./(1.-rMdist*rdist);
+      func = num*iden;
+      ncoord += func;
+      dfunc = (-nn*rNdist*iden)+(func*(iden*mm)*rMdist);
+      add_grad=1;
+    }
+    if (add_grad==1) {
+      dfunc=dfunc/(r_0*rmsd*ref_dist_mat.alpha_pairs);
+      // total gradient
+      for (i=0;i<30;i++) {
+        for(ix=0;ix<3;ix++) {
+          colvar.myder[i_c][atom_list[i]][ix] += dfunc*g[i][ix];
+        }
+      }
+    }
+  } // loop on ires
+  colvar.ss0[i_c] = ncoord;
+
+}
+
+//--------------------------------------------------------------------------------------------------------------
+
+int PREFIX read_alpharmsd(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+// Coordinates N CA C O CB (Angstrom) of alpha 6-res block from the representative pdbs of
+// each of the 5 architecture entries in class "mainly alpha" of CATH database
+// (1oai 1mz9 1jdh 1ppr 1h12)
+  static rvec ref_alpha[30]={   
+    { 0.733,  0.519,  5.298}, // N    i
+    { 1.763,  0.810,  4.301}, // CA
+    { 1.527, -0.045,  3.053}, // C
+    { 1.646,  0.436,  1.928}, // O
+    { 3.166,  0.543,  4.881}, // CB
+    { 1.180, -1.312,  3.254}, // N    i+1
+    { 0.924, -2.203,  2.126}, // CA
+    {-0.239, -1.711,  1.261}, // C
+    {-0.190, -1.815,  0.032}, // O
+    { 0.650, -3.626,  2.626}, // CB
+    {-1.280, -1.172,  1.891}, // N    i+2
+    {-2.416, -0.661,  1.127}, // CA
+    {-1.964,  0.529,  0.276}, // C
+    {-2.364,  0.659, -0.880}, // O
+    {-3.548, -0.217,  2.056}, // CB
+    {-1.130,  1.391,  0.856}, // N    i+3
+    {-0.620,  2.565,  0.148}, // CA
+    { 0.231,  2.129, -1.032}, // C
+    { 0.179,  2.733, -2.099}, // O
+    { 0.228,  3.439,  1.077}, // CB
+    { 1.028,  1.084, -0.833}, // N    i+4
+    { 1.872,  0.593, -1.919}, // CA
+    { 1.020,  0.020, -3.049}, // C
+    { 1.317,  0.227, -4.224}, // O
+    { 2.850, -0.462, -1.397}, // CB
+    {-0.051, -0.684, -2.696}, // N    i+5
+    {-0.927, -1.261, -3.713}, // CA
+    {-1.663, -0.171, -4.475}, // C
+    {-1.916, -0.296, -5.673}, // O
+    {-1.933, -2.219, -3.074}  // CB
+  };
+
+  int i, iw, iat, j, help, ix;
+  double r_0, d_0, d;
+  double delta = 0.0;
+  double angstrom_scale;
+  char string[400];
+  real threshold, value;
+
+  help=0;
+  d_0=0.;
+
+  colvar.cell_pbc[count]=1; // default is PBC
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0){
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR ALPHARMSD\n"); help=1;}
+
+  if(colvar.natoms[count]%5!=0){ fprintf(fplog,"|- ERROR: TOTAL NUMBER OF ATOMS MUST BE MULTIPLE OF 5\n"); help=1; }
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+  iw=seek_word(word,"NN");
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.nn[count]); } else { fprintf(fplog,"|- NEEDED NN KEYWORD FOR ALPHARMSD\n"); help=1;}
+  iw=seek_word(word,"MM");
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.mm[count]);} else { fprintf(fplog,"|- NEEDED MM KEYWORD FOR ALPHARMSD\n"); help=1;}
+  iw=seek_word(word,"R_0");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &r_0); } else { fprintf(fplog,"|- NEEDED R_0 KEYWORD FOR ALPHARMSD\n"); help=1;}
+  iw=seek_word(word,"D_0");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &d_0); }
+  iw=seek_word(word,"NOPBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 0;}
+  iw=seek_word(word,"PBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 1;}
+  iw=seek_word(word,"ANGSTROM_SCALE");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &angstrom_scale); } else { fprintf(fplog,"|- NEEDED ANGSTROM_SCALE KEYWORD FOR ALPHARMSD\n"); help=1;}
+
+  if(help){
+          fprintf(fplog, "\n-ALPHARMSD CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "ALPHARMSD LIST <g1> NN 8 MM 12 R_0 0.08 SIGMA 1.0 ANGSTROM_SCALE 0.1 NOPBC\n");
+          fprintf(fplog, "         g1->    \n");
+          fprintf(fplog, "            7     9    26    27    11 \n");
+          fprintf(fplog, "           28    30    45    46    32 \n");
+          fprintf(fplog, "           47    49    56    57    51 \n");
+          fprintf(fplog, "           58    60    71    72    62 \n");
+          fprintf(fplog, "           73    75    88    89    77 \n");
+          fprintf(fplog, "           90    92   100   101    94 \n");
+          fprintf(fplog, "          102   104   120   121   106 \n");
+          fprintf(fplog, "          122   124   136   137   126 \n");
+          fprintf(fplog, "          138   140   147   148   142 \n");
+          fprintf(fplog, "          149   151   163   164   153 \n");
+          fprintf(fplog, "          165   167   183   184   169 \n");
+          fprintf(fplog, "          185   187   190   191   189 \n");
+          fprintf(fplog, "          192   194   209   210   196    \n");
+          fprintf(fplog, "         g1<-    \n");
+          fprintf(fplog, "       \n");
+          fprintf(fplog, " (where each row contains N CA C O CB of consecutive residues)\n");
+          fprintf(fplog, "       \n");
+          plumed_error("PluMed dead with errors: check log file");
+  }
+
+  colvar.r_0[count]      = (real) r_0;
+  colvar.d_0[count]      = (real) d_0;
+  colvar.type_s[count]   = 37;
+
+  fprintf(fplog, "%1i-ALPHARMSD; ATOMS INVOLVED: %i; ", count+1, colvar.natoms[count]);
+  if(colvar.cell_pbc[count]) fprintf(fplog, " PBC ON");
+  else                       fprintf(fplog, " PBC OFF");
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+  fprintf(fplog, "|--FUNCTIONAL FORM: (1-((dist_mat_rmsd-d_0)/r_0)^n) / (1-((dist_mat_rmsd-d_0)/r_0)^m) \n");
+  fprintf(fplog, "|--PARAMETERS: n= %i m= %i r_0= %f d_0= %f\n", colvar.nn[count], colvar.mm[count], colvar.r_0[count], colvar.d_0[count]);
+  threshold=pow(0.00001,1./(colvar.nn[count]-colvar.mm[count]));
+  value=(1.-pow(threshold,colvar.nn[count]))/(1.-pow(threshold,colvar.mm[count]));
+  fprintf(fplog, "|--CUTOFF VALUE: %f\n",value);
+  fprintf(fplog, "|--CUTOFF DISTANCE: %f\n",threshold*r_0+d_0);
+
+  iat=0;
+  fprintf(fplog,"|- SET MEMBERS: ");
+  for(i=0;i<colvar.natoms[count];i++){fprintf(fplog," %d ",colvar.cvatoms[count][i]+1);if((i+1)%20==0)fprintf(fplog,"\n               ");}fprintf(fplog,"\n\n");
+
+  fprintf(fplog,"|- IMPORTANT NOTE: THIS CV REQUIRES ALIGN_ATOMS (FOR ALL BACKBONE) ON SOME CODES LIKE GROMACS4 !!!\n");
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  // storing reference distance matrix (converted from angstrom to angstrom*angstrom_scale)
+  ref_dist_mat.alpha_pairs=0.; // pairs without covalent bond
+  for (i=0;i<29;i++) {
+    for (j=i+1;j<30;j++) {
+      d=0.;
+      for (ix=0;ix<3;ix++) {
+        d += pow((ref_alpha[i][ix]-ref_alpha[j][ix]),2);
+      }
+      d=sqrt(d);
+      // here d is in angstrom: covalent bonds among N CA C O CB are maximum 1.54 A
+      if(d>1.7) {
+        // convert d in length units of the MD program
+        d=d*angstrom_scale;
+        ref_dist_mat.alpha_pairs+=1.;
+      } else {
+        // exclude covalent bonds
+        d=-999.;
+      }
+      ref_dist_mat.alpha[i][j]=d;
+      ref_dist_mat.alpha[j][i]=d;
+    }
+  }
+ 
+  return colvar.natoms[count]; 
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_angle.c dl_class_1.9/srcmod/Plumed/restraint_angle.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_angle.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_angle.c	2015-11-07 17:37:19.323602329 +0100
@@ -0,0 +1,201 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX angle_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int i, j, iat, k, ix;
+  real myp[3][3], totmasse[3], d[3][3];
+  rvec rij, sij, tij;
+  real mod_rij, mod_sij;
+  real eps, sign0;
+  real caa, cbb, cab, ccc, sab;
+  real ac, Vac, bc, dVac, cos_psi, sin_psi;
+
+  totmasse[0] = totmasse[1] = totmasse[2] = 0.;
+  myp[0][0] = myp[0][1] = myp[0][2] = 0.;
+  myp[1][0] = myp[1][1] = myp[1][2] = 0.;
+  myp[2][0] = myp[2][1] = myp[2][2] = 0.;
+  k = 0;
+
+  for(j=0;j<3;j++) {
+    for(i=0;i<colvar.list[i_c][j];i++){
+      iat = colvar.cvatoms[i_c][k];
+      myp[j][0] += mtd_data->mass[iat]*mtd_data->pos[iat][0];
+      myp[j][1] += mtd_data->mass[iat]*mtd_data->pos[iat][1];
+      myp[j][2] += mtd_data->mass[iat]*mtd_data->pos[iat][2];
+      totmasse[j] += mtd_data->mass[iat];
+      k++;
+    }
+    myp[j][0] /= totmasse[j];
+    myp[j][1] /= totmasse[j];
+    myp[j][2] /= totmasse[j];
+  }
+
+  minimal_image(myp[1], myp[0], &mod_rij, rij);
+  minimal_image(myp[1], myp[2], &mod_sij, sij);
+  
+  caa = norm2(rij);
+  cab = iprod(rij,sij);
+  cbb = norm2(sij);
+
+  oprod(rij,sij,tij);
+  sab = norm(tij);
+  ccc = 1.0/sqrt(caa*cbb);
+  ac = cab*ccc; // cosine of teta
+  Vac = acos(ac);
+  dVac = -ccc/sqrt(1.-ac*ac);
+
+  for(ix=0;ix<3;ix++) {
+    d[0][ix] = -dVac*(-cab/caa*rij[ix]+sij[ix]);
+    d[1][ix] = dVac*(-cab/caa*rij[ix]-cab/cbb*sij[ix]+rij[ix]+sij[ix]);
+    d[2][ix] = dVac*(cab/cbb*sij[ix]-rij[ix]);
+  }
+
+  // Now we do appropriate multiplication of the derivatives to get what we are interested in
+  if( colvar.doTrig[i_c]==0 ){ colvar.ss0[i_c] = Vac; }
+  else if( colvar.doTrig[i_c]==1 ){
+     cos_psi=cos( Vac );
+     for(i=0;i<3;++i){d[0][i]*= cos_psi;  d[1][i]*= cos_psi; d[2][i]*= cos_psi;}
+     colvar.ss0[i_c] = sin( Vac );
+  }
+  else if( colvar.doTrig[i_c]==2 ){
+     sin_psi=-sin( Vac );
+     for(i=0;i<3;++i){d[0][i]*= sin_psi;  d[1][i]*= sin_psi; d[2][i]*= sin_psi;}
+     colvar.ss0[i_c] = cos( Vac );
+  }
+  else{ plumed_error("No trigonometric mode defined in torsion restraint"); }
+
+
+
+  k=0;
+  for(j=0;j<3;j++) {
+    for(i=0;i<colvar.list[i_c][j];i++){
+      iat = colvar.cvatoms[i_c][k];
+      for(ix=0;ix<3;ix++) colvar.myder[i_c][k][ix] = d[j][ix]*mtd_data->mass[iat]/totmasse[j];
+      k++;
+    }
+  }
+
+  //colvar.ss0[i_c] = Vac;
+}
+
+//---------------------------------------------------------------------------------------------------------------
+
+int PREFIX read_angle(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i,j, iat, iw, help;
+  double delta = 0.0;
+  char string[400];
+  
+  help = 0;
+
+  colvar.doTrig[count]=0;    // Default is to do no trigonometry (raw angle)
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0) {
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+             j=plumed_get_group(word[iw+2],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][1]=j;
+             j=plumed_get_group(word[iw+3],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][2]=j;
+  } else { fprintf(fplog,"|- NEEDED LIST KEYWORD FOR ANGLE\n"); help=1;}
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);  
+             colvar.delta_r[count]  = (real) delta; }
+ 
+  if(help){
+          fprintf(fplog, "\n-ANGLE CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "      ANGLE LIST 12 17 20 SIGMA 1.0 \n");
+          fprintf(fplog, "              \n");
+          fprintf(fplog, "or in case of group: \n");
+          fprintf(fplog, "      ANGLE LIST <g1> <g2> <g3> SIGMA 1.0  \n");
+          fprintf(fplog, "         g1->    \n");
+          fprintf(fplog, "         6 10    \n");
+          fprintf(fplog, "         g1<-    \n");
+          fprintf(fplog, "                 \n");
+          fprintf(fplog, "         g2->    \n");
+          fprintf(fplog, "         8 15 21 \n");
+          fprintf(fplog, "         g2<-    \n");
+          fprintf(fplog, "                 \n"); 
+          fprintf(fplog, "         g3->    \n");
+          fprintf(fplog, "         23 29 31\n");
+          fprintf(fplog, "         g3<-    \n");
+          fprintf(fplog, "   \n");
+          plumed_error("PluMeD dead with errors: check log file");
+  }
+
+  iw=seek_word(word,"SIN");
+  if(iw>=0){ colvar.doTrig[count]=1; }
+  iw=seek_word(word,"COS");
+  if(iw>=0){ colvar.doTrig[count]=2; }
+
+  colvar.type_s[count]   = 4;
+
+  if(colvar.doTrig[count]==0){
+	  fprintf(fplog, "\n%1i-ANGLE: (1st SET: %i ATOMS), (2nd SET: %i ATOMS), (3rd SET: %i ATOMS); ", count+1,
+	    colvar.list[count][0], colvar.list[count][1], colvar.list[count][2]);
+  }
+
+  if(colvar.doTrig[count]==1){
+	  fprintf(fplog, "\n%1i-SINE OF ANGLE: (1st SET: %i ATOMS), (2nd SET: %i ATOMS), (3rd SET: %i ATOMS); ", count+1,
+	    colvar.list[count][0], colvar.list[count][1], colvar.list[count][2]);
+  }
+
+  if(colvar.doTrig[count]==1){
+	  fprintf(fplog, "\n%1i-COSINE OF ANGLE: (1st SET: %i ATOMS), (2nd SET: %i ATOMS), (3rd SET: %i ATOMS); ", count+1,
+	    colvar.list[count][0], colvar.list[count][1], colvar.list[count][2]);
+  }
+
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n");
+ 
+  iat=0;
+  fprintf(fplog,"|- 1st SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][0];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 2nd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][1];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 3rd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][2];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  return colvar.natoms[count];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_antibetarmsd.c dl_class_1.9/srcmod/Plumed/restraint_antibetarmsd.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_antibetarmsd.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_antibetarmsd.c	2015-11-07 17:37:19.327602445 +0100
@@ -0,0 +1,306 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX antibetarmsd_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int firstAtom, secondAtom, i, j, ix;
+  int nn = colvar.nn[i_c], mm = colvar.mm[i_c];
+  rvec rij;
+  real num, iden, mod_rij, rdist, func, dfunc, rNdist, rMdist;
+  real ncoord, r_0 = colvar.r_0[i_c], d_0 = colvar.d_0[i_c];
+  real threshold;
+  threshold=pow(0.00001,1./(nn-mm));
+
+  int ires, jres, nres, iat, add_grad;
+  int atom_list[30];
+  real dist, g[30][3], rmsd, cutoff;
+  cutoff=colvar.realpar[i_c][0][0];
+
+  nres=colvar.natoms[i_c]/5;
+  ncoord=0.;
+  for (i=0;i<colvar.natoms[i_c];i++) { for (ix=0;ix<3;ix++) { colvar.myder[i_c][i][ix]=0.; } }
+
+  // ires:   0 1 ... = (N CA C O CB) (N CA C O CB) ...
+  // iat:    0 1 2 3 4 5 6 ... = N CA C O CB N CA ...
+  // loop over residue triplets {i,j}{i+1,j-1}{i+2,j-2} with (j-2)-(i+2)>2 (this leaves min 2 residues in the turn)
+  for (ires=0;ires<nres-7;ires++) { 
+  for (jres=ires+7;jres<nres;jres++) { 
+    // copying atom indexes from 3 pairs of residues (6*5 atoms) in atom_list
+    // order of H-bonded residues in ref_antibeta[]: 1-6 2-5 3-4
+    for(i=0;i<15;i++) {
+      atom_list[i]=ires*5+i;
+      atom_list[i+15]=(jres-2)*5+i;
+    }
+//    if(colvar.it==0){for(i=0;i<30;i++){printf("ires1,jres1 = %d %d atom_list %d = %d\n",ires,jres,i,colvar.cvatoms[i_c][atom_list[i]]);}} // DEBUG
+    // check if it's worth to compute the rmsd (if segments are not too far)
+    firstAtom=colvar.cvatoms[i_c][atom_list[6]];   // CA at the center of first segment
+    secondAtom=colvar.cvatoms[i_c][atom_list[21]]; // CA at the center of second segment
+    if(colvar.cell_pbc[i_c]){
+      minimal_image(mtd_data->pos[firstAtom], mtd_data->pos[secondAtom], &mod_rij, rij);
+    } else {
+      rij[0] = mtd_data->pos[firstAtom][0]-mtd_data->pos[secondAtom][0];
+      rij[1] = mtd_data->pos[firstAtom][1]-mtd_data->pos[secondAtom][1];
+      rij[2] = mtd_data->pos[firstAtom][2]-mtd_data->pos[secondAtom][2];
+      mod_rij = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+    }
+    if (mod_rij>cutoff) continue; // this can save a lot of computer time!
+    // reset
+    rmsd=0.;
+    for (i=0;i<30;i++) { for (ix=0;ix<3;ix++) { g[i][ix]=0.; } }
+    // rmsd between distance matrices
+    for (i=0;i<29;i++) {
+      firstAtom=colvar.cvatoms[i_c][atom_list[i]];
+      for (j=i+1;j<30;j++) {
+        secondAtom=colvar.cvatoms[i_c][atom_list[j]];
+        // skip covalent bonds
+        if (ref_dist_mat.antibeta[i][j]<=0.) continue;
+        if(colvar.cell_pbc[i_c]){
+          minimal_image(mtd_data->pos[firstAtom], mtd_data->pos[secondAtom], &mod_rij, rij);
+        } else {
+          rij[0] = mtd_data->pos[firstAtom][0]-mtd_data->pos[secondAtom][0];
+          rij[1] = mtd_data->pos[firstAtom][1]-mtd_data->pos[secondAtom][1];
+          rij[2] = mtd_data->pos[firstAtom][2]-mtd_data->pos[secondAtom][2];
+          mod_rij = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+        }
+        dist = mod_rij-ref_dist_mat.antibeta[i][j];
+//        printf("i j ai aj rij rij0 = %d %d %d %d %8.3f %8.3f\n",i,j,colvar.cvatoms[i_c][atom_list[i]],colvar.cvatoms[i_c][atom_list[j]],mod_rij,ref_dist_mat.antibeta[i][j]); // DEBUG
+        rmsd += dist*dist;
+        // store the atom-dependent part of the gradients
+        for (ix=0;ix<3;ix++) {
+          g[i][ix]+=dist*rij[ix]/mod_rij;
+          g[j][ix]-=dist*rij[ix]/mod_rij;
+        }
+      }
+    }
+    // normalize by the number of off-diagonal elements in the 30*30 matrix 
+    rmsd=sqrt(rmsd/ref_dist_mat.antibeta_pairs); 
+//    printf("step = %d  ires,jres = %d %d  RMSD = %8.3f\n",colvar.it,ires,jres,rmsd); // DEBUG
+    // switching function
+    rdist = (rmsd-d_0)/r_0;
+    add_grad=0;
+    /* analitic limit of the switching function */
+    if(rdist<=0.){
+      ncoord+=1.;
+      dfunc=0.;
+    }else if(rdist>0.999999 && rdist<1.000001){
+      ncoord+=nn/mm;
+      dfunc=0.5*nn*(nn-mm)/mm;
+      add_grad=1;
+    }else if(rdist>threshold){
+      dfunc=0.;
+    }else{
+      rNdist = pow(rdist, nn-1);
+      rMdist = pow(rdist, mm-1);
+      num = 1.-rNdist*rdist;
+      iden = 1./(1.-rMdist*rdist);
+      func = num*iden;
+      ncoord += func;
+      dfunc = (-nn*rNdist*iden)+(func*(iden*mm)*rMdist);
+      add_grad=1;
+    }
+    if (add_grad==1) {
+      dfunc=dfunc/(r_0*rmsd*ref_dist_mat.antibeta_pairs);
+      // total gradient
+      for (i=0;i<30;i++) {
+        for(ix=0;ix<3;ix++) {
+          colvar.myder[i_c][atom_list[i]][ix] += dfunc*g[i][ix];
+        }
+      }
+    }
+  } // loop on jres
+  } // loop on ires
+  colvar.ss0[i_c] = ncoord;
+
+}
+
+//--------------------------------------------------------------------------------------------------------------
+
+int PREFIX read_antibetarmsd(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+// Coordinates N CA C O CB (Angstrom) of antibeta 3+3 blocks from the representative pdbs of
+// each of the 20 architecture entries in class "mainly beta" of CATH database
+// (1bds 1gvk 1h8p 1i5p 1itv 1k7i 1m3y 1n7v 1nh2 1qre 1rg8 1tl2 1w6s 1ylh 2bbk 2dpf 2hnu 2nwf 3sil 4bcl)
+  static rvec ref_antibeta[30]={
+    { 2.263, -3.795,  1.722}, // N    i
+    { 2.493, -2.426,  2.263}, // CA
+    { 1.301, -1.517,  1.921}, // C
+    { 0.852, -1.504,  0.739}, // O
+    { 3.847, -1.838,  1.761}, // CB
+    { 0.818, -0.738,  2.917}, // N    i+1
+    {-0.299,  0.243,  2.748}, // CA
+    { 0.273,  1.680,  2.854}, // C
+    { 0.902,  1.993,  3.888}, // O
+    {-1.421, -0.076,  3.757}, // CB
+    { 0.119,  2.532,  1.813}, // N    i+2
+    { 0.683,  3.916,  1.680}, // CA
+    {-0.394,  5.011,  1.630}, // C
+    {-1.459,  4.814,  0.982}, // O
+    { 1.580,  3.940,  0.395}, // CB
+    {-2.962,  3.559, -1.359}, // N    j-2
+    {-2.439,  2.526, -2.287}, // CA
+    {-2.081,  1.231, -1.520}, // C
+    {-1.524,  1.324, -0.409}, // O
+    {-1.189,  3.006, -3.087}, // CB
+    {-2.326,  0.037, -2.095}, // N    j-1
+    {-1.858, -1.269, -1.554}, // CA
+    {-0.869, -1.949, -2.512}, // C
+    {-1.255, -2.070, -3.710}, // O
+    {-3.053, -2.199, -1.291}, // CB
+    { 0.326, -2.363, -2.072}, // N    j
+    { 1.405, -2.992, -2.872}, // CA
+    { 1.745, -4.399, -2.330}, // C
+    { 1.899, -4.545, -1.102}, // O
+    { 2.699, -2.129, -2.917}, // CB
+  };
+
+  int i, iw, iat, j, help, ix;
+  double r_0, d_0, d;
+  double delta = 0.0;
+  double angstrom_scale, strands_cutoff;
+  char string[400];
+  real threshold, value;
+
+  help=0;
+  d_0=0.;
+
+  colvar.cell_pbc[count]=1; // default is PBC
+  colvar.realpar[count][0][0]=1000000.; // by default, no cutoff on the distance between beta-strands
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0){
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR ANTIBETARMSD\n"); help=1;}
+
+  if(colvar.natoms[count]%5!=0){ fprintf(fplog,"|- ERROR: TOTAL NUMBER OF ATOMS MUST BE MULTIPLE OF 5\n"); help=1; }
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+  iw=seek_word(word,"NN");
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.nn[count]); } else { fprintf(fplog,"|- NEEDED NN KEYWORD FOR ANTIBETARMSD\n"); help=1;}
+  iw=seek_word(word,"MM");
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.mm[count]);} else { fprintf(fplog,"|- NEEDED MM KEYWORD FOR ANTIBETARMSD\n"); help=1;}
+  iw=seek_word(word,"R_0");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &r_0); } else { fprintf(fplog,"|- NEEDED R_0 KEYWORD FOR ANTIBETARMSD\n"); help=1;}
+  iw=seek_word(word,"D_0");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &d_0); }
+  iw=seek_word(word,"NOPBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 0;}
+  iw=seek_word(word,"PBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 1;}
+  iw=seek_word(word,"ANGSTROM_SCALE");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &angstrom_scale); } else { fprintf(fplog,"|- NEEDED ANGSTROM_SCALE KEYWORD FOR ANTIBETARMSD\n"); help=1;}
+  iw=seek_word(word,"STRANDS_CUTOFF");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &strands_cutoff); }
+
+  if(help){
+          fprintf(fplog, "\n-ANTIBETARMSD CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "ANTIBETARMSD LIST <g1> NN 8 MM 12 R_0 0.08 SIGMA 1.0 ANGSTROM_SCALE 0.1 STRANDS_CUTOFF 1. NOPBC\n");
+          fprintf(fplog, "         g1->    \n");
+          fprintf(fplog, "            7     9    26    27    11 \n");
+          fprintf(fplog, "           28    30    45    46    32 \n");
+          fprintf(fplog, "           47    49    56    57    51 \n");
+          fprintf(fplog, "           58    60    71    72    62 \n");
+          fprintf(fplog, "           73    75    88    89    77 \n");
+          fprintf(fplog, "           90    92   100   101    94 \n");
+          fprintf(fplog, "          102   104   120   121   106 \n");
+          fprintf(fplog, "          122   124   136   137   126 \n");
+          fprintf(fplog, "          138   140   147   148   142 \n");
+          fprintf(fplog, "          149   151   163   164   153 \n");
+          fprintf(fplog, "          165   167   183   184   169 \n");
+          fprintf(fplog, "          185   187   190   191   189 \n");
+          fprintf(fplog, "          192   194   209   210   196    \n");
+          fprintf(fplog, "         g1<-    \n");
+          fprintf(fplog, "       \n");
+          fprintf(fplog, " (where each row contains N CA C O CB of consecutive residues)\n");
+          fprintf(fplog, "       \n");
+          plumed_error("PluMeD dead with errors: check log file");         
+  }
+
+  colvar.r_0[count]      = (real) r_0;
+  colvar.d_0[count]      = (real) d_0;
+  colvar.realpar[count][0][0] = (real) strands_cutoff;
+  colvar.type_s[count]   = 38;
+
+  fprintf(fplog, "%1i-ANTIBETARMSD; ATOMS INVOLVED: %i; ", count+1, colvar.natoms[count]);
+  if(colvar.cell_pbc[count]) fprintf(fplog, " PBC ON;");
+  else                       fprintf(fplog, " PBC OFF;");
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+  fprintf(fplog, "|--FUNCTIONAL FORM: (1-((dist_mat_rmsd-d_0)/r_0)^n) / (1-((dist_mat_rmsd-d_0)/r_0)^m) \n");
+  fprintf(fplog, "|--PARAMETERS: n= %i m= %i r_0= %f d_0= %f\n", colvar.nn[count], colvar.mm[count], colvar.r_0[count], colvar.d_0[count]);
+  threshold=pow(0.00001,1./(colvar.nn[count]-colvar.mm[count]));
+  value=(1.-pow(threshold,colvar.nn[count]))/(1.-pow(threshold,colvar.mm[count]));
+  fprintf(fplog, "|--CUTOFF VALUE: %f\n",value);
+  fprintf(fplog, "|--CUTOFF DISTANCE: %f\n",threshold*r_0+d_0);
+  if(colvar.realpar[count][0][0]<1000000.) { fprintf(fplog, "|--STRANDS_CUTOFF DISTANCE: %f\n",colvar.realpar[count][0][0]); }
+  fprintf(fplog, "|--ANGSTROM_SCALE: %f\n",angstrom_scale);
+
+  iat=0;
+  fprintf(fplog,"|- SET MEMBERS: ");
+  for(i=0;i<colvar.natoms[count];i++){fprintf(fplog," %d ",colvar.cvatoms[count][i]+1);if((i+1)%20==0)fprintf(fplog,"\n               ");}fprintf(fplog,"\n\n");
+
+  fprintf(fplog,"|- IMPORTANT NOTE: THIS CV REQUIRES ALIGN_ATOMS (FOR ALL BACKBONE) ON SOME CODES LIKE GROMACS4 !!!\n");
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  // storing reference distance matrix (converted from angstrom to angstrom*angstrom_scale)
+  ref_dist_mat.antibeta_pairs=0.; // pairs without covalent bond
+  for (i=0;i<29;i++) {
+    for (j=i+1;j<30;j++) {
+      d=0.;
+      for (ix=0;ix<3;ix++) {
+        d += pow((ref_antibeta[i][ix]-ref_antibeta[j][ix]),2);
+      }
+      d=sqrt(d);
+      // here d is in angstrom: covalent bonds among N CA C O CB are maximum 1.54 A
+      if(d>1.7) {
+        // convert d in length units of the MD program
+        d=d*angstrom_scale;
+        ref_dist_mat.antibeta_pairs+=1.;
+      } else {
+        // exclude covalent bonds
+        d=-999.;
+      }
+      ref_dist_mat.antibeta[i][j]=d;
+      ref_dist_mat.antibeta[j][i]=d;
+    }
+  }
+ 
+  return colvar.natoms[count]; 
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint.c dl_class_1.9/srcmod/Plumed/restraint.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint.c	2015-11-07 17:37:19.330602532 +0100
@@ -0,0 +1,1267 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX restraint(struct mtd_data_s *mtd_data)
+{
+  int i_c, ncv, nth, ntrh, ntp, rpxm, ntwg;                    // indexes for cycles and time
+
+  hills.Vhills = cvw.Vwall = Vext = Vrecon = Vconstr = Vsteerplan = 0.;  // Hills,  Walls , Constraint, external potential and steerplan energy initialization
+
+  colvar.it=mtd_data->istep;                                   // update microdynamics step
+  if(colvar.it==mtd_data->istep_old){
+    logical.not_same_step=0;
+  } else {
+    logical.not_same_step=1;
+    mtd_data->istep_old=colvar.it;
+  }
+
+  ncv  = colvar.nconst;                                                                           	                  // number of CVs
+  ntp  = (logical.not_same_step)&&(logical.print)&&(!(colvar.it%colvar.nt_print));			                  // have I got to print COLVAR?
+  nth  = ( (logical.not_same_step)&&(logical.do_hills)&&(!(colvar.it%hills.nt_hills))&&(!firstTime) )
+         || (hills.max_height>0);              									          // have I got to add HILL?
+  ntrh = (logical.not_same_step)&&(logical.do_hills)&&(!(colvar.it%hills.nr_hills))&&(logical.do_walkers)&&(!firstTime) ; // period in steps to read HILLS
+  ntwg = (logical.write_grid)&&(logical.not_same_step)&&(!(colvar.it%grid.w_stride))&&(!firstTime);                       // write GRID on file
+
+#ifdef PLUMED_GROMACS
+  set_pbc(&mtd_data->metapbc, mtd_data->ePBC, mtd_data->cell);                                              // set pbc
+#endif
+
+
+
+  if(logical.rpxm) rpxm = !(colvar.it%mtd_data->repl_ex_nst) && (logical.not_same_step);                    // have I got a replica exchange trial
+  else rpxm = 0;
+  if(logical.debug){						// debug is a GROMACS global which identifies
+    test_derivatives(mtd_data);		                       // the use of -debug options in mdrun
+    #ifdef RECONMETAD
+     #ifndef DRIVER
+       if( reconOn==1 ){test_recon_derivatives(mtd_data);}    // Reconnaissance metadynamics version of test derivatives
+     #endif
+    #endif  
+    EXIT();			        // allow for only one step of dynamics
+  }
+
+// eventually align atoms
+  if(colvar.align_atoms){
+     int i,iatom1,iatom2;
+     real distance[3],dummy;
+     for(i=0;i<colvar.align_atoms-1;i++){
+       iatom1=colvar.align_list[i];
+       iatom2=colvar.align_list[i+1];
+       minimal_image(mtd_data->pos[iatom2],mtd_data->pos[iatom1],&dummy,distance);
+       mtd_data->pos[iatom2][0]=mtd_data->pos[iatom1][0]+distance[0];
+       mtd_data->pos[iatom2][1]=mtd_data->pos[iatom1][1]+distance[1];
+       mtd_data->pos[iatom2][2]=mtd_data->pos[iatom1][2]+distance[2];
+     }
+   };
+
+// eventually dump atoms
+#ifdef PLUMED_GROMACS
+  if(mtd_data->dump_atoms && (logical.not_same_step)&&(!(colvar.it%mtd_data->dump_stride)) ){
+    rvec* atoms;
+    int i,iat;
+    if(!mtd_data->dump_file) mtd_data->dump_file = open_xtc(mtd_data->dump_filen,"w");
+    snew(atoms,mtd_data->dump_atoms);
+    for(i=0;i<mtd_data->dump_atoms;i++){
+      iat=mtd_data->dump_list[i];
+      atoms[i][0]=mtd_data->pos[iat][0];
+      atoms[i][1]=mtd_data->pos[iat][1];
+      atoms[i][2]=mtd_data->pos[iat][2];
+    };
+    write_xtc(mtd_data->dump_file,mtd_data->dump_atoms,colvar.it,mtd_data->time,mtd_data->cell,atoms,1000.0);
+    sfree(atoms);
+  };
+#endif
+
+  // this cycle is intended to calculate CVs values and derivatives
+
+  for(i_c=0;i_c<ncv;i_c++){
+    colvar.ff_hills[i_c] = 0.;                 	// initialization hills forces
+    cvw.fwall[i_c]       = 0.;  		// initialization walls forces
+    fext[i_c]            = 0.;                  // initialization external forces
+
+//    if((!logical.always[i_c])&&(logical.rpxm)&&(!rpxm)&&(!ntp)) continue;
+    if((!logical.always[i_c])&&(!ntp)) {   //if a variable is used only for printing purposes and it isn't the time to print then
+      if(logical.rpxm) {
+        if((!rpxm)&&(!firstTime)) continue;  //if we are doing bias-exchange and it isn't the time for an exchange we could avoid to calculate the variable
+      } else continue; //if we are not doing bias-exchange we could avoid to calculate the variable
+      // but if we are doing bias-exchange and it is time to try an axchange we must calculate all the variables
+    }
+
+    //fprintf(mtd_data->fplog,"CALCULATING CV %d\n",i_c); 
+    //fflush(mtd_data->fplog); 
+
+    switch(colvar.type_s[i_c]){
+      // geometric CVs
+      case 1: dist_restraint(i_c, mtd_data); break;			// DISTANCE
+      case 2: mindist_restraint(i_c, mtd_data); break;               	// MINDIST
+      case 3: coord_restraint(i_c, mtd_data); break;	              	// COORD
+      case 4: angle_restraint(i_c, mtd_data); break;	                // ANGLE
+      case 5: torsion_restraint(i_c, mtd_data); break;                  // TORSION
+      case 6: alfabeta_restraint(i_c, mtd_data); break;                	// ALPHA-BETA
+      // interaction CVs
+      case 7: hbonds_restraint(i_c, mtd_data); break;                   // HBONDS
+      case 8: dipole_restraint(i_c, mtd_data); break;       		// DIPOLE
+      // conformations CVs
+      case 11: radgyr_restraint(i_c, mtd_data); break;   	       	// RGYR
+      case 16: dihcor_restraint(i_c, mtd_data); break;                 	// DIHEDRAL-COR
+      // water CVs
+      case 20: waterbridge_restraint(i_c, mtd_data); break;            	// WATERBRIDGE
+      // trajectory CVs
+      case 30: spath_restraint(i_c, mtd_data); break;                   // S_MAPPATH
+      case 31: zpath_restraint(i_c, mtd_data); break;                   // Z_MAPPATH
+      case 32: position_restraint(i_c, mtd_data); break;                // ATOM POSITION
+      case 33: elstpot_restraint(i_c, mtd_data); break;                 // ELSTPOT POSITION
+      case 34: puckering_restraint(i_c, mtd_data); break;               // PUCKERING
+      case 35: energy_restraint(i_c, mtd_data); break;                  // ENERGY
+      case 36: helix_restraint(i_c, mtd_data); break;                   // HELIX
+      case 37: alpharmsd_restraint(i_c, mtd_data); break;               // ALPHARMSD
+      case 38: antibetarmsd_restraint(i_c, mtd_data); break;            // ANTIBETARMSD
+      case 39: parabetarmsd_restraint(i_c, mtd_data); break;            // PARABETARMSD
+      //case 40: camshift_restraint(i_c, mtd_data); break;              // CAMSHIFT ENERGY
+      //case 41: camshiftens_restraint(i_c, mtd_data); break;           // ENS CAMSHIFT ENERGY
+      case 42: pca_restraint(i_c, mtd_data); break;      		// PCA PROJECTION
+      case 45: cmap_restraint(i_c, mtd_data); break;                    // CMAP 
+#if defined CVS  
+      case 46: bespoke_restraint(i_c, mtd_data); break;                 // BESPOKE COLLECTIVE COORDINATES
+#endif
+      case 47: rdf_restraint(i_c, 1, mtd_data); break;                  // DISCRETIZED RDF
+      case 49: histogram_restraint(i_c, mtd_data); break;               // HISTOGRAM CV
+      case 50: poly_restraint(i_c, mtd_data); break;			// POLYNOMIAL COMBINATION
+      case 51: func_restraint(i_c, mtd_data); break;			// GENERAL FUNC OF CVS 
+      case 52: adf_restraint(i_c, 1, mtd_data); break;                  // DISCRITIZED ANGLE DISTRIBUTION FUNCTION 
+	  case 53: msd_restraint(i_c,  mtd_data); break;    	
+      case 55: sprint_restraint(i_c, mtd_data); break;                  // SPRINT TOPOLOGICAL CV
+    }
+
+#ifdef PATHREF_FINDIFF
+    fprintf(mtd_data->fplog,"|---CALLING THE TEST \n");
+    //finite difference tests over reference frame derivatives
+        if(colvar.type_s[i_c]==30){pathref_findiff(i_c,mtd_data);}
+        if(colvar.type_s[i_c]==31){pathref_findiff(i_c,mtd_data);}
+    fprintf(mtd_data->fplog,"|---END OF CALL \n");
+    EXIT();
+#endif
+
+  }
+
+  mtd_data->time=colvar.it*(mtd_data->dt)+mtd_data->time_offset;
+
+  if(logical.commit) commit_analysis();     // committors analysis
+	
+  if(couplingmatrix.is_on) calc_couplingmatrix(colvar.it);	
+
+  // this is the really dynamics code in which we calculate hills forces and then forces on CVs.
+  if(logical.do_hills){
+    hills_force();						// compute hills force and energy
+    if(logical.widthadapt) hills_adapt();			// to adapt gaussian width
+    if(nth) {
+      hills_add(mtd_data);                                      // add HILL
+    } 
+    if(ntrh) {
+       read_hills(mtd_data,0,hills.first_read);              	// is it time to read_hills?
+       hills.first_read = 0;
+    }
+    if(ntwg)  grid_write_tofile(&grid);                         // write GRID on file
+  }
+
+  cvw.Vwall=soft_walls_engine(colvar.ss0,cvw.fwall);                // Wall potential
+
+  Vext=ext_forces_engine(colvar.ss0,&extpot,fext);              // External potential
+
+  cvw.Vwall+=steer_engine(colvar.ss0,cvw.fwall);                // Wall potential
+  
+  cvw.Vwall+=abmd_engine(colvar.ss0,cvw.fwall);                // Wall potential
+
+  if (logical.do_dafed) dafed_engine(colvar.ss0);	       // #### d-AFED
+
+  cvw.Vwall+=tamd_engine(colvar.ss0,cvw.fwall);                // TAMD/DAFED temperarily added here
+  
+  if (logical.do_constraint) Vconstr+=constraint_engine(mtd_data->dt);            // shake on the cvs 
+
+  stopwhen_engine(); // kill the run in specific points
+  
+  if(logical.do_steerplan)steerplan_engine();               // steerplan to plan adaptive us and more! 
+
+  apply_forces(mtd_data);
+
+  if(logical.debug_derivatives) debug_derivatives(mtd_data,ntp);
+
+  if(colvar.pg.nlist!=0)calc_projections( &(colvar.pg)); 
+
+  if(ntp) print_colvar_enercv(mtd_data->time);	        	// dump COLVAR
+
+  if(firstTime)firstTime = 0;			                // the first PluMed step 
+
+}
+
+//------------------------------------------------------------------------------------------
+
+real PREFIX soft_walls_engine(real* ss0,real* force){
+  // Wall potential: V_wall(s) = sigma*((s-s0+offset)/redux)**n
+  // WARNING: n must be even, sigma>0, redux>0; offset>0; s0 can be positive or negative
+  real uscale,lscale,uexp,lexp;
+  real V;
+  int i;
+  V=0.;
+  for(i=0;i<colvar.nconst;i++){
+    if(force) force[i]=0.0;
+    if(logical.upper[i]) {                                                      // if there is a soft wall on this cv
+      uscale = (ss0[i]-cvw.upper[i]+cvw.uoff[i])/cvw.ueps[i];                   // calculates the position on the wall 
+      if(uscale>0.) {
+        uexp = (real) cvw.uexp[i];
+        V+=cvw.sigma[i]*pow(uscale, cvw.uexp[i]);
+        if(force) force[i]+=-(cvw.sigma[i]/cvw.ueps[i])*uexp*pow(uscale, cvw.uexp[i]-1);
+      }
+    }
+    if(logical.lower[i]) {                                                      // if there is a soft wall on this cv
+      lscale = (ss0[i]-cvw.lower[i]-cvw.loff[i])/cvw.leps[i];                   // calculates the position on the wall
+      if(lscale<0.) {
+        lexp = (real) cvw.lexp[i];
+        V+=cvw.lsigma[i]*pow(lscale, cvw.lexp[i]);
+        if(force) force[i]+=-(cvw.lsigma[i]/cvw.leps[i])*lexp*pow(lscale, cvw.lexp[i]-1);
+      }
+    }
+  };
+  return V;
+};
+  
+//-------------------------------------------------------------------------------------------
+
+real PREFIX tamd_engine(real* ss0,real* force)
+{
+  real V,tmp;
+  int i_c;
+  V=0.0;
+  if(logical.tamd) for(i_c=0;i_c<colvar.nconst;i_c++)if(colvar.on[i_c]){
+    real tmp;
+    real ff0,ff1;
+    if(firstTime){
+// Dummy variable is initialized at the physical temperature
+      real c2=sqrt(mtd_data.boltz*tamd.starttemp/tamd.spring[i_c]);
+      tmp=c2*rando_gaussian(&tamd.seed);
+      tamd.pos[i_c]=ss0[i_c] + tmp;
+      fprintf(mtd_data.fplog,"|- TAMD/DAFED %d CV : STARTVALUE %f\n",i_c+1,tamd.pos[i_c]);
+      fflush(mtd_data.fplog);
+      ff0=ff1=tamd.spring[i_c]*tmp;
+    } else {
+      tmp=-ss0[i_c]+tamd.pos[i_c];
+      if(colvar.type_s[i_c]==5 || ( colvar.type_s[i_c]==34 && colvar.type[i_c]==2 )) {
+                       if(tmp > M_PI)
+                         tmp -= 2.*M_PI;
+                       if(tmp < -M_PI)
+                        tmp += 2.*M_PI;
+      } 
+      real h0,h1;
+      ff0=tamd.spring[i_c]*tmp;
+      h0=0.5*tamd.spring[i_c]*tmp*tmp;
+      real c1=exp(-mtd_data.dt/tamd.tau);
+      real c2=sqrt(mtd_data.boltz*tamd.wtemp/tamd.spring[i_c])*(1.0-c1*c1);
+      tmp=c1*tmp + c2*rando_gaussian(&tamd.seed);
+      ff1=tamd.spring[i_c]*tmp;
+      h1=0.5*tamd.spring[i_c]*tmp*tmp;
+      tamd.pos[i_c]=ss0[i_c] + tmp;
+      tamd.drift+=(h1-h0)*(1/tamd.simtemp-1/tamd.wtemp)/mtd_data.boltz;
+    }
+    real ff=0.5*(ff1+ff0);
+    V+=0.5*tamd.spring[i_c]*tmp*tmp;
+    if(force) force[i_c] += ff;
+  }
+  return V;
+};
+
+real PREFIX steer_engine(real* ss0,real* force)
+{ 
+  real V, tmp;
+  real dpos;	 // ### increment in steering reference position.
+  real ff=0.;
+  int i_c;
+#ifdef STANDALONE
+  FILE *file;
+  char *str, stringa[800], filename[100];
+#endif
+
+  V=0.0;
+  dpos=0.0;     // ### initializing properly is important for dpos
+
+  for(i_c=0;i_c<colvar.nconst;i_c++) if(logical.steer[i_c]){
+
+    if(firstTime){
+      if(cvsteer.impose_start[i_c] == 0) cvsteer.pos[i_c] = cvsteer.start[i_c] = ss0[i_c];
+      else cvsteer.pos[i_c] = cvsteer.start[i_c];
+
+      fprintf(mtd_data.fplog,"|- STEERING %d CV : STARTVALUE %f\n",i_c+1,cvsteer.start[i_c]);
+      fflush(mtd_data.fplog);
+ 
+      if(cvsteer.max[i_c] < cvsteer.start[i_c]) cvsteer.sign[i_c] = -1; 
+      else cvsteer.sign[i_c] = +1;
+
+      // check if you're there since the beginning
+      if(cvsteer.pos[i_c]==cvsteer.max[i_c]) {
+        fprintf(mtd_data.fplog,"|- STEERING %d CV ARRIVED TO TARGET POINT %f in %d STEPS\n",i_c+1,cvsteer.max[i_c],colvar.it);
+        fflush(mtd_data.fplog);
+      } 
+
+      // #### Initialize work
+      cvsteer.work[i_c]= 0.0;
+      cvsteer.old_force[i_c]= 0.0;
+
+#ifdef STANDALONE
+      sprintf(filename, "STEER.%d.rst",i_c);
+      file = fopen(filename,"w");
+      fprintf(file,"%lf  %lf",cvsteer.start[i_c],cvsteer.pos[i_c]);
+      fclose(file);
+#endif
+    } else { // increase when you're not at the first step 
+#ifdef STANDALONE 
+      // open the file 
+      sprintf(filename, "STEER.%d.rst",i_c); 
+      file = fopen(filename,"r");
+      if(file==NULL){
+        char buf[1024];
+        sprintf(buf,"Cannot read %s  : EXITING\n",filename);
+        plumed_error(buf);
+      } else {
+        str = fgets(stringa, 800, file); 
+        sscanf(str, "%lf %lf",&cvsteer.start[i_c],&cvsteer.pos[i_c]);  
+        fprintf(mtd_data.fplog,"|- STEERING %d CV RESTARTED FROM POINT: %f  STARTED: %f\n",i_c+1,cvsteer.pos[i_c],cvsteer.start[i_c]);  
+        fclose(file);
+        if(cvsteer.max[i_c] < cvsteer.start[i_c]){
+          cvsteer.sign[i_c] = -1; 
+        } else {
+          cvsteer.sign[i_c] = +1;
+        } 
+      }
+      if((logical.not_same_step) && fabs(cvsteer.pos[i_c]-cvsteer.start[i_c])<fabs(cvsteer.max[i_c]-cvsteer.start[i_c])) {
+        // #### Introduce variable dpos used for work
+        dpos =    cvsteer.sign[i_c] * cvsteer.delta[i_c] / 1000.0;
+        cvsteer.pos[i_c] += dpos;
+      }
+      sprintf(filename, "STEER.%d.rst",i_c); 
+      file = fopen(filename,"w");
+      fprintf(file,"%lf  %lf",cvsteer.start[i_c],cvsteer.pos[i_c]);
+      fclose(file); 
+#else
+      if((logical.not_same_step) && fabs(cvsteer.pos[i_c]-cvsteer.start[i_c])<fabs(cvsteer.max[i_c]-cvsteer.start[i_c])) {
+        // #### Introduce variable dpos used for work
+	dpos =  cvsteer.sign[i_c] * cvsteer.delta[i_c] / 1000.0;
+    	cvsteer.pos[i_c] += dpos ;
+      }
+#endif
+    } 
+    if(fabs(cvsteer.pos[i_c]-cvsteer.start[i_c])>fabs(cvsteer.max[i_c]-cvsteer.start[i_c])) {
+      cvsteer.pos[i_c] = cvsteer.max[i_c];
+      fprintf(mtd_data.fplog,"|- STEERING %d CV ARRIVED TO TARGET POINT %f in %d STEPS\n",i_c+1,cvsteer.max[i_c],colvar.it);  
+      fflush(mtd_data.fplog); 
+    }
+    /* HERE PUT THE PERIODICITY YOU NEED!!!!!!!! */ 
+    tmp = ss0[i_c]-cvsteer.pos[i_c];
+    if(colvar.type_s[i_c]==5 || ( colvar.type_s[i_c]==34 && colvar.type[i_c]==2 )) {
+      if(tmp > M_PI) tmp -= 2.*M_PI;
+      if(tmp < -M_PI) tmp += 2.*M_PI;
+    }
+    if(cvsteer.annealing[i_c]>0.) { 
+      ff = -(cvsteer.annealing[i_c]/mtd_data.temp_t)*cvsteer.spring[i_c]*tmp-(cvsteer.annealing[i_c]/mtd_data.temp_t)*cvsteer.slope[i_c];
+      V += 0.5*(cvsteer.annealing[i_c]/mtd_data.temp_t)*cvsteer.spring[i_c]*tmp*tmp+cvsteer.slope[i_c]*(cvsteer.annealing[i_c]/mtd_data.temp_t)*tmp;
+    } else {
+      ff = -cvsteer.spring[i_c]*tmp - cvsteer.slope[i_c];
+      V += 0.5*cvsteer.spring[i_c]*tmp*tmp + cvsteer.slope[i_c]*tmp;
+    }
+    if(force) force[i_c] += ff;
+
+    // #### Work integration with trapeze scheme
+    cvsteer.work[i_c] += 0.5 * dpos * (ff + cvsteer.old_force[i_c]);
+    // Alternatively, one could use :
+    // work += 0.5 * k * dpos * [  ss0 + ss0_old  - 2*pos + dpos  ]
+    cvsteer.old_force[i_c] = ff;
+  }
+  return V;
+}
+
+//---------------------------------------------------------------------------------------------
+
+real PREFIX abmd_engine(real* ss0, real* force)
+{
+  real V, ff;
+  int i_c;
+
+  V=0.0;
+  for(i_c=0;i_c<colvar.nconst;i_c++)if(logical.abmd[i_c]){
+
+    abmd.now[i_c] = (ss0[i_c]-abmd.exp[i_c])*(ss0[i_c]-abmd.exp[i_c]);
+
+    if(firstTime&&!logical.restart_abmd) abmd.min[i_c] = abmd.now[i_c];
+
+    if(abmd.now[i_c]<abmd.min[i_c]) abmd.min[i_c] = abmd.now[i_c];
+    else {
+      ff = -2.*abmd.spring[i_c]*(abmd.now[i_c]-abmd.min[i_c])*(ss0[i_c]-abmd.exp[i_c]);
+      if(force) force[i_c] += ff;
+      V += 0.5*abmd.spring[i_c]*(abmd.now[i_c]-abmd.min[i_c])*(abmd.now[i_c]-abmd.min[i_c]);
+    }
+
+  }
+  return V;
+}
+
+//---------------------------------------------------------------------------------------------
+
+real PREFIX ext_forces_engine(real* ss0, struct grid_s *grid, real* force)
+{
+  real Vex = 0.0;
+
+  if(logical.do_external) Vex=grid_getstuff(grid,ss0,force);
+
+  return Vex;
+}
+
+//------------------------------------------------------------------------------
+
+void PREFIX init_print_colvar_enercv()
+{
+/*
+  In this routine we print the headers for the COLVAR file.
+*/
+  int i_c, nactive;
+  FILE* cv_file;
+  cv_file = fopen((mtd_data.ionode?mtd_data.colfilen:"/dev/null"), "a");
+  fprintf(cv_file, "%s", "#! FIELDS");
+  fprintf(cv_file, "%s", " time");
+  for(i_c=0;i_c<colvar.nconst;i_c++) fprintf(cv_file, " cv%i", i_c+1);
+#ifdef CVS
+  if( colvar.nbespoke > 0 ){ fprintf(cv_file, " bespoke_error"); }
+#endif
+  if (logical.do_hills) fprintf(cv_file, " vbias");
+  if (logical.do_walls) fprintf(cv_file, " vwall");
+  if (logical.do_constraint) fprintf(cv_file, " vconstr");
+  if (logical.do_steerplan)  fprintf(cv_file, " vstp");
+  if (logical.do_external) fprintf(cv_file, " vext");
+#ifdef RECONMETAD
+#ifndef DRIVER
+//  if( reconOn==1 && reconinpt.monitor!=1 ){ fprintf(cv_file, " vrecon"); }
+//  if( reconOn==1 && reconinpt.monitor==1 ){ fprintf(cv_file, " current_basin"); }
+  if( reconOn==1 ){ fprintf(cv_file, " vrecon"); }  
+#endif
+#endif
+  for(i_c=0;i_c<colvar.nconst;i_c++){  if(logical.steer[i_c]){fprintf(cv_file," XX XX RST%d WORK%d",i_c+1,i_c+1);} }
+  for(i_c=0;i_c<colvar.nconst;i_c++){  if(logical.abmd[i_c]){fprintf(cv_file," XX XX ABMD%d ",i_c+1);} }
+  for(i_c=0;i_c<colvar.nconst;i_c++){  if(logical.cnstr[i_c]){fprintf(cv_file," XX XX CONSTRPOS%d CONSTRENE%d ",i_c+1,i_c+1);} }
+  if (logical.do_steerplan){ fprintf(cv_file,"%s",steerplan.log)   ;}; 
+  if (colvar.pg.nlist!=0)  fprintf(cv_file, "%s",colvar.pg.log ); 
+  for(i_c=0;i_c<colvar.nconst;i_c++){  if(logical.dafed[i_c]){
+    fprintf(cv_file," dAFED%dS dAFED%dT dAFED%dE dAFED%dW ",i_c+1,i_c+1,i_c+1,i_c+1);} }
+  for(i_c=0;i_c<colvar.nconst;i_c++){  if(logical.tamd && colvar.on[i_c]){fprintf(cv_file," TAMD%d ",i_c+1);} }
+  if(logical.tamd) {fprintf(cv_file," TAMD_drift ");};
+// end of headers
+  fprintf(cv_file,"\n");
+// list active CVs (useful e.g. for bias-exchange post-processing)
+  if(strlen(colvar.hills_label)>0){
+    nactive=0;
+    for(i_c=0;i_c<colvar.nconst;i_c++){ if(colvar.on[i_c]) nactive++; }
+    fprintf(cv_file, "#! ACTIVE %d",nactive);
+    if(nactive>0) {
+      for(i_c=0;i_c<colvar.nconst;i_c++){ if(colvar.on[i_c]) fprintf(cv_file, " %d",i_c+1); }
+    }
+    fprintf(cv_file, " %s",colvar.hills_label); 
+    fprintf(cv_file,"\n");
+  }
+// close COLVAR file
+  fclose(cv_file);
+}
+
+void PREFIX print_colvar_enercv(real time_s)
+{
+    int i, i_c; // real consRecon=0.;
+    static FILE *cv_file=NULL;
+
+// This will allow us to build a conserved quantity for reconnaissance metadynamics
+// #ifdef RECONMETAD
+//    if( reconOn==1 ) consRecon=getCons_recon( myreconObj );
+// #endif
+
+//#ifdef RECONMETAD 
+//#ifndef DRIVER
+//    int current_basin=0; 
+//    if( reconOn==1 && reconinpt.monitor==1 ){
+//      double welikedupes_s[reconinpt.nconst];
+//      for(i=0;i<reconinpt.nconst;i++) welikedupes_s[i]=colvar.ss0[reconinpt.cvlist[i]];
+//      current_basin=dometa_monitor( reconinpt.nconst, welikedupes_s, myreconObj ); 
+//    } 
+//#endif
+//#endif
+
+    if(!cv_file) cv_file = fopen((mtd_data.ionode?mtd_data.colfilen:"/dev/null"), "a");
+/*
+ATTENTION: all the quantities written here should be consistent with the header written in init_print_colvar_enercv()
+In this way the new colvar format will work properly
+To keep the new fmt equivalent to the old one (at least for a transition time)
+we leave here also the "comments" such as "RST 3". These numbers are labeled with XX
+in the header, and at some point will be removed.
+*/
+    fprintf(cv_file, "%10.4f", time_s);
+    for(i_c=0;i_c<colvar.nconst;i_c++) fprintf(cv_file, "   %14.9f", colvar.ss0[i_c]);
+#ifdef CVS
+    real bespoke_err=0.; //double cv_in[colvar.bespoke_ncv];
+    if( colvar.nbespoke > 0 ){ 
+//       for(i=0;i<colvar.bespoke_ncv;i++){ cv_in[i]=colvar.ss0[ colvar.bespoke_cvlist[i] ]; }
+       bespoke_err=calculate_bespoke_error( mybespokeObj );
+       fprintf(cv_file, "   %14.9f", bespoke_err); 
+    }
+#endif
+    if (logical.do_hills) fprintf(cv_file, " %14.9f ",hills.Vhills/mtd_data.eunit);
+    if (logical.do_walls) fprintf(cv_file, " %14.9f ",cvw.Vwall/mtd_data.eunit);
+    if (logical.do_constraint) fprintf(cv_file, "  %14.9f ",Vconstr/mtd_data.eunit);
+    if (logical.do_steerplan) fprintf(cv_file, "  %14.9f ",Vsteerplan/mtd_data.eunit);
+    if (logical.do_external) fprintf(cv_file, "  %14.9f ",Vext/mtd_data.eunit);
+#ifdef RECONMETAD
+#ifndef DRIVER
+    if( reconOn==1 ){ fprintf(cv_file, "   %14.9f", Vrecon/mtd_data.eunit ); }
+//    if( reconOn==1 && reconinpt.monitor!=1 ){ fprintf(cv_file, "   %14.9f", Vrecon/mtd_data.eunit ); }
+//    if( reconOn==1 && reconinpt.monitor==1 ){ fprintf(cv_file, "   %14d", current_basin ); }
+#endif
+#endif
+    for(i_c=0;i_c<colvar.nconst;i_c++){  if(logical.steer[i_c]){fprintf(cv_file," RST %d %14.9f %20.9lf",i_c+1,cvsteer.pos[i_c], cvsteer.work[i_c] );} }
+    for(i_c=0;i_c<colvar.nconst;i_c++){  if(logical.abmd[i_c]){fprintf(cv_file," ABMD %d %14.9f ",i_c+1, abmd.min[i_c] );} }
+    for(i_c=0;i_c<colvar.nconst;i_c++){  if(logical.cnstr[i_c]){fprintf(cv_file," CONSTR %d %14.9f %20.9lf ",i_c+1,cvcnstr.pos[i_c],cvcnstr.energy[i_c]);} }
+    if(logical.do_steerplan)fprintf(cv_file,"%s",steerplan.log)  ;
+    if(colvar.pg.nlist!=0)  fprintf(cv_file, "%s",colvar.pg.log ); 
+    for(i_c=0;i_c<colvar.nconst;i_c++){ if(logical.dafed[i_c]){ print_dafed(&dafed[i_c], cv_file, i_c); } }
+    for(i_c=0;i_c<colvar.nconst;i_c++){  if(logical.tamd && colvar.on[i_c]){fprintf(cv_file," %14.9f ",tamd.pos[i_c]);} }
+    if(logical.tamd) {fprintf(cv_file," %14.9f ",tamd.drift);};
+    fprintf(cv_file, "\n");
+    fflush(cv_file);
+#ifdef STANDALONE 
+    fclose(cv_file);
+#endif
+}
+
+//-----------------------------------------------------------------------------------------------------------------------------
+
+void PREFIX commit_analysis()
+{
+  int i, a, b, ix;
+  FILE *commit_file;
+
+  if(firstTime){
+    commit_file = fopen((mtd_data.ionode?"COMMIT":"/dev/null"), "a");
+    for(i=0;i<colvar.nconst;i++) fprintf(commit_file, "   %14.7f", colvar.ss0[i]);
+    fclose(commit_file);
+  }
+
+  a = 0;
+  b = 0;
+  for(i=0;i<commit.ncv;i++){
+    ix=commit.index[i];
+    if(commit.Amin[ix]<colvar.ss0[ix] && colvar.ss0[ix]<commit.Amax[ix]) a++;
+    if(commit.Bmin[ix]<colvar.ss0[ix] && colvar.ss0[ix]<commit.Bmax[ix]) b++;
+  }
+
+  if(a==commit.ncv || b==commit.ncv) {
+    fprintf(mtd_data.fplog, "|- SYSTEM HAS REACHED AN ENDING REGION\n");
+    logical.commit = 0;
+    commit_file = fopen((mtd_data.ionode?"COMMIT":"/dev/null"), "a");
+    if(a==commit.ncv) fprintf(commit_file, " A \n");
+    if(b==commit.ncv) fprintf(commit_file, " B \n");
+    fclose(commit_file);
+#ifdef PLUMED_GROMACS45
+    gmx_set_stop_condition(1); 
+#else
+    EXIT();
+#endif
+  }
+}
+
+//----------------------------------------------------------------------------------------------------------------------
+void PREFIX apply_forces(struct mtd_data_s *mtd_data )
+{
+  real ddr, uscale, lscale, dsdt, nor, fact;
+  int ix, i, iat, wall,i_c;
+  #ifdef NAMD
+  Vector f;   
+  #endif 
+
+#ifdef RECONMETAD
+#ifndef DRIVER
+   // Setup an array to contain the derivatives from reconnaissance metadynamics
+   real recon_der[colvar.nconst]; for(i=0;i<colvar.nconst;i++) recon_der[i]=0.0;
+   if( reconOn==1 ){                             // && reconinpt.monitor!=1 ){
+      double welikedupes_s[reconinpt.nconst], welikedupes_d[reconinpt.nconst];
+      // Transfer colvars from plumed arrays to dummy array for reconnaissance
+      for(i=0;i<reconinpt.nconst;i++) welikedupes_s[i]=colvar.ss0[reconinpt.cvlist[i]];
+      // Do the reconnaissance calculation
+      real ene; ene=dometa_recon(colvar.it, reconinpt.nconst, welikedupes_s, welikedupes_d, myreconObj);
+      // Transfer energy and derivatives to plumed arrays
+      Vrecon+=ene; for(i=0;i<reconinpt.nconst;i++) recon_der[reconinpt.cvlist[i]]=welikedupes_d[i]; 
+   } 
+#endif
+#endif
+
+// set to zero all forces
+#ifndef PLUMED_GROMACS
+  for(i=0;i<mtd_data->natoms;i++){
+    mtd_data->force[i][0] = 0.0; 
+    mtd_data->force[i][1] = 0.0;
+    mtd_data->force[i][2] = 0.0;
+  }  
+#endif
+
+  for(i_c=0;i_c<colvar.nconst;i_c++){
+
+    ddr = colvar.ff_hills[i_c] + cvw.fwall[i_c] + fext[i_c]	// hills, soft wall and external contribution
+          +   (real) dafed[i_c].f;               // #### d-AFED contribution
+
+#ifdef RECONMETAD
+#ifndef DRIVER
+//    if( reconOn==1 && reconinpt.monitor!=1 ) ddr+= recon_der[i_c];      // Reconnaissance metadynamics forces
+    if( reconOn==1 ) ddr+=recon_der[i_c];      // Reconnaissance metadynamics forces
+#endif
+#endif
+
+    if(logical.cnstr[i_c]) ddr-=cvcnstr.lambdadt2[i_c];         // constraint
+
+#ifdef PLUMED_GROMACS
+    if(colvar.type_s[i_c]==35) {colvar.d_0[i_c]=ddr; continue;}  // Don't apply force here, do it where you have dd information
+#endif
+
+    for(i=0;i<colvar.natoms[i_c];i++) {
+      iat = colvar.cvatoms[i_c][i];
+#ifdef NAMD 
+       f.x=ddr*colvar.myder[i_c][i][0];
+       f.y=ddr*colvar.myder[i_c][i][1];
+       f.z=ddr*colvar.myder[i_c][i][2];
+       addForce(iat,f);
+#else
+      mtd_data->force[iat][0] += ddr*colvar.myder[i_c][i][0];     // PluMeD forces
+      mtd_data->force[iat][1] += ddr*colvar.myder[i_c][i][1];
+      mtd_data->force[iat][2] += ddr*colvar.myder[i_c][i][2];
+#endif    
+    }
+  }
+}
+//
+// this engine SHAKEs  the needed d.o.f. (one by one, not interwined)  
+// based on Frenkel's book
+//
+real PREFIX constraint_engine(real tstep0){
+  real tstep;
+  int go,i,i_c,iat,niter,j;
+  real ***posc,***newposc,***velc,***oldposc,***startder;
+  FILE *fp;
+  char *str,string[100]; 
+  real **hack_pos1,totene;
+  real lambdadt2,tmp,totlambdadt2;
+  char buf[200]; 
+  // check whether constraining else skip
+
+
+  go=0;
+  for(i_c=0;i_c<colvar.nconst;i_c++){
+     if(logical.cnstr[i_c]){go=1;}
+  }
+  if(go==0){return 0.;}
+
+  totene=0.;
+
+   //sprintf(buf,"|- ENTERING CONSTRAINING NST %d DT %f \n",mtd_data.istep,tstep );
+   //plumed_warn(buf);
+# ifdef AMBER
+   tstep=tstep0; 
+#else
+   tstep=tstep0; 
+#endif
+
+
+  // first step: do the mallocs ( always in STANDALONE ) 
+
+#ifndef STANDALONE
+  if(mtd_data.istep==0){
+#endif
+
+    cvcnstr.newposc  =(real ***)malloc(colvar.nconst*sizeof(real **));
+    cvcnstr.oldposc  =(real ***)malloc(colvar.nconst*sizeof(real **));
+    cvcnstr.velc     =(real ***)malloc(colvar.nconst*sizeof(real **));
+    cvcnstr.posc     =(real ***)malloc(colvar.nconst*sizeof(real **));
+    cvcnstr.startder =(real ***)malloc(colvar.nconst*sizeof(real **));
+    cvcnstr.go       =(int *)malloc(colvar.nconst*sizeof(int));
+    cvcnstr.oldcv    =(real *)malloc(colvar.nconst*sizeof(real));
+
+// amber uses its own force vector
+
+// standalone needs alloc
+# if defined (STANDALONE)
+    cvcnstr.oldforce =(real *)malloc(mtd_data.natoms*3*sizeof(real));
+#endif
+
+    for(i_c=0;i_c<colvar.nconst;i_c++){
+       if(logical.cnstr[i_c]==1){
+         cvcnstr.posc[i_c]       =float_2d_array_alloc(mtd_data.natoms,3); 
+         cvcnstr.newposc[i_c]    =float_2d_array_alloc(mtd_data.natoms,3); 
+         cvcnstr.oldposc[i_c]    =float_2d_array_alloc(mtd_data.natoms,3); 
+         cvcnstr.velc[i_c]       =float_2d_array_alloc(mtd_data.natoms,3); 
+         cvcnstr.startder[i_c]   =float_2d_array_alloc(mtd_data.natoms,3); 
+       }   
+    } 
+
+#ifndef STANDALONE
+  }
+#endif
+  // alias those names 
+  posc   =cvcnstr.posc;
+  newposc=cvcnstr.newposc;
+  oldposc=cvcnstr.oldposc;
+  velc=cvcnstr.velc;
+  startder=cvcnstr.startder;
+  // assign positions
+  for(i_c=0;i_c<colvar.nconst;i_c++){
+        //fprintf(mtd_data.fplog,"PP %d \n",colvar.natoms[i_c]);  
+       if(logical.cnstr[i_c]==1){
+          cvcnstr.go[i_c]=1;
+          cvcnstr.oldcv[i_c]=colvar.ss0[i_c];
+          for(i=0;i<colvar.natoms[i_c];i++){
+               iat = colvar.cvatoms[i_c][i];
+               posc[i_c][iat][0]=mtd_data.pos[iat][0]; 
+               posc[i_c][iat][1]=mtd_data.pos[iat][1]; 
+               posc[i_c][iat][2]=mtd_data.pos[iat][2]; 
+               startder[i_c][i][0]=colvar.myder[i_c][i][0]; 
+               startder[i_c][i][1]=colvar.myder[i_c][i][1]; 
+               startder[i_c][i][2]=colvar.myder[i_c][i][2]; 
+          }
+       }
+  }
+  if(mtd_data.istep==0){
+  // first step: put velocity to zero, put old position to the actual one 
+    for(i_c=0;i_c<colvar.nconst;i_c++){
+       if(logical.cnstr[i_c]==1){
+              for(i=0;i<colvar.natoms[i_c];i++){
+                   iat = colvar.cvatoms[i_c][i];
+                   oldposc[i_c][iat][0]=posc[i_c][iat][0]; 
+                   oldposc[i_c][iat][1]=posc[i_c][iat][1]; 
+                   oldposc[i_c][iat][2]=posc[i_c][iat][2]; 
+              }
+       }
+     }
+  }
+   
+#ifdef STANDALONE
+  // if standalone check if velocity is available from yout software
+  fp = fopen("f.xyz","r");
+//  sprintf(buf,"|- TAKING FORCE FILE \n");
+//  plumed_warn(buf);
+ 
+  if( fp ) {
+    // exists
+    i=0;
+    while(1){
+       str=fgets(string,100,fp);
+       if(str==NULL)break;
+       if(feof(fp))break;
+   //    plumed_warn(str);
+       str = strtok( string, " \t" );
+       cvcnstr.oldforce[i*3+0]=atof(str);
+       str=strtok(NULL," \t");
+       cvcnstr.oldforce[i*3+1]=atof(str);
+       str=strtok(NULL," \t");
+       cvcnstr.oldforce[i*3+2]=atof(str);
+       str=strtok(NULL," \t");
+       i++; 
+    } 
+    if(i!=mtd_data.natoms){ plumed_error("|- FORCE FILE DOES NOT MATCH THE NUMBER OF ATOMS ");}
+    fclose(fp);
+  } else {
+    plumed_error("|- NEED FOR FORCE FILE  \n");
+  } 
+//  sprintf(buf," TAKING VEL FILE \n");
+//  plumed_warn(buf);
+ 
+  fp = fopen("v.xyz","r");
+  if( fp ) {
+    // exists
+    for(i_c=0;i_c<colvar.nconst;i_c++){
+       if(logical.cnstr[i_c]==1){
+          i=0;
+          while(1){
+             str=fgets(string,100,fp);
+             if(str==NULL)break;
+             if(feof(fp))break;
+          //   plumed_warn(str);
+             str = strtok( string, " \t" );
+             cvcnstr.velc[i_c][i][0]=atof(str);
+             str=strtok(NULL," \t");
+             cvcnstr.velc[i_c][i][0]=atof(str);
+             str=strtok(NULL," \t");
+             cvcnstr.velc[i_c][i][0]=atof(str);
+             str=strtok(NULL," \t");
+             i++;
+          } 
+          if(i!=mtd_data.natoms){ plumed_error("|- VELOCITY FILE DOES NOT MATCH THE NUMBER OF ATOMS \n");}
+          rewind(fp);
+       } 
+    }
+    fclose(fp);
+  } else {
+    // doesnt exist ! old positions?
+//    sprintf(buf," TAKING OLDPOS FILE \n");
+//    plumed_warn(buf);
+ 
+    fp = fopen("oldx.xyz","r");
+    if( fp ) {
+      for(i_c=0;i_c<colvar.nconst;i_c++){
+          if(logical.cnstr[i_c]==1){
+             i=0;
+             while(1){
+                str=fgets(string,100,fp);
+                if(str==NULL)break;
+                if(feof(fp))break;
+             //   plumed_warn(str);
+                str = strtok( string, " \t" );
+                oldposc[i_c][i][0]=atof(str);
+                str=strtok(NULL," \t");
+                oldposc[i_c][i][0]=atof(str);
+                str=strtok(NULL," \t");
+                oldposc[i_c][i][0]=atof(str);
+                str=strtok(NULL," \t");
+                i++;
+             } 
+             if(i!=mtd_data.natoms){ plumed_error("|- VELOCITY FILE DOES NOT MATCH THE NUMBER OF ATOMS \n");}
+          }
+       }
+       fclose(fp);
+       for(i_c=0;i_c<colvar.nconst;i_c++){
+           if(logical.cnstr[i_c]==1){
+                  for(i=0;i<colvar.natoms[i_c];i++){
+                       iat = colvar.cvatoms[i_c][i];
+                       velc[i_c][iat][0]=(posc[i_c][iat][0]-oldposc[i_c][iat][0])/tstep; 
+                       velc[i_c][iat][1]=(posc[i_c][iat][1]-oldposc[i_c][iat][1])/tstep; 
+                       velc[i_c][iat][2]=(posc[i_c][iat][2]-oldposc[i_c][iat][2])/tstep; 
+
+                       //fprintf(mtd_data.fplog,"|- %d V %f %f %f\n",i,velc[i_c][iat][0],velc[i_c][iat][1],velc[i_c][iat][2]);
+                       //fprintf(mtd_data.fplog,"|- %d P %f %f %f\n",i,posc[i_c][iat][0],posc[i_c][iat][1],posc[i_c][iat][2]);
+                       // save the old constraint derivative: pay attention on the derivative ordering
+                  }
+           }
+       } 
+    } else {
+       plumed_error("|- CONSTRAINT NOT POSSIBLE WITHOUT EITHER OLD POSITION OR ACTUAL VELOCITIES \n");
+    }
+  }
+#else
+  // calculate velocity through finite difference (take this as default)
+  for(i_c=0;i_c<colvar.nconst;i_c++){
+      if(logical.cnstr[i_c]==1){
+             for(i=0;i<colvar.natoms[i_c];i++){
+                  iat = colvar.cvatoms[i_c][i];
+// take all the time the findiff so to be sure
+//#ifdef AMBER
+	// take velocity from the right vector
+        //          velc[i_c][iat][0]=cvcnstr.oldvel[iat*3+0]; 
+        //          velc[i_c][iat][1]=cvcnstr.oldvel[iat*3+1]; 
+        //          velc[i_c][iat][2]=cvcnstr.oldvel[iat*3+2]; 
+//#else
+	// take velocity from finite differences 
+                  velc[i_c][iat][0]=(posc[i_c][iat][0]-oldposc[i_c][iat][0])/tstep; 
+                  velc[i_c][iat][1]=(posc[i_c][iat][1]-oldposc[i_c][iat][1])/tstep; 
+                  velc[i_c][iat][2]=(posc[i_c][iat][2]-oldposc[i_c][iat][2])/tstep; 
+//#endif
+             }
+      }
+  }  
+
+#endif
+ 
+  for(i_c=0;i_c<colvar.nconst;i_c++){
+     if(logical.cnstr[i_c]==1){
+
+           if(cvcnstr.verbose[i_c]==1){sprintf(buf," DOING CONSTRAINTS ON CV %d INIT VAL: %f ",i_c+1,cvcnstr.oldcv[i_c]);
+           plumed_warn(buf);}
+           niter=0;
+           totlambdadt2=0.;
+           while(cvcnstr.go[i_c]){// check on threshold value
+              tmp=cvcnstr.spring[i_c]*(cvcnstr.oldcv[i_c]-cvcnstr.pos[i_c]); // fake constraint spring gradient 
+              for(i=0;i<colvar.natoms[i_c];i++){
+                  iat = colvar.cvatoms[i_c][i];
+                  // make a velocity verlet free evolution (assume the units are congruent)
+                  //  r_n= r_o +v dt - 0.5 * dt**2 * F
+                  for (j=0;j<3;j++){
+#if defined (AMBER)  || defined (STANDALONE)
+// time evolution for known codes 
+                     newposc[i_c][iat][j]=posc[i_c][iat][j]+  velc[i_c][iat][j]*tstep+ 
+                           0.5 * tstep *tstep * 
+                     (cvcnstr.oldforce[iat*3+j])  / mtd_data.mass[iat]       
+                     - totlambdadt2*tmp*startder[i_c][i][j]/mtd_data.mass[iat];
+
+// I do not know this code
+#else
+                     sprintf(buf," CONSTRAINTS NOT IMPLEMENTED IN THIS PROGRAM ");
+                     plumed_error(buf);
+#endif            
+                  }
+                  
+              }
+              //calculate the constraint value
+              
+              // do an hack : unlock the address from mtd_data.pos and redirict to an identical vector newposc[i_c]    
+
+              hack_pos1=mtd_data.pos; // remember this address
+              mtd_data.pos=newposc[i_c]; //calculate now with this coordinates 
+              switch(colvar.type_s[i_c]){
+                  // geometric CVs
+                  case 1: dist_restraint(i_c, &mtd_data); break;			// DISTANCE
+                  case 2: mindist_restraint(i_c, &mtd_data); break;               	// MINDIST
+                  case 3: coord_restraint(i_c, &mtd_data); break;	              	// COORD
+                  case 4: angle_restraint(i_c, &mtd_data); break;	                // ANGLE
+                  case 5: torsion_restraint(i_c, &mtd_data); break;                  // TORSION
+                  case 6: alfabeta_restraint(i_c, &mtd_data); break;                	// ALPHA-BETA
+                  // interaction CVs
+                  case 7: hbonds_restraint(i_c, &mtd_data); break;                   // HBONDS
+                  case 8: dipole_restraint(i_c, &mtd_data); break;       		// DIPOLE
+                  // conformations CVs
+                  case 11: radgyr_restraint(i_c, &mtd_data); break;   	       	// RGYR
+                  case 16: dihcor_restraint(i_c, &mtd_data); break;                 	// DIHEDRAL-COR
+                  // water CVs
+                  case 20: waterbridge_restraint(i_c, &mtd_data); break;            	// WATERBRIDGE
+                  // trajectory CVs
+                  case 30: spath_restraint(i_c, &mtd_data); break;                   // S_MAPPATH
+                  case 31: zpath_restraint(i_c, &mtd_data); break;                   // Z_MAPPATH
+                  case 32: position_restraint(i_c, &mtd_data); break;                // ATOM POSITION
+                  case 33: elstpot_restraint(i_c, &mtd_data); break;                 // ELSTPOT POSITION
+                  case 34: puckering_restraint(i_c, &mtd_data); break;               // PUCKERING
+                  case 35: energy_restraint(i_c, &mtd_data); break;                  // ENERGY
+                  case 36: helix_restraint(i_c, &mtd_data); break;                   // HELIX
+                  case 37: alpharmsd_restraint(i_c, &mtd_data); break;               // ALPHARMSD
+                  case 38: antibetarmsd_restraint(i_c, &mtd_data); break;            // ANTIBETARMSD
+                  case 39: parabetarmsd_restraint(i_c, &mtd_data); break;            // PARABETARMSD
+                  //case 40: camshift_restraint(i_c, &mtd_data); break;              // CAMSHIFT ENERGY
+#ifdef CVS
+                  case 46: bespoke_restraint(i_c, &mtd_data); break;                 // BESPOKE COLLECTIVE COORDINATES
+#endif
+                  case 47: rdf_restraint(i_c, 1, &mtd_data); break;                  // DISCRETIZED RDF
+                  case 49: histogram_restraint(i_c, &mtd_data); break;               // HISTOGRAM CV
+                  case 52: adf_restraint(i_c, 1, &mtd_data); break;                  // DISCRITIZED ANGLE DISTRIBUTION FUNCTION
+                  case 55: sprint_restraint(i_c, &mtd_data); break;                   // SPRINT TOPOLOGICAL CV
+              }
+
+              mtd_data.pos=hack_pos1;  
+              //return     
+              //calculate lambda*deltat*deltat 
+              tmp=0.;
+              for(i=0;i<colvar.natoms[i_c];i++){
+                 iat = colvar.cvatoms[i_c][i];
+                 tmp+=startder[i_c][i][0]*colvar.myder[i_c][i][0]/mtd_data.mass[iat];
+                 tmp+=startder[i_c][i][1]*colvar.myder[i_c][i][1]/mtd_data.mass[iat];
+                 tmp+=startder[i_c][i][2]*colvar.myder[i_c][i][2]/mtd_data.mass[iat];
+              }   
+              // calculate new lambda
+              lambdadt2=(colvar.ss0[i_c]-cvcnstr.pos[i_c])/(cvcnstr.oldcv[i_c]-cvcnstr.pos[i_c]);
+              lambdadt2/=2*cvcnstr.spring[i_c];
+              lambdadt2/=tmp;
+              // die?
+              tmp=sqrt((colvar.ss0[i_c]-cvcnstr.pos[i_c])*(colvar.ss0[i_c]-cvcnstr.pos[i_c]));  
+              if(cvcnstr.verbose[i_c]==1) fprintf(mtd_data.fplog,"|- totlambdadt2 %12.6f lambdadt2 %12.6f tmp %12.6f POS %12.6f CV %12.6f NITER %4d STEP %8.3f\n",totlambdadt2,lambdadt2,tmp,cvcnstr.pos[i_c],colvar.ss0[i_c],niter,tstep);
+
+              //
+              // KILL THE ITERATION:
+              //
+              if(tmp<cvcnstr.delta[i_c])cvcnstr.go[i_c]=0;
+              if(niter>cvcnstr.maxiter[i_c])cvcnstr.go[i_c]=0;  
+
+              // apply it  (put here because it allows for a simpler debug when compared with my guineapig program) 
+              //if ( cvcnstr.go[i_c]!=0 )totlambdadt2+=lambdadt2;
+              totlambdadt2+=lambdadt2;
+
+              niter++;
+           }    
+           cvcnstr.lambdadt2[i_c]=totlambdadt2*2.*cvcnstr.spring[i_c]*(cvcnstr.oldcv[i_c]-cvcnstr.pos[i_c])/(tstep*tstep); 
+           if(cvcnstr.verbose[i_c]==1){sprintf(buf," DONE CONSTRAINT ON CV %d LAMBDA %f ITER %d ",i_c+1,cvcnstr.lambdadt2[i_c],niter);
+           cvcnstr.energy[i_c]=totlambdadt2*pow(cvcnstr.oldcv[i_c]-cvcnstr.pos[i_c],2)/(tstep*tstep); 
+           totene+=cvcnstr.energy[i_c];
+           plumed_warn(buf);}
+     }
+  }
+  // put the actual position as the old position
+  for(i_c=0;i_c<colvar.nconst;i_c++){
+     if(logical.cnstr[i_c]==1){
+        colvar.ss0[i_c]=cvcnstr.oldcv[i_c];
+        for(i=0;i<colvar.natoms[i_c];i++){
+             iat = colvar.cvatoms[i_c][i];
+             oldposc[i_c][iat][0]=posc[i_c][iat][0]; 
+             oldposc[i_c][iat][1]=posc[i_c][iat][1]; 
+             oldposc[i_c][iat][2]=posc[i_c][iat][2]; 
+             colvar.myder[i_c][i][0]=startder[i_c][i][0];
+             colvar.myder[i_c][i][1]=startder[i_c][i][1];
+             colvar.myder[i_c][i][2]=startder[i_c][i][2];
+        }
+     }
+  }
+  //sprintf(buf,"|- EXITING CONSTRAINING \n");
+  //plumed_warn(buf);
+ 
+  return totene;
+};
+ 
+void PREFIX steerplan_engine()
+{ 
+   int i,j,k,l,m,thisstage,nextstage,mycv; 
+   real time,x1,x2,k1,k2,deltat,tmp,force;
+   time=mtd_data.time;
+   //fprintf(mtd_data.fplog,"|- STEERPLAN_ON TIME %f FIRSTTIME %d\n",time,firstTime);
+
+   //char string2[200],string[200];
+   //for(i=0;i<steerplan.totstages;i++){
+   //    fprintf(mtd_data.fplog,"|- TIME: %12.6f  ",steerplan.actions[i].t);  
+   //    for(j=0;j<steerplan.ncvs;j++){
+   //      if(steerplan.actions[i].activecv[j].wildcardpos){
+   //       sprintf(string,"*");
+   //      }else {
+   //       sprintf(string,"%12.6f",steerplan.actions[i].activecv[j].pos);
+   //      }
+   //      if(steerplan.actions[i].activecv[j].wildcardk){
+   //       sprintf(string2,"*");
+   //      }else {
+   //       sprintf(string2,"%12.6f",steerplan.actions[i].activecv[j].k);
+   //      }
+   //      if(steerplan.actions[i].activecv[j].k<0){
+   //           fprintf(mtd_data.fplog," CV %3d SKIPPING THIS STAGE... ",(steerplan.actions[i].activecv[j].ncv+1));
+   //      }else{
+   //           fprintf(mtd_data.fplog," CV %3d KAPPA %12s POS %12s ",steerplan.actions[i].activecv[j].ncv+1,string2,string);
+   //      }
+   //    }
+   //    fprintf(mtd_data.fplog,"\n");  
+   //}
+ 
+   // firsttime: define the initial stage and the time for the nextone 
+   // which stage I am? New one? calculate new params
+#ifdef STANDALONE 
+        FILE *file;
+        char filename[100],sstr[100] ;
+        char *str, stringa[800];
+        char buf[1024];
+        // open the file 
+        if(!firstTime){
+          sprintf(filename, "STEERPLAN.rst"); 
+          file = fopen(filename,"r");
+          if(file==NULL){
+            sprintf(buf,"Cannot read %s  : EXITING\n",filename);
+            plumed_error(buf);
+          }else{
+            str = fgets(sstr, 100, file); 
+            sscanf(str,"%lf",&steerplan.nextstage_time);
+            for(i=0;i<steerplan.ncvs;i++){
+                 str = fgets(sstr, 100, file); 
+                 sscanf(sstr,"%lf %lf %lf %lf %d",&steerplan.actualcv[i].k,&steerplan.actualcv[i].kv,&steerplan.actualcv[i].x0,&steerplan.actualcv[i].v,&steerplan.actualcv[i].type);
+            }
+            fclose(file);
+          }
+        }
+#endif
+   if(time>=steerplan.nextstage_time||firstTime){
+       for(i=0;i<steerplan.totstages;i++){
+           if(steerplan.actions[i].t>=time){steerplan.current_stage=i;
+              if((i+1)!=steerplan.totstages){steerplan.nextstage_time=steerplan.actions[i+1].t;}
+              else{steerplan.nextstage_time=1.e9;} 
+           break;} 
+       }
+       fprintf(mtd_data.fplog,"|- CURRENT STAGE %d  \n",steerplan.current_stage);
+       // setup the run
+       thisstage=steerplan.current_stage;
+       for(i=0;i<steerplan.ncvs;i++){
+          mycv=steerplan.actions[thisstage].activecv[i].ncv;
+          // is this a skipped stage for this cv?
+          if (steerplan.actions[thisstage].activecv[i].k<0){// bypass and keep the values 
+                 fprintf(mtd_data.fplog,"|- STEERPLAN CV  %d :NOTHING TO UPDATE TO AT THIS STAGE. I'LL GO ON AS BEFORE\n",steerplan.actions[thisstage].activecv[i].ncv+1);
+               // if firstime you don't specify any action this is taken as k=0 pos=* type=1 v=0.  action
+               // case1: coming  from nowhere: default is put k=0 (no effective potential)
+              if(firstTime){
+                       steerplan.actualcv[i].k=0.;
+                       steerplan.actualcv[i].v=0.;
+                       steerplan.actualcv[i].kv=0.;
+                       steerplan.actualcv[i].x0=colvar.ss0[mycv];
+                       steerplan.actualcv[i].type=1;
+                       // keeep nowhere
+              }
+          }else{ // scan to the next stages to find the following pinpoints if any
+                 fprintf(mtd_data.fplog,"|- STEERPLAN CV  %d SCANNING FOR THE NEXT ACTION\n",steerplan.actions[thisstage].activecv[i].ncv+1);
+                 // case2: going to  nowhere: default is keep the old restraint (static: v=0.)
+                 // this happens when the list is over or when all the k are <0  
+                 if(thisstage==steerplan.totstages-1){
+             //    fprintf(mtd_data.fplog,"1 THISSTAGE %d TOTSTAGES %d\n",thisstage,steerplan.totstages);
+                       if(!steerplan.actions[thisstage].activecv[i].wildcardk){steerplan.actualcv[i].k=steerplan.actions[thisstage].activecv[i].k;}
+                       steerplan.actualcv[i].v=0.;
+                       steerplan.actualcv[i].kv=0.;
+                       if(steerplan.actions[thisstage].activecv[i].wildcardpos){
+                                steerplan.actualcv[i].x0=colvar.ss0[mycv]; 
+                       }
+                       else{ steerplan.actualcv[i].x0=steerplan.actions[thisstage].activecv[i].pos;}
+                       steerplan.actualcv[i].type=steerplan.actions[thisstage].activecv[i].type;
+                 }else{ 
+                       for(j=thisstage+1;j<steerplan.totstages;j++){
+                    //       fprintf(mtd_data.fplog,"XXCV %d K %f WC %d\n",mycv+1,steerplan.actions[j].activecv[i].k,steerplan.actions[j].activecv[i].wildcardk);
+                           if((steerplan.actions[j].activecv[i].k>=0.) || (steerplan.actions[j].activecv[i].wildcardk==1)){
+                           break;} // got it!!!!
+                       } 
+                       if(j==steerplan.totstages){//no more actions to take! 
+                           if(!steerplan.actions[thisstage].activecv[i].wildcardk){steerplan.actualcv[i].k=steerplan.actions[thisstage].activecv[i].k;}
+                           steerplan.actualcv[i].v=0.;
+                           steerplan.actualcv[i].kv=0.;
+                           if(steerplan.actions[thisstage].activecv[i].wildcardpos){
+                               steerplan.actualcv[i].x0=colvar.ss0[mycv];
+                           }
+                           else{ steerplan.actualcv[i].x0=steerplan.actions[thisstage].activecv[i].pos;}
+                           steerplan.actualcv[i].type=steerplan.actions[thisstage].activecv[i].type;
+                    //       fprintf(mtd_data.fplog,"2 THISSTAGE %d TOTSTAGES %d\n",thisstage,steerplan.totstages);
+                       }else{ 
+                    //      fprintf(mtd_data.fplog,"3 THISSTAGE %d TOTSTAGES %d\n",thisstage,steerplan.totstages);
+                          deltat=(steerplan.actions[j].t-steerplan.actions[thisstage].t)/mtd_data.dt;              
+                          // copy the actual center (wildcard?) : start from the actual real cv 
+                          if(steerplan.actions[thisstage].activecv[i].wildcardpos){steerplan.actualcv[i].x0=colvar.ss0[mycv];}
+                          else{ steerplan.actualcv[i].x0=steerplan.actions[thisstage].activecv[i].pos;}
+                          // copy the next center (wildcard?) : start from the previous center!!!
+                          if(steerplan.actions[j].activecv[i].wildcardpos){
+                              steerplan.actualcv[i].v=0.;   
+                              steerplan.actualcv[i].nowhere=1;
+                          }
+                          else { 
+                             x1=steerplan.actualcv[i].x0; 
+                             x2=steerplan.actions[j].activecv[i].pos  ;
+                             steerplan.actualcv[i].v=(x2-x1)/deltat   ;
+                             steerplan.actualcv[i].nowhere=0;
+                          };
+ 
+                           // copy the actual k (wildcard? dont do anything ) 
+                          if(!steerplan.actions[thisstage].activecv[i].wildcardk){steerplan.actualcv[i].k=steerplan.actions[thisstage].activecv[i].k;}
+                          // copy the next k (wildcard?) : keep this one 
+                          if(steerplan.actions[j].activecv[i].wildcardk){k2=steerplan.actions[thisstage].activecv[i].k;}
+                          else { k2=steerplan.actions[j].activecv[i].k  ;};
+                          k1=steerplan.actualcv[i].k;
+                          steerplan.actualcv[i].kv=(k2-k1)/deltat   ;
+                          steerplan.actualcv[i].type=steerplan.actions[thisstage].activecv[i].type;
+                     //     fprintf(mtd_data.fplog,"XXX CV %d X1 %f X2 %f K1 %f K2 %f \n",steerplan.actions[thisstage].activecv[i].ncv+1,x1,x2,k1,k2); 
+                       } 
+                 } 
+                  
+          }
+       }
+   }else{// evolove normally
+      for(i=0;i<steerplan.ncvs;i++){
+            steerplan.actualcv[i].k=steerplan.actualcv[i].k+steerplan.actualcv[i].kv;
+            steerplan.actualcv[i].x0=steerplan.actualcv[i].x0+steerplan.actualcv[i].v;
+            if(steerplan.actualcv[i].nowhere){
+                     mycv=steerplan.actions[steerplan.current_stage].activecv[i].ncv;
+                     steerplan.actualcv[i].x0=colvar.ss0[mycv]; 
+            }
+
+      }      
+   }
+#ifdef STANDALONE
+       sprintf(filename,"STEERPLAN.rst");
+       file = fopen(filename,"w");
+       fprintf(file,"%lf\n",steerplan.nextstage_time);
+       for(i=0;i<steerplan.ncvs;i++){
+            fprintf(file,"%lf %lf %lf %lf %d\n",steerplan.actualcv[i].k,steerplan.actualcv[i].kv,steerplan.actualcv[i].x0,steerplan.actualcv[i].v,steerplan.actualcv[i].type);
+       }
+       fclose(file);
+#endif
+
+   // create a log string
+   strcpy(steerplan.log," STP ");
+   char cvlog[100]; 
+   for(i=0;i<steerplan.ncvs;i++){
+          mycv=steerplan.actions[steerplan.current_stage].activecv[i].ncv;
+          //fprintf(mtd_data.fplog,"|- STEERPLAN CV  %d : \n",steerplan.actions[steerplan.current_stage].activecv[i].ncv+1);
+          //fprintf(mtd_data.fplog,"|- X  %12.6f XV %12.6f  K %12.6f KV %12.6f  \n",steerplan.actualcv[i].x0,steerplan.actualcv[i].v,steerplan.actualcv[i].k,steerplan.actualcv[i].kv);
+          sprintf(cvlog," CV %2d X %12.6f K %12.6f T %1d ",mycv+1,steerplan.actualcv[i].x0,steerplan.actualcv[i].k,steerplan.actualcv[i].type);
+          strcat(steerplan.log,cvlog);
+   }  
+   //fprintf(mtd_data.fplog,"%s\n",steerplan.log);
+
+    // now the plan is fine: do what you need!!
+
+   for(i=0;i<steerplan.ncvs;i++){
+      mycv=steerplan.actions[steerplan.current_stage].activecv[i].ncv; 
+      tmp=colvar.ss0[mycv]-steerplan.actualcv[i].x0;
+        
+      if(steerplan.actualcv[i].type==2){
+         // positive: wall only if positive
+         if(tmp<0.)tmp=0.;
+      } else if (steerplan.actualcv[i].type==3){
+         // negative: wall only if negative 
+         if(tmp>0.)tmp=0.;
+      } 
+      if(colvar.type_s[mycv]==5 || ( colvar.type_s[mycv]==34 && colvar.type[mycv]==2 )){
+                       if(tmp > M_PI)
+                         tmp -= 2.*M_PI;
+                       if(tmp < -M_PI)
+                        tmp += 2.*M_PI;
+      } 
+      //force = -steerplan.actualcv[i].k*tmp;
+      steerplan.actualcv[i].force = -steerplan.actualcv[i].k*tmp;
+      steerplan.actualcv[i].energy = steerplan.actualcv[i].k*tmp*tmp*0.5;
+      cvw.fwall[mycv] +=  steerplan.actualcv[i].force ;
+      Vsteerplan  +=  steerplan.actualcv[i].k*tmp*tmp*0.5; 
+   } 
+
+//   fprintf(mtd_data.fplog,"|- STEERPLAN_ON END\n");
+}
+
+//---------------------------------------------------------------------------------------------
+void PREFIX stopwhen_engine (){
+    int i;
+    int stop;
+    stop=0;
+    for(i=0;i<colvar.nconst;i++){
+      if(stopwhen.actmin[i]){
+              if(colvar.ss0[i]<stopwhen.min[i]){
+                  fprintf(mtd_data.fplog, "|-PLUMED STOPWHEN:\n" );
+                  fprintf(mtd_data.fplog, "|-NOW KILLING BEGAUSE CV  %d IS LESS THAN %f :ACTUAL VALUE IS %f \n",i+1,stopwhen.min[i],colvar.ss0[i] );
+                  fflush(mtd_data.fplog);
+                  stop=1;
+              }
+      }
+      if(stopwhen.actmax[i]){
+              if(colvar.ss0[i]>stopwhen.max[i]){
+                  fprintf(mtd_data.fplog, "|-PLUMED STOPWHEN:\n" );
+                  fprintf(mtd_data.fplog, "|-NOW KILLING BEGAUSE CV  %d IS MORE THAN %f : ACTUAL VALUE IS %f \n",i+1,stopwhen.max[i],colvar.ss0[i] );
+                  fflush(mtd_data.fplog);
+                  stop=1;
+              }
+      }
+    } 
+    if(stop){
+#ifdef PLUMED_GROMACS45
+                  gmx_set_stop_condition(1); 
+#else
+                  EXIT();
+#endif
+    }
+}
+//---------------------------------------------------------------------------------------------
+
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_cmap.c dl_class_1.9/srcmod/Plumed/restraint_cmap.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_cmap.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_cmap.c	2015-11-07 17:37:19.337602735 +0100
@@ -0,0 +1,282 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+
+#include "metadyn.h"
+
+void  PREFIX cmap_restraint(int i_c, struct mtd_data_s *mtd_data) {
+
+  int    iat, i, tot_con;
+  struct sz_data *pmy_sz;
+  struct cmap_inpack inpack;
+  real   cmap;
+  int    jj,k,j,ii,jjj,iii;
+  int    tot;
+  real   tmp4_r0_0,tmp4_r0_1,tmp4_r0_2;
+  real   tmp2_r0,tmp3_r0, dist_r0;
+  real   tmp1,tmp2,tmp3;
+  real   pow_P, pow_Q, R01;
+  int    P1,Q1;
+  rvec   rij;
+
+
+  cmap = 0.;
+  pmy_sz=&my_sz_list[ic_to_sz[i_c]];
+                                                         
+  for (i=0;i<colvar.natoms[i_c];i++){
+               iat = colvar.cvatoms[i_c][i];
+               inpack.r0[i][0] = mtd_data->pos[iat][0];
+               inpack.r0[i][1] = mtd_data->pos[iat][1];
+               inpack.r0[i][2] = mtd_data->pos[iat][2];
+  }
+
+  cmap_running(i_c, &inpack,&pmy_sz->my_cmap_pack);
+
+  tot_con=pmy_sz->my_cmap_pack.number+pmy_sz->my_cmap_pack.gnumber;        
+  for(i=0;i<tot_con;i++) cmap += inpack.cmap[i];
+
+  colvar.ss0[i_c] = cmap; 
+
+// derivatives calculation
+  for(i=0;i<colvar.natoms[i_c];i++) {
+     colvar.myder[i_c][i][0] = 0.;
+     colvar.myder[i_c][i][1] = 0.; 
+     colvar.myder[i_c][i][2] = 0.;
+  }
+
+  for(j=0;j<pmy_sz->my_cmap_pack.number;j++){
+   if(pmy_sz->my_cmap_pack.weight[j]!=0){
+     ii=pmy_sz->my_cmap_pack.index_from1[j];
+     jj=pmy_sz->my_cmap_pack.index_from2[j];
+
+     if(colvar.cell_pbc[i_c]){
+       minimal_image(inpack.r0[ii], inpack.r0[jj], &dist_r0, rij);
+     } else {
+       rij[0] = inpack.r0[ii][0]-inpack.r0[jj][0];
+       rij[1] = inpack.r0[ii][1]-inpack.r0[jj][1];
+       rij[2] = inpack.r0[ii][2]-inpack.r0[jj][2];
+       dist_r0=sqrt(pow2(inpack.r0[ii][0]-inpack.r0[jj][0])+
+                 pow2(inpack.r0[ii][1]-inpack.r0[jj][1])+
+                 pow2(inpack.r0[ii][2]-inpack.r0[jj][2]));
+     };
+
+     R01=pmy_sz->my_cmap_pack.r0[j];
+     P1=pmy_sz->my_cmap_pack.nn[j];
+     Q1=pmy_sz->my_cmap_pack.nd[j];
+
+     if(fabs(dist_r0/R01-1.0)<0.00001){
+           colvar.myder[i_c][ii][0]+=rij[0]*P1*(P1-Q1)/Q1;
+           colvar.myder[i_c][ii][1]+=rij[1]*P1*(P1-Q1)/Q1;
+           colvar.myder[i_c][ii][2]+=rij[2]*P1*(P1-Q1)/Q1;
+           colvar.myder[i_c][jj][0]-=rij[0]*P1*(P1-Q1)/Q1;
+           colvar.myder[i_c][jj][1]-=rij[1]*P1*(P1-Q1)/Q1;
+           colvar.myder[i_c][jj][2]-=rij[2]*P1*(P1-Q1)/Q1;
+     } else {
+           power(dist_r0/R01,P1,Q1,&pow_P,&pow_Q);
+
+           tmp2_r0=(Q1*pow_Q*(1.-pow_P)-P1*pow_P*(1.-pow_Q))*R01/dist_r0*pmy_sz->my_cmap_pack.weight[j];
+           tmp3_r0=R01*(1.-pow_Q)*(1.-pow_Q);
+
+           tmp4_r0_0=rij[0]/dist_r0;
+           tmp4_r0_1=rij[1]/dist_r0;
+           tmp4_r0_2=rij[2]/dist_r0;
+
+           tmp1=tmp2_r0*tmp4_r0_0/tmp3_r0;
+           tmp2=tmp2_r0*tmp4_r0_1/tmp3_r0;
+           tmp3=tmp2_r0*tmp4_r0_2/tmp3_r0;
+           colvar.myder[i_c][ii][0]+=tmp1;
+           colvar.myder[i_c][ii][1]+=tmp2;
+           colvar.myder[i_c][ii][2]+=tmp3;
+           colvar.myder[i_c][jj][0]-=tmp1;
+           colvar.myder[i_c][jj][1]-=tmp2;
+           colvar.myder[i_c][jj][2]-=tmp3;
+     }
+   }
+  }
+
+// group contacts
+
+  if(pmy_sz->my_cmap_pack.logical_group){
+   for(j=0;j<pmy_sz->my_cmap_pack.gnumber;j++){
+
+    i=j+pmy_sz->my_cmap_pack.number;
+    ii=pmy_sz->my_cmap_pack.index1[i];
+    jj=pmy_sz->my_cmap_pack.index2[i];
+
+    if(colvar.cell_pbc[i_c]){
+      minimal_image(pmy_sz->my_cmap_pack.group.rcm[ii], pmy_sz->my_cmap_pack.group.rcm[jj], &dist_r0, rij);
+    } else {
+      rij[0] = pmy_sz->my_cmap_pack.group.rcm[ii][0]-pmy_sz->my_cmap_pack.group.rcm[jj][0];
+      rij[1] = pmy_sz->my_cmap_pack.group.rcm[ii][1]-pmy_sz->my_cmap_pack.group.rcm[jj][1];
+      rij[2] = pmy_sz->my_cmap_pack.group.rcm[ii][2]-pmy_sz->my_cmap_pack.group.rcm[jj][2];
+      dist_r0=sqrt(pow2(pmy_sz->my_cmap_pack.group.rcm[ii][0]-pmy_sz->my_cmap_pack.group.rcm[jj][0])+
+                   pow2(pmy_sz->my_cmap_pack.group.rcm[ii][1]-pmy_sz->my_cmap_pack.group.rcm[jj][1])+
+                   pow2(pmy_sz->my_cmap_pack.group.rcm[ii][2]-pmy_sz->my_cmap_pack.group.rcm[jj][2]));
+    };
+
+
+   R01=pmy_sz->my_cmap_pack.r0[i];
+   P1=pmy_sz->my_cmap_pack.nn[i];
+   Q1=pmy_sz->my_cmap_pack.nd[i];
+
+   if(fabs(dist_r0/R01-1.0)<0.00001){
+    for(jjj=0;jjj<pmy_sz->my_cmap_pack.group.numatom[ii];jjj++){
+     iii=pmy_sz->my_cmap_pack.group.index_to_list[ii][jjj];
+     colvar.myder[i_c][iii][0]+=rij[0]*P1*(P1-Q1)/Q1/((real) pmy_sz->my_cmap_pack.group.numatom[ii]);
+     colvar.myder[i_c][iii][1]+=rij[1]*P1*(P1-Q1)/Q1/((real) pmy_sz->my_cmap_pack.group.numatom[ii]);
+     colvar.myder[i_c][iii][2]+=rij[2]*P1*(P1-Q1)/Q1/((real) pmy_sz->my_cmap_pack.group.numatom[ii]);
+    }
+    for(jjj=0;jjj<pmy_sz->my_cmap_pack.group.numatom[jj];jjj++){
+     iii=pmy_sz->my_cmap_pack.group.index_to_list[jj][jjj];
+     colvar.myder[i_c][iii][0]-=rij[0]*P1*(P1-Q1)/Q1/((real) pmy_sz->my_cmap_pack.group.numatom[jj]);
+     colvar.myder[i_c][iii][1]-=rij[1]*P1*(P1-Q1)/Q1/((real) pmy_sz->my_cmap_pack.group.numatom[jj]);
+     colvar.myder[i_c][iii][2]-=rij[2]*P1*(P1-Q1)/Q1/((real) pmy_sz->my_cmap_pack.group.numatom[jj]);
+    }
+
+   }else{
+
+    power(dist_r0/R01,P1,Q1,&pow_P,&pow_Q);
+
+    tmp2_r0=(Q1*pow_Q*(1.-pow_P)-P1*pow_P*(1.-pow_Q))*R01/dist_r0*pmy_sz->my_cmap_pack.weight[i];
+    tmp3_r0=R01*(1.-pow_Q)*(1.-pow_Q);
+
+    tmp4_r0_0=rij[0]/dist_r0;
+    tmp4_r0_1=rij[1]/dist_r0;
+    tmp4_r0_2=rij[2]/dist_r0;
+
+    tmp1=tmp2_r0*tmp4_r0_0/tmp3_r0;
+    tmp2=tmp2_r0*tmp4_r0_1/tmp3_r0;
+    tmp3=tmp2_r0*tmp4_r0_2/tmp3_r0;
+
+    for(jjj=0;jjj<pmy_sz->my_cmap_pack.group.numatom[ii];jjj++){
+     iii=pmy_sz->my_cmap_pack.group.index_to_list[ii][jjj];
+     colvar.myder[i_c][iii][0]+=tmp1/((real) pmy_sz->my_cmap_pack.group.numatom[ii]);
+     colvar.myder[i_c][iii][1]+=tmp2/((real) pmy_sz->my_cmap_pack.group.numatom[ii]);
+     colvar.myder[i_c][iii][2]+=tmp3/((real) pmy_sz->my_cmap_pack.group.numatom[ii]);
+    }
+    for(jjj=0;jjj<pmy_sz->my_cmap_pack.group.numatom[jj];jjj++){
+     iii=pmy_sz->my_cmap_pack.group.index_to_list[jj][jjj];
+     colvar.myder[i_c][iii][0]-=tmp1/((real) pmy_sz->my_cmap_pack.group.numatom[jj]);
+     colvar.myder[i_c][iii][1]-=tmp2/((real) pmy_sz->my_cmap_pack.group.numatom[jj]);
+     colvar.myder[i_c][iii][2]-=tmp3/((real) pmy_sz->my_cmap_pack.group.numatom[jj]);
+    }
+   }
+  }
+ }
+
+
+  return;
+}
+
+// ------------------------------------------------------------------------------------------------
+
+int PREFIX read_cmap(char **word, int count,t_plumed_input *input,FILE *fplog)
+{
+
+  int i,iw;
+  double sigma = 0.0;
+  char file_maps[129];
+  char file_group[129];
+  struct sz_data *my_sz;
+  int help;
+
+  help=0; 
+  colvar.cell_pbc[count]=1; // default is PBC
+
+  my_sz=&(my_sz_list[nsz]);
+  ic_to_sz[count]=nsz;
+
+  my_sz->my_cmap_pack.logical_group = 0; // no GROUP
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &sigma);
+             colvar.delta_r[count]  = (real) sigma; }
+  iw = seek_word(word,"INDEX");
+  if(iw>=0) { sscanf(word[iw+1],"%s", file_maps);
+  } else {
+    fprintf(fplog,"|- NEEDED INDEX KEYWORD FOR CMAP\n");
+    help=1;
+  }
+  iw=seek_word(word,"GROUP");
+  if(iw>=0) {
+   sscanf(word[iw+1],"%s",file_group);
+   my_sz->my_cmap_pack.logical_group = 1;
+  }
+  iw=seek_word(word,"NOPBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 0;}
+  iw=seek_word(word,"PBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 1;}
+
+  if(help){
+         fprintf(fplog,"|- CMAP SYNTAX:\n");
+         fprintf(fplog,"|- INDEX              : contact definition file \n");
+         fprintf(fplog,"|- GROUP              : group definition file \n");
+         fprintf(fplog,"|- SIGMA              : hills width for this cv\n");
+         fprintf(fplog,"|- e.g.\n");
+         fprintf(fplog,"|- \n");
+         fprintf(fplog,"|- CMAP INDEX cmap.index { GROUP cmap.group } { NOPBC } SIGMA 1.0 \n");
+         fprintf(fplog,"|- \n");
+         plumed_error("PluMeD dead with errors: check log file");
+  } 
+
+  
+  fprintf(fplog, "\n%1i-CMAP: INDEX file %s ", count+1, file_maps);
+  if(my_sz->my_cmap_pack.logical_group) fprintf(fplog, " GROUP file %s ", file_group); 
+  if(colvar.cell_pbc[count]) fprintf(fplog, " PBC ON ");
+  else                       fprintf(fplog, " PBC OFF ");
+  if (logical.do_hills){
+        if (colvar.delta_r[count]>0){
+                 fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+        }
+  }
+  else fprintf(fplog,"\n");
+
+
+  read_sz_map(my_sz,file_maps,file_maps,file_group,0,fplog);
+
+  colvar.natoms[count]   = my_sz->my_cmap_pack.atoms; 
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+  snew(colvar.cvatoms[count], colvar.natoms[count]);
+
+  for(i=0;i<colvar.natoms[count];i++)
+    colvar.cvatoms[count][i] = my_sz->my_cmap_pack.list[i];
+  
+  nsz++;
+
+  if(nsz==NMAX_PATH) plumed_error("TOO MANY PATH CVS. Increase NMAX_PATH in metadyn.h and recompile");
+
+  fprintf(fplog,"\n");
+
+  return colvar.natoms[count];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_coord.c dl_class_1.9/srcmod/Plumed/restraint_coord.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_coord.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_coord.c	2015-11-07 17:37:19.340602822 +0100
@@ -0,0 +1,336 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+int coord_step;
+
+void PREFIX coord_newlist(int i_c, struct mtd_data_s *mtd_data)
+{
+  int firstAtom,secondAtom,i,j,iat;
+
+//  fprintf(stderr,"coord_newslist has been called on step %d.\n",coord_step);
+  for (j=0; j<colvar.natoms[i_c]; j++) 
+  { 
+    i = colvar.cvatoms[i_c][j];
+    if(j<colvar.list[i_c][0]) (nlist[i_c]).nn[j]=0; 
+    (nlist[i_c]).base[j][0]=mtd_data->pos[i][0]; 
+    (nlist[i_c]).base[j][1]=mtd_data->pos[i][1]; 
+    (nlist[i_c]).base[j][2]=mtd_data->pos[i][2];
+  }
+
+  
+  rvec rij;
+  real mod_rij;
+  for(i=0;i<colvar.list[i_c][0];i++) {                                           // sum over CoordNumber(i)
+    firstAtom = colvar.cvatoms[i_c][i];
+    for(j=colvar.list[i_c][0];j<colvar.natoms[i_c];j++) {
+      secondAtom = colvar.cvatoms[i_c][j];
+      if(colvar.cell_pbc[i_c]){
+        minimal_image(mtd_data->pos[firstAtom], mtd_data->pos[secondAtom], &mod_rij, rij);
+      } else {
+        rij[0] = mtd_data->pos[firstAtom][0]-mtd_data->pos[secondAtom][0];
+        rij[1] = mtd_data->pos[firstAtom][1]-mtd_data->pos[secondAtom][1];
+        rij[2] = mtd_data->pos[firstAtom][2]-mtd_data->pos[secondAtom][2];
+        mod_rij  = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+      };
+      if (mod_rij<(nlist[i_c]).rskin)
+      {
+//       (nlist[i_c]).ni[i][(nlist[i_c]).nn[i]]=secondAtom;(nlist[i_c]).nn[i]++;
+       (nlist[i_c]).ni[i][(nlist[i_c]).nn[i]]=j;(nlist[i_c]).nn[i]++;
+       if ((nlist[i_c]).nn[i]>=MAXNN) 
+       {
+         char buf[1024];
+         sprintf(buf,"OOPS! Number of neighbours exceeds MAXNN! Change the source and retry! %d \n",(nlist[i_c]).nn[i]);
+         plumed_error(buf); 
+       }
+      }	  
+    }
+//    fprintf(stderr," neig:  %d,%d \n",i,(nlist[i_c]).nn[i]);
+  }
+}
+
+void PREFIX coord_checklist(int i_c, struct mtd_data_s *mtd_data)
+{
+  int i,j; double dr=((nlist[i_c]).rskin-(nlist[i_c]).rcut)*0.5;
+  rvec rij;
+  real mod_rij;
+  for (j=0; j<colvar.natoms[i_c]; j++) 
+  { 
+    i = colvar.cvatoms[i_c][j];
+    if(colvar.cell_pbc[i_c]){
+      minimal_image(mtd_data->pos[i], (nlist[i_c]).base[j], &mod_rij, rij);    //UGLY AS HELL, BUT IT'S DLPOLY'S FAULT
+    } else {
+      rij[0] = mtd_data->pos[i][0]-(nlist[i_c]).base[j][0];
+      rij[1] = mtd_data->pos[i][1]-(nlist[i_c]).base[j][1];
+      rij[2] = mtd_data->pos[i][2]-(nlist[i_c]).base[j][2];
+      mod_rij  = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+    };
+    if( fabs(rij[0])>dr || fabs(rij[1])>dr || fabs(rij[2])>dr ) { coord_newlist(i_c,mtd_data); break; }
+  } 
+}
+
+void PREFIX coord_restraint_nlist(int i_c, struct mtd_data_s *mtd_data)
+{
+
+  int firstAtom, secondAtom, i, j, ix;
+  int nn = colvar.nn[i_c], mm = colvar.mm[i_c];
+  if(coord_step==0) coord_newlist(i_c,mtd_data);
+  ++coord_step; coord_checklist(i_c,mtd_data); 
+
+  rvec rij;
+  real num, iden, mod_rij, rdist, func, dfunc, rNdist, rMdist;
+  real ncoord, r_0 = colvar.r_0[i_c], d_0 = colvar.d_0[i_c];
+  real threshold;
+
+  threshold=pow(0.00001,1./(nn-mm));
+
+  ncoord = 0.;                                                                    
+  for(i=0;i<colvar.natoms[i_c];i++) for(ix=0;ix<3;ix++) colvar.myder[i_c][i][ix] = 0.;
+
+  for(i=0;i<colvar.list[i_c][0];i++) {                                           // sum over CoordNumber(i)
+    firstAtom = colvar.cvatoms[i_c][i];
+    for(j=0;j<(nlist[i_c]).nn[i];j++) {
+//      secondAtom = (nlist[i_c]).ni[i][j];
+      secondAtom = colvar.cvatoms[i_c][(nlist[i_c]).ni[i][j]];
+      if(colvar.cell_pbc[i_c]){
+        minimal_image(mtd_data->pos[firstAtom], mtd_data->pos[secondAtom], &mod_rij, rij);
+      } else {
+        rij[0] = mtd_data->pos[firstAtom][0]-mtd_data->pos[secondAtom][0];
+        rij[1] = mtd_data->pos[firstAtom][1]-mtd_data->pos[secondAtom][1];
+        rij[2] = mtd_data->pos[firstAtom][2]-mtd_data->pos[secondAtom][2];
+        mod_rij  = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+      };
+      rdist = (mod_rij-d_0)/r_0;
+      /* analitic limit of the switching function */
+      if(rdist<=0.){
+       ncoord+=1.;
+       dfunc=0.;
+      }else if(rdist>0.999999 && rdist<1.000001){
+       ncoord+=nn/mm;
+       dfunc=0.5*nn*(nn-mm)/mm;
+      }else if(rdist>threshold){
+       dfunc=0.;
+      }else{
+        rNdist = pow(rdist, nn-1);
+        rMdist = pow(rdist, mm-1);
+        num = 1.-rNdist*rdist;
+        iden = 1./(1.-rMdist*rdist);
+        func = num*iden;
+        ncoord += func;
+        dfunc = ((-nn*rNdist*iden)+(func*(iden*mm)*rMdist))/(mod_rij*colvar.r_0[i_c]);
+      }
+      for(ix=0;ix<3;ix++) {
+        colvar.myder[i_c][i][ix] += +dfunc*rij[ix];
+//        colvar.myder[i_c][j][ix] += -dfunc*rij[ix];
+        colvar.myder[i_c][(nlist[i_c]).ni[i][j]][ix] += -dfunc*rij[ix];
+      }
+    }
+  }
+  colvar.ss0[i_c] = ncoord;
+
+}
+void PREFIX coord_restraint_no_nlist(int i_c, struct mtd_data_s *mtd_data)
+{
+  int firstAtom, secondAtom, i, j, ix;
+  int nn = colvar.nn[i_c], mm = colvar.mm[i_c];
+  rvec rij;
+  real num, iden, mod_rij, rdist, func, dfunc, rNdist, rMdist;
+  real ncoord, r_0 = colvar.r_0[i_c], d_0 = colvar.d_0[i_c];
+  real threshold;
+
+  threshold=pow(0.00001,1./(nn-mm));
+
+  ncoord = 0.;                                                                    
+  for(i=0;i<colvar.natoms[i_c];i++) for(ix=0;ix<3;ix++) colvar.myder[i_c][i][ix] = 0.;
+
+  for(i=0;i<colvar.list[i_c][0];i++) {                                           // sum over CoordNumber(i)
+    firstAtom = colvar.cvatoms[i_c][i];
+    for(j=colvar.list[i_c][0];j<colvar.natoms[i_c];j++) {
+      if(colvar.logic[i_c] == 1 && (j-colvar.list[i_c][0]) != i) continue;
+      secondAtom = colvar.cvatoms[i_c][j];
+      if(colvar.cell_pbc[i_c]){
+        minimal_image(mtd_data->pos[firstAtom], mtd_data->pos[secondAtom], &mod_rij, rij);
+      } else {
+        rij[0] = mtd_data->pos[firstAtom][0]-mtd_data->pos[secondAtom][0];
+        rij[1] = mtd_data->pos[firstAtom][1]-mtd_data->pos[secondAtom][1];
+        rij[2] = mtd_data->pos[firstAtom][2]-mtd_data->pos[secondAtom][2];
+        mod_rij  = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+      };
+      rdist = (mod_rij-d_0)/r_0;
+      /* analitic limit of the switching function */
+      if(rdist<=0.){
+       ncoord+=1.;
+       dfunc=0.;
+      }else if(rdist>0.999999 && rdist<1.000001){
+       ncoord+=nn/mm;
+       dfunc=0.5*nn*(nn-mm)/mm;
+      }else if(rdist>threshold){
+       dfunc=0.;
+      }else{
+        rNdist = pow(rdist, nn-1);
+        rMdist = pow(rdist, mm-1);
+        num = 1.-rNdist*rdist;
+        iden = 1./(1.-rMdist*rdist);
+        func = num*iden;
+        ncoord += func;
+        dfunc = ((-nn*rNdist*iden)+(func*(iden*mm)*rMdist))/(mod_rij*colvar.r_0[i_c]);
+      }
+      for(ix=0;ix<3;ix++) {
+        colvar.myder[i_c][i][ix] += +dfunc*rij[ix];
+        colvar.myder[i_c][j][ix] += -dfunc*rij[ix];
+      }
+    }
+  }
+  colvar.ss0[i_c] = ncoord;
+
+}
+
+void PREFIX coord_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  if(logical.nlist[i_c]){
+    coord_restraint_nlist(i_c,mtd_data);
+  }
+  else{
+    coord_restraint_no_nlist(i_c,mtd_data);
+  }
+}
+//--------------------------------------------------------------------------------------------------------------
+
+int PREFIX read_coord(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i, iw, iat, j, help;
+  double r_0, d_0,r_cut=0.0,r_skin=0.0;
+  double delta = 0.0;
+  char string[400];
+
+  real threshold, value;
+  help=0;
+  d_0=0.;
+
+  colvar.cell_pbc[count]=1; // default is PBC
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0){   
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+             j=plumed_get_group(word[iw+2],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][1]=j;
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR COORD\n"); help=1;}
+  iw=seek_word(word,"PAIR");
+  if(iw>=0) colvar.logic[count] = 1;
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+  iw=seek_word(word,"NN");
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.nn[count]); } else { fprintf(fplog,"|- NEEDED NN KEYWORD FOR COORD\n"); help=1;}
+  iw=seek_word(word,"MM");
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.mm[count]);} else { fprintf(fplog,"|- NEEDED MM KEYWORD FOR COORD\n"); help=1;}
+  iw=seek_word(word,"R_0");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &r_0); } else { fprintf(fplog,"|- NEEDED R_0 KEYWORD FOR COORD\n"); help=1;}
+  iw=seek_word(word,"D_0");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &d_0); }
+  iw=seek_word(word,"R_CUT");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &r_cut);}
+  iw=seek_word(word,"R_SKIN");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &r_skin);} 
+  iw=seek_word(word,"NOPBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 0;}
+  iw=seek_word(word,"PBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 1;}
+
+  if(help){
+          fprintf(fplog, "\n-COORD CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "COORD LIST <g1> <g2>  NN 6 MM 12 R_0 0.75 D_0 3. SIGMA 1.0 \n");
+          fprintf(fplog, "         g1->    \n");
+          fprintf(fplog, "         5 1 6    \n");
+          fprintf(fplog, "         g1<-    \n");
+          fprintf(fplog, "       \n");
+          fprintf(fplog, "         g2->    \n");
+          fprintf(fplog, "         LOOP 6921 21786 5 \n");
+          fprintf(fplog, "         g2<-    \n");
+          fprintf(fplog, "       \n");
+          plumed_error("PluMed dead with errors: check log file");
+  }
+
+  colvar.r_0[count]      = (real) r_0;
+  colvar.d_0[count]      = (real) d_0;
+  colvar.type_s[count]   = 3;
+
+  fprintf(fplog, "%1i-COORDINATION NUMBER OF (1st SET: %i ATOMS) WRT (2nd SET: %i ATOMS); ", count+1, colvar.list[count][0], colvar.list[count][1]);
+  if(colvar.cell_pbc[count]) fprintf(fplog, " PBC ON");
+  else                       fprintf(fplog, " PBC OFF");
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+  fprintf(fplog, "|--FUNCTIONAL FORM: (1-((d_ij-d_0)/r_0)^n) / (1-((d_ij-d_0)/r_0)^m) \n");
+  fprintf(fplog, "|--PARAMETERS: n= %i m= %i r_0= %f d_0= %f\n", colvar.nn[count], colvar.mm[count], colvar.r_0[count], colvar.d_0[count]);
+
+  threshold=pow(0.00001,1./(colvar.nn[count]-colvar.mm[count]));
+  value=(1.-pow(threshold,colvar.nn[count]))/(1.-pow(threshold,colvar.mm[count]));
+  fprintf(fplog, "|--CUTOFF VALUE: %f\n",value);
+  fprintf(fplog, "|--CUTOFF DISTANCE: %f\n",threshold*r_0+d_0);
+  if(colvar.logic[count]) fprintf(fplog,"|--PAIR COORDINATION ACTIVE \n"); 
+  if(colvar.logic[count] == 1 && colvar.list[count][0] != colvar.list[count][1])
+    plumed_error("If PAIR is active <g1> anf <g2> must have the same number of atoms");
+
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  //allocate arrays for internal Verlet lists machinery
+  if(r_cut>0.0 || r_skin>0.0)  
+  {  
+     if (r_cut>=r_skin) plumed_error("R_SKIN MUST BE GREATER THAN R_CUT");
+     if (colvar.logic[count]) plumed_error("PAIR OPTION IS NOT WORKING WITH VERLET LIST");
+     fprintf(fplog, "|--VERLET LIST ACTIVE: R_CUT %lf R_SKIN %lf \n",r_cut,r_skin); 
+     logical.nlist[count]=1;
+     (nlist[count]).rcut=r_cut;  
+     (nlist[count]).rskin=r_skin;  
+     (nlist[count]).base=float_2d_array_alloc(colvar.natoms[count],3);
+     (nlist[count]).nn=(int *) malloc(colvar.list[count][0]*sizeof(int));
+     (nlist[count]).ni=int_2d_array_alloc(colvar.list[count][0],MAXNN);
+     coord_step=0;
+  } 
+  else
+  {fprintf(fplog,"|--VERLET LIST NOT ACTIVE\n");}
+
+  iat=0;
+  fprintf(fplog,"|- 1st SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][0];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 2nd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][1];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+
+  return colvar.natoms[count]; 
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_dihcor.c dl_class_1.9/srcmod/Plumed/restraint_dihcor.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_dihcor.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_dihcor.c	2015-11-07 17:37:19.344602938 +0100
@@ -0,0 +1,210 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+//-----------------------------------------------------------------------------
+// COLVAR = nearest-neighbour correlation in a set of dihedrals:
+// \sum_i ( 1 + cos ( \phi_i - \phi_{i+1} ) )*0.5
+//-----------------------------------------------------------------------------
+#include "metadyn.h"
+
+void PREFIX dihcor_restraint(int i_c, struct mtd_data_s *mtd_data) 
+{
+  real ***d, *psi;
+  real psisum, dpsi, dps, cos_psi;
+  int i, ix, idtc, ndtc;
+  int a0, a1, a2, a3;
+  int t1, t2, t3;
+  rvec vp1, vp2, vp3;
+  real pi, nv1, nv2, n21, sc1, sc2;
+  real twopi, in21, sign, tmp;
+  rvec r01, r21, r23, m, n;
+
+  twopi = M_2PI;
+  pi = M_PI;
+
+  ndtc = colvar.type[i_c];
+  snew(d, ndtc);
+  for(idtc=0;idtc<ndtc;idtc++) {
+    snew(d[idtc], 4);
+    for(i=0;i<4;i++) snew(d[idtc][i], 3);
+  }
+  snew(psi, ndtc);
+
+  for(idtc=0;idtc<ndtc;idtc++){
+    for(ix=0;ix<3;ix++) {
+      colvar.myder[i_c][4*idtc+0][ix] = 0.;
+      colvar.myder[i_c][4*idtc+1][ix] = 0.;
+      colvar.myder[i_c][4*idtc+2][ix] = 0.;
+      colvar.myder[i_c][4*idtc+3][ix] = 0.;
+    }
+
+    a0 = colvar.cvatoms[i_c][4*idtc+0];
+    a1 = colvar.cvatoms[i_c][4*idtc+1];
+    a2 = colvar.cvatoms[i_c][4*idtc+2];
+    a3 = colvar.cvatoms[i_c][4*idtc+3];
+
+#if defined (PLUMED_GROMACS)
+#if defined (PLUMED_GROMACS45)
+    psi[idtc] = dih_angle(mtd_data->pos[a0], mtd_data->pos[a1], mtd_data->pos[a2], mtd_data->pos[a3], &mtd_data->metapbc, 
+                          r01, r21, r23, m, n, &sign, &t1, &t2, &t3);
+#else
+    psi[idtc] = dih_angle(mtd_data->pos[a0], mtd_data->pos[a1], mtd_data->pos[a2], mtd_data->pos[a3], &mtd_data->metapbc, 
+                          r01, r21, r23, m, n, &cos_psi, &sign, &t1, &t2, &t3);
+#endif
+#else
+     psi[idtc] = dih_angle(mtd_data->pos[a0], mtd_data->pos[a1], mtd_data->pos[a2], mtd_data->pos[a3],
+                          r01, r21, r23, m, n, &cos_psi, &sign);
+#endif
+
+    oprod(r01, r21, vp1);
+    oprod(r21, r23, vp2);
+    oprod(vp1, vp2, vp3);
+
+    if(psi[idtc]>=pi) psi[idtc] -= twopi;
+    else if(psi[idtc] < -pi) psi[idtc] += twopi;
+
+    nv1 = norm(vp1);
+    nv2 = norm(vp2);
+    n21 = norm(r21);
+
+    sc1 = iprod(r01, r21);
+    sc2 = iprod(r23, r21);
+
+    in21 = 1./(n21*n21);
+
+    sc1 = sc1*in21;
+    sc2 = sc2*in21;
+
+    for(i=0;i<3;++i) {
+      d[idtc][0][i] = -n21 * vp1[i] / (nv1*nv1);
+      d[idtc][3][i] = n21 * vp2[i] / (nv2*nv2);
+      d[idtc][1][i] = ((sc1-1.0)*d[idtc][0][i] - sc2*d[idtc][3][i]);
+      d[idtc][2][i] = ((sc2-1.0)*d[idtc][3][i] - sc1*d[idtc][0][i]);
+    }
+  }
+
+  psisum = 0.;
+  for(idtc=0;idtc<ndtc-1;idtc++) {
+    dps = (psi[idtc]-psi[idtc+1]);
+
+    psisum += 0.5*(cos(dps)+1.);
+    dpsi = 0.5*sin(dps);
+
+    for(ix=0;ix<3;ix++){
+      colvar.myder[i_c][4*idtc+0][ix] += dpsi*d[idtc][0][ix];
+      colvar.myder[i_c][4*idtc+1][ix] += dpsi*d[idtc][1][ix];
+      colvar.myder[i_c][4*idtc+2][ix] += dpsi*d[idtc][2][ix];
+      colvar.myder[i_c][4*idtc+3][ix] += dpsi*d[idtc][3][ix];
+      colvar.myder[i_c][4*(idtc+1)+0][ix] -= dpsi*d[idtc+1][0][ix];
+      colvar.myder[i_c][4*(idtc+1)+1][ix] -= dpsi*d[idtc+1][1][ix];
+      colvar.myder[i_c][4*(idtc+1)+2][ix] -= dpsi*d[idtc+1][2][ix];
+      colvar.myder[i_c][4*(idtc+1)+3][ix] -= dpsi*d[idtc+1][3][ix];
+    }
+  }
+
+  colvar.ss0[i_c] = psisum;
+  for(idtc=0;idtc<ndtc;idtc++) {
+    sfree(d[idtc][0]);
+    sfree(d[idtc][1]);
+    sfree(d[idtc][2]);
+    sfree(d[idtc][3]);
+    sfree(d[idtc]);
+  }
+
+
+  sfree(d);
+  sfree(psi);
+}
+
+//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
+
+int PREFIX read_dihcor(char **word, int count, t_plumed_input *input,int *iline,FILE *fplog)
+{
+  int iat, atnr1, atnr2, atnr3, atnr4, iw;
+  double delta = 0.0;
+  char string[400];
+  int help;
+
+  help = 0;
+
+  iw=seek_word(word,"NDIH");
+  if(iw>=0) { 
+      sscanf(word[iw+1],"%i", &colvar.type[count]);
+  } else {
+    fprintf(fplog,"|- NEEDED NDIH KEYWORD FOR DIHCOR\n");
+    help=1;
+  }
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+
+   if(help){
+         fprintf(fplog,"|- DIHCOR SYNTAX:\n");
+         fprintf(fplog,"|- NDIH               : number of dihedrals\n");
+         fprintf(fplog,"|- SIGMA              : hills width for this cv\n");
+         fprintf(fplog,"e.g. \n");
+         fprintf(fplog,"DIHCOR NDIH 1 SIGMA 0.1 \n");
+         fprintf(fplog,"168 170 172 188 \n");
+         plumed_error("PluMeD dead with errors: check log file");         
+  }
+
+  colvar.type_s[count]   = 16;
+  colvar.natoms[count]   = 4*colvar.type[count]; 
+
+  fprintf(fplog, "\n%1i-DIHCOR: %i DIHEDRAL; ", count+1, colvar.type[count]);
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+
+  snew(colvar.cvatoms[count], colvar.natoms[count]);
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  for(iat=0;iat<colvar.type[count];iat++) {
+    (*iline)++;
+    sscanf(input->words[*iline][0],"%i",&atnr1);
+    sscanf(input->words[*iline][1],"%i",&atnr2);
+    sscanf(input->words[*iline][2],"%i",&atnr3);
+    sscanf(input->words[*iline][3],"%i",&atnr4);
+    atnr1--;
+    atnr2--;
+    atnr3--;
+    atnr4--;
+    colvar.cvatoms[count][4*iat]   = atnr1;
+    colvar.cvatoms[count][4*iat+1] = atnr2;
+    colvar.cvatoms[count][4*iat+2] = atnr3;
+    colvar.cvatoms[count][4*iat+3] = atnr4;
+    fprintf(fplog, "|--DIH %i, ATOMS: %i %i %i %i\n", iat+1, atnr1+1, atnr2+1, atnr3+1, atnr4+1);
+  }
+
+  fprintf(fplog,"\n");
+  return colvar.type[count];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_dipole.c dl_class_1.9/srcmod/Plumed/restraint_dipole.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_dipole.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_dipole.c	2015-11-07 17:37:19.347603025 +0100
@@ -0,0 +1,111 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX dipole_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int  i, ai;
+  rvec dipje;
+  real dfunc;
+
+  clear_rvec(dipje);
+
+  for(i=0;i<colvar.natoms[i_c];i++) {
+    ai = colvar.cvatoms[i_c][i];
+    dipje[0] += mtd_data->pos[ai][0]*mtd_data->charge[ai];
+    dipje[1] += mtd_data->pos[ai][1]*mtd_data->charge[ai];
+    dipje[2] += mtd_data->pos[ai][2]*mtd_data->charge[ai];
+  }
+
+  colvar.ss0[i_c] = norm(dipje);
+
+  for(i=0;i<colvar.natoms[i_c];i++) {
+    ai = colvar.cvatoms[i_c][i];
+    dfunc = mtd_data->charge[ai]/colvar.ss0[i_c];
+    colvar.myder[i_c][i][0] = dfunc*dipje[0];
+    colvar.myder[i_c][i][1] = dfunc*dipje[1];
+    colvar.myder[i_c][i][2] = dfunc*dipje[2];
+  }
+
+}
+
+//-------------------------------------------------------------------------------------------------------
+
+int PREFIX read_dipole(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i, j, iat, iw;
+  double delta = 0.0;
+  char string[400];
+  int help;
+  help = 0;
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0){
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+  } else {
+    fprintf(fplog,"|- NEEDED LIST KEYWORD FOR DIPOLE\n");
+    help=1;
+  }
+
+  iw=seek_word(word,"SIGMA");
+ if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+
+  if(help){
+         fprintf(fplog,"|- DIPOLE SYNTAX:\n");
+         fprintf(fplog,"|- LIST             : atom number/name of the group of atoms\n");
+         fprintf(fplog,"|- SIGMA            : hills width for this cv\n");
+         fprintf(fplog,"e.g. \n");
+         fprintf(fplog,"DIPOLE LIST <g1> SIGMA 0.1 \n");
+         fprintf(fplog, "         g1->    \n");
+         fprintf(fplog, "         6 10 15 30 32    \n");
+         fprintf(fplog, "         g1<-    \n"); 
+         plumed_error("PluMeD dead with errors: check log file");
+  } 
+ 
+  colvar.type_s[count]   = 8;
+
+  fprintf(fplog, "\n%1i-DIPOLE: ATOMS %i ", count+1, colvar.natoms[count]);
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+
+  fprintf(fplog,"|- SET MEMBERS: ");
+  for(i=0;i<colvar.natoms[count];i++){fprintf(fplog," %d ",colvar.cvatoms[count][i]+1);if((i+1)%20==0)fprintf(fplog,"\n               ");}fprintf(fplog,"\n\n");
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  return colvar.natoms[count];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_dist.c dl_class_1.9/srcmod/Plumed/restraint_dist.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_dist.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_dist.c	2015-11-07 17:37:19.350603112 +0100
@@ -0,0 +1,722 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+void PREFIX dist_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int i, iat;
+  real mod_rij, mass1, mass2;
+  rvec rij, sum1, sum2;
+	
+  mass1 = mass2 = 0.;
+  sum1[0] = sum1[1] = sum1[2] = 0.;
+  sum2[0] = sum2[1] = sum2[2] = 0.;
+
+
+  // point to axis
+  if(colvar.intpar[i_c][3]==1){
+     pt_from_axis_restraint(i_c, mtd_data);  
+     return;
+  } else if(colvar.intpar[i_c][3]==2){
+     diffdist_restraint(i_c, mtd_data);  
+     return;
+  } else if(colvar.intpar[i_c][7]==1){
+     proj_on_axis_restraint(i_c, mtd_data);
+     return;
+  };
+  
+  for(i=0;i<colvar.list[i_c][0];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    sum1[0] += mtd_data->mass[iat]*mtd_data->pos[iat][0];
+    sum1[1] += mtd_data->mass[iat]*mtd_data->pos[iat][1];
+    sum1[2] += mtd_data->mass[iat]*mtd_data->pos[iat][2];
+    mass1 += mtd_data->mass[iat];
+  }
+  for(i=colvar.list[i_c][0];i<colvar.natoms[i_c];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    sum2[0] += mtd_data->mass[iat]*mtd_data->pos[iat][0];
+    sum2[1] += mtd_data->mass[iat]*mtd_data->pos[iat][1];
+    sum2[2] += mtd_data->mass[iat]*mtd_data->pos[iat][2];
+    mass2 += mtd_data->mass[iat];
+  }
+
+  sum1[0] /= mass1; sum1[1] /= mass1; sum1[2] /= mass1;
+  sum2[0] /= mass2; sum2[1] /= mass2; sum2[2] /= mass2;
+
+  // Project center of masses, if required
+  if(colvar.intpar[i_c][0])
+    sum2[0]=sum1[0]=0.0;
+  if(colvar.intpar[i_c][1])
+    sum2[1]=sum1[1]=0.0;
+  if(colvar.intpar[i_c][2])
+    sum2[2]=sum1[2]=0.0;
+
+
+  if(colvar.cell_pbc[i_c]){
+    minimal_image(sum1, sum2, &mod_rij, rij);
+  } else {
+    rij[0] = sum1[0]-sum2[0];
+    rij[1] = sum1[1]-sum2[1];
+    rij[2] = sum1[2]-sum2[2];
+    mod_rij  = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+  };
+
+  for(i=0;i<colvar.list[i_c][0];i++) { 
+    iat = colvar.cvatoms[i_c][i];
+    colvar.myder[i_c][i][0] =  (mtd_data->mass[iat]*rij[0])/(mass1*mod_rij);
+    colvar.myder[i_c][i][1] =  (mtd_data->mass[iat]*rij[1])/(mass1*mod_rij);
+    colvar.myder[i_c][i][2] =  (mtd_data->mass[iat]*rij[2])/(mass1*mod_rij);
+  }
+  for(i=colvar.list[i_c][0];i<colvar.natoms[i_c];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    colvar.myder[i_c][i][0] = -(mtd_data->mass[iat]*rij[0])/(mass2*mod_rij);
+    colvar.myder[i_c][i][1] = -(mtd_data->mass[iat]*rij[1])/(mass2*mod_rij);
+    colvar.myder[i_c][i][2] = -(mtd_data->mass[iat]*rij[2])/(mass2*mod_rij);
+  }
+
+  colvar.ss0[i_c] = mod_rij;
+
+}
+
+// ------------------------------------------------------------------------------------------------
+
+int PREFIX read_dist(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i, iw, iat,j;
+  double delta = 0.0;
+  char string[400];
+  char *name_ow1=NULL,*name_ow2=NULL,*name_ow3=NULL;
+  int help;
+  help=0;
+
+  colvar.cell_pbc[count]=1; // default is PBC
+
+  // default is not to project
+  colvar.intpar[count][0] = 0;
+  colvar.intpar[count][1] = 0;
+  colvar.intpar[count][2] = 0;
+  // point to axis is by default off
+  colvar.intpar[count][3] = 0;
+  // optimized external weights
+  colvar.intpar[count][4] = 0;
+  colvar.intpar[count][5] = 0;
+  colvar.intpar[count][6] = 0;
+  // proj to axis is by default off
+  colvar.intpar[count][7] = 0;
+
+  iw=seek_word(word,"NOPBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 0;}
+  iw=seek_word(word,"PBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 1;}
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0){   
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+             j=plumed_get_group(word[iw+2],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][1]=j;
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR DISTANCE\n"); help=1;}
+
+  /* Project on a given axis. (TONI) I am putting this before SIGMA
+     for consisency with POSITION  */
+  iw=seek_word(word,"DIR");
+  if(iw>=0) { 
+    char chr[3];
+    int dropx,dropy,dropz;	/* discard x,y,z component? */
+    dropx=dropy=dropz=1;	/* yes on all axis, except those requested */
+    sscanf(word[iw+1],"%s", chr); 
+    if(strchr(chr,'X') || strchr(chr,'x')) {
+      dropx=0;			/* keep x */
+    } 
+    if(strchr(chr,'Y') || strchr(chr,'y')) {
+      dropy=0;
+    }
+    if(strchr(chr,'Z') || strchr(chr,'z')) {
+      dropz=0;
+    }
+    if(dropx && dropy && dropz) {
+      fprintf(fplog,"|- INVALID PROJECTION SPECIFIED\n"); help=1;
+    } 
+    colvar.intpar[count][0] = dropx;
+    colvar.intpar[count][1] = dropy;
+    colvar.intpar[count][2] = dropz;
+  }
+
+  /* point from axis : in this case take another point or group: the one that appear in list define the axis, this defines the point   */
+  iw = seek_word(word,"POINT_FROM_AXIS");
+  if(iw>=0){   
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][2]=j;
+             /* switch on point from axis option */
+             colvar.intpar[count][3] = 1;
+  }
+  /* proj on axis : in this case take another point or group: the one that appear in list define the axis, this defines the point   */
+  iw = seek_word(word,"PROJ_ON_AXIS");
+  if(iw>=0){
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][2]=j;
+             /* switch on proj on axis option */
+             colvar.intpar[count][7] = 1;
+  } 
+  // optimized external weights only for this variable 
+  iw = seek_word(word,"OW1");
+  if(iw>=0){   
+      colvar.intpar[count][4]=1; 
+      name_ow1=word[iw+1]; 
+  }
+  iw = seek_word(word,"OW2");
+  if(iw>=0){   
+      colvar.intpar[count][5]=1; 
+      name_ow2=word[iw+1]; 
+  }
+  iw = seek_word(word,"OW3");
+  if(iw>=0){   
+      colvar.intpar[count][6]=1; 
+      name_ow3=word[iw+1]; 
+  }
+  // other two groups if you need difference of distances  
+  iw = seek_word(word,"DIFFDIST");
+  if(iw>=0){   
+        j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+        colvar.natoms[count]+=j;
+        colvar.list[count][2]=j;
+        j=plumed_get_group(word[iw+2],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+        colvar.natoms[count]+=j;
+        colvar.list[count][3]=j;
+        /* switch on  diffdist option */
+        colvar.intpar[count][3] = 2;
+  } 
+ 
+ 
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);  
+             colvar.delta_r[count]  = (real) delta; }
+
+ // else if (logical.do_hills) { fprintf(fplog,"|- NEEDED SIGMA KEYWORD FOR DISTANCE\n"); help=1;}
+  if(help){
+          fprintf(fplog, "\n-DISTANCE CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "      DISTANCE LIST 15 30 DIR {projection} { POINT_FROM_AXIS/PROJ_ON_AXIS <g3>  }  {DIFFDIST  <g3> <g4> }SIGMA 1.0 \n");
+          fprintf(fplog, "  \n");
+          fprintf(fplog, "or in case of groups    \n");
+          fprintf(fplog, "      DISTANCE LIST <g1> <g2> SIGMA 1.0 \n");
+          fprintf(fplog, "         g1->    \n");
+          fprintf(fplog, "         6 10    \n");
+          fprintf(fplog, "         g1<-    \n");
+          fprintf(fplog, "                 \n");
+          fprintf(fplog, "         g2->    \n");
+          fprintf(fplog, "         8 15 21 \n");
+          fprintf(fplog, "         g2<-    \n");
+          fprintf(fplog, "                 \n");
+          fprintf(fplog, " {projection} can be X, Y, Z, XY, XZ or YZ");
+          plumed_error("PluMeD dead with errors: check log file");
+  }
+
+  colvar.type_s[count]   = 1;
+
+  fprintf(fplog, "\n%1i-DISTANCE: (1st SET: %i ATOMS), (2nd SET: %i ATOMS); ", count+1, colvar.list[count][0], colvar.list[count][1]);
+  if(colvar.cell_pbc[count]) fprintf(fplog, " PBC ON");
+  else                       fprintf(fplog, " PBC OFF");
+  if (logical.do_hills){
+ 	if (colvar.delta_r[count]>0){
+        	 fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+        }
+  }
+  else fprintf(fplog,"\n");
+
+  iat=0;
+  fprintf(fplog, "|- DISCARDING DISTANCE COMPONENTS (XYZ): %d%d%d\n",
+	  colvar.intpar[count][0],colvar.intpar[count][1],colvar.intpar[count][2]);
+  fprintf(fplog,"|- 1st SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][0];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 2nd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][1];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+  if(colvar.intpar[count][3]==1){
+    fprintf(fplog,"|- 3nd SET MEMBERS (ONLY FOR POINT_FROM_AXIS: this defines the point, the others above define the two points of the axis): ");
+    for(i=0;i<colvar.list[count][2];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+  }
+  if(colvar.intpar[count][7]==1){
+    fprintf(fplog,"|- 3nd SET MEMBERS (ONLY FOR PROJ_ON_AXIS: this defines the point, the others above define the two points of the axis): ");
+    for(i=0;i<colvar.list[count][2];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+  }
+  if(colvar.intpar[count][3]==2){
+    fprintf(fplog,"|- 3nd SET MEMBERS (ONLY FOR DIFFDIST: this defines the other two points): ");
+    for(i=0;i<colvar.list[count][2];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+    fprintf(fplog,"|- 3nd SET MEMBERS (ONLY FOR DIFFDIST: this defines the other two points): ");
+    for(i=0;i<colvar.list[count][3];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+  }
+
+
+  /* import the optimized weights */
+  if(colvar.intpar[count][4]){
+     // pass the address to the first  address of region
+     import_ow(&(colvar.ow_weight[count*3]),name_ow1,0,colvar.list[count][0],colvar.cvatoms[count]); 
+  } 
+  if(colvar.intpar[count][5]){
+     import_ow(&(colvar.ow_weight[count*3+1]),name_ow2,colvar.list[count][0],colvar.list[count][0]+colvar.list[count][1],colvar.cvatoms[count]); 
+  } 
+  if(colvar.intpar[count][6]){
+     import_ow(&(colvar.ow_weight[count*3+2]),name_ow3,colvar.list[count][1]+colvar.list[count][0],colvar.list[count][0]+colvar.list[count][1]+colvar.list[count][2],colvar.cvatoms[count]); 
+  } 
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  return colvar.natoms[count];
+}
+void PREFIX pt_from_axis_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int i,j, iat;
+  real mod_ba, mod_ha, mass_a, mass_b, mass_h, dot, mod_ptx, mass;
+  rvec r_ba,r_ha, sum_a, sum_b, sum_h;
+  real tau_t;
+
+  mass_a = mass_b = mass_h = 0.;
+  sum_a[0] = sum_a[1] = sum_a[2] = 0.;
+  sum_b[0] = sum_b[1] = sum_b[2] = 0.;
+  sum_h[0] = sum_h[1] = sum_h[2] = 0.;
+
+  j=0;
+  // added optimized weights for axis fitting
+  for(i=0;i<colvar.list[i_c][0];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    if(colvar.intpar[i_c][4]){mass=colvar.ow_weight[i_c*3][j];j++;} 
+    else{mass=mtd_data->mass[iat];}   
+    sum_a[0] += mass*mtd_data->pos[iat][0];
+    sum_a[1] += mass*mtd_data->pos[iat][1];
+    sum_a[2] += mass*mtd_data->pos[iat][2];
+    if(colvar.intpar[i_c][4]){mass_a +=1;}
+    else {mass_a += mass;}
+  }
+  j=0;
+  for(i=colvar.list[i_c][0];i<colvar.list[i_c][0]+colvar.list[i_c][1];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    if(colvar.intpar[i_c][5]){mass=colvar.ow_weight[i_c*3+1][j];j++;} 
+    else{mass=mtd_data->mass[iat];}   
+    sum_b[0] += mass*mtd_data->pos[iat][0];
+    sum_b[1] += mass*mtd_data->pos[iat][1];
+    sum_b[2] += mass*mtd_data->pos[iat][2];
+    if(colvar.intpar[i_c][5]){mass_b +=1;}
+    else {mass_b += mass;}
+  }
+  j=0;
+  for(i=colvar.list[i_c][0]+colvar.list[i_c][1];i<colvar.natoms[i_c];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    if(colvar.intpar[i_c][6]){mass=colvar.ow_weight[i_c*3+2][j];j++;} 
+    else{mass=mtd_data->mass[iat];}   
+    sum_h[0] += mass*mtd_data->pos[iat][0];
+    sum_h[1] += mass*mtd_data->pos[iat][1];
+    sum_h[2] += mass*mtd_data->pos[iat][2];
+    if(colvar.intpar[i_c][6]){mass_h +=1;}
+    else {mass_h += mass;}
+  }
+
+
+  sum_a[0] /= mass_a; sum_a[1] /= mass_a; sum_a[2] /= mass_a;
+  sum_b[0] /= mass_b; sum_b[1] /= mass_b; sum_b[2] /= mass_b;
+  sum_h[0] /= mass_h; sum_h[1] /= mass_h; sum_h[2] /= mass_h;
+
+  // 
+
+  if(colvar.cell_pbc[i_c]){
+    minimal_image(sum_b, sum_a, &mod_ba, r_ba);
+  } else {
+    r_ba[0] = sum_b[0]-sum_a[0];
+    r_ba[1] = sum_b[1]-sum_a[1];
+    r_ba[2] = sum_b[2]-sum_a[2];
+    mod_ba  = sqrt(r_ba[0]*r_ba[0]+r_ba[1]*r_ba[1]+r_ba[2]*r_ba[2]);
+  };
+
+  if(colvar.cell_pbc[i_c]){
+    minimal_image(sum_h, sum_a, &mod_ha, r_ha);
+  } else {
+    r_ha[0] = sum_h[0]-sum_a[0];
+    r_ha[1] = sum_h[1]-sum_a[1];
+    r_ha[2] = sum_h[2]-sum_a[2];
+    mod_ha  = sqrt(r_ha[0]*r_ha[0]+r_ha[1]*r_ha[1]+r_ha[2]*r_ha[2]);
+  };
+
+  // dot
+  dot=r_ha[0]*r_ba[0]+r_ha[1]*r_ba[1]+r_ha[2]*r_ba[2];
+
+  // point to axis dist
+  mod_ptx=pow(mod_ha*mod_ha-(dot*dot)/(mod_ba*mod_ba),0.5);  
+
+  // tau_t
+  tau_t=dot/(mod_ba*mod_ba)  ;
+
+  // put everything in globally visible structures
+
+  j=0;
+  for(i=0;i<colvar.list[i_c][0];i++) { 
+    iat = colvar.cvatoms[i_c][i];
+    if(colvar.intpar[i_c][4]){mass=colvar.ow_weight[i_c*3][j];j++;} 
+    else{mass=mtd_data->mass[iat];}   
+    colvar.myder[i_c][i][0] = mass/mass_a*(-r_ha[0]+(r_ba[0]+r_ha[0])*tau_t-r_ba[0]*tau_t*tau_t)/mod_ptx ; 
+    colvar.myder[i_c][i][1] = mass/mass_a*(-r_ha[1]+(r_ba[1]+r_ha[1])*tau_t-r_ba[1]*tau_t*tau_t)/mod_ptx ; 
+    colvar.myder[i_c][i][2] = mass/mass_a*(-r_ha[2]+(r_ba[2]+r_ha[2])*tau_t-r_ba[2]*tau_t*tau_t)/mod_ptx ;
+  }
+  j=0;
+  for(i=colvar.list[i_c][0];i<colvar.list[i_c][0]+colvar.list[i_c][1];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    if(colvar.intpar[i_c][5]){mass=colvar.ow_weight[i_c*3+1][j];j++;} 
+    else{mass=mtd_data->mass[iat];}   
+    colvar.myder[i_c][i][0] = mass/mass_b*(-r_ha[0]*tau_t+r_ba[0]*tau_t*tau_t)/mod_ptx ; 
+    colvar.myder[i_c][i][1] = mass/mass_b*(-r_ha[1]*tau_t+r_ba[1]*tau_t*tau_t)/mod_ptx ; 
+    colvar.myder[i_c][i][2] = mass/mass_b*(-r_ha[2]*tau_t+r_ba[2]*tau_t*tau_t)/mod_ptx ; 
+  }
+  j=0;
+  for(i=colvar.list[i_c][0]+colvar.list[i_c][1];i<colvar.natoms[i_c];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    if(colvar.intpar[i_c][6]){mass=colvar.ow_weight[i_c*3+2][j];j++;} 
+    else{mass=mtd_data->mass[iat];}   
+    colvar.myder[i_c][i][0] = mass/mass_h*(r_ha[0]-r_ba[0]*tau_t)/mod_ptx ;
+    colvar.myder[i_c][i][1] = mass/mass_h*(r_ha[1]-r_ba[1]*tau_t)/mod_ptx ;
+    colvar.myder[i_c][i][2] = mass/mass_h*(r_ha[2]-r_ba[2]*tau_t)/mod_ptx ;
+  }
+
+  colvar.ss0[i_c] = mod_ptx;
+
+  if( !(colvar.it%colvar.nt_print) ) {
+     fprintf(mtd_data->fplog,"|-POINT_FROM_AXIS: A %8.3f %8.3f %8.3f  ",sum_a[0],sum_a[1],sum_a[2]);
+     fprintf(mtd_data->fplog," B %8.3f %8.3f %8.3f  ",sum_b[0],sum_b[1],sum_b[2]);
+     fprintf(mtd_data->fplog," T %8.3f %8.3f %8.3f  ",sum_b[0]+tau_t*(sum_b[0]-sum_a[0]),sum_b[1]+tau_t*(sum_b[1]-sum_a[1]),sum_b[2]+tau_t*(sum_b[2]-sum_a[2]));
+     fprintf(mtd_data->fplog," H %8.3f %8.3f %8.3f  \n",sum_h[0],sum_h[1],sum_h[2]);
+  }
+
+
+
+}
+void PREFIX import_ow(real **weight ,char* filename , int start, int end , int *indexes )
+{
+    FILE *fp;
+    char string[100],*str; 
+    int id,size,i,j;
+    int *ind_tmp ;
+    int *idone; 
+    real *weight_tmp;
+    real ww;
+    fprintf(mtd_data.fplog,"|-IMPORTING OPTIMIZED MASS WEIGHT %s\n",filename);
+    fp=fopen(filename,"r");
+    if (fp == NULL) {
+       char buf[1024];
+       sprintf(buf,"UNSUCCESSFULL OPENING FOR FILE %s",filename);
+       plumed_error(buf);  
+    }
+    j=0;
+    while(1){
+        str=fgets(string,100,fp);
+        if(str==NULL)break;
+        if (feof(fp))break;
+        j++;
+    }
+    fclose(fp);
+    snew(ind_tmp,j);snew(weight_tmp,j);
+
+    size=0;
+    fp=fopen(filename,"r");
+    while(1){
+        str=fgets(string,100,fp);
+        if(str==NULL)break;
+        if (feof(fp))break;
+        char *result = NULL;
+        result = strtok( string, " \t" );   
+        id=atoi(result);
+        result = strtok( NULL, " \t" );   
+        ww=atof(result);
+        weight_tmp[size]=ww; ind_tmp[size]=id-1;
+        //fprintf(mtd_data.fplog,"|-IND %d WEIGHT %f \n",ind_tmp[size]+1,weight_tmp[size]);
+        size++; 
+    }
+    // check consistency
+    // number first 
+    if(size!=(end-start)) {
+       char buf[1024];
+       sprintf(buf,"Expected %d mass weights. Found %d. Only one weight per atom is allowed!",end-start,size);
+       plumed_error(buf);  
+    }
+    snew(*weight,size);
+    //  reorder and check 
+    snew(idone,size);for(i=0;i<size;i++)idone[i]=0; 
+    for(i=0;i<size;i++){
+          if(!idone[i]){ // only if it is not done
+                for(j=start;j<end;j++){
+                     if(indexes[j]==ind_tmp[i]){ 
+                        //(*weight)[j]=weight_tmp[i];
+                        (*weight)[i]=weight_tmp[i];
+                        idone[i]=1;
+                        fprintf(mtd_data.fplog,"|-FOUND_MATCH FOR ATOM %d : WW %f \n",indexes[j]+1,(*weight)[i]);
+                        break;
+                     } 
+                } 
+          }else{ plumed_error("The same atom is occurring twice in the weights"); }
+    }
+  sfree(ind_tmp); 
+  sfree(weight_tmp); 
+  sfree(idone);
+  return;
+} 
+void PREFIX diffdist_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int i,j, iat;
+  real mod_ba, mod_gh, mass_a, mass_b, mass_h, mass_g, mod_diff,mass;
+  rvec r_ba,r_gh, sum_a, sum_b, sum_h, sum_g;
+  rvec dd_drh,dd_dra,dd_drb,dd_drg; 
+
+  mass_a = mass_b = mass_h = mass_g= 0.;
+  sum_a[0] = sum_a[1] = sum_a[2] = 0.;
+  sum_b[0] = sum_b[1] = sum_b[2] = 0.;
+  sum_h[0] = sum_h[1] = sum_h[2] = 0.;
+  sum_g[0] = sum_g[1] = sum_g[2] = 0.;
+
+  for(i=0;i<colvar.list[i_c][0];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    mass=mtd_data->mass[iat];   
+    sum_a[0] += mass*mtd_data->pos[iat][0];
+    sum_a[1] += mass*mtd_data->pos[iat][1];
+    sum_a[2] += mass*mtd_data->pos[iat][2];
+    mass_a += mass;
+  }
+  for(i=colvar.list[i_c][0];i<colvar.list[i_c][0]+colvar.list[i_c][1];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    mass=mtd_data->mass[iat];   
+    sum_b[0] += mass*mtd_data->pos[iat][0];
+    sum_b[1] += mass*mtd_data->pos[iat][1];
+    sum_b[2] += mass*mtd_data->pos[iat][2];
+    mass_b += mass;
+  }
+  for(i=colvar.list[i_c][0]+colvar.list[i_c][1];i<colvar.list[i_c][0]+colvar.list[i_c][1]+colvar.list[i_c][2];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    mass=mtd_data->mass[iat];   
+    sum_h[0] += mass*mtd_data->pos[iat][0];
+    sum_h[1] += mass*mtd_data->pos[iat][1];
+    sum_h[2] += mass*mtd_data->pos[iat][2];
+    mass_h += mass;
+  }
+  for(i=colvar.list[i_c][0]+colvar.list[i_c][1]+colvar.list[i_c][2];i<colvar.natoms[i_c];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    mass=mtd_data->mass[iat];   
+    sum_g[0] += mass*mtd_data->pos[iat][0];
+    sum_g[1] += mass*mtd_data->pos[iat][1];
+    sum_g[2] += mass*mtd_data->pos[iat][2];
+    mass_g += mass;
+  }
+
+
+  sum_a[0] /= mass_a; sum_a[1] /= mass_a; sum_a[2] /= mass_a;
+  sum_b[0] /= mass_b; sum_b[1] /= mass_b; sum_b[2] /= mass_b;
+  sum_h[0] /= mass_h; sum_h[1] /= mass_h; sum_h[2] /= mass_h;
+  sum_g[0] /= mass_g; sum_g[1] /= mass_g; sum_g[2] /= mass_g;
+
+  // 
+
+  if(colvar.cell_pbc[i_c]){
+    minimal_image(sum_b, sum_a, &mod_ba, r_ba);
+    minimal_image(sum_g, sum_h, &mod_gh, r_gh);
+  } else {
+    r_ba[0] = sum_b[0]-sum_a[0];
+    r_ba[1] = sum_b[1]-sum_a[1];
+    r_ba[2] = sum_b[2]-sum_a[2];
+    mod_ba  = sqrt(r_ba[0]*r_ba[0]+r_ba[1]*r_ba[1]+r_ba[2]*r_ba[2]);
+    r_gh[0] = sum_g[0]-sum_h[0];
+    r_gh[1] = sum_g[1]-sum_h[1];
+    r_gh[2] = sum_g[2]-sum_h[2];
+    mod_gh  = sqrt(r_gh[0]*r_gh[0]+r_gh[1]*r_gh[1]+r_gh[2]*r_gh[2]);
+  };
+
+  // point to axis dist
+
+  mod_diff=mod_ba-mod_gh;  
+
+  // derivative respect to point
+
+  dd_dra[0]= (sum_a[0]-sum_b[0])/mod_ba;
+  dd_dra[1]= (sum_a[1]-sum_b[1])/mod_ba;
+  dd_dra[2]= (sum_a[2]-sum_b[2])/mod_ba;
+
+  dd_drb[0]= (sum_b[0]-sum_a[0])/mod_ba; 
+  dd_drb[1]= (sum_b[1]-sum_a[1])/mod_ba; 
+  dd_drb[2]= (sum_b[2]-sum_a[2])/mod_ba; 
+
+  dd_drh[0]= (sum_g[0]-sum_h[0])/mod_gh;
+  dd_drh[1]= (sum_g[1]-sum_h[1])/mod_gh;
+  dd_drh[2]= (sum_g[2]-sum_h[2])/mod_gh;
+
+  dd_drg[0]= (sum_h[0]-sum_g[0])/mod_gh; 
+  dd_drg[1]= (sum_h[1]-sum_g[1])/mod_gh; 
+  dd_drg[2]= (sum_h[2]-sum_g[2])/mod_gh; 
+ 
+  // put everything in globally visible structures
+
+  for(i=0;i<colvar.list[i_c][0];i++) { 
+    iat = colvar.cvatoms[i_c][i];
+    mass=mtd_data->mass[iat];   
+    colvar.myder[i_c][i][0] =  (mass*dd_dra[0])/(mass_a);
+    colvar.myder[i_c][i][1] =  (mass*dd_dra[1])/(mass_a);
+    colvar.myder[i_c][i][2] =  (mass*dd_dra[2])/(mass_a);
+  }
+  for(i=colvar.list[i_c][0];i<colvar.list[i_c][0]+colvar.list[i_c][1];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    mass=mtd_data->mass[iat];   
+    colvar.myder[i_c][i][0] =  (mass*dd_drb[0])/(mass_b);
+    colvar.myder[i_c][i][1] =  (mass*dd_drb[1])/(mass_b);
+    colvar.myder[i_c][i][2] =  (mass*dd_drb[2])/(mass_b);
+  }
+  for(i=colvar.list[i_c][0]+colvar.list[i_c][1];i<colvar.list[i_c][0]+colvar.list[i_c][1]+colvar.list[i_c][2];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    mass=mtd_data->mass[iat];   
+    colvar.myder[i_c][i][0] =  (mass*dd_drh[0])/(mass_h);
+    colvar.myder[i_c][i][1] =  (mass*dd_drh[1])/(mass_h);
+    colvar.myder[i_c][i][2] =  (mass*dd_drh[2])/(mass_h);
+  }
+  for(i=colvar.list[i_c][0]+colvar.list[i_c][1]+colvar.list[i_c][2];i<colvar.natoms[i_c];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    mass=mtd_data->mass[iat];   
+    colvar.myder[i_c][i][0] =  (mass*dd_drg[0])/(mass_g);
+    colvar.myder[i_c][i][1] =  (mass*dd_drg[1])/(mass_g);
+    colvar.myder[i_c][i][2] =  (mass*dd_drg[2])/(mass_g);
+  }
+
+  colvar.ss0[i_c] = mod_diff;
+
+}
+
+void PREFIX proj_on_axis_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int i,j, iat;
+  real mod_ba, mod_ba_3, mod_ha, mass_a, mass_b, mass_h, dot, mass;
+  rvec r_ba,r_ha, sum_a, sum_b, sum_h;
+
+
+  mass_a = mass_b = mass_h = 0.;
+  sum_a[0] = sum_a[1] = sum_a[2] = 0.;
+  sum_b[0] = sum_b[1] = sum_b[2] = 0.;
+  sum_h[0] = sum_h[1] = sum_h[2] = 0.;
+
+  j=0;
+  // added optimized weights for axis fitting
+  for(i=0;i<colvar.list[i_c][0];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    if(colvar.intpar[i_c][4]){mass=colvar.ow_weight[i_c*3][j];j++;} 
+    else{mass=mtd_data->mass[iat];}   
+    sum_a[0] += mass*mtd_data->pos[iat][0];
+    sum_a[1] += mass*mtd_data->pos[iat][1];
+    sum_a[2] += mass*mtd_data->pos[iat][2];
+    if(colvar.intpar[i_c][4]){mass_a +=1;}
+    else {mass_a += mass;}
+  }
+  j=0;
+  for(i=colvar.list[i_c][0];i<colvar.list[i_c][0]+colvar.list[i_c][1];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    if(colvar.intpar[i_c][5]){mass=colvar.ow_weight[i_c*3+1][j];j++;} 
+    else{mass=mtd_data->mass[iat];}   
+    sum_b[0] += mass*mtd_data->pos[iat][0];
+    sum_b[1] += mass*mtd_data->pos[iat][1];
+    sum_b[2] += mass*mtd_data->pos[iat][2];
+    if(colvar.intpar[i_c][5]){mass_b +=1;}
+    else {mass_b += mass;}
+  }
+  j=0;
+  for(i=colvar.list[i_c][0]+colvar.list[i_c][1];i<colvar.natoms[i_c];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    if(colvar.intpar[i_c][6]){mass=colvar.ow_weight[i_c*3+2][j];j++;} 
+    else{mass=mtd_data->mass[iat];}   
+    sum_h[0] += mass*mtd_data->pos[iat][0];
+    sum_h[1] += mass*mtd_data->pos[iat][1];
+    sum_h[2] += mass*mtd_data->pos[iat][2];
+    if(colvar.intpar[i_c][6]){mass_h +=1;}
+    else {mass_h += mass;}
+  }
+
+
+  sum_a[0] /= mass_a; sum_a[1] /= mass_a; sum_a[2] /= mass_a;
+  sum_b[0] /= mass_b; sum_b[1] /= mass_b; sum_b[2] /= mass_b;
+  sum_h[0] /= mass_h; sum_h[1] /= mass_h; sum_h[2] /= mass_h;
+
+
+  if(colvar.cell_pbc[i_c]){
+    minimal_image(sum_b, sum_a, &mod_ba, r_ba);
+  } else {
+    r_ba[0] = sum_b[0]-sum_a[0];
+    r_ba[1] = sum_b[1]-sum_a[1];
+    r_ba[2] = sum_b[2]-sum_a[2];
+    mod_ba  = sqrt(r_ba[0]*r_ba[0]+r_ba[1]*r_ba[1]+r_ba[2]*r_ba[2]);
+  };
+
+  if(colvar.cell_pbc[i_c]){
+    minimal_image(sum_h, sum_a, &mod_ha, r_ha);
+  } else {
+    r_ha[0] = sum_h[0]-sum_a[0];
+    r_ha[1] = sum_h[1]-sum_a[1];
+    r_ha[2] = sum_h[2]-sum_a[2];
+  };
+
+  // dot
+  dot=r_ha[0]*r_ba[0]+r_ha[1]*r_ba[1]+r_ha[2]*r_ba[2];
+  mod_ba_3=pow(mod_ba,3);
+
+  // derivatives 
+  j=0;
+  for(i=0;i<colvar.list[i_c][0];i++) { 
+    iat = colvar.cvatoms[i_c][i];
+    if(colvar.intpar[i_c][4]){mass=colvar.ow_weight[i_c*3][j];j++;} 
+    else{mass=mtd_data->mass[iat];}   
+    colvar.myder[i_c][i][0] = mass/mass_a*(-(r_ba[0]+r_ha[0])/mod_ba+r_ba[0]*dot/mod_ba_3);  
+    colvar.myder[i_c][i][1] = mass/mass_a*(-(r_ba[1]+r_ha[1])/mod_ba+r_ba[1]*dot/mod_ba_3); 
+    colvar.myder[i_c][i][2] = mass/mass_a*(-(r_ba[2]+r_ha[2])/mod_ba+r_ba[2]*dot/mod_ba_3);
+  }
+  j=0;
+  for(i=colvar.list[i_c][0];i<colvar.list[i_c][0]+colvar.list[i_c][1];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    if(colvar.intpar[i_c][5]){mass=colvar.ow_weight[i_c*3+1][j];j++;} 
+    else{mass=mtd_data->mass[iat];}   
+    colvar.myder[i_c][i][0] = mass/mass_b*(r_ha[0]/mod_ba-r_ba[0]*dot/mod_ba_3); 
+    colvar.myder[i_c][i][1] = mass/mass_b*(r_ha[1]/mod_ba-r_ba[1]*dot/mod_ba_3); 
+    colvar.myder[i_c][i][2] = mass/mass_b*(r_ha[2]/mod_ba-r_ba[2]*dot/mod_ba_3);
+  }
+  j=0;
+  for(i=colvar.list[i_c][0]+colvar.list[i_c][1];i<colvar.natoms[i_c];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    if(colvar.intpar[i_c][6]){mass=colvar.ow_weight[i_c*3+2][j];j++;} 
+    else{mass=mtd_data->mass[iat];}   
+    colvar.myder[i_c][i][0] = mass/mass_h*r_ba[0]/mod_ba; 
+    colvar.myder[i_c][i][1] = mass/mass_h*r_ba[1]/mod_ba; 
+    colvar.myder[i_c][i][2] = mass/mass_h*r_ba[2]/mod_ba;
+  }
+
+  colvar.ss0[i_c] = dot/mod_ba; 
+
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_elstpot.c dl_class_1.9/srcmod/Plumed/restraint_elstpot.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_elstpot.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_elstpot.c	2015-11-07 17:37:19.353603200 +0100
@@ -0,0 +1,164 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX elstpot_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int firstAtom, secondAtom,iat, i, j, k, ix;
+  real r_0=colvar.realpar[i_c][0][0];   
+  real cut=colvar.realpar[i_c][1][0];   
+  real elstpot;
+  real mass1=0.;
+  elstpot=0.; 
+
+  for(i=0;i<colvar.natoms[i_c];i++){
+    for(ix=0;ix<3;ix++) colvar.myder[i_c][i][ix] = 0.;
+  }
+
+  real mod_rij,func,dfunc;
+  rvec rij, sum1;
+  // position of the point where it's felt the potential 
+  sum1[0] = sum1[1] = sum1[2] = 0.;
+  for(i=0;i<colvar.list[i_c][0];i++) {
+    iat = colvar.cvatoms[i_c][i];
+    sum1[0] += mtd_data->mass[iat]*mtd_data->pos[iat][0];
+    sum1[1] += mtd_data->mass[iat]*mtd_data->pos[iat][1];
+    sum1[2] += mtd_data->mass[iat]*mtd_data->pos[iat][2];
+    mass1 += mtd_data->mass[iat];
+  }
+  sum1[0] /= mass1; sum1[1] /= mass1; sum1[2] /= mass1;
+ 
+  for(j=colvar.list[i_c][0];j<colvar.natoms[i_c];j++) {
+      iat = colvar.cvatoms[i_c][j];
+      minimal_image(sum1, mtd_data->pos[iat], &mod_rij, rij);
+      func=(mtd_data->charge[iat]/mod_rij);
+      elstpot+=func*coscut(mod_rij,r_0,cut);
+      //elstpot+=func;
+      dfunc=-func*coscut(mod_rij,r_0,cut)/mod_rij+func*dcoscut(mod_rij,r_0,cut) ;
+      //dfunc=-func/mod_rij ;
+      for(ix=0;ix<3;ix++) {
+           colvar.myder[i_c][j][ix] -= dfunc*rij[ix]/mod_rij;
+      }
+      for(i=0;i<colvar.list[i_c][0];i++) {
+           k = colvar.cvatoms[i_c][i];
+           for(ix=0;ix<3;ix++) {
+        	 colvar.myder[i_c][i][ix] -= -dfunc*rij[ix]*mtd_data->mass[k]/(mod_rij*mass1);
+           }
+      }
+  }
+  colvar.ss0[i_c] = elstpot;
+
+}
+
+//--------------------------------------------------------------------------------------------------------------
+
+int PREFIX read_elstpot(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i, iw, iat, j, help;
+  double r_0, cut,beta ;
+  double delta = 0.0;
+  char string[400];
+  real threshold, value;
+
+  help=0;
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0){   
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+             j=plumed_get_group(word[iw+2],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][1]=j;
+
+
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR ELSTPOT\n"); help=1;}
+  // the mu for fermi function 
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+  // the beta for fermi function 
+  iw=seek_word(word,"R_0");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &r_0); } else { fprintf(fplog,"|- NEEDED R_0 KEYWORD FOR ELSTPOT\n"); help=1;}
+  // a clean cutoff
+  iw=seek_word(word,"CUT");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &cut); }
+  if(r_0>cut){fprintf(fplog,"|- NEEDED CUT > R_0 KEYWORD FOR ELSTPOT \n");}
+  if(help){
+          fprintf(fplog, "\n-ELSTPOT CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "ELSTPOT LIST <g1> <g2>  R_0 4.0  CUT 6.0  SIGMA 1.0 \n");
+          fprintf(fplog, "         g1->    \n");
+          fprintf(fplog, "         5 1 6    \n");
+          fprintf(fplog, "         g1<-    \n");
+          fprintf(fplog, "       \n");
+          fprintf(fplog, "         g2->    \n");
+          fprintf(fplog, "         LOOP 6921 21786 5 \n");
+          fprintf(fplog, "         g2<-    \n");
+          fprintf(fplog, "       \n");
+          plumed_error("PluMeD dead with errors: check log file");
+  }
+
+
+  (colvar.realpar[count][0][0])     = (real) r_0;
+  (colvar.realpar[count][1][0])     = (real) cut;
+
+  fprintf(fplog, "%1i-ELSTPOT ON  (1st SET: %i ATOMS) CAUSED BY (2nd SET: %i ATOMS); ", count+1, colvar.list[count][0], colvar.list[count][1]);
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+  fprintf(fplog, "|--FUNCTIONAL FORM:  sum_i  (q_2^i)/(r_2^i- sum_k( r_1^k ) ) f(r_2^i- sum_k( r_1^k ),r_0,cut ) Heaviside( r_2^i- sum_k( r_1^k )-cut)  \n");
+  fprintf(fplog, "|--PARAMETERS: r_0= %f cut= %f \n",  colvar.realpar[count][0][0] ,colvar.realpar[count][1][0] );
+
+  iat=0;
+  fprintf(fplog,"|- 1st SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][0];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 2nd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][1];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  return colvar.natoms[count]; 
+}
+real PREFIX coscut(real r,real r_0, real cut){
+   if(r<r_0)return 1.; 
+   if(r>cut)return 0.;
+   real d=(r-r_0)/(cut-r_0);
+   return cos(0.5*M_PI*d); 
+}
+real PREFIX dcoscut(real r,real r_0, real cut){
+   if(r<r_0)return 0.; 
+   if(r>cut)return 0.;
+   real d=(r-r_0)/(cut-r_0);
+   return -sin(0.5*M_PI*d)*0.5*M_PI/(cut-r_0); 
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_energy.c dl_class_1.9/srcmod/Plumed/restraint_energy.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_energy.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_energy.c	2015-11-07 17:37:19.356603287 +0100
@@ -0,0 +1,66 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX energy_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+ 
+  colvar.ss0[i_c] = mtd_data->energy;
+
+}
+
+//-----------------------------------------------------------------------------------------------------------------
+
+int PREFIX read_energy(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i, iat, iw;
+  double delta = 0.0;
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+
+  fprintf(fplog, "\n%1i-ENERGY ", count+1); 
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+
+  colvar.natoms[count]   = mtd_data.natoms;
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+  snew(colvar.cvatoms[count], colvar.natoms[count]);
+
+  for(iat=0;iat<colvar.natoms[count];iat++) colvar.cvatoms[count][iat] = iat;   
+
+  return colvar.natoms[count];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_func.c dl_class_1.9/srcmod/Plumed/restraint_func.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_func.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_func.c	2015-11-07 17:37:19.359603374 +0100
@@ -0,0 +1,202 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX func_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+
+int i,ix;
+int jcv;
+int iatG, iatT;
+real ff;
+
+#ifdef HAVE_MATHEVAL
+   struct mathfunction_s *myfunc;
+   myfunc=&mathfunction[i_c];
+   // reset all
+   for(i=0;i<colvar.natoms[i_c];i++){ 
+   for(ix=0;ix<3;ix++){ 
+      colvar.myder[i_c][i][ix]=0; } }
+
+   i=0;
+   for (i = 0; i < myfunc->count; i++){
+       // collect all the needed vals
+       myfunc->valcvs[i]=colvar.ss0[ myfunc->indcvs[i] ]; 
+       // calculate the function
+   }
+   colvar.ss0[i_c]=evaluator_evaluate(myfunc->f,myfunc->count, myfunc->names,myfunc->valcvs); 
+   // now calculate the derivatives
+   iatG=0;
+   for (jcv = 0; jcv < myfunc->count; jcv++){
+	  ff=evaluator_evaluate(myfunc->f_prim[jcv],myfunc->count, myfunc->names,myfunc->valcvs); 
+      for(iatT=0;iatT<colvar.natoms[myfunc->indcvs[jcv]];iatT++){
+         for(ix=0;ix<3;ix++) colvar.myder[i_c][iatG][ix] += ff*colvar.myder[myfunc->indcvs[jcv]][iatT][ix];
+         iatG++;
+      }
+    }
+
+#else
+   fprintf(mtd_data->fplog, "FUNCTION OF CVS NOT SUPPORTED: COMPILE WITH LIBMATHEVAL \n");
+   plumed_error("PluMeD dead with errors: check log file");
+   EXIT(); 
+#endif
+
+return;
+}
+
+
+
+int PREFIX read_func(char **word, int count, t_plumed_input *input,int *iline, int *nw ,FILE *fplog)
+{
+char *tok,tok2;
+int iw, i, j, k;
+double delta=0.0;
+int nterms;
+int help;
+int go;
+int done;
+help=0;
+done=0;
+int jcv;
+char temp[300];
+struct mathfunction_s *myfunc;
+#ifdef HAVE_MATHEVAL
+myfunc=&mathfunction[count];
+
+   go=0; 
+   //fprintf(fplog,"NW IS %d \n",*nw);
+   // allow spacing: from first quote up to last quote
+   for(i=0;i<(*nw);i++){
+       // find the quotes 
+       tok=strstr(word[i],"\"");
+       if(tok!=NULL){
+           if(go==1){ go=0; 
+                 // fprintf(fplog,"LASTTOK IS %s WORD IS %s\n",tok,word[i]);
+                  strcat(myfunc->fline,word[i]);
+                  strcat(myfunc->fline,"\0");done=1;}
+           else     { go=1; 
+                 // fprintf(fplog,"FIRSTTOK IS %s WORD IS %s\n",tok,word[i]); 
+                  strcpy(myfunc->fline,word[i]) ; };
+       };
+       if(go==1 && tok==NULL ){  
+                 //fprintf(fplog,"WORD IS %s\n",word[i])  ; 
+                   strcat(myfunc->fline,word[i])  ;}
+   } 
+   if(done==0)help=1;
+   if(help){
+    fprintf(fplog, "\n|-FUNCTION CV: WRONG SYNTAX\n");
+    fprintf(fplog, "e.g.:     \n");
+    fprintf(fplog, "      FUNCTION \" CV_1+3*CV_2 \"  {SIGMA 1.0}\n");
+    plumed_error("PluMeD dead with errors: check log file");
+   }
+
+
+   //fprintf(fplog,"THE FUNCTION IS %s \n",myfunc->fline); 
+   // now substitute
+   i=0;
+   strcpy(temp,"");
+   while(myfunc->fline[i] !='\0'){
+     if( strncmp(&myfunc->fline[i],"\"",1)!=0){ strncat(temp,&myfunc->fline[i],1);}
+     i++;
+   }
+   //EXIT();
+   strcat(temp,"\0"); 
+   strcpy(myfunc->fline,temp);
+   fprintf(fplog, "\n%1i-FUNCTION: %s \n", count+1,myfunc->fline);
+ 
+   myfunc->f = evaluator_create (myfunc->fline);
+   evaluator_get_variables (myfunc->f, &myfunc->names, &myfunc->count);
+   // allocate the primes 300 chars should be enough
+   myfunc->f_prim=(void **)malloc(myfunc->count*sizeof(void *));
+   myfunc->indcvs=(int *)malloc(myfunc->count*sizeof(int));
+   myfunc->valcvs=(real *)malloc(myfunc->count*sizeof(real));
+   fprintf(fplog,"|-VARIABLES IDENTIFIED: \n");
+   // parse the names
+   k=0;
+   colvar.natoms[count]=0;
+   for (i = 0; i < myfunc->count; i++){
+          fprintf(fplog, "|-CV %d  :   %s \n",i+1, myfunc->names[i]);
+          tok=strtok(myfunc->names[i],"CV_");
+          myfunc->indcvs[i]=atoi(tok)-1; 
+          logical.always[  myfunc->indcvs[i]  ]=1; 
+          if(myfunc->indcvs[i]>=count){
+              fprintf(fplog,"\n\nCV %d DOES NOT APPEAR TO HAVE BEEN DEFINED YET.\n",jcv+1);
+              fprintf(fplog,"ONLY PREVIOUSLY DEFINED CVs CAN BE COMBINED BY FUNC!\n");
+              plumed_error("PluMeD dead with errors: check log file");
+              EXIT(); // just to be sure!
+          };
+          //fprintf(fplog, "INDEXCV  :   %d \n",myfunc->indcvs[i]);
+          jcv=myfunc->indcvs[i];
+          colvar.natoms[count]+=colvar.natoms[jcv]; 
+         // fprintf(fplog,"jcv=%d, natoms=%d\n", jcv, colvar.natoms[jcv]);
+          srenew(colvar.cvatoms[count],colvar.natoms[count]);
+      // Copy atom indexes from jcv into count 
+          for(j=0;j<colvar.natoms[jcv];j++){
+             colvar.cvatoms[count][k] = colvar.cvatoms[jcv][j]; 
+           k++; }
+     }
+
+     for (i = 0; i < myfunc->count; i++){
+       fprintf (fplog,"|- FIRST DERIVATIVE RESPECT TO %s :  ", myfunc->names[i]);
+       myfunc->f_prim[i]=evaluator_derivative(myfunc->f,myfunc->names[i]);
+       fprintf (fplog," %s\n", evaluator_get_string (myfunc->f_prim[i]));
+     } 
+
+fprintf(fplog,"|%d ATOMS IN THIS CV:\n", colvar.natoms[count]);
+for(j=0; j<colvar.natoms[count]; j++){
+  fprintf(fplog, "|-(ifunc=%d), (atid=%d)\n",j,colvar.cvatoms[count][j]);
+} 
+ 
+colvar.type_s[count]   = 51;
+snew(colvar.myder[count], colvar.natoms[count]);
+
+iw=seek_word(word,"SIGMA");
+if(iw>=0){ 
+  sscanf(word[iw+1],"%lf", &delta);
+  colvar.delta_r[count]  = (real) delta; 
+}
+
+ if (logical.do_hills) fprintf(fplog,"|- SIGMA %f\n",colvar.delta_r[count]);
+ else fprintf(fplog,"\n");
+
+ return colvar.natoms[count];
+// EXIT(); 
+#else
+  fprintf(fplog, "\n-FUNCTION CV: YOU CANNOT DO THAT. COMPILE WITH LIBMATHEVAL \n");
+  plumed_error("PluMeD dead with errors: check log file");
+  EXIT();
+#endif
+}
+
+
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_hbonds.c dl_class_1.9/srcmod/Plumed/restraint_hbonds.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_hbonds.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_hbonds.c	2015-11-07 17:37:19.362603461 +0100
@@ -0,0 +1,205 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX hbonds_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int j, ix, i, kk, firstAtom, secondAtom;
+  double nn, mm;
+  rvec rij;
+  real mod_rij, rdist;
+  double nhbond, r6dist, r12dist, num, iden;
+  double rijfmod, deriv;
+  int firstRes = 1, secondRes = -1;  // ### Default residue numbers always different.
+
+  nhbond = 0.;
+  nn = (double) colvar.nn[i_c];
+  mm = (double) colvar.mm[i_c];
+  for(i=0;i<colvar.natoms[i_c];i++) for(ix=0;ix<3;ix++) colvar.myder[i_c][i][ix] = 0.;
+
+  for(i=0;i<colvar.list[i_c][0];i++) {						// cycle over acceptors
+    firstAtom = colvar.cvatoms[i_c][i];						// acceptors atom
+    if (colvar.list[i_c][2] == colvar.list[i_c][0]) {
+    	firstRes = colvar.cvatoms[i_c][i + colvar.natoms[i_c]]; // #### acceptors atom
+    }
+    for(j=colvar.list[i_c][0];j<colvar.natoms[i_c];j++) {	                // cycle over hydrogens
+      kk=i-j+colvar.list[i_c][0];
+      if(colvar.type[i_c]==1) {
+        if(abs(kk)<=4) continue;
+        if(kk%2==0) continue;
+      } else if(colvar.type[i_c]==2) {
+        if(abs(kk)!=4) continue;
+      } else if(colvar.type[i_c]==3) {
+        if(abs(kk)<=4) continue;
+        if(kk%2==1) continue;
+      } else if(colvar.type[i_c]==4) {
+        if(kk!=0) continue;   
+      } else if(colvar.type[i_c]==6) {    // #### This type is undocumented, so we put it to six for consistency
+        if(abs(kk)<=4) continue; 
+      }
+      secondAtom = colvar.cvatoms[i_c][j];			// hydrogen atom
+      if (colvar.list[i_c][3] == colvar.list[i_c][1]) {
+    	  secondRes = colvar.cvatoms[i_c][j + colvar.natoms[i_c] ];
+      }
+
+      if(firstAtom==secondAtom) continue;
+      // ##### There must be no force for donor and acceptor atoms on the same peptide group.
+      if(colvar.type[i_c]==5) {
+          if (firstRes == secondRes) continue;
+    	  if(abs(firstAtom - secondAtom)<=5) continue;
+      }
+      if(colvar.cell_pbc[i_c]){ // distance acceptor/donor
+        minimal_image(mtd_data->pos[firstAtom], mtd_data->pos[secondAtom], &mod_rij, rij);
+      } else {
+        rij[0] = mtd_data->pos[firstAtom][0]-mtd_data->pos[secondAtom][0];
+        rij[1] = mtd_data->pos[firstAtom][1]-mtd_data->pos[secondAtom][1];
+        rij[2] = mtd_data->pos[firstAtom][2]-mtd_data->pos[secondAtom][2];
+        mod_rij  = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+      };
+      rdist = mod_rij/colvar.r_0[i_c];				// weighted distance
+      if(rdist>0.99998 && rdist<1.00002) rdist = 0.99999;	// to keep the function continuos
+      r6dist = pow(rdist, nn);	
+      num = 1.-r6dist;						// numerator
+      r12dist = pow(rdist, mm);	
+      iden = 1./(1.-r12dist);					// denominator
+
+      nhbond += num*iden;
+      for(ix=0;ix<3;ix++) {
+        rijfmod = (double) rij[ix]/(mod_rij*mod_rij);
+        deriv = -rijfmod*(-mm*r12dist+r6dist*(nn+(mm-nn)*r12dist))*iden*iden;
+        colvar.myder[i_c][i][ix] += (real) deriv;
+        colvar.myder[i_c][j][ix] += (real) -deriv;
+      }
+    }
+  }
+  colvar.ss0[i_c] = (real) nhbond;
+  
+}
+
+// --------------------------------------------------------------------------------------------------------------
+
+int PREFIX read_hbonds(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  double delta = 0.0;
+  double r_0;
+  int iat, i, j, iw, help;
+  char string[400];
+
+  help=0;
+  colvar.nn[count] = 6;
+  colvar.mm[count] = 12;
+
+#if defined (PLUMED_GROMACS)
+  r_0 = 0.25;
+#else
+  r_0 = 2.5;
+#endif
+
+  colvar.cell_pbc[count]=1; // default is PBC
+
+  iw=seek_word(word,"NOPBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 0;}
+  iw=seek_word(word,"PBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 1;}
+  iw = seek_word(word,"LIST");
+  if(iw>=0){
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+             j=plumed_get_group(word[iw+2],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][1]=j;
+  }  else {fprintf(fplog,"|- NEEDED LIST KEYWORD FOR HBONDS\n"); help=1;}
+  // ##### List of residue numbers for excluding intra-residue h-bonds.
+  iw = seek_word(word,"RESLIST");
+  if(iw>=0){
+               j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+               colvar.list[count][2]=j;
+               if (j != colvar.list[count][0] ) plumed_error("HBONDS RESLIST : residue numbers should correspond to atoms!");
+               j=plumed_get_group(word[iw+2],&colvar.cvatoms[count],colvar.natoms[count] + j ,input,fplog);
+               colvar.list[count][3]=j;
+               if (j != colvar.list[count][1] ) plumed_error("HBONDS RESLIST : residue numbers should correspond to atoms!");
+  }else{
+			  colvar.list[count][2]=0;
+			  colvar.list[count][3]=0;
+  }
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+  iw=seek_word(word,"NN");
+  if(iw>=0) {sscanf(word[iw+1],"%i", &colvar.nn[count]); }
+  iw=seek_word(word,"MM");
+  if(iw>=0) {sscanf(word[iw+1],"%i", &colvar.mm[count]); }
+  iw=seek_word(word,"R_0");
+  if(iw>=0) {sscanf(word[iw+1],"%lf", &r_0); } 
+  iw=seek_word(word,"TYPE");
+  if(iw>=0) {sscanf(word[iw+1],"%i", &colvar.type[count]); } else {fprintf(fplog,"|- NEEDED TYPE KEYWORD FOR HBONDS\n"); help=1;}
+
+  if(help){
+          fprintf(fplog, "\n-HBONDS CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "HBONDS LIST <H> <O> TYPE 0 SIGMA 0.1 [NN 6 MM 12 R_0 2.5]\n");
+          fprintf(fplog, "         H->    \n");
+          fprintf(fplog, "         6 10    \n");
+          fprintf(fplog, "         H<-    \n");
+          fprintf(fplog, "                 \n");
+          fprintf(fplog, "         O->    \n");
+          fprintf(fplog, "         8 12 \n");
+          fprintf(fplog, "         O<-    \n");
+          fprintf(fplog, "                 \n"); 
+          plumed_error("PluMeD dead with errors: check log file");
+  }
+
+  colvar.r_0[count]	 = (real) r_0;
+  colvar.type_s[count]   = 7;
+
+  fprintf(fplog, "\n%1i-HBONDS: NN %i MM %i R_0 %lf ", count+1, colvar.nn[count], colvar.mm[count], colvar.r_0[count]);
+  if(colvar.cell_pbc[count]) fprintf(fplog, " PBC ON");
+  else                       fprintf(fplog, " PBC OFF");
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+  // ##### Type 5 is documented
+  fprintf(fplog, "|--HBONDS: WILL COUNT INTRA PROTEIN HBONDS, TYPE = %i (0 = ALL, 1 = BETA ODD, 2 = ALPHA, 3 = BETA EVEN, 4 = NATIVE, 5 = ALL NOT WITHIN 5 ATOMS, 6 = BETA ALL)\n", colvar.type[count]);
+
+  iat=0;
+  fprintf(fplog,"|- 1st SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][0];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 2nd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][1];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");  
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  return colvar.natoms[count];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_helix.c dl_class_1.9/srcmod/Plumed/restraint_helix.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_helix.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_helix.c	2015-11-07 17:37:19.365603548 +0100
@@ -0,0 +1,231 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX helix_restraint(int i_c, struct mtd_data_s *mtd_data) 
+{
+  real **psi;
+  real tnorm[6], prdt[6], prdt_sign[6];
+  real dpsi[6], dps[6], cos_psi[6];
+  real nv1[6], nv2[6];
+  real vp1[6][3], vp2[6][3];
+  real r01[6][3], r21[6][3], r23[6][3];
+  real psisum, psi_sum_tmp, pi;
+  real ddotd[9], dnormd[9], dcosd[9];
+  real fd1, fd2, fmod, mod_rij;
+  int i, ii, jj, idtc, ndtc;
+  int a0, a1, a2, a3;
+ 
+  ndtc   = colvar.type[i_c];
+  psisum = 0.;
+  pi     = M_PI; 
+  psi    = (real **)float_2d_array_alloc(6,ndtc);
+
+  for(idtc=0;idtc<ndtc;idtc++) {
+
+   psi_sum_tmp = 1.;
+
+   for(ii=0;ii<6;ii++) {
+
+    a0 = colvar.cvatoms[i_c][24*idtc+ii*4+0];
+    a1 = colvar.cvatoms[i_c][24*idtc+ii*4+1];
+    a2 = colvar.cvatoms[i_c][24*idtc+ii*4+2];
+    a3 = colvar.cvatoms[i_c][24*idtc+ii*4+3];
+   
+    minimal_image(mtd_data->pos[a1],mtd_data->pos[a0],&mod_rij,r01[ii]);
+    minimal_image(mtd_data->pos[a2],mtd_data->pos[a1],&mod_rij,r21[ii]);
+    minimal_image(mtd_data->pos[a3],mtd_data->pos[a2],&mod_rij,r23[ii]);
+
+    oprod(r01[ii], r21[ii], vp1[ii]);
+    oprod(r21[ii], r23[ii], vp2[ii]);
+    nv1[ii] = norm(vp1[ii]);
+    nv2[ii] = norm(vp2[ii]);
+    tnorm[ii] = nv1[ii] * nv2[ii];
+
+    prdt[ii] = iprod(vp1[ii], vp2[ii]); 
+    prdt_sign[ii] = iprod(r01[ii],vp2[ii]);
+    prdt_sign[ii] /= fabs(prdt_sign[ii]);
+
+    cos_psi[ii] = prdt[ii] / tnorm[ii];   
+    if(fabs(cos_psi[ii]) > 1.) cos_psi[ii] /= fabs(cos_psi[ii]);
+
+    psi[ii][idtc] = prdt_sign[ii] * acos(cos_psi[ii]);
+
+    if(ii<3) dps[ii] = psi[ii][idtc]-colvar.map0[i_c][idtc];
+    else     dps[ii] = psi[ii][idtc]-colvar.map1[i_c][idtc];
+
+    psi_sum_tmp = psi_sum_tmp*0.5*(cos(dps[ii])+1.);
+
+   } 
+
+   psisum += psi_sum_tmp; 
+
+   for(ii=0;ii<6;ii++) {     
+    dpsi[ii]    = -0.5*sin(dps[ii]);
+    for(jj=0;jj<6;jj++) if(ii!=jj) dpsi[ii] = dpsi[ii]*0.5*(cos(dps[jj])+1.); 
+   }
+
+   for(ii=0;ii<6;ii++) { 
+    /* derivatives of the scalar product */
+    ddotd[0] =  r21[ii][1]*vp2[ii][2] - r21[ii][2]*vp2[ii][1];
+    ddotd[1] = -r21[ii][0]*vp2[ii][2] + r21[ii][2]*vp2[ii][0];
+    ddotd[2] =  r21[ii][0]*vp2[ii][1] - r21[ii][1]*vp2[ii][0];
+
+    ddotd[3] = -r21[ii][1]*vp1[ii][2] + r21[ii][2]*vp1[ii][1];
+    ddotd[4] =  r21[ii][0]*vp1[ii][2] - r21[ii][2]*vp1[ii][0];
+    ddotd[5] = -r21[ii][0]*vp1[ii][1] + r21[ii][1]*vp1[ii][0];
+
+    ddotd[6] =  r23[ii][1]*vp1[ii][2] - r01[ii][1]*vp2[ii][2] - r23[ii][2]*vp1[ii][1] + r01[ii][2]*vp2[ii][1];
+    ddotd[7] = -r23[ii][0]*vp1[ii][2] + r01[ii][0]*vp2[ii][2] + r23[ii][2]*vp1[ii][0] - r01[ii][2]*vp2[ii][0];
+    ddotd[8] =  r23[ii][0]*vp1[ii][1] - r01[ii][0]*vp2[ii][1] - r23[ii][1]*vp1[ii][0] + r01[ii][1]*vp2[ii][0];
+
+    /* derivatives of the norm part */
+    fd1 = nv2[ii] / nv1[ii];
+    fd2 = nv1[ii] / nv2[ii];
+
+    dnormd[0] = -ddotd[3] * fd1;
+    dnormd[1] = -ddotd[4] * fd1;
+    dnormd[2] = -ddotd[5] * fd1;
+
+    dnormd[3] = -ddotd[0] * fd2;
+    dnormd[4] = -ddotd[1] * fd2;
+    dnormd[5] = -ddotd[2] * fd2;
+
+    dnormd[6] = ( r23[ii][1]*vp2[ii][2]-r23[ii][2]*vp2[ii][1] )*fd2 + ( r01[ii][2]*vp1[ii][1]-r01[ii][1]*vp1[ii][2] )*fd1;
+    dnormd[7] = (-r23[ii][0]*vp2[ii][2]+r23[ii][2]*vp2[ii][0] )*fd2 + ( r01[ii][0]*vp1[ii][2]-r01[ii][2]*vp1[ii][0] )*fd1;
+    dnormd[8] = ( r23[ii][0]*vp2[ii][1]-r23[ii][1]*vp2[ii][0] )*fd2 + (-r01[ii][0]*vp1[ii][1]+r01[ii][1]*vp1[ii][0] )*fd1;
+
+    for(i=0;i<9;i++)
+        dnormd[i] /= tnorm[ii]*tnorm[ii];
+
+         /* derivatives of cosine */
+    for(i=0;i<9;i++)
+        dcosd[i] = ddotd[i]/tnorm[ii] - prdt[ii]*dnormd[i];
+
+    /* check for numerical inconsistency */
+    if(fabs(psi[ii][idtc])<0.00001 || fabs(psi[ii][idtc]-pi)<0.00001 || fabs(psi[ii][idtc]+pi)<0.00001)
+        fmod = 0.;
+    else
+        fmod = prdt_sign[ii] / fabs(sin(psi[ii][idtc]));
+
+    /* atom derivatives */
+    colvar.myder[i_c][24*idtc+ii*4+0][0] = dcosd[0] * fmod * dpsi[ii];
+    colvar.myder[i_c][24*idtc+ii*4+0][1] = dcosd[1] * fmod * dpsi[ii];
+    colvar.myder[i_c][24*idtc+ii*4+0][2] = dcosd[2] * fmod * dpsi[ii];
+
+    colvar.myder[i_c][24*idtc+ii*4+1][0] = -(dcosd[0]-dcosd[6]) * fmod * dpsi[ii];
+    colvar.myder[i_c][24*idtc+ii*4+1][1] = -(dcosd[1]-dcosd[7]) * fmod * dpsi[ii];
+    colvar.myder[i_c][24*idtc+ii*4+1][2] = -(dcosd[2]-dcosd[8]) * fmod * dpsi[ii];
+
+    colvar.myder[i_c][24*idtc+ii*4+2][0] = -(dcosd[6]-dcosd[3]) * fmod * dpsi[ii];
+    colvar.myder[i_c][24*idtc+ii*4+2][1] = -(dcosd[7]-dcosd[4]) * fmod * dpsi[ii];
+    colvar.myder[i_c][24*idtc+ii*4+2][2] = -(dcosd[8]-dcosd[5]) * fmod * dpsi[ii];
+
+    colvar.myder[i_c][24*idtc+ii*4+3][0] = -dcosd[3] * fmod * dpsi[ii];
+    colvar.myder[i_c][24*idtc+ii*4+3][1] = -dcosd[4] * fmod * dpsi[ii];
+    colvar.myder[i_c][24*idtc+ii*4+3][2] = -dcosd[5] * fmod * dpsi[ii];
+
+   }
+  }
+
+  colvar.ss0[i_c] = psisum;
+
+  free_2dr_array_alloc(psi,6);
+
+}
+
+//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
+
+ int PREFIX read_helix   (char **word,int count,t_plumed_input *input,int *iline,FILE *fplog)
+{
+  int i, iat, iw;
+  int atnr[24];
+  int help;
+  double delta, r_0, r_1;
+  char string[400];
+
+  help = 0;
+  
+  iw=seek_word(word,"NLOOP");
+  if(iw>=0) {sscanf(word[iw+1],"%i", &colvar.type[count]);} else {fprintf(fplog,"|- NEEDED NLOOP KEYWORD FOR HELIX\n"); help=1;}
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0) {
+       sscanf(word[iw+1],"%lf", &delta);
+       colvar.delta_r[count]  = (real) delta; }
+
+   if(help){
+         fprintf(fplog,"|- HELIX SYNTAX:\n");
+         fprintf(fplog,"|- NLOOP              : number of loops\n");
+         fprintf(fplog,"|- SIGMA              : hills width for this cv\n");
+         fprintf(fplog,"e.g. \n");
+         fprintf(fplog,"HELIX NLOOP 2 SIGMA 0.1 \n");
+         fprintf(fplog,"12 14 20 22   22 24 35 37   37 39 49 51  -0.785    10 12 14 20  20 22 24 35   35 37 39 49   -1.200 \n");
+         fprintf(fplog,"22 24 35 37   37 39 49 51   51 53 59 61  -0.785    20 22 24 35  35 37 39 49   49 51 53 59   -1.200 \n");
+         plumed_error("PluMeD dead with errors: check log file");
+  }
+
+
+  colvar.natoms[count]   = 24*colvar.type[count]; 
+
+  fprintf(fplog, "\n%1i-HELIX: %i LOOPS; ", count+1, colvar.type[count]);
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n");
+
+  snew(colvar.cvatoms[count], colvar.natoms[count]);
+  snew(colvar.myder[count],   colvar.natoms[count]);
+  snew(colvar.map0[count],    colvar.type[count]);
+  snew(colvar.map1[count],    colvar.type[count]);
+
+  for(iat=0;iat<colvar.type[count];iat++){
+    (*iline)++;
+    for(i=0;i<12;i++)  sscanf(input->words[*iline][i],"%i", &atnr[i]); 
+    sscanf(input->words[*iline][12],"%lf",&r_0);
+    for(i=13;i<25;i++) sscanf(input->words[*iline][i],"%i", &atnr[i-1]);
+    sscanf(input->words[*iline][25],"%lf",&r_1);
+
+    for(i=0;i<24;i++) colvar.cvatoms[count][24*iat+i]   = atnr[i]-1;
+    colvar.map0[count][iat] = (real) r_0;
+    colvar.map1[count][iat] = (real) r_1;
+
+    fprintf(fplog, "|--LOOP %i, ATOMS: ",iat+1);
+    for (i=0;i<3;i++) fprintf(fplog, "%i %i %i %i - ",atnr[i*4+0],atnr[i*4+1],atnr[i*4+2],atnr[i*4+3]);
+    fprintf(fplog, " R_0 :: %lf\n",colvar.map0[count][iat]);
+    fprintf(fplog, "          ATOMS: ");
+    for (i=0;i<3;i++) fprintf(fplog, "%i %i %i %i - ",atnr[12+i*4+0],atnr[12+i*4+1],atnr[12+i*4+2],atnr[12+i*4+3]);
+    fprintf(fplog, " R_1 :: %lf\n",colvar.map1[count][iat]); 
+  }
+
+  return colvar.type[count];
+
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_histogram.c dl_class_1.9/srcmod/Plumed/restraint_histogram.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_histogram.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_histogram.c	2015-11-07 17:37:19.368603635 +0100
@@ -0,0 +1,255 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.                                      
+*            
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX histogram_restraint(int i_c, struct mtd_data_s *mtd_data) {
+  int i, j, k, j_c; real lowB, upperB, dertmp;
+
+
+  k=0; colvar.ss0[i_c]=0.0;
+  for(i=0;i<colvar.histo_ncv[i_c];i++){
+     j_c = colvar.histo_cvlist[i_c][i];
+
+     lowB = ( colvar.histo_low[i_c] - colvar.ss0[j_c] ) / ( sqrt(2.0) * colvar.histo_width[i_c] ) ;
+     upperB = ( colvar.histo_high[i_c] - colvar.ss0[j_c] ) / ( sqrt(2.0) * colvar.histo_width[i_c] ) ;
+     dertmp = ( exp( -lowB*lowB ) - exp( -upperB*upperB ) ) / ( sqrt(2.0*M_PI)*colvar.histo_width[i_c] );
+
+     // Accumulate this colvar
+     colvar.ss0[i_c]+=0.5*( erf( upperB ) - erf( lowB ) );
+
+     // And derivatives 
+     for(j=0;j<colvar.natoms[j_c];j++) {
+        colvar.myder[i_c][k][0]=dertmp*colvar.myder[j_c][j][0];
+        colvar.myder[i_c][k][1]=dertmp*colvar.myder[j_c][j][1];
+        colvar.myder[i_c][k][2]=dertmp*colvar.myder[j_c][j][2];
+        k++;
+     }
+  }
+
+}
+
+int PREFIX read_histogram( char **word, int count, t_plumed_input *input, FILE *fplog ) {
+  int i, j, k, iw, ncolvar, ngrid, nspline;  int* cvlist;
+  double smooth, delta = 0.0; int help=0;
+
+  ncolvar=0; cvlist=NULL;
+
+  // This reads in all the CVs used for histogram collective coordinates
+  iw = seek_word(word,"CV_LIST"); 
+  if(iw>=0){  ncolvar=plumed_get_group(word[iw+1],&cvlist,0,input,fplog); 
+             if( ncolvar>count ){ plumed_error("NUMBER OF CVS USED TO CALCULATE HISTOGRAM"); }
+  } 
+  else{ fprintf(fplog,"|- NEEDED CV_LIST KEYWORD FOR HISTOGRAM\n"); help=1;}
+
+  colvar.histo_ncv[count]=ncolvar; 
+  snew( colvar.histo_cvlist[count], colvar.histo_ncv[count] );
+  for(i=0;i<colvar.histo_ncv[count];++i){ colvar.histo_cvlist[count][i]=cvlist[i]; }
+
+  // This is the sanity check for CV_LIST ( part 2 : check all the cvs used to construct histogram cvs are declared before any BESPOKE cvs)
+  for(i=0;i<colvar.histo_ncv[count];i++){
+     if( colvar.histo_cvlist[count][i]>count ){fprintf(fplog,"HISTOGRAM COMMAND MUST COME AFTER ALL CVS USED TO CREATE HISTOGRAM CV \n"); help=1; }
+     // Number of atoms involved in this CV (sum of number of atoms involved in all other cvs)
+     colvar.natoms[count]+=colvar.natoms[ colvar.histo_cvlist[count][i] ];
+  }
+
+  iw = seek_word(word,"RANGE");
+  if(iw>=0) { 
+     sscanf(word[iw+1], "%lf", &delta ); colvar.histo_low[count] = (real) delta; 
+     sscanf(word[iw+2], "%lf", &delta ); colvar.histo_high[count] = (real) delta; 
+  } 
+  else{ fprintf(fplog,"|- NEEDED RANGE KEYWORD FOR HISTOGRAM\n"); help=1; }
+
+  iw = seek_word(word,"WIDTH");
+  if(iw>=0) { sscanf(word[iw+1], "%lf", &delta ); colvar.histo_width[count] = (real) delta; }
+  else{ fprintf(fplog,"|- NEEDED WIDTH KEYWORD FOR HISTOGRAM\n"); help=1; }
+
+  // Setup array of atoms involved in this cv
+  snew( colvar.cvatoms[count], colvar.natoms[count] ); k=0;
+  for(i=0;i<colvar.histo_ncv[count];i++){
+     for(j=0;j<colvar.natoms[ colvar.histo_cvlist[count][i] ];j++){
+        colvar.cvatoms[count][k]=colvar.cvatoms[ colvar.histo_cvlist[count][i] ][j];
+        k++;
+     }
+  }
+  // Setup derivatives array
+  snew( colvar.myder[count], colvar.natoms[count] );
+
+  if(help){ 
+     fprintf(fplog,"\n-HISTOGRAM CV: WRONG SYNTAX\n");
+     fprintf(fplog,"e.g.:    \n");
+     fprintf(fplog,"TORSION LIST <g1> <g2> <g3> <g4>    \n");
+     fprintf(fplog,"TORSION LIST <g2> <g3> <g4> <g5>    \n");
+     fprintf(fplog,"TORSION LIST <g3> <g4> <g5> <g6>    \n");
+     fprintf(fplog,"TORSION LIST <g4> <g5> <g6> <g7>    \n");
+     fprintf(fplog,"HISTOGRAM CV_LIST <cv_list> RANGE 2.0 3.0 WIDTH 0.5\n");
+     fprintf(fplog,"cvlist-> \n");
+     fprintf(fplog,"1 2 3 4  \n");
+     fprintf(fplog,"cvlist<- \n");
+     fprintf(fplog,"         \n"); 
+     plumed_error("PluMed dead with errors: check log file");
+  }
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+
+  fprintf(fplog, "%1i-HISTOGRAM COLLECTIVE COORDINATE CREATED FROM %i OTHER CVS \n", count+1, colvar.histo_ncv[count]);
+  fprintf(fplog, "|--PARAMETERS: RANGE OF DESIRED VALUE = %f %f.  WIDTH OF GAUSSIAN FOR SMOOTHING %f. \n", colvar.histo_low[count], colvar.histo_high[count],colvar.histo_width[count] );
+  fprintf(fplog,"|- COLVARS USED IN HISTOGRAM CV:");
+  for(i=0;i<colvar.histo_ncv[count];i++){fprintf(fplog," %d ",colvar.histo_cvlist[count][i]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+
+  return colvar.natoms[count];
+}
+
+// A separate test derivatives routine
+
+void PREFIX histogram_testderivatives(int j_c, struct mtd_data_s *mtd_data)
+{ 
+  real teststep = 0.00001, invstep = 100000. ; 
+  double testforce, analder, val1, val2;
+  int i_c, i_bc, ix, i, j, k, iat, it;
+
+  for(i=0;i<colvar.natoms[j_c];i++) {   // Loop over all atoms in the CV 
+      iat = colvar.cvatoms[j_c][i];
+      for(ix=0;ix<3;ix++) {              // Loop over all coordinates 
+          mtd_data->pos[iat][ix] += teststep;
+          for(i_bc=0;i_bc<colvar.histo_ncv[j_c];i_bc++) { // Loop over all cvs used to construct histo cv
+              i_c=colvar.histo_cvlist[j_c][i_bc];
+              switch(colvar.type_s[i_c]){
+                case 1: dist_restraint(i_c, mtd_data); break;
+                case 2: mindist_restraint(i_c, mtd_data); break;
+                case 3: coord_restraint(i_c, mtd_data); break;
+                case 4: angle_restraint(i_c, mtd_data); break;
+                case 5: torsion_restraint(i_c, mtd_data); break;
+                case 6: alfabeta_restraint(i_c, mtd_data); break;
+                case 7: hbonds_restraint(i_c, mtd_data); break;
+                case 8: dipole_restraint(i_c, mtd_data); break;
+                case 11: radgyr_restraint(i_c, mtd_data); break;
+                case 16: dihcor_restraint(i_c, mtd_data); break;
+                case 20: waterbridge_restraint(i_c, mtd_data); break;
+                case 30: spath_restraint(i_c, mtd_data); break;
+                case 31: zpath_restraint(i_c, mtd_data); break;
+                case 32: position_restraint(i_c, mtd_data); break;
+                case 33: elstpot_restraint(i_c, mtd_data); break;
+                case 34: puckering_restraint(i_c, mtd_data); break;
+                case 36: helix_restraint(i_c, mtd_data); break;
+                case 37: alpharmsd_restraint(i_c, mtd_data); break;
+                case 38: antibetarmsd_restraint(i_c, mtd_data); break;
+                case 39: parabetarmsd_restraint(i_c, mtd_data); break;
+                //case 40: camshift_restraint(i_c, mtd_data); break;
+                case 45: cmap_restraint(i_c, mtd_data); break;
+                case 47: rdf_restraint(i_c, 1, mtd_data); break;
+                case 52: adf_restraint(i_c, 0, mtd_data); break;
+              }
+          }
+          histogram_restraint( j_c, mtd_data ); k=0; val1=colvar.ss0[j_c];
+
+          mtd_data->pos[iat][ix] += -2.*teststep;
+          for(i_bc=0;i_bc<colvar.histo_ncv[j_c];i_bc++) {
+              i_c=colvar.histo_cvlist[j_c][i_bc];
+              switch(colvar.type_s[i_c]){
+               case 1: dist_restraint(i_c, mtd_data); break;
+               case 2: mindist_restraint(i_c, mtd_data); break;
+               case 3: coord_restraint(i_c, mtd_data); break;
+               case 4: angle_restraint(i_c, mtd_data); break;
+               case 5: torsion_restraint(i_c, mtd_data); break;
+               case 6: alfabeta_restraint(i_c, mtd_data); break;
+               case 7: hbonds_restraint(i_c, mtd_data); break;
+               case 8: dipole_restraint(i_c, mtd_data); break;
+               case 11: radgyr_restraint(i_c, mtd_data); break;
+               case 16: dihcor_restraint(i_c, mtd_data); break;
+               case 20: waterbridge_restraint(i_c, mtd_data); break;
+               case 30: spath_restraint(i_c, mtd_data); break;
+               case 31: zpath_restraint(i_c, mtd_data); break;
+               case 32: position_restraint(i_c, mtd_data); break;
+               case 33: elstpot_restraint(i_c, mtd_data); break;
+               case 34: puckering_restraint(i_c, mtd_data); break;
+               case 36: helix_restraint(i_c, mtd_data); break;
+               case 37: alpharmsd_restraint(i_c, mtd_data); break;
+               case 38: antibetarmsd_restraint(i_c, mtd_data); break;
+               case 39: parabetarmsd_restraint(i_c, mtd_data); break;
+               //case 40: camshift_restraint(i_c, mtd_data); break;
+               case 45: cmap_restraint(i_c, mtd_data); break;
+               case 47: rdf_restraint(i_c, 1, mtd_data); break;
+               case 52: adf_restraint(i_c, 0, mtd_data); break;
+              }
+          }
+          histogram_restraint( j_c, mtd_data ); val2=colvar.ss0[j_c];
+
+          testforce = 0.5*((val1*invstep)-(val2*invstep)); 
+
+          mtd_data->pos[iat][ix] += teststep;
+          for(i_bc=0;i_bc<colvar.histo_ncv[j_c];i_bc++) {
+              i_c=colvar.histo_cvlist[j_c][i_bc];
+              switch(colvar.type_s[i_c]){
+                case 1: dist_restraint(i_c, mtd_data); break;
+                case 2: mindist_restraint(i_c, mtd_data); break;
+                case 3: coord_restraint(i_c, mtd_data); break;
+                case 4: angle_restraint(i_c, mtd_data); break;
+                case 5: torsion_restraint(i_c, mtd_data); break;
+                case 6: alfabeta_restraint(i_c, mtd_data); break;
+                case 7: hbonds_restraint(i_c, mtd_data); break;
+                case 8: dipole_restraint(i_c, mtd_data); break;
+                case 11: radgyr_restraint(i_c, mtd_data); break;
+                case 16: dihcor_restraint(i_c, mtd_data); break;
+                case 20: waterbridge_restraint(i_c, mtd_data); break;
+                case 30: spath_restraint(i_c, mtd_data); break;
+                case 31: zpath_restraint(i_c, mtd_data); break;
+                case 32: position_restraint(i_c, mtd_data); break;
+                case 33: elstpot_restraint(i_c, mtd_data); break;
+                case 34: puckering_restraint(i_c, mtd_data); break;
+                case 36: helix_restraint(i_c, mtd_data); break;
+                case 37: alpharmsd_restraint(i_c, mtd_data); break;
+                case 38: antibetarmsd_restraint(i_c, mtd_data); break;
+                case 39: parabetarmsd_restraint(i_c, mtd_data); break;
+                //case 40: camshift_restraint(i_c, mtd_data); break;
+                case 45: cmap_restraint(i_c, mtd_data); break;
+                case 47: rdf_restraint(i_c, 1, mtd_data); break;
+                case 52: adf_restraint(i_c, 0, mtd_data); break;
+              }
+          }
+          histogram_restraint( j_c, mtd_data );
+          
+          analder=0; 
+          for(j=0;j<colvar.natoms[j_c];j++) {
+             if(colvar.cvatoms[j_c][j]==iat) {
+                analder+=colvar.myder[j_c][j][ix]; 
+             }
+          }
+          printf("Force atom %5i[%i] ** analytic %15.10f ** numeric %15.10f *** DELTA %15.10f\n",
+              iat, ix, analder, testforce, analder-testforce); 
+      }
+  }
+
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_mindist.c dl_class_1.9/srcmod/Plumed/restraint_mindist.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_mindist.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_mindist.c	2015-11-07 17:37:19.371603722 +0100
@@ -0,0 +1,146 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+
+#include "metadyn.h"
+
+void PREFIX mindist_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int firstAtom, secondAtom, i, j, ix;
+  rvec rij;
+  real mod_rij;
+  double sum, pe, beta, dist;
+  sum=0.0;
+
+  beta = colvar.beta[i_c];
+
+  for(i=0;i<colvar.natoms[i_c];i++) for(ix=0;ix<3;ix++) colvar.myder[i_c][i][ix] = 0.;
+
+  for(i=0;i<colvar.list[i_c][0];i++){
+    firstAtom  = colvar.cvatoms[i_c][i];
+    for(j=colvar.list[i_c][0];j<colvar.natoms[i_c];j++){
+      secondAtom = colvar.cvatoms[i_c][j];
+      if(firstAtom != secondAtom){
+        if(colvar.cell_pbc[i_c]){
+          minimal_image(mtd_data->pos[firstAtom],mtd_data->pos[secondAtom], &mod_rij, rij);
+        } else {
+          rij[0] = mtd_data->pos[firstAtom][0] - mtd_data->pos[secondAtom][0];
+          rij[1] = mtd_data->pos[firstAtom][1] - mtd_data->pos[secondAtom][1];
+          rij[2] = mtd_data->pos[firstAtom][2] - mtd_data->pos[secondAtom][2];
+          mod_rij  = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+        };
+        pe = exp(beta/mod_rij);
+        sum += pe;
+        for(ix=0;ix<3;ix++) { 
+          colvar.myder[i_c][j][ix] += -pe*rij[ix]/(mod_rij*mod_rij*mod_rij);
+          colvar.myder[i_c][i][ix] += pe*rij[ix]/(mod_rij*mod_rij*mod_rij);
+        }
+      }
+    }
+  }
+
+  dist = beta/log(sum);
+  colvar.ss0[i_c] = (real) dist;
+
+  for(i=0;i<colvar.natoms[i_c];i++) for(ix=0;ix<3;ix++) colvar.myder[i_c][i][ix] = colvar.myder[i_c][i][ix]*dist*dist/sum;
+}
+
+//----------------------------------------------------------------------------------------------------------------
+
+int PREFIX read_mindist(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i, iw, j, iat, help;
+  double delta = 0.0;
+  char string[400];
+
+  if(sizeof(real)==sizeof(float)) colvar.beta[count] = 20.;
+  else colvar.beta[count] = 50.;
+
+  help=0;
+
+  colvar.cell_pbc[count]=1; // default is PBC
+
+  iw=seek_word(word,"NOPBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 0;}
+  iw=seek_word(word,"PBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 1;}
+  iw=seek_word(word,"BETA");
+  if(iw>=0){sscanf(word[iw+1],"%lf", &delta);
+             colvar.beta[count]  = (real) delta; }
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0){   
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+             j=plumed_get_group(word[iw+2],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][1]=j;
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR DISTANCE\n"); help=1;}
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+
+  if(help){
+          fprintf(fplog, "\n-MINDIST CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "MINDIST LIST <g1> <g2>  SIGMA 0.1 BETA 500.\n");
+          fprintf(fplog, "         g1->    \n");
+          fprintf(fplog, "         6 10    \n");
+          fprintf(fplog, "         g1<-    \n");
+          fprintf(fplog, "                 \n");
+          fprintf(fplog, "         g2->    \n");
+          fprintf(fplog, "         8 15 21 \n");
+          fprintf(fplog, "         g2<-    \n");
+          fprintf(fplog, "                 \n"); 
+          plumed_error("PluMeD dead with errors: check log file");
+  }
+
+  colvar.type_s[count] = 2;
+
+  fprintf(fplog, "\n%1i-MINDIST: (1st SET: %i ATOMS), (2nd SET: %i ATOMS); ", count+1, colvar.list[count][0], colvar.list[count][1]);
+  if(colvar.cell_pbc[count]) fprintf(fplog, " PBC ON; ");
+  else                       fprintf(fplog, " PBC OFF; ");
+  fprintf(fplog," BETA %f; ",colvar.beta[count]);
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n");
+  iat=0;
+  fprintf(fplog,"|- 1st SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][0];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 2nd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][1];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  return colvar.natoms[count];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_parabetarmsd.c dl_class_1.9/srcmod/Plumed/restraint_parabetarmsd.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_parabetarmsd.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_parabetarmsd.c	2015-11-07 17:37:19.374603809 +0100
@@ -0,0 +1,355 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX parabetarmsd_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int firstAtom, secondAtom, i, j, ix;
+  int nn = colvar.nn[i_c], mm = colvar.mm[i_c];
+  rvec rij;
+  real num, iden, mod_rij, rdist, func, dfunc, rNdist, rMdist;
+  real ncoord, r_0 = colvar.r_0[i_c], d_0 = colvar.d_0[i_c];
+  real threshold;
+  threshold=pow(0.00001,1./(nn-mm));
+
+  int ires, jres, nres, iat, add_grad, iblock;
+  int atom_list[30];
+  real dist_mat[30][30], dist_mat_rij[30][30][3];
+  real dist, g[30][3], rmsd, cutoff;
+  cutoff=colvar.realpar[i_c][0][0];
+
+  nres=colvar.natoms[i_c]/5;
+  ncoord=0.;
+  for (i=0;i<colvar.natoms[i_c];i++) { for (ix=0;ix<3;ix++) { colvar.myder[i_c][i][ix]=0.; } }
+
+  // ires:   0 1 ... = (N CA C O CB) (N CA C O CB) ...
+  // iat:    0 1 2 3 4 5 6 ... = N CA C O CB N CA ...
+  // loop over residue triplets {i,j}{i+1,j+1}{i+2,j+2} 
+  //  with (j-i)>5 (this leaves min 3 residues in the connecting chain)
+  for (ires=0;ires<nres-8;ires++) { 
+  for (jres=ires+6;jres<nres-2;jres++) { 
+    // copying atom indexes from 3 pairs of residues (6*5 atoms) in atom_list
+    // order of H-bonded residues in ref_parabeta[]: 1-4 2-5 3-6
+    for(i=0;i<15;i++) {
+      atom_list[i]=ires*5+i;
+      atom_list[i+15]=jres*5+i;
+    }
+//    for(i=0;i<30;i++){printf("ires1,jres1 = %d %d atom_list %d = %d\n",ires,jres,i,colvar.cvatoms[i_c][atom_list[i]]);} // DEBUG
+    // check if it's worth to compute the rmsd (if segments are not too far)
+    firstAtom=colvar.cvatoms[i_c][atom_list[6]];   // CA at the center of first segment
+    secondAtom=colvar.cvatoms[i_c][atom_list[21]]; // CA at the center of second segment
+    if(colvar.cell_pbc[i_c]){
+      minimal_image(mtd_data->pos[firstAtom], mtd_data->pos[secondAtom], &mod_rij, rij);
+    } else {
+      rij[0] = mtd_data->pos[firstAtom][0]-mtd_data->pos[secondAtom][0];
+      rij[1] = mtd_data->pos[firstAtom][1]-mtd_data->pos[secondAtom][1];
+      rij[2] = mtd_data->pos[firstAtom][2]-mtd_data->pos[secondAtom][2];
+      mod_rij = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+    }
+    if (mod_rij>cutoff) continue; // this can save a lot of computer time!
+    // rmsd between distance matrices
+    for (i=0;i<29;i++) {
+      firstAtom=colvar.cvatoms[i_c][atom_list[i]];
+      for (j=i+1;j<30;j++) {
+        secondAtom=colvar.cvatoms[i_c][atom_list[j]];
+        // skip covalent bonds
+        if (ref_dist_mat.parabeta[0][i][j]<=0.||ref_dist_mat.parabeta[1][i][j]<=0.) continue;
+        if(colvar.cell_pbc[i_c]){
+          minimal_image(mtd_data->pos[firstAtom], mtd_data->pos[secondAtom], &mod_rij, rij);
+        } else {
+          rij[0] = mtd_data->pos[firstAtom][0]-mtd_data->pos[secondAtom][0];
+          rij[1] = mtd_data->pos[firstAtom][1]-mtd_data->pos[secondAtom][1];
+          rij[2] = mtd_data->pos[firstAtom][2]-mtd_data->pos[secondAtom][2];
+          mod_rij = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+        }
+        dist_mat[i][j]=mod_rij;
+        for (ix=0;ix<3;ix++) { dist_mat_rij[i][j][ix]=rij[ix]; }
+      }
+    }
+    // loop over the two types of parabeta blocks
+    for (iblock=0;iblock<2;iblock++) {
+      // reset
+      rmsd=0.;
+      for (i=0;i<30;i++) { for (ix=0;ix<3;ix++) { g[i][ix]=0.; } }
+      for (i=0;i<29;i++) {
+        for (j=i+1;j<30;j++) {
+          if (ref_dist_mat.parabeta[0][i][j]<=0.||ref_dist_mat.parabeta[1][i][j]<=0.) continue;
+          dist = dist_mat[i][j]-ref_dist_mat.parabeta[iblock][i][j];
+//          printf("i j ai aj rij rij0 = %d %d %d %d %8.3f %8.3f\n",i,j,colvar.cvatoms[i_c][atom_list[i]],colvar.cvatoms[i_c][atom_list[j]],dist_mat[i][j],ref_dist_mat.parabeta[iblock][i][j]); // DEBUG
+          rmsd += dist*dist;
+          // store the atom-dependent part of the gradients
+          for (ix=0;ix<3;ix++) {
+            g[i][ix]+=dist*dist_mat_rij[i][j][ix]/dist_mat[i][j];
+            g[j][ix]-=dist*dist_mat_rij[i][j][ix]/dist_mat[i][j];
+          }
+        }
+      }
+      // normalize by the number of off-diagonal elements in the 30*30 matrix 
+      rmsd=sqrt(rmsd/ref_dist_mat.parabeta_pairs[iblock]); 
+//      printf("step = %d  ires,jres = %d %d  RMSD = %8.3f\n",colvar.it,ires,jres,rmsd); // DEBUG
+      // switching function
+      rdist = (rmsd-d_0)/r_0;
+      add_grad=0;
+      /* analitic limit of the switching function */
+      if(rdist<=0.){
+        ncoord+=1.;
+        dfunc=0.;
+      }else if(rdist>0.999999 && rdist<1.000001){
+        ncoord+=nn/mm;
+        dfunc=0.5*nn*(nn-mm)/mm;
+        add_grad=1;
+      }else if(rdist>threshold){
+        dfunc=0.;
+      }else{
+        rNdist = pow(rdist, nn-1);
+        rMdist = pow(rdist, mm-1);
+        num = 1.-rNdist*rdist;
+        iden = 1./(1.-rMdist*rdist);
+        func = num*iden;
+        ncoord += func;
+        dfunc = (-nn*rNdist*iden)+(func*(iden*mm)*rMdist);
+        add_grad=1;
+      }
+      if (add_grad==1) {
+        dfunc=dfunc/(r_0*rmsd*ref_dist_mat.parabeta_pairs[iblock]);
+        // total gradient
+        for (i=0;i<30;i++) {
+          for(ix=0;ix<3;ix++) {
+            // the factor 0.5 cures the double-counting in not-too-short sheets
+            colvar.myder[i_c][atom_list[i]][ix] += 0.5*dfunc*g[i][ix];
+          }
+        }
+      }
+    } // loop on iblock
+  } // loop on jres
+  } // loop on ires
+  // the factor 0.5 cures the double-counting in not-too-short sheets
+  colvar.ss0[i_c] = 0.5*ncoord;
+
+}
+
+//--------------------------------------------------------------------------------------------------------------
+
+int PREFIX read_parabetarmsd(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+// Coordinates N CA C O CB (Angstrom) of parabeta 3+3 blocks from the representative pdbs of
+// each of the 20 architecture entries in class "mainly beta" of CATH database
+// (1bds 1gvk 1h8p 1i5p 1itv 1k7i 1m3y 1n7v 1nh2 1qre
+// 1rg8 1tl2 1w6s 1ylh 2bbk 2dpf 2hnu 2nwf 3sil 4bcl)
+// There are 2 different ideal parabeta blocks!
+  static rvec ref_parabeta[60]={
+    { 1.244, -4.620, -2.127}, // N    i
+    {-0.016, -4.500, -1.395}, // CA
+    {-0.287, -3.000, -1.301}, // C
+    { 0.550, -2.245, -0.822}, // O
+    { 0.105, -5.089,  0.024}, // CB
+    {-1.445, -2.551, -1.779}, // N    i+1
+    {-1.752, -1.130, -1.677}, // CA
+    {-2.906, -0.961, -0.689}, // C
+    {-3.867, -1.738, -0.695}, // O
+    {-2.113, -0.550, -3.059}, // CB
+    {-2.774,  0.034,  0.190}, // N    i+2
+    {-3.788,  0.331,  1.201}, // CA
+    {-4.294,  1.743,  0.937}, // C
+    {-3.503,  2.671,  0.821}, // O
+    {-3.188,  0.300,  2.624}, // CB
+    { 4.746, -2.363,  0.188}, // N    j
+    { 3.427, -1.839,  0.545}, // CA
+    { 3.346, -0.365,  0.181}, // C
+    { 4.237,  0.412,  0.521}, // O
+    { 3.135, -1.958,  2.074}, // CB
+    { 2.261,  0.013, -0.487}, // N    j+1
+    { 2.024,  1.401, -0.875}, // CA
+    { 0.914,  1.902,  0.044}, // C
+    {-0.173,  1.330,  0.052}, // O
+    { 1.489,  1.514, -2.313}, // CB
+    { 1.202,  2.940,  0.828}, // N    j+2
+    { 0.190,  3.507,  1.718}, // CA
+    {-0.229,  4.791,  1.038}, // C
+    { 0.523,  5.771,  0.996}, // O
+    { 0.772,  3.801,  3.104}, // CB
+      {-1.439, -5.122, -1.144}, // N    i
+      {-0.816, -3.803, -1.013}, // CA
+      {-1.928, -2.770, -0.952}, // C
+      {-2.991, -2.970, -1.551}, // O
+      { 0.099, -3.509, -2.206}, // CB
+      {-1.698, -1.687, -0.215}, // N    i+1
+      {-2.681, -0.613, -0.143}, // CA
+      {-1.984,  0.681, -0.574}, // C
+      {-0.807,  0.921, -0.273}, // O
+      {-3.323, -0.477,  1.267}, // CB
+      {-2.716,  1.492, -1.329}, // N    i+2
+      {-2.196,  2.731, -1.883}, // CA
+      {-2.989,  3.949, -1.433}, // C
+      {-4.214,  3.989, -1.583}, // O
+      {-2.263,  2.692, -3.418}, // CB
+      { 2.464, -4.352,  2.149}, // N    j
+      { 3.078, -3.170,  1.541}, // CA
+      { 2.080, -2.021,  1.639}, // C
+      { 0.938, -2.178,  1.225}, // O
+      { 3.398, -3.415,  0.060}, // CB
+      { 2.525, -0.886,  2.183}, // N    j+1
+      { 1.692,  0.303,  2.346}, // CA
+      { 2.420,  1.410,  1.608}, // C
+      { 3.567,  1.733,  1.937}, // O
+      { 1.541,  0.665,  3.842}, // CB
+      { 1.758,  1.976,  0.600}, // N    j+2
+      { 2.373,  2.987, -0.238}, // CA
+      { 1.684,  4.331, -0.148}, // C
+      { 0.486,  4.430, -0.415}, // O
+      { 2.367,  2.527, -1.720}  // CB
+  };
+
+  int i, iw, iat, j, help, ix, iblock;
+  double r_0, d_0, d;
+  double delta = 0.0;
+  double angstrom_scale, strands_cutoff;
+  char string[400];
+  real threshold, value;
+
+  help=0;
+  d_0=0.;
+
+  colvar.cell_pbc[count]=1; // default is PBC
+  colvar.realpar[count][0][0]=1000000.; // by default, no cutoff on the distance between beta-strands
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0){
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR PARABETARMSD\n"); help=1;}
+
+  if(colvar.natoms[count]%5!=0){ fprintf(fplog,"|- ERROR: TOTAL NUMBER OF ATOMS MUST BE MULTIPLE OF 5\n"); help=1; }
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+  iw=seek_word(word,"NN");
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.nn[count]); } else { fprintf(fplog,"|- NEEDED NN KEYWORD FOR PARABETARMSD\n"); help=1;}
+  iw=seek_word(word,"MM");
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.mm[count]);} else { fprintf(fplog,"|- NEEDED MM KEYWORD FOR PARABETARMSD\n"); help=1;}
+  iw=seek_word(word,"R_0");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &r_0); } else { fprintf(fplog,"|- NEEDED R_0 KEYWORD FOR PARABETARMSD\n"); help=1;}
+  iw=seek_word(word,"D_0");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &d_0); }
+  iw=seek_word(word,"NOPBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 0;}
+  iw=seek_word(word,"PBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 1;}
+  iw=seek_word(word,"ANGSTROM_SCALE");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &angstrom_scale); } else { fprintf(fplog,"|- NEEDED ANGSTROM_SCALE KEYWORD FOR PARABETARMSD\n"); help=1;}
+  iw=seek_word(word,"STRANDS_CUTOFF");
+  if(iw>=0) { sscanf(word[iw+1],"%lf", &strands_cutoff); }
+
+  if(help){
+          fprintf(fplog, "\n-PARABETARMSD CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "PARABETARMSD LIST <g1> NN 8 MM 12 R_0 0.08 SIGMA 1.0 ANGSTROM_SCALE 0.1 STRANDS_CUTOFF 1. NOPBC\n");
+          fprintf(fplog, "         g1->    \n");
+          fprintf(fplog, "            7     9    26    27    11 \n");
+          fprintf(fplog, "           28    30    45    46    32 \n");
+          fprintf(fplog, "           47    49    56    57    51 \n");
+          fprintf(fplog, "           58    60    71    72    62 \n");
+          fprintf(fplog, "           73    75    88    89    77 \n");
+          fprintf(fplog, "           90    92   100   101    94 \n");
+          fprintf(fplog, "          102   104   120   121   106 \n");
+          fprintf(fplog, "          122   124   136   137   126 \n");
+          fprintf(fplog, "          138   140   147   148   142 \n");
+          fprintf(fplog, "          149   151   163   164   153 \n");
+          fprintf(fplog, "          165   167   183   184   169 \n");
+          fprintf(fplog, "          185   187   190   191   189 \n");
+          fprintf(fplog, "          192   194   209   210   196    \n");
+          fprintf(fplog, "         g1<-    \n");
+          fprintf(fplog, "       \n");
+          fprintf(fplog, " (where each row contains N CA C O CB of consecutive residues)\n");
+          fprintf(fplog, "       \n");
+          plumed_error("PluMeD dead with errors: check log file");
+  }
+
+  colvar.r_0[count]      = (real) r_0;
+  colvar.d_0[count]      = (real) d_0;
+  colvar.realpar[count][0][0] = (real) strands_cutoff;
+  colvar.type_s[count]   = 39;
+
+  fprintf(fplog, "%1i-PARABETARMSD; ATOMS INVOLVED: %i; ", count+1, colvar.natoms[count]);
+  if(colvar.cell_pbc[count]) fprintf(fplog, " PBC ON;");
+  else                       fprintf(fplog, " PBC OFF;");
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+  fprintf(fplog, "|--FUNCTIONAL FORM: (1-((dist_mat_rmsd-d_0)/r_0)^n) / (1-((dist_mat_rmsd-d_0)/r_0)^m) \n");
+  fprintf(fplog, "|--PARAMETERS: n= %i m= %i r_0= %f d_0= %f\n", colvar.nn[count], colvar.mm[count], colvar.r_0[count], colvar.d_0[count]);
+  threshold=pow(0.00001,1./(colvar.nn[count]-colvar.mm[count]));
+  value=(1.-pow(threshold,colvar.nn[count]))/(1.-pow(threshold,colvar.mm[count]));
+  fprintf(fplog, "|--CUTOFF VALUE: %f\n",value);
+  fprintf(fplog, "|--CUTOFF DISTANCE: %f\n",threshold*r_0+d_0);
+  if(colvar.realpar[count][0][0]<1000000.) { fprintf(fplog, "|--STRANDS_CUTOFF DISTANCE: %f\n",colvar.realpar[count][0][0]); }
+  fprintf(fplog, "|--ANGSTROM_SCALE: %f\n",angstrom_scale);
+
+  iat=0;
+  fprintf(fplog,"|- SET MEMBERS: ");
+  for(i=0;i<colvar.natoms[count];i++){fprintf(fplog," %d ",colvar.cvatoms[count][i]+1);if((i+1)%20==0)fprintf(fplog,"\n               ");}fprintf(fplog,"\n\n");
+
+  fprintf(fplog,"|- IMPORTANT NOTE: THIS CV REQUIRES ALIGN_ATOMS (FOR ALL BACKBONE) ON SOME CODES LIKE GROMACS4 !!!\n");
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  // storing reference distance matrix (converted from angstrom to angstrom*angstrom_scale)
+  ref_dist_mat.parabeta_pairs[0]=0.; // pairs without covalent bond
+  ref_dist_mat.parabeta_pairs[1]=0.; // pairs without covalent bond
+  for (iblock=0;iblock<2;iblock++) {
+    for (i=0;i<29;i++) {
+      for (j=i+1;j<30;j++) {
+        d=0.;
+        for (ix=0;ix<3;ix++) {
+          d += pow((ref_parabeta[i+iblock*30][ix]-ref_parabeta[j+iblock*30][ix]),2);
+        }
+        d=sqrt(d);
+        // here d is in angstrom: covalent bonds among N CA C O CB are maximum 1.54 A
+        if(d>1.7) {
+          // convert d in length units of the MD program
+          d=d*angstrom_scale;
+          ref_dist_mat.parabeta_pairs[iblock]+=1.;
+        } else {
+          // exclude covalent bonds
+          d=-999.;
+        }
+        ref_dist_mat.parabeta[iblock][i][j]=d;
+        ref_dist_mat.parabeta[iblock][j][i]=d;
+      }
+    }
+  }
+ 
+  return colvar.natoms[count]; 
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_pca.c dl_class_1.9/srcmod/Plumed/restraint_pca.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_pca.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_pca.c	2015-11-07 17:37:19.377603896 +0100
@@ -0,0 +1,641 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+
+#include "metadyn.h"
+
+void PREFIX pca_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+	int i,j,k,l,n,iat,cvnatom;
+        struct rmsd_inpack inpack;
+        struct rmsd_mini_outpack outpack;
+	rvec rrpfit;
+	real cm0,cm1,cm2;
+	real cv;
+	real dr000,dr010,dr020,dr100,dr110,dr120,dr200,dr210,dr220;
+	real dr001,dr011,dr021,dr101,dr111,dr121,dr201,dr211,dr221;
+	real dr002,dr012,dr022,dr102,dr112,dr122,dr202,dr212,dr222;
+	real d00n,d01n,d02n,d10n,d11n,d12n,d20n,d21n,d22n;
+	real r1p0,r1p1,r1p2,sc0,sc1,sc2,myinc0,myinc1,myinc2;
+	//NB: I already checked that the atom used are less then MAXATOMS_RMSD
+	real egvx[MAXATOMS_RMSD],egvy[MAXATOMS_RMSD],egvz[MAXATOMS_RMSD];
+
+
+
+	// **********************************
+	// Prepare the system: 
+	// - find rotation matrix
+	// - move CM in origin
+	// **********************************
+	if (colvar.pca_align[i_c]==1) {
+		// I have to align the structure to the reference (i.e., find rotation matrix and apply it)
+
+		// Fills the inpack structure with the coordinates of the reference (r0) and the current frame (r1)
+		inpack.natoms = colvar.pca_align_atoms;
+		inpack.totmass = colvar.pca_align_totmass;
+
+		if (!(mtd_data->istep%colvar.pca_upstride[i_c])) {
+
+			//here every colvar.pca_upstride[i_c] steps or every step if UPSTRIDE is not used
+			for (i=0;i<colvar.pca_align_atoms;i++){
+				iat = colvar.pca_align_list[i];
+
+				inpack.mass[i] = colvar.pca_align_mass[i];	// mass-weighted alignment (but all masses are set to 1)
+				//NB: the coordinates have already been translated with CM in the origin upon initialization
+				inpack.r0[0][i] = colvar.pca_align_coord[i][0];
+				inpack.r0[1][i] = colvar.pca_align_coord[i][1];
+				inpack.r0[2][i] = colvar.pca_align_coord[i][2];
+
+				// current conformation
+				inpack.r1[0][i] = mtd_data->pos[iat][0];	
+				inpack.r1[1][i] = mtd_data->pos[iat][1];
+				inpack.r1[2][i] = mtd_data->pos[iat][2];
+
+//				if (logical.debug) printf("%d iat=%d mass=%lf\tr0(% lf % lf % lf)\tr1(% lf % lf % lf)\n",i,iat,inpack.mass[i],inpack.r0[0][i],inpack.r0[1][i],inpack.r0[2][i],inpack.r1[0][i],inpack.r1[1][i],inpack.r1[2][i]);
+			}
+
+			// moves r0 and r1 in r0p and r1p with CM in the origin
+			// actually r0 is only copied in r0p (iopt=6) since it has already its CM in origin
+			// gives in d[][] the rotation matrix and in dd_r1[][][][] its derivatives (simple=0)
+			// NB: r0p and r1p are multiplied by the atom mass
+			rmsd_mini_pack(inpack,&outpack,6,0,1);
+
+
+			if (colvar.pca_upstride[i_c]>1) {
+				// if I use UPSTRIDE > 1, then save matrix and derivatives in old_* 
+				for (i=0;i<3;i++) 
+					for (j=0;j<3;j++)  {
+						colvar.old_d[i][j] = outpack.d[i][j];
+						for (k=0;k<3;k++)
+							for (n=0;n<colvar.natoms[i_c];n++) colvar.old_dd_dr1[i][j][k][n] = outpack.dd_dr1[i][j][k][n];
+					}
+			}
+
+			// puts the new rotation matrix in static variables for efficiency!
+			d00n = outpack.d[0][0];
+			d01n = outpack.d[0][1];
+			d02n = outpack.d[0][2];
+			d10n = outpack.d[1][0];
+			d11n = outpack.d[1][1];
+			d12n = outpack.d[1][2];
+			d20n = outpack.d[2][0];
+			d21n = outpack.d[2][1];
+			d22n = outpack.d[2][2];
+
+		} else {
+			// if I'm here, I'm using UPSTRIDE and it is NOT time to calculate a new matrix:
+			// I recover it from the last saved one
+
+			// reset the CM of the current positions and fills outpack.r0p/r1p
+			cm0 = cm1 = cm2 = 0.;
+			for (i=0;i<colvar.pca_align_atoms;i++) {
+				iat = colvar.pca_align_list[i];
+				cm0 += mtd_data->pos[iat][0]*colvar.pca_align_mass[i];
+				cm1 += mtd_data->pos[iat][1]*colvar.pca_align_mass[i];
+				cm2 += mtd_data->pos[iat][2]*colvar.pca_align_mass[i];
+			}
+			cm0 = cm0 / (real) colvar.pca_align_totmass;
+			cm1 = cm1 / (real) colvar.pca_align_totmass;
+			cm2 = cm2 / (real) colvar.pca_align_totmass;
+			for (i=0;i<colvar.pca_align_atoms;i++) {
+				iat = colvar.pca_align_list[i];
+
+				//NB: the coordinates have already been translated with CM in the origin upon initialization
+				outpack.r0p[0][i] = colvar.pca_align_coord[i][0];
+				outpack.r0p[1][i] = colvar.pca_align_coord[i][1];
+				outpack.r0p[2][i] = colvar.pca_align_coord[i][2];
+
+				// current conformation
+				outpack.r1p[0][i] = mtd_data->pos[iat][0] - cm0;
+				outpack.r1p[1][i] = mtd_data->pos[iat][1] - cm1;
+				outpack.r1p[2][i] = mtd_data->pos[iat][2] - cm2;
+			}
+
+			// restore the matrix derivatives from old one
+			for (i=0;i<3;i++) 
+				for (j=0;j<3;j++)  {
+					for (k=0;k<3;k++)
+						for (n=0;n<colvar.natoms[i_c];n++) outpack.dd_dr1[i][j][k][n] = colvar.old_dd_dr1[i][j][k][n];
+				}
+
+			// restore the old rotation matrix in static variables for efficiency!
+			d00n = colvar.old_d[0][0];
+			d01n = colvar.old_d[0][1];
+			d02n = colvar.old_d[0][2];
+			d10n = colvar.old_d[1][0];
+			d11n = colvar.old_d[1][1];
+			d12n = colvar.old_d[1][2];
+			d20n = colvar.old_d[2][0];
+			d21n = colvar.old_d[2][1];
+			d22n = colvar.old_d[2][2];
+		}
+
+	} else {
+
+		// I am using the NOALIGN keyword: don't need to find the rotation matrix
+		// I only calculate the current CM and if also the DIFF keyword is used, I fill the outpack.r0p with
+		// the reference structure for later use
+		cm0 = cm1 = cm2 = 0.;
+		for (i=0;i<colvar.pca_align_atoms;i++) {
+			iat = colvar.pca_align_list[i];
+
+			cm0 += mtd_data->pos[iat][0]*colvar.pca_align_mass[i];
+			cm1 += mtd_data->pos[iat][1]*colvar.pca_align_mass[i];
+			cm2 += mtd_data->pos[iat][2]*colvar.pca_align_mass[i];
+
+			if (colvar.pca_diff[i_c]==1) {
+				//NB: the coordinates have already been translated with CM in the origin upon initialization
+				outpack.r0p[0][i] = colvar.pca_align_coord[i][0];
+				outpack.r0p[1][i] = colvar.pca_align_coord[i][1];
+				outpack.r0p[2][i] = colvar.pca_align_coord[i][2];
+			}
+
+		}
+		cm0 = cm0 / (real) colvar.pca_align_totmass;
+		cm1 = cm1 / (real) colvar.pca_align_totmass;
+		cm2 = cm2 / (real) colvar.pca_align_totmass;
+	}
+
+//	if (logical.debug) printf("PCA Rotation matrix : % lf\t% lf\t% lf\n                  % lf\t% lf\t% lf\n                  % lf\t% lf\t% lf\n",d00n,d01n,d02n,d10n,d11n,d12n,d20n,d21n,d22n);
+
+
+	// NB :  colvar.natoms[i_c] == colvar.pca_align_atoms
+	cvnatom = colvar.pca_align_atoms;
+
+	// copy the coefficients in 3 vectors for efficiency
+	for(n=0; n<cvnatom; n++) {
+		egvx[n] = colvar.pcacomp[i_c][n].coeff[0];
+		egvy[n] = colvar.pcacomp[i_c][n].coeff[1];
+		egvz[n] = colvar.pcacomp[i_c][n].coeff[2];
+	}
+
+
+	// **********************************
+	// Calculates new CV value
+	// **********************************
+	cv = 0.;
+	for(n=0; n<cvnatom; n++){
+//		if (logical.debug) printf("outpack %d r0(% lf % lf % lf)\tr1(% lf % lf % lf)\n",n,outpack.r0p[0][n],outpack.r0p[1][n],outpack.r0p[2][n],outpack.r1p[0][n],outpack.r1p[1][n],outpack.r1p[2][n]);
+
+		if (colvar.pca_align[i_c]==1) {
+			// apply the rotation to the current position (translated with CM in origin)
+			rrpfit[0] = d00n * outpack.r1p[0][n] + d01n * outpack.r1p[1][n] + d02n * outpack.r1p[2][n];
+			rrpfit[1] = d10n * outpack.r1p[0][n] + d11n * outpack.r1p[1][n] + d12n * outpack.r1p[2][n];
+			rrpfit[2] = d20n * outpack.r1p[0][n] + d21n * outpack.r1p[1][n] + d22n * outpack.r1p[2][n];
+		} else {
+			// I don't have to align to reference, only use the current conformation (translated with CM in origin)
+			iat = colvar.pca_align_list[n];
+			rrpfit[0] = mtd_data->pos[iat][0] - cm0;
+			rrpfit[1] = mtd_data->pos[iat][1] - cm1;
+			rrpfit[2] = mtd_data->pos[iat][2] - cm2;
+		}
+
+		if (colvar.pca_diff[i_c]==1) {
+			// g_anaeig version :
+			// project the differences between current roto-translated (=aligned) structure and reference onto the eigenvector
+			// NB: since r0p and r1p are returned multiplied by the atom mass, I divide their contribution by the mass
+			cv +=((rrpfit[0] - outpack.r0p[0][n]) * egvx[n] \
+			    + (rrpfit[1] - outpack.r0p[1][n]) * egvy[n] \
+			    + (rrpfit[2] - outpack.r0p[2][n]) * egvz[n]) / colvar.pca_align_mass[n];
+		} else {
+			// directly project the current roto-translated (=aligned to reference) structure onto the eigenvector
+			cv +=(rrpfit[0] * egvx[n] \
+			    + rrpfit[1] * egvy[n] \
+			    + rrpfit[2] * egvz[n]) / colvar.pca_align_mass[n];
+		}
+	}
+
+
+	//returns the value of the CV
+	colvar.ss0[i_c] = cv;
+
+//	if (logical.debug) printf("CV = %lf\n",cv);
+
+
+	// **********************************
+	// Calculates CV derivative
+	// **********************************
+	if (colvar.pca_align[i_c]==0) {
+
+		// If I don't align (ie rotate) the derivative is the egv coeff minus the contribution for the CM displacement
+		for(i=0; i<cvnatom; i++) {
+			colvar.myder[i_c][i][0] = egvx[i];
+			colvar.myder[i_c][i][1] = egvy[i];
+			colvar.myder[i_c][i][2] = egvz[i];
+
+			myinc0 = 0;
+			myinc1 = 0;
+			myinc2 = 0;
+			for(j=0;j<cvnatom;j++) {
+				myinc0 += egvx[j];
+				myinc1 += egvy[j];
+				myinc2 += egvz[j];
+			}
+
+			colvar.myder[i_c][i][0] -= myinc0/(real) colvar.pca_align_totmass;
+			colvar.myder[i_c][i][1] -= myinc1/(real) colvar.pca_align_totmass;
+			colvar.myder[i_c][i][2] -= myinc2/(real) colvar.pca_align_totmass;
+		}
+
+	} else {
+
+		// If I align (ie rotate) it is more complicated
+		for(i=0; i<cvnatom; i++) {
+			colvar.myder[i_c][i][0] = d00n*egvx[i] + d10n*egvy[i] + d20n*egvz[i];
+			colvar.myder[i_c][i][1] = d01n*egvx[i] + d11n*egvy[i] + d21n*egvz[i];
+			colvar.myder[i_c][i][2] = d02n*egvx[i] + d12n*egvy[i] + d22n*egvz[i];
+		}
+
+		d00n /= (real) inpack.totmass;
+		d01n /= (real) inpack.totmass;
+		d02n /= (real) inpack.totmass;
+		d10n /= (real) inpack.totmass;
+		d11n /= (real) inpack.totmass;
+		d12n /= (real) inpack.totmass;
+		d20n /= (real) inpack.totmass;
+		d21n /= (real) inpack.totmass;
+		d22n /= (real) inpack.totmass;
+	
+		for(i=0; i<cvnatom; i++) {
+
+			dr000 = outpack.dd_dr1[0][0][0][i];
+			dr010 = outpack.dd_dr1[0][1][0][i];
+			dr020 = outpack.dd_dr1[0][2][0][i];
+			dr100 = outpack.dd_dr1[1][0][0][i];
+			dr110 = outpack.dd_dr1[1][1][0][i];
+			dr120 = outpack.dd_dr1[1][2][0][i];
+			dr200 = outpack.dd_dr1[2][0][0][i];
+			dr210 = outpack.dd_dr1[2][1][0][i];
+			dr220 = outpack.dd_dr1[2][2][0][i];
+
+			dr001 = outpack.dd_dr1[0][0][1][i];
+			dr011 = outpack.dd_dr1[0][1][1][i];
+			dr021 = outpack.dd_dr1[0][2][1][i];
+			dr101 = outpack.dd_dr1[1][0][1][i];
+			dr111 = outpack.dd_dr1[1][1][1][i];
+			dr121 = outpack.dd_dr1[1][2][1][i];
+			dr201 = outpack.dd_dr1[2][0][1][i];
+			dr211 = outpack.dd_dr1[2][1][1][i];
+			dr221 = outpack.dd_dr1[2][2][1][i];
+
+			dr002 = outpack.dd_dr1[0][0][2][i];
+			dr012 = outpack.dd_dr1[0][1][2][i];
+			dr022 = outpack.dd_dr1[0][2][2][i];
+			dr102 = outpack.dd_dr1[1][0][2][i];
+			dr112 = outpack.dd_dr1[1][1][2][i];
+			dr122 = outpack.dd_dr1[1][2][2][i];
+			dr202 = outpack.dd_dr1[2][0][2][i];
+			dr212 = outpack.dd_dr1[2][1][2][i];
+			dr222 = outpack.dd_dr1[2][2][2][i];
+
+			myinc0 = 0;
+			myinc1 = 0;
+			myinc2 = 0;
+
+			for(j=0;j<cvnatom;j++) {
+
+				r1p0 = outpack.r1p[0][j];		// NB: r1p is actually the position*mass
+				r1p1 = outpack.r1p[1][j];
+				r1p2 = outpack.r1p[2][j];
+
+				sc0=egvx[j];
+				sc1=egvy[j];
+				sc2=egvz[j];
+
+				// NB: the '-' part comes from the translation of the CM in the origin
+				myinc0 += (dr000*r1p0 + dr010*r1p1 + dr020*r1p2 - d00n) * sc0 \
+					+ (dr100*r1p0 + dr110*r1p1 + dr120*r1p2 - d10n) * sc1 \
+					+ (dr200*r1p0 + dr210*r1p1 + dr220*r1p2 - d20n) * sc2;
+
+				myinc1 += (dr001*r1p0 + dr011*r1p1 + dr021*r1p2 - d01n) * sc0 \
+					+ (dr101*r1p0 + dr111*r1p1 + dr121*r1p2 - d11n) * sc1 \
+					+ (dr201*r1p0 + dr211*r1p1 + dr221*r1p2 - d21n) * sc2;
+
+				myinc2 += (dr002*r1p0 + dr012*r1p1 + dr022*r1p2 - d02n) * sc0 \
+					+ (dr102*r1p0 + dr112*r1p1 + dr122*r1p2 - d12n) * sc1 \
+					+ (dr202*r1p0 + dr212*r1p1 + dr222*r1p2 - d22n) * sc2;
+
+
+			}
+
+			colvar.myder[i_c][i][0] += myinc0;
+			colvar.myder[i_c][i][1] += myinc1;
+			colvar.myder[i_c][i][2] += myinc2;
+
+/*			if (logical.debug) {
+				printf("der[i=%d] x = %lf (myinc0=%e)\n",i,colvar.myder[i_c][i][0],myinc0);
+				printf("der[i=%d] y = %lf (myinc1=%e)\n",i,colvar.myder[i_c][i][1],myinc1);
+				printf("der[i=%d] z = %lf (myinc2=%e)\n",i,colvar.myder[i_c][i][2],myinc2);
+			}
+*/
+		}
+
+	}
+	return;
+}
+
+// ------------------------------------------------------------------------------------------------
+
+
+int PREFIX read_pca(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+	int i,n,iw,a1,a2,natom,align_natom,help;
+	double x,y,z,coeff,mass;
+	char aux[100];
+	FILE *fp;
+
+	help = 0;
+	natom = 0;
+	n = 0;
+
+	colvar.type_s[count] = 42;	// sets the CV type
+	//	colvar.cell_pbc[count]=1;	// default is PBC
+
+	colvar.pca_diff[count] = 0;		//default, don't do difference (to do it, use keyword DIFF)
+	colvar.pca_align[count] = 1;		//default, align structure to reference befor projection (to avoid alignment, use keyword NOALIGN)
+	colvar.pca_upstride[count] = -1;	//default, update the rotation matrix and derivatives every 1 step
+
+	// ***************************************************** EIGENVEC ******************************
+	// ***************************************************** EIGENVEC ******************************
+	iw = seek_word(word,"EIGENVEC");
+	if(iw>=0){   
+		fp = fopen(word[iw+1],"r");
+		if (fp==NULL) {
+			fprintf(fplog,"\n-PCA CV: error opening EIGENVEC file [%s]\nAborting\n\n",word[iw+1]);
+			fprintf(stderr,"\nPLUMED ERROR : PCA CV: error opening EIGENVEC file [%s]\nAborting\n\n",word[iw+1]);
+			EXIT();
+		}
+
+		//do a first loop just to count the number of coefficients. I need it to allocate the appropriate memory
+		while(fgets(aux,100,fp)!=NULL) {
+			//ignoring comment lines
+			if (strncmp(aux,"#",1)) {
+				if(sscanf(aux,"%d %lf %lf %lf",&a1,&x,&y,&z)!=4) {
+					fprintf(fplog,"\n-PCA CV: error reading EIGENVEC file [%s]: expecting 4 columns: atomid x y z\nAborting\n\n",word[iw+1]);
+					fprintf(stderr,"\nPLUMED ERROR : PCA CV: error reading EIGENVEC file [%s]: expecting 4 columns: atomid x y z\nAborting\n\n",word[iw+1]);
+					EXIT();
+				}
+				natom++;	//number of atoms
+			}
+		}
+
+		//allocate structure pcacomp
+		snew(colvar.pcacomp[count],natom);
+
+		//allocate memory for atoms, coefficients and derivatives
+		snew(colvar.cvatoms[count], natom);	//will contain the atom id
+		snew(colvar.myder[count], natom);	//will contain the derivatives
+
+		//saves the number of atoms
+		colvar.natoms[count] = natom;
+
+		rewind(fp);
+		while(fgets(aux,100,fp)!=NULL) {
+			//ignoring comment lines
+			if (strncmp(aux,"#",1)) {
+				if(sscanf(aux,"%d %lf %lf %lf",&a1,&x,&y,&z)!=4) {
+					fprintf(fplog,"\n-PCA CV: error reading EIGENVEC file [%s]: expecting 4 columns: atomid x y z\nAborting\n\n",word[iw+1]);
+					fprintf(stderr,"\nPLUMED ERROR : PCA CV: error reading EIGENVEC file [%s]: expecting 4 columns: atomid x y z\nAborting\n\n",word[iw+1]);
+					EXIT();
+				}
+				colvar.pcacomp[count][n].a1 = a1-1;
+				colvar.pcacomp[count][n].coeff[0] = x;
+				colvar.pcacomp[count][n].coeff[1] = y;
+				colvar.pcacomp[count][n].coeff[2] = z;
+				n++;
+			}
+		}
+
+		fclose(fp);
+
+		if (logical.debug) { 
+			fprintf(fplog,"\n%1i-PCA CV: correctly read %d atoms and coefficients from input EIGENVEC file [%s]",count+1,natom,word[iw+1]);
+			fflush(NULL);
+		}
+	} else { fprintf(fplog,"|- NEEDED EIGENVEC KEYWORD FOR PCA CV\n"); help=1; }
+
+
+	// ***************************************************** FRAME ******************************
+	// ***************************************************** FRAME ******************************
+	align_natom = n = 0;
+	iw=seek_word(word,"FRAME");
+	if(iw>=0){   
+		fp = fopen(word[iw+1],"r");
+		if (fp==NULL) {
+			fprintf(fplog,"\n-PCA CV: error opening FRAME file [%s]\nAborting\n\n",word[iw+1]);
+			fprintf(stderr,"\nPLUMED ERROR : PCA CV: error opening FRAME file [%s]\nAborting\n\n",word[iw+1]);
+			EXIT();
+		}
+
+		//do a first loop just to count the number of atoms. I need it to allocate the appropriate memory
+		while(fgets(aux,100,fp)!=NULL) {
+			//ignoring comment lines
+			if (strncmp(aux,"#",1)) {
+				if(sscanf(aux,"%d %lf %lf %lf",&a1,&x,&y,&z)!=4) {
+					fprintf(fplog,"\n-PCA CV: error reading FRAME file [%s]: expecting 4 columns: atomid x y z\nAborting",word[iw+1]);
+					fprintf(stderr,"\nPLUMED ERROR : PCA CV: error reading FRAME file [%s]: expecting 4 columns: atomid x y z\nAborting",word[iw+1]);
+					EXIT();
+				}
+				// DEVEL : expect also a mass column
+				/*                        	if(sscanf(aux,"%d %lf %lf %lf %lf",&a1,&x,&y,&z,&mass)!=5) {
+								fprintf(fplog,"\n-PCA CV: error reading FRAME file [%s]: expecting 5 columns: atomid x y z mass\nAborting",word[iw+1]);
+								fprintf(stderr,"\nPLUMED ERROR : PCA CV: error reading FRAME file [%s]: expecting 5 columns: atomid x y z mass\nAborting",word[iw+1]);
+								EXIT();
+								}
+				 */
+				align_natom++;	//number of atoms
+			}
+		}
+
+		colvar.pca_align_atoms = align_natom;
+		snew(colvar.pca_align_list, align_natom);	// contain the list of atoms of the reference structure used to align
+		snew(colvar.pca_align_coord, align_natom);	// contain the xyz coordinates of the reference structure 
+		snew(colvar.pca_align_mass, align_natom);	// contain the list of atoms of the reference structure used to align
+		colvar.pca_align_totmass = 0.;
+
+		rewind(fp);
+		while(fgets(aux,100,fp)!=NULL) {
+			//ignoring comment lines
+			if (strncmp(aux,"#",1)) {
+				if(sscanf(aux,"%d %lf %lf %lf",&a1,&x,&y,&z)!=4) {
+					fprintf(fplog,"\n-PCA CV: error reading FRAME file [%s]: expecting 4 columns: atomid x y z\nAborting",word[iw+1]);
+					fprintf(stderr,"\nPLUMED ERROR : PCA CV: error reading FRAME file [%s]: expecting 4 columns: atomid x y z\nAborting",word[iw+1]);
+					EXIT();
+				}
+
+				mass = 1.0;	// forces mass = 1, the use of a mass is under development
+
+				// DEVEL : expect also a mass column
+				/*                        	if(sscanf(aux,"%d %lf %lf %lf %lf",&a1,&x,&y,&z,&mass)!=5) {
+								fprintf(fplog,"\n-PCA CV: error reading FRAME file [%s]: expecting 5 columns: atomid x y z mass\nAborting",word[iw+1]);
+								fprintf(stderr,"\nPLUMED ERROR : PCA CV: error reading FRAME file [%s]: expecting 5 columns: atomid x y z mass\nAborting",word[iw+1]);
+								EXIT();
+								}
+				 */
+				if (!(mass>0)) plumed_error("null mass not allowed for atoms in reference frame file");
+				colvar.pca_align_list[n] = a1-1;
+				colvar.cvatoms[count][n] = a1-1;
+				colvar.pca_align_coord[n][0] = x;	//NB: I leave unaltered the units
+				colvar.pca_align_coord[n][1] = y;
+				colvar.pca_align_coord[n][2] = z;
+				colvar.pca_align_mass[n] = mass;
+				colvar.pca_align_totmass += mass;
+				n++;
+			}
+		}
+		fclose(fp);
+
+		if (colvar.pca_align_totmass<0.000001) {
+			fprintf(fplog,"\n-PCA CV: ERROR total mass is : %lf\n-PCA CV: if you do not want to mass-weight the alignment to the reference frame, just set to 1 every atom mass.\n",colvar.pca_align_totmass);
+			EXIT();
+		}
+
+		// centers the atoms with the CM in the origin (so I don't have to do it every step)
+		x = y = z = 0.;
+		for (i=0;i<natom;i++) {
+			x += colvar.pca_align_coord[i][0] * colvar.pca_align_mass[i];
+			y += colvar.pca_align_coord[i][1] * colvar.pca_align_mass[i];
+			z += colvar.pca_align_coord[i][2] * colvar.pca_align_mass[i];
+		}
+		x = x / colvar.pca_align_totmass;
+		y = y / colvar.pca_align_totmass;
+		z = z / colvar.pca_align_totmass;
+		if (logical.debug) printf(" CENTERING ref frame (old CM :  % lf\t% lf\t% lf)\n",x,y,z);
+		for (i=0;i<natom;i++) {
+			colvar.pca_align_coord[i][0] -= x;
+			colvar.pca_align_coord[i][1] -= y;
+			colvar.pca_align_coord[i][2] -= z;
+			if (logical.debug) printf("%i = % lf\t% lf\t% lf\n",i,colvar.pca_align_coord[i][0],colvar.pca_align_coord[i][1],colvar.pca_align_coord[i][2]);
+		}
+
+		if (logical.debug) { 
+			fprintf(fplog,"\n%1i-PCA CV: correctly read %d atoms and coordinates from input FRAME file [%s] with total mass %lf",count+1,natom,word[iw+1],colvar.pca_align_totmass);
+			fflush(NULL);
+		}
+	} else { fprintf(fplog,"|- NEEDED FRAME KEYWORD FOR PCA CV\n"); help=1; }
+
+	// ***************************************************** DIFF ****************************
+	// ***************************************************** DIFF ****************************
+	iw=seek_word(word,"DIFF");
+	if(iw>=0) colvar.pca_diff[count] = 1;
+
+	// ***************************************************** NOALIGN ****************************
+	// ***************************************************** NOALIGN ****************************
+	iw=seek_word(word,"NOALIGN");
+	if(iw>=0) colvar.pca_align[count] = 0;
+
+
+	// ***************************************************** UPSTRIDE **************************
+	// ***************************************************** UPSTRIDE **************************
+	iw=seek_word(word,"UPSTRIDE");		//UNDER DEVEL!!
+	if(iw>=0) {
+		sscanf(word[iw+1],"%lf", &coeff);
+		colvar.pca_upstride[count] = (int) coeff;
+	}
+
+	// ***************************************************** SIGMA ******************************
+	// ***************************************************** SIGMA ******************************
+	iw=seek_word(word,"SIGMA");
+	if(iw>=0) {
+		sscanf(word[iw+1],"%lf", &coeff);
+		colvar.delta_r[count]  = (real) coeff;
+	}
+	// else { fprintf(fplog,"|- NEEDED SIGMA KEYWORD FOR PCA\n"); help=1; }
+
+
+	// ********************** I CHECK THAT THE ATOMS ON WHICH I ALIGN ARE THE SAME SET OF THE ATOMS ON WHICH I CALCULATED THE PCA ******
+	// ********************** I CHECK THAT THE ATOMS ON WHICH I ALIGN ARE THE SAME SET OF THE ATOMS ON WHICH I CALCULATED THE PCA ******
+	// ********************** I CHECK THAT THE ATOMS ON WHICH I ALIGN ARE THE SAME SET OF THE ATOMS ON WHICH I CALCULATED THE PCA ******
+	if (colvar.pca_align_atoms != natom) {fprintf(fplog,"ERROR : THE NUMBER OF ATOMS ON WHICH I ALIGN IS DIFFERENT FROM THE NUMBER OF COMPONENTS\n");EXIT();}
+	if (colvar.pca_align_atoms > MAXATOMS_RMSD)  {fprintf(fplog,"ERROR : INCREASE MAXATOMS_RMSD IN metadyn.h FILE TO AT LEAST THE NUMBER OF ATOMS USED : %d\n",colvar.pca_align_atoms);EXIT();}
+	for (n=0;n<natom;n++) {
+		if (colvar.pca_align_list[n] != colvar.pcacomp[count][n].a1 ) {fprintf(fplog,"ERROR : THE ATOMS ON WHICH I ALIGN IS DIFFERENT FROM THE ATOMS ON WHICH I APPLY THE EIGENVECTOR\n");EXIT();}
+	}
+
+
+	if(help){
+		fprintf(fplog, "\nPCA CV: WRONG SYNTAX\n");
+		fprintf(fplog, "e.g.:     \n");
+		fprintf(fplog, "PCA FRAME reference.dat EIGENVEC eigvector.dat [DIFF] [SIGMA s]\n");
+		//		fprintf(fplog, "PCA FRAME reference.dat EIGENVEC eigvector.dat [DIFF] [UPSTRIDE n] [SIGMA s]\n");	//DEVEL
+		fprintf(fplog, "where\n");
+		fprintf(fplog, " reference.dat is a 4-columns file with the reference structure used for alignment in the format: atomid x y z\n");
+		fprintf(fplog, " eigvector.dat is a 4-columns file with the eigenvector in the format: atomid x y z\n\n");
+		fprintf(fplog, " if DIFF keyword is used, the difference between the current conformation and the reference frame is projected: CV=<(X-ref),evec>\n\n");
+		//		fprintf(fplog, " if UPSTRIDE keyword is used, the rotation matrix and derivatives are updated every n steps instead of every step (for performance) NB UNDER TESTING!!!!! \n\n");//DEVEL
+		fprintf(fplog, "NB: the alignment is non mass weighted\n");
+		fprintf(fplog, "NB: double precision code and ALIGN_ATOMS directive are recommended\n");
+		fprintf(fplog, "NB: x y z are intended in engine units\n");
+		fprintf(fplog, "NB: in both files, lines beginning with '#' are ignored, no white lines are allowed\n");
+		//		fprintf(fplog, "NB: UPSTRIDE should be smaller than HILLS STRIDE\n");		//DEVEL
+		plumed_error("PluMed dead with errors: check log file\n");
+	}
+
+	fprintf(fplog, "\n%1i-PCA: %d atoms used for alignment and projection",count+1,align_natom);
+
+	if (colvar.pca_upstride[count]>1) fprintf(fplog,"; UPSTRIDE %d\n",colvar.pca_upstride[count]);
+	else colvar.pca_upstride[count] = 1;	//set the default to every step
+
+	if (logical.do_hills) fprintf(fplog,"; SIGMA %f\n",colvar.delta_r[count]);
+	else fprintf(fplog,"\n");
+
+	if (colvar.pca_align[count]==1) {
+		if (colvar.pca_diff[count]==1) {
+			//align and diff
+			fprintf(fplog,"|- DIFF KEYWORD PRESENT\n");
+			fprintf(fplog,"|- ALIGN CURRENT STRUCTURE X TO REFERENCE R AND PROJECT THE DIFFERENCE WITH R : CV = < (X'-R), EIGENVEC >\n");
+		} else {
+			//align no diff
+			fprintf(fplog,"|- ALIGN CURRENT STRUCTURE X TO REFERENCE R AND PROJECT IT : CV = < X', EIGENVEC >\n");
+		}
+	} else {
+		if (colvar.pca_diff[count]==1) {
+			//no align, yes diff
+			fprintf(fplog,"|- NOALIGN AND DIFF KEYWORDS PRESENT\n");
+			fprintf(fplog,"|- NO ALIGNMENT OF CURRENT STRUCTURE X, PROJECTION OF THE DIFFERENCE WITH REFERENCE R : CV = < (X-R), EIGENVEC >\n");
+		} else {
+			//no align no diff
+			fprintf(fplog,"|- NOALIGN KEYWORD PRESENT\n");
+			fprintf(fplog,"|- DIRECT PROJECTION OF THE CURRENT STRUCTURE X : CV = < X, EIGENVEC >\n");
+		}
+	}
+
+	fprintf(fplog,"|- EIGENVECTOR COMPONENTS\n|-  #  \t: ATOM\t X Y Z\n");
+	for(i=0;i<natom;i++){
+		fprintf(fplog,"|- %3d\t: %d \t % lf % lf % lf\n",i+1,colvar.pcacomp[count][i].a1+1,colvar.pcacomp[count][i].coeff[0],colvar.pcacomp[count][i].coeff[1],colvar.pcacomp[count][i].coeff[2]);
+	}
+	fflush(NULL);
+
+	return colvar.natoms[count];
+}
+
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_poly.c dl_class_1.9/srcmod/Plumed/restraint_poly.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_poly.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_poly.c	2015-11-07 17:37:19.381604012 +0100
@@ -0,0 +1,217 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+
+void PREFIX poly_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+
+int i,ix;
+double shift, coeff, sterm, expo, vcv, factor;
+int jcv;
+int iatG, iatT;
+
+// fprintf(mtd_data->fplog,"count is %d\n",i_c);
+// for(int i=0;i<i_c; i++) fprintf(mtd_data->fplog,"%d, num=%f\n", i, colvar.ss0[i]);
+
+i=0;
+colvar.ss0[i_c]=0;
+if(1) while(colvar.intpar[i_c][i]>=0){
+   jcv = colvar.intpar[i_c][i];
+   shift = colvar.vecpar[i_c][i][0];
+   coeff=  colvar.vecpar[i_c][i][1];
+   expo =  colvar.vecpar[i_c][i][2];
+   sterm = coeff*pow(colvar.ss0[jcv]+shift,expo);
+    colvar.ss0[i_c] += sterm;
+   /* fprintf(mtd_data->fplog, 
+     "| poly TERM %d (cv=%d, sh=%f, coef=%f, exp=%f) CONTRIB %f\n", 
+     i, jcv, shift, coeff, expo, sterm); */
+   i++;
+}
+
+//fprintf(mtd_data->fplog,"natoms=%d\n",colvar.natoms[i_c]);
+for(i=0;i<colvar.natoms[i_c];i++){ 
+ for(ix=0;ix<3;ix++){ 
+  colvar.myder[i_c][i][ix]=0; } }
+
+
+// Calculates derivative
+iatG=0;
+i=0;
+while(colvar.intpar[i_c][i]>=0){
+  jcv=colvar.intpar[i_c][i];
+  shift = colvar.vecpar[i_c][i][0];
+  coeff=  colvar.vecpar[i_c][i][1];
+  expo =  colvar.vecpar[i_c][i][2];
+  if(fabs(expo-0.00)<1e-7) {vcv=0.0;} 
+   else if(fabs(expo-1.0)<1e-7) { vcv = 1.0;} 
+   else { vcv = pow(colvar.ss0[jcv]+shift,expo-1);} 
+  factor=expo*coeff*vcv;
+  for(iatT=0;iatT<colvar.natoms[jcv];iatT++){
+    for(ix=0;ix<3;ix++) colvar.myder[i_c][iatG][ix] += factor*colvar.myder[jcv][iatT][ix];
+     // for debug
+     /* fprintf(mtd_data->fplog, 
+       "| poly(%d) term=%d (iatG=%d [%5.3f,%5.3f,%5.3f], fctr=%f, jcv=%d iatT=%d [%5.3f,%5.3f,%5.3f] \n", 
+        i, i_c, iatG, colvar.myder[i_c][iatG][0], colvar.myder[i_c][iatG][1], 
+                 colvar.myder[i_c][iatG][2], 
+        factor, jcv, iatT, 
+        colvar.myder[jcv][iatT][0], colvar.myder[jcv][iatT][1], 
+        colvar.myder[jcv][iatT][2]
+    ); */
+    iatG++;
+  }
+  i++; 
+}
+
+
+return;
+}
+
+
+
+int PREFIX read_poly(char **word, int count, t_plumed_input *input,int *iline,FILE *fplog)
+{
+
+int iw, i, j, k;
+double delta=0.0;
+int nterms;
+int help;
+help=0;
+double shift, coeff,expo ;
+int jcv;
+
+// fprintf(fplog,"count is %d\n",count);
+// for(int i=0;i<count; i++) fprintf(fplog,"%d, num=%d\n", i, colvar.natoms[i]);
+
+iw = seek_word(word,"TERMS");
+if(iw>=0) { sscanf(word[iw+1],"%d", &nterms); } 
+ else { fprintf(fplog,"|- NEEDED TERMS KEYWORD FOR POLY\n"); help=1;}
+if(nterms>20) {
+  fprintf(fplog,"|- TO USE MORE THAN 20 TERMS, MODIFY ALLOCATION OF vecpar in metadyn.h!\n");
+  plumed_error("PluMeD dead with errors: check log file");
+  exit(1); // just in case...
+}
+
+iw=seek_word(word,"SIGMA");
+if(iw>=0){ 
+  sscanf(word[iw+1],"%lf", &delta);
+  colvar.delta_r[count]  = (real) delta; 
+}
+
+ if(help){
+  fprintf(fplog, "\n-POLY CV: WRONG SYNTAX\n");
+  fprintf(fplog, "e.g.:     \n");
+  fprintf(fplog, "      POLY TERMS 3 {SIGMA 1.0}\n");
+  fprintf(fplog, "      CV 1 {SHIFT 0.0} {COEFF 1.0} {EXP 1.0}\n");
+  fprintf(fplog, "      CV 2 {SHIFT 0.0} {COEFF 1.0} {EXP 1.0}\n");
+  plumed_error("PluMeD dead with errors: check log file");
+ }
+
+
+fprintf(fplog, "\n%li-POLY (POLYNOMIAL FUNCTION OF CVs): COMBINING %d TERMS, ",count+1,nterms);
+if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+ else fprintf(fplog,"\n");
+
+k=0;
+colvar.natoms[count]=0;
+for(i=0; i<nterms; i++){
+    fprintf(fplog, "|- TERM %d ",i+1);
+    shift = 0.0;
+    coeff = 1.0;
+    expo  = 1.0;
+    jcv = 0;
+    (*iline)++;
+    for(j=0;j<(input->nwords[*iline])-1;j++) {
+     if(seek_word(&(input->words[*iline][j]),"CV")>=0){
+      sscanf(input->words[*iline][j+1],"%d",&jcv);}
+     if(seek_word(&(input->words[*iline][j]),"SHIFT")>=0){
+       sscanf(input->words[*iline][j+1],"%lf",&shift); }
+     if(seek_word(&(input->words[*iline][j]),"COEFF")>=0){ 
+       sscanf(input->words[*iline][j+1],"%lf",&coeff); }
+     if(seek_word(&(input->words[*iline][j]),"EXP")>=0){ 
+       sscanf(input->words[*iline][j+1],"%lf",&expo); }
+    }
+    if(jcv==0){
+     fprintf(fplog,"\n\nCV NEEDS TO BE SPECIFIED IN POLY!\n");
+     plumed_error("PluMeD dead with errors: check log file");
+     exit(1); // just to be sure!
+    } else if (jcv>count) {
+     fprintf(fplog,"\n\nCV %d DOES NOT APPEAR TO HAVE BEEN DEFINED YET.\n",jcv+1);
+     fprintf(fplog,"ONLY PREVIOUSLY DEFINED CVs CAN BE COMBINED BY POLY!\n");
+     plumed_error("PluMeD dead with errors: check log file");
+     exit(1); // just to be sure!
+    } else {
+     jcv--;
+     colvar.intpar[count][i] = jcv;
+     logical.always[ jcv ]=1;     
+     colvar.vecpar[count][i][0] = shift;
+     colvar.vecpar[count][i][1] = coeff;
+     colvar.vecpar[count][i][2] = expo;
+     colvar.natoms[count]+=colvar.natoms[jcv]; 
+     // fprintf(fplog,"jcv=%d, natoms=%d\n", jcv, colvar.natoms[jcv]);
+     srenew(colvar.cvatoms[count],colvar.natoms[count]);
+     // Copy atom indexes from jcv into count 
+     for(j=0;j<colvar.natoms[jcv];j++){
+         colvar.cvatoms[count][k] = colvar.cvatoms[jcv][j]; 
+         k++; }
+    }
+    fprintf(fplog," CV %d SHIFT %lf, COEFF %lf, EXP %lf (NATOMS=%d)\n", jcv, shift,coeff,expo, 
+    colvar.natoms[count]);
+}
+
+ // a negative value in intpar means no more terms
+ colvar.intpar[count][nterms] = -1;
+
+
+// FOR DEBUG
+if(0){ 
+ i=0;
+ while(colvar.intpar[count][i]>=0){
+  fprintf(fplog,"|TERM %d: CV %d SHIFT %lf, COEFF %lf, EXP %lf\n", 
+   i, colvar.intpar[count][i],colvar.vecpar[count][i][0], 
+      colvar.vecpar[count][i][1],colvar.vecpar[count][i][2]); 
+   i++;
+ }
+ fprintf(fplog,"|%d ATOMS IN THIS CV:\n", colvar.natoms[count]);
+ for(j=0; j<colvar.natoms[count]; j++)
+  fprintf(fplog, "|-(ipoly=%d), (atid=%d)\n",j,colvar.cvatoms[count][j]);
+} 
+
+  colvar.type_s[count]   = 50;
+  snew(colvar.myder[count], colvar.natoms[count]);
+  return colvar.natoms[count];
+
+}
+
+
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_position.c dl_class_1.9/srcmod/Plumed/restraint_position.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_position.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_position.c	2015-11-07 17:37:19.383604070 +0100
@@ -0,0 +1,267 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX position_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int  i, j, iat;
+  int  dir;
+  rvec v0, v1;
+  rvec pos2;
+  real l0, l1, l2;
+  int i1, i2, i3;
+
+  for(iat=0;iat<colvar.natoms[i_c];iat++)
+    colvar.myder[i_c][iat][0] = colvar.myder[i_c][iat][1] = colvar.myder[i_c][iat][2] = 0.;
+
+  if(colvar.intpar[i_c][0]<3){
+    iat = colvar.cvatoms[i_c][0];
+    dir = colvar.intpar[i_c][0];
+    colvar.ss0[i_c] = 0.;
+    for(i=0;i<colvar.natoms[i_c];i++){
+      iat = colvar.cvatoms[i_c][i];
+      colvar.ss0[i_c] +=  mtd_data->pos[iat][dir]/colvar.natoms[i_c];
+      colvar.myder[i_c][i][dir] = 1./colvar.natoms[i_c];
+    }
+
+  } else if(colvar.intpar[i_c][0]==3) {
+    i1=colvar.intpar[i_c][1];
+    i2=colvar.intpar[i_c][2];
+    i3=colvar.intpar[i_c][3];
+    pos2[0]=pos2[1]=pos2[2]=0.;
+    v0[0]=v0[1]=v0[2]=0.;
+    v1[0]=v1[1]=v1[2]=0.;
+    for(i=0;i<colvar.natoms[i_c];i++){
+      iat = colvar.cvatoms[i_c][i];
+      for(dir=i1;dir<i2;dir+=i3)pos2[dir]+=mtd_data->pos[iat][dir]/colvar.natoms[i_c];
+    }
+
+    for(dir=i1;dir<i2;dir+=i3)v0[dir]=colvar.vecpar[i_c][1][dir]-colvar.vecpar[i_c][0][dir];
+    for(dir=i1;dir<i2;dir+=i3)v1[dir]=                 pos2[dir]-colvar.vecpar[i_c][0][dir];
+    l0=norm(v0);
+    colvar.ss0[i_c]=iprod(v0,v1)/l0;
+    for(i=0;i<colvar.natoms[i_c];i++)
+      for(dir=i1;dir<i2;dir+=i3)
+        colvar.myder[i_c][i][dir]=v0[dir]/colvar.natoms[i_c]/l0;
+
+  } else if(colvar.intpar[i_c][0]==4) {
+    i1=colvar.intpar[i_c][1];
+    i2=colvar.intpar[i_c][2];
+    i3=colvar.intpar[i_c][3];
+    pos2[0]=pos2[1]=pos2[2]=0.;
+    v0[0]=v0[1]=v0[2]=0.;
+    v1[0]=v1[1]=v1[2]=0.;
+    for(i=0;i<colvar.natoms[i_c];i++){
+      iat = colvar.cvatoms[i_c][i];
+      for(dir=i1;dir<i2;dir+=i3)pos2[dir]+=mtd_data->pos[iat][dir]/colvar.natoms[i_c];
+    }
+
+    for(dir=i1;dir<i2;dir+=i3)v0[dir]=colvar.vecpar[i_c][1][dir]-colvar.vecpar[i_c][0][dir];
+    for(dir=i1;dir<i2;dir+=i3)v1[dir]=                 pos2[dir]-colvar.vecpar[i_c][0][dir];
+    l0=norm(v0);
+    l1=norm2(v1);
+    l2=iprod(v0,v1)/l0;
+    colvar.ss0[i_c]=sqrt(l1-l2*l2);
+    for(i=0;i<colvar.natoms[i_c];i++)
+      for(dir=i1;dir<i2;dir+=i3)
+        colvar.myder[i_c][i][dir]=(v1[dir]-l2*v0[dir]/l0)/colvar.natoms[i_c]/colvar.ss0[i_c];
+
+  }
+}
+
+// ------------------------------------------------------------------------------------------------
+
+int PREFIX read_position(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i, iw, j;
+  double delta = 0.0;
+  char string[400];
+  char chr[3];
+  int help;
+  int i1, i2, i3;
+  double rtmp;
+
+  help=0;
+  chr[0]=chr[1]=chr[2]=' ';
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0){   
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR POSITION\n"); help=1;}
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }	
+
+  iw=seek_word(word,"DIR");
+  if(iw>=0) { 
+    sscanf(word[iw+1],"%s", chr); 
+    if(!strcmp(chr,"X") || !strcmp(chr,"x"))
+      colvar.intpar[count][0] = 0;
+    else if(!strcmp(chr,"Y") || !strcmp(chr,"y"))
+      colvar.intpar[count][0] = 1;
+    else if(!strcmp(chr,"Z") || !strcmp(chr,"z"))
+      colvar.intpar[count][0] = 2;
+  }
+
+  iw=seek_word(word,"LINE_POS");
+  if(iw>=0) { 
+    colvar.intpar[count][0] = 3;
+    sscanf(word[++iw],"%s", chr); 
+    if     (!strcmp(chr,"X")){
+      colvar.intpar[count][1] = 0;
+      colvar.intpar[count][2] = 1;
+      colvar.intpar[count][3] = 1;
+    }else if(!strcmp(chr,"Y")){
+      colvar.intpar[count][1] = 1;
+      colvar.intpar[count][2] = 2;
+      colvar.intpar[count][3] = 1;
+    }else if(!strcmp(chr,"Z")){
+      colvar.intpar[count][1] = 2;
+      colvar.intpar[count][2] = 3;
+      colvar.intpar[count][3] = 1;
+    }else if(!strcmp(chr,"XY")){
+      colvar.intpar[count][1] = 0;
+      colvar.intpar[count][2] = 2;
+      colvar.intpar[count][3] = 1;
+    }else if(!strcmp(chr,"XZ")){
+      colvar.intpar[count][1] = 0;
+      colvar.intpar[count][2] = 3;
+      colvar.intpar[count][3] = 2;
+    }else if(!strcmp(chr,"YZ")){
+      colvar.intpar[count][1] = 1;
+      colvar.intpar[count][2] = 3;
+      colvar.intpar[count][3] = 1;
+    }else if(!strcmp(chr,"XYZ")){
+      colvar.intpar[count][1] = 0;
+      colvar.intpar[count][2] = 3;
+      colvar.intpar[count][3] = 1;
+    }else{
+      help=1;
+    }
+
+    i1=colvar.intpar[count][1];
+    i2=colvar.intpar[count][2];
+    i3=colvar.intpar[count][3];
+    for(i=i1;i<i2;i+=i3){
+      sscanf(word[++iw],"%lf", &rtmp); 
+      colvar.vecpar[count][0][i]= (real) rtmp; 
+    }
+    for(i=i1;i<i2;i+=i3){
+      sscanf(word[++iw],"%lf", &rtmp); 
+      colvar.vecpar[count][1][i]= (real) rtmp; 
+    }
+  } 
+
+  iw=seek_word(word,"LINE_DIST");
+  if(iw>=0) { 
+    colvar.intpar[count][0] = 4;
+    sscanf(word[++iw],"%s", chr); 
+    if     (!strcmp(chr,"X")){
+      colvar.intpar[count][1] = 0;
+      colvar.intpar[count][2] = 1;
+      colvar.intpar[count][3] = 1;
+    }else if(!strcmp(chr,"Y")){
+      colvar.intpar[count][1] = 1;
+      colvar.intpar[count][2] = 2;
+      colvar.intpar[count][3] = 1;
+    }else if(!strcmp(chr,"Z")){
+      colvar.intpar[count][1] = 2;
+      colvar.intpar[count][2] = 3;
+      colvar.intpar[count][3] = 1;
+    }else if(!strcmp(chr,"XY")){
+      colvar.intpar[count][1] = 0;
+      colvar.intpar[count][2] = 2;
+      colvar.intpar[count][3] = 1;
+    }else if(!strcmp(chr,"XZ")){
+      colvar.intpar[count][1] = 0;
+      colvar.intpar[count][2] = 3;
+      colvar.intpar[count][3] = 2;
+    }else if(!strcmp(chr,"YZ")){
+      colvar.intpar[count][1] = 1;
+      colvar.intpar[count][2] = 3;
+      colvar.intpar[count][3] = 1;
+    }else if(!strcmp(chr,"XYZ")){
+      colvar.intpar[count][1] = 0;
+      colvar.intpar[count][2] = 3;
+      colvar.intpar[count][3] = 1;
+    }else{
+      help=1;
+    }
+
+    i1=colvar.intpar[count][1];
+    i2=colvar.intpar[count][2];
+    i3=colvar.intpar[count][3];
+    for(i=i1;i<i2;i+=i3){
+      sscanf(word[++iw],"%lf", &rtmp); 
+      colvar.vecpar[count][0][i]= (real) rtmp; 
+    }
+    for(i=i1;i<i2;i+=i3){
+      sscanf(word[++iw],"%lf", &rtmp); 
+      colvar.vecpar[count][1][i]= (real) rtmp; 
+    }
+  } 
+
+  if(chr[0]==' ')help=1;
+
+  if(help){
+          fprintf(fplog, "\n-POSIION CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "      POSITION LIST 42 {TYPE} SIGMA 1.0 \n");
+          fprintf(fplog, "or in case of groups    \n");
+          fprintf(fplog, "      POSITION LIST <g1> {TYPE} SIGMA 1.0 \n");
+          fprintf(fplog, "         g1->    \n");
+          fprintf(fplog, "         6 10    \n");
+          fprintf(fplog, "         g1<-    \n");
+          fprintf(fplog, "                 \n");
+          fprintf(fplog, " TYPE can be either DIR, LINE_POS or LINE_DIST\n");
+          fprintf(fplog, " possible flags for DIR are X, Y and Z\n");
+          fprintf(fplog, " possible flags for LINE_POS and LINE_DIST are X, Y, Z, XY, XZ, YZ or XYZ\n");
+          plumed_error("PluMeD dead with errors: check log file");
+  }
+
+  colvar.type_s[count]   = 32;
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  fprintf(fplog, "%i-%1s POSITION OF %i ATOMS; ", count+1,chr,colvar.natoms[count]);
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+  fprintf(fplog,"|- SET MEMBERS: ");
+  for(i=0;i<colvar.natoms[count];i++){fprintf(fplog," %d ",colvar.cvatoms[count][i]+1);if((i+1)%20==0)fprintf(fplog,"\n               ");}fprintf(fplog,"\n\n");
+
+  return 0;
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_puckering.c dl_class_1.9/srcmod/Plumed/restraint_puckering.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_puckering.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_puckering.c	2015-11-07 17:37:19.386604157 +0100
@@ -0,0 +1,392 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+/*
+ * Notation follows
+ * M. Sega, E. Autieri and F. Pederiva
+ * On the Calculation of Puckering Free Energy Surfaces
+ * J. Chem. Phys. 2009 vol. 130 (22) pp. 225102
+ *
+ */
+#define Delta(x,y) ((x)==(y)?5./6.:-1./6.)
+#define SQRT3_2 .86602540378443864676
+
+// TRIPLE PRODUCT  a . (bxc)
+real PREFIX tprod (rvec a,rvec b, rvec c ) {
+	rvec vp;
+	oprod(b,c,vp);
+	return iprod(a,vp);
+}
+
+// WEIGHTS FOR SUMMATION OVER j
+// weights for R' and R'' definitions
+real puckW[] = {0., SQRT3_2,SQRT3_2,0.,-SQRT3_2,-SQRT3_2};
+real puckV[] = {1., 0.5, -0.5 , -1., -0.5, 0.5};
+// weights for puckering coordinate definitions
+real puckBIGW[] = {0., SQRT3_2,-SQRT3_2,0.,SQRT3_2,-SQRT3_2};
+real puckBIGV[] = {1.,-0.5,-0.5,1.,-0.5,-0.5};
+real puckSIGN[] = {1.,-1.,1.,-1.,1.,-1.}; // (-1)^(j-1) term in summation
+
+// GENERATE THE VECTORS R_j
+// REFERRED TO THE GEOMETRICAL CENTER OF THE RING Rcm
+// FROM THE ORIGINAL COORDIANTE VECTORS r_j
+real PREFIX generate_R(int i_c,struct mtd_data_s *mtd_data,rvec* R,rvec Rp,rvec Rdp,rvec RpxRdp){
+	rvec Rcm,temp;
+	real tempr;
+	int i,j,alpha,iat,prev;
+	rvec folded[6];
+	Rcm[0]=Rcm[1]=Rcm[2]=0.0;
+	// vector Rcm definition (geometrical center of the ring)
+	// position of the first atom of the ring
+        iat = colvar.cvatoms[i_c][0];
+        folded[0][0]=mtd_data->pos[iat][0];
+        folded[0][1]=mtd_data->pos[iat][1];
+        folded[0][2]=mtd_data->pos[iat][2];
+	// position of the other 5 atom with the minimal image convention
+	for(j=1;j<6;j++){ 
+            iat = colvar.cvatoms[i_c][j];
+            prev = colvar.cvatoms[i_c][j-1];
+	    minimal_image(mtd_data->pos[iat],mtd_data->pos[prev],&tempr,temp);
+            for(alpha=0;alpha<3;alpha++){
+	       folded[j][alpha]=folded[j-1][alpha]+temp[alpha];
+	    }
+	}
+	// definition of the Rcm vector (NOT NORMALIZED!!!)
+	for(j=0;j<6;j++){ 
+		Rcm[0]+=folded[j][0]; 
+		Rcm[1]+=folded[j][1]; 
+		Rcm[2]+=folded[j][2]; 
+	}
+	// vectors R_j definition (ring element's coordinate respect to the center)
+	for(j=0;j<6;j++) {
+		R[j][0] = folded[j][0]-Rcm[0]/6.; // NOTE: here the Rcm vector is normalized properly
+		R[j][1] = folded[j][1]-Rcm[1]/6.; // component by component
+		R[j][2] = folded[j][2]-Rcm[2]/6.;
+	}  
+	// vectors R' and R'' definitions
+	Rp[0] = Rp[1] = Rp[2] = 0.;
+	Rdp[0] = Rdp[1] = Rdp[2] = 0.;
+	for(j=0;j<6;j++){
+           for(alpha=0;alpha<3;alpha++){
+	      Rp[alpha] += puckW[j] * R[j][alpha];
+	      Rdp[alpha] += puckV[j] * R[j][alpha];
+	   }
+	}
+	// vector product R'xR'' definition
+	oprod(Rp,Rdp,RpxRdp);
+	// returns |R'xR''|
+	return  sqrt(iprod(RpxRdp,RpxRdp)); 
+}
+
+// PROJECTION z_j OF THE R_j VECTOR
+real PREFIX puckering_Zeta (rvec R,rvec RpxRdp,real mod) {
+	real tmp;
+	tmp = iprod(R,RpxRdp);
+	return tmp/mod;
+}
+
+// GRADIENT nabla_i OF THE PROJECTION z_j
+// returns the vector nabla_i z_j
+void PREFIX puckering_gradZeta(rvec gradZ,int index_i,int index_j,real* z,rvec* R,rvec Rp, rvec Rdp, rvec RpxRdp,real mod){
+	int l,alpha;
+	rvec sum1,sum2,RdpRj,RjRp;
+	real Ei,Fi;
+	real RpRp,RpRdp,RdpRdp,tmp1,tmp2;
+	for(alpha=0;alpha<3;alpha++){
+		sum1[alpha]=0.;
+		sum2[alpha]=0.;
+	}
+	// coefficients 
+	Ei=0.;	Fi=0.;
+	for(l=0;l<6;l++){
+		Ei += Delta(index_i,l)*puckW[l] ;
+		Fi += Delta(index_i,l)*puckV[l] ;
+	}
+	// scalar and vector products
+	RpRp=iprod(Rp,Rp);
+	RdpRdp=iprod(Rdp,Rdp);
+	RpRdp=iprod(Rp,Rdp);
+	oprod(Rdp,R[index_j],RdpRj);
+	oprod(R[index_j],Rp,RjRp);
+	// building blocks
+	for(alpha=0;alpha<3;alpha++){
+		sum1[alpha] = 2.*Ei*( Rp[alpha]*RdpRdp - Rdp[alpha]*RpRdp ) +2.*Fi*( Rdp[alpha]*RpRp - Rp[alpha]*RpRdp);
+		sum2[alpha] = Delta(index_i,index_j)*RpxRdp[alpha] + Ei*RdpRj[alpha] + Fi*RjRp[alpha];
+	}
+	// effective computation of grad_i z_j
+        for(alpha=0;alpha<3;alpha++)
+	   gradZ[alpha] =-z[index_j]*sum1[alpha]/(2.*mod*mod) +  sum2[alpha]/mod; 
+}
+
+// PUCKERING COORDINATE Q (total puckering amplitude)
+real PREFIX puckering_Q(real *z){
+	real QQ=0.;
+	int i;
+	for(i=0;i<6;i++) QQ += z[i]*z[i];
+	return sqrt(QQ);
+}
+
+// GRADIENT OF PUCKERING COORDINATE Q
+void PREFIX puckering_gradQ(rvec gradQ, real* z, real Q,rvec*R, rvec Rp, rvec Rdp, rvec RpxRdp,real mod,int index){
+	int alpha,j;
+	rvec gQ,gzj;
+	gQ[0]=gQ[1]=gQ[2]=0.;
+
+	for(j=0;j<6;j++){
+		puckering_gradZeta(gzj,index,j,z,R,Rp,Rdp,RpxRdp,mod); 
+		for(alpha=0;alpha<3;alpha++){
+			gQ[alpha] += z[j] * gzj[alpha];
+		}
+	}
+	for(alpha=0;alpha<3;alpha++){
+		gQ[alpha] /= Q;
+		gradQ[alpha] = gQ[alpha];
+	}
+}
+
+// PUCKERING COORDINATE phi
+real PREFIX puckering_phi(real *z){
+	real tempphi,phi, A, B;
+	int j;
+	A=0.;	B=0.;
+	for(j=0;j<6;j++){
+		A += puckBIGW[j]*z[j];
+		B += puckBIGV[j]*z[j];
+	}
+	// disambiguation of the phi angle
+	// and its definition in the (CICLIC) range [0,2pi)
+	tempphi=atan(-A/B);
+	if(B >= 0.){
+		if(tempphi >= 0.){
+			phi = tempphi;
+		}else{	phi = tempphi + 2.*M_PI;}
+	}else{ phi = tempphi + M_PI; }
+	return phi;
+}
+
+// GRADIENT OF PUCKERING COORDINATE phi
+void PREFIX puckering_gradphi(rvec gradphi, real* z,rvec*R, rvec Rp, rvec Rdp, rvec RpxRdp,real mod,int index){
+	int j,alpha;
+	real A,B;
+	rvec gphi, gzj,gA,gB;
+	gphi[0]=gphi[1]=gphi[2]=0.;
+	A=0.;	B=0.;
+	gA[0]=gA[1]=gA[2]=0.;
+	gB[0]=gB[1]=gB[2]=0.;
+	for(j=0;j<6;j++){
+		puckering_gradZeta(gzj,index,j,z,R,Rp,Rdp,RpxRdp,mod);
+		A += z[j]*puckBIGW[j];
+		B += z[j]*puckBIGV[j];
+		for(alpha=0;alpha<3;alpha++){
+			gA[alpha] += gzj[alpha]*puckBIGW[j];
+			gB[alpha] += gzj[alpha]*puckBIGV[j];
+		}
+	}
+	for(alpha=0;alpha<3;alpha++){
+		gphi[alpha] = (A*gB[alpha]-B*gA[alpha])/(A*A+B*B);
+		gradphi[alpha]=gphi[alpha];
+	}	
+}
+
+// PUCKERING COORDINATE theta
+real PREFIX puckering_theta(real * z){
+	real A,B,C;
+	int j;
+	A=0.;	B=0.;	C=0.;
+	for(j=0;j<6;j++){
+		A += puckBIGW[j]*z[j];
+		B += puckBIGV[j]*z[j];
+		C += puckSIGN[j]*z[j];
+	}
+	return  acos( C / sqrt(2.*(A*A+B*B) +C*C ) );
+}
+
+// GRADIENT OF PUCKERING COORDINATE theta
+void PREFIX puckering_gradtheta(rvec gradtheta, real* z,rvec*R,rvec Rp,rvec Rdp,rvec RpxRdp,real mod,int index){
+	real A,B,C,Q;
+	rvec gtheta, gzj,gA,gB,gC;
+	int j,alpha;
+	gtheta[0]=gtheta[1]=gtheta[2]=0.;
+	A=0.;   B=0.;	C=0.;
+	gA[0]=gA[1]=gA[2]=0.;
+	gB[0]=gB[1]=gB[2]=0.;
+	gC[0]=gC[1]=gC[2]=0.;
+	Q=puckering_Q(z);
+	for(j=0;j<6;j++){
+		puckering_gradZeta(gzj,index,j,z,R,Rp,Rdp,RpxRdp,mod);
+		A += z[j]*puckBIGW[j];
+		B += z[j]*puckBIGV[j];
+		C += z[j]*(j%2?-1:1);
+		for(alpha=0;alpha<3;alpha++){
+			gA[alpha] += gzj[alpha]*puckBIGW[j];
+			gB[alpha] += gzj[alpha]*puckBIGV[j];
+			gC[alpha] += gzj[alpha]*(j%2?-1:1);
+		}
+	}
+	for(alpha=0;alpha<3;alpha++){
+	  gtheta[alpha] = ( C*( B*gB[alpha] + A*gA[alpha] )/sqrt( A*A+B*B ) - sqrt( A*A+B*B)*gC[alpha] );
+	  gtheta[alpha] = gtheta[alpha]/( 3.*sqrt(2.)*Q*Q );
+	  gradtheta[alpha]=gtheta[alpha];
+	}
+}
+
+// FOR METADYNAMICS: called by restaint.c 
+// this function selects what puckering coordinate will be used
+// due to the contents of the META_INP input file
+void PREFIX puckering_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int i,j, iat;
+  real mod,Q;
+  rvec rij, sum1, sum2, RpxRdp,Rp,Rdp,gradQ,gradphi,gradtheta;
+  static rvec *R=NULL;
+  
+  real z[6];
+  if(R==NULL) R=(rvec*) malloc(sizeof(rvec)*6);
+
+  // generation of the geometrical center coordinate set R_j
+  // and accessories vectors (see above)
+  mod = generate_R(i_c,mtd_data,R,Rp,Rdp,RpxRdp);
+
+  // generation of the projection z_j
+  for(j=0;j<6;j++){
+     z[j]=puckering_Zeta (R[j],RpxRdp,mod);
+  }
+  // calculation of puckering amplitude (needed for all the puckering coords)
+  Q = puckering_Q(z);
+  // selection of the puckering coordinate
+  switch(colvar.type[i_c]) {
+	case 1: // puckering coordinate Q
+	     { 
+                colvar.ss0[i_c] = Q;
+		for(i=0;i<6;i++){
+		  puckering_gradQ(gradQ, z, Q, R, Rp, Rdp, RpxRdp, mod, i); 
+                  colvar.myder[i_c][i][0] = gradQ[0]; 
+                  colvar.myder[i_c][i][1] = gradQ[1]; 
+                  colvar.myder[i_c][i][2] = gradQ[2]; 
+		}
+	     }
+	       break;
+       case 2: // puckering coordinate phi
+	    {
+		    real phi = puckering_phi(z);
+		    rvec gradphi;
+		    colvar.ss0[i_c] = phi;
+		    for(i=0;i<6;i++){
+			puckering_gradphi(gradphi, z, R, Rp, Rdp, RpxRdp, mod, i);
+			colvar.myder[i_c][i][0] = gradphi[0];
+			colvar.myder[i_c][i][1] = gradphi[1];
+			colvar.myder[i_c][i][2] = gradphi[2];
+		    }
+	    }
+	       break;
+       case 3: // puckering coordinate theta
+	    {
+		    real theta = puckering_theta(z);
+		    rvec gradtheta;
+		    colvar.ss0[i_c] = theta;
+		    for(i=0;i<6;i++){
+			puckering_gradtheta(gradtheta,z, R, Rp, Rdp, RpxRdp,mod,i);
+			colvar.myder[i_c][i][0] = gradtheta[0];
+			colvar.myder[i_c][i][1] = gradtheta[1];
+			colvar.myder[i_c][i][2] = gradtheta[2];
+		    }
+		    
+	    }
+	       break;
+       default: break;
+		
+   }
+
+}
+
+// ------------------------------------------------------------------------------------------------
+
+int PREFIX read_puckering(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i, iw, iat, j;
+  double delta = 0.0;
+  char string[400];
+  int help;
+  help=0;
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0){
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR PUCKERING\n"); help=1;}
+
+  if(colvar.natoms[count]!=6) {fprintf(fplog, "PUCKERING is not able to run with more or less than 6 atom in the ring\n"); help=1;}
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+
+  iw=seek_word(word,"TYPE");
+  if(iw>0){
+    if(seek_word2(word,"Q",iw)>iw)colvar.type[count] = 1;
+    if(seek_word2(word,"PHI",iw)>iw)colvar.type[count] = 2;
+    if(seek_word2(word,"THETA",iw)>iw)colvar.type[count] = 3;
+  } else{ fprintf(fplog,"|- NEEDED TYPE KEYWORD FOR PUCKERING\n"); help=1;}
+
+  if(help){
+          printf("%i \n",help);
+          fprintf(fplog, "\n-PUCKERING CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "PUCKERING LIST <g1> SIGMA 0.1 TYPE Q/PHI/THETA\n");
+          fprintf(fplog, "         g1->            \n");
+          fprintf(fplog, "         six atoms       \n");
+          fprintf(fplog, "         g1<-            \n");
+          fprintf(fplog, "                         \n");
+          plumed_error("PluMeD dead with errors: check log file");
+  }
+
+  colvar.type_s[count] = 34;
+
+  if(colvar.type[count]==1){
+    fprintf(fplog, "\n%i-PUCKERINGQ; ATOMS INVOLVED: %i; ", count+1, colvar.natoms[count]);
+  }else if(colvar.type[count]==2){
+    fprintf(fplog, "\n%i-PUCKERINGPHI; ATOMS INVOLVED: %i; ", count+1, colvar.natoms[count]);
+  }else if(colvar.type[count]==3){
+    fprintf(fplog, "\n%i-PUCKERINGTHETA; ATOMS INVOLVED: %i; ", count+1, colvar.natoms[count]);
+  }
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+ fprintf(fplog,"|- SET MEMBERS: ");
+  for(i=0;i<colvar.natoms[count];i++){fprintf(fplog," %d ",colvar.cvatoms[count][i]+1);if((i+1)%20==0)fprintf(fplog,"\n               ");}fprintf(fplog,"\n\n");
+
+  return colvar.natoms[count];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_rdf.c dl_class_1.9/srcmod/Plumed/restraint_rdf.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_rdf.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_rdf.c	2015-11-07 17:37:19.389604244 +0100
@@ -0,0 +1,250 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+// These two routines are only used in here
+
+// double triangleFunc( double x ){
+//     double result; result=fabs(x);
+//     if(result<1.0){return 1.0-result;}
+//     return 0.0;
+// }   
+// 
+// double integratedTriangleFunc( double a, double b ){
+//     double ia, ib; 
+// 
+//     if (b<=-1. || a >=1.) return 0.;
+// 
+//     if( a>-1.0 ){ ia=a; }else{ ia=-1.0; } 
+//     if( b<1.0 ){ ib=b; } else{ ib=1.0; }
+// 
+//     return (ib*(2.-fabs(ib))-ia*(2.-fabs(ia)))*0.5;
+// }  
+
+void PREFIX rdf_restraint(int i_c, int ignore_repeats, struct mtd_data_s *mtd_data) {
+  int i, j, k, iat, jat; 
+  real lowB, upperB, dertmp, mod_rij, norm_factor; rvec rij;
+
+//  fprintf(mtd_data->fplog,"New call %d\n",i_c );
+//  fprintf(mtd_data->fplog, "ATOM 1 %f %f %f \n", mtd_data->pos[colvar.cvatoms[i_c][0]][0], mtd_data->pos[colvar.cvatoms[i_c][0]][1], mtd_data->pos[colvar.cvatoms[i_c][0]][2] );
+//  fprintf(mtd_data->fplog,"ATOM 2 %f %f %f \n", mtd_data->pos[colvar.cvatoms[i_c][1]][0], mtd_data->pos[colvar.cvatoms[i_c][1]][1], mtd_data->pos[colvar.cvatoms[i_c][1]][2] );
+
+  // We calculate all beads for a given rdf in the first call to this routine
+  // so any further calls we just return without doing anything
+  for(i=0;i<i_c;i++){ 
+     if( colvar.type_s[i]==47 && colvar.rdflab[i]==colvar.rdflab[i_c] ){ 
+       if( ignore_repeats==1 ){ return; }   // This flag ensures we calculate each cv separately when debugging derivatives 
+     } 
+  }
+
+  // Initialize all colvars and derivatives to zero
+  for(k=0;k<colvar.nconst;k++){
+     if( colvar.type_s[k]==47 && colvar.rdflab[k]==colvar.rdflab[i_c] ){ 
+       colvar.ss0[k]=0.0; 
+       for(i=0;i<colvar.natoms[k];i++){ 
+           colvar.myder[k][i][0]=colvar.myder[k][i][1]=colvar.myder[k][i][2]=0.0; 
+       }
+     }  
+  }
+
+  // Accumulate n(r) and its derivative 
+  for(i=0;i<colvar.list[i_c][0];i++){   // Loop over central atoms
+     iat = colvar.cvatoms[i_c][i];
+     for(j=colvar.list[i_c][0];j<colvar.natoms[i_c];j++){   // Loop over other atoms
+         jat = colvar.cvatoms[i_c][j];
+         
+         // Cycle if the two atoms are the same
+         if( iat==jat ){ continue; }
+         
+         // Compute the distance between atom i and atom j and the derivative
+         if(colvar.cell_pbc[i_c]){ minimal_image(mtd_data->pos[iat], mtd_data->pos[jat], &mod_rij, rij); }
+         else{
+           rij[0] = mtd_data->pos[iat][0]-mtd_data->pos[jat][0];
+           rij[1] = mtd_data->pos[iat][1]-mtd_data->pos[jat][1];
+           rij[2] = mtd_data->pos[iat][2]-mtd_data->pos[jat][2];
+           mod_rij  = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+         }
+
+         // Now loop over all colvars of this rdf and add the rdf and derivative
+         for(k=0;k<colvar.nconst;k++){
+            // Cycle if not a rdf bead of this type
+            if( colvar.type_s[k]!=47 || colvar.rdflab[k]!=colvar.rdflab[i_c] ){ continue; }
+
+            //lowB=(colvar.rdfBeadLower[k]-mod_rij) / colvar.rdfBeadWidth[k];
+            //upperB=(colvar.rdfBeadUpper[k]-mod_rij) / colvar.rdfBeadWidth[k];
+
+            //dertmp = triangleFunc( lowB ) / colvar.rdfBeadWidth[k] - triangleFunc( upperB ) / colvar.rdfBeadWidth[k];
+            //colvar.ss0[k]+=integratedTriangleFunc( lowB, upperB );
+
+            lowB = ( colvar.rdfBeadLower[k] - mod_rij ) / ( sqrt(2.0) * colvar.rdfBeadWidth[k] ) ;
+            upperB = ( colvar.rdfBeadUpper[k] - mod_rij ) / ( sqrt(2.0) * colvar.rdfBeadWidth[k] ) ;  
+            dertmp = ( exp( -lowB*lowB ) - exp( -upperB*upperB ) ) / ( sqrt(2.0*M_PI)*colvar.rdfBeadWidth[k] );
+            colvar.ss0[k] += 0.5*( erf( upperB ) - erf( lowB ) ); 
+
+//            fprintf( mtd_data->fplog,"Hello %d %d %d : %f %f %f %f %f %f\n", k, iat, jat, mod_rij, lowB, upperB, triangleFunc( lowB ), triangleFunc( upperB ), integratedTriangleFunc( lowB, upperB ) );
+
+            // Accumulate the derivative on each distance pair
+            colvar.myder[k][i][0] += dertmp*( rij[0]/mod_rij ); 
+            colvar.myder[k][i][1] += dertmp*( rij[1]/mod_rij );
+            colvar.myder[k][i][2] += dertmp*( rij[2]/mod_rij ); 
+            colvar.myder[k][j][0] -= dertmp*( rij[0]/mod_rij );
+            colvar.myder[k][j][1] -= dertmp*( rij[1]/mod_rij );
+            colvar.myder[k][j][2] -= dertmp*( rij[2]/mod_rij );
+         }
+     }
+  }
+
+  real constant; constant = ( 4.0 * M_PI * colvar.list[i_c][0] ) / 3.0;
+
+  // Convert n(r) to g(r) (assumes unit density)
+  for(k=0;k<colvar.nconst;k++){
+     if( colvar.type_s[k]==47 && colvar.rdflab[k]==colvar.rdflab[i_c] && colvar.rdfNorm[i_c]==1 ){
+        norm_factor = constant * ( pow(colvar.rdfBeadUpper[k],3) - pow(colvar.rdfBeadLower[k],3) );
+        colvar.ss0[k] /= norm_factor;
+        for(i=0;i<colvar.natoms[k];i++){
+            colvar.myder[k][i][0]/=norm_factor;
+            colvar.myder[k][i][1]/=norm_factor;
+            colvar.myder[k][i][2]/=norm_factor;
+        }
+     }
+     else if( colvar.type_s[k]==47 && colvar.rdflab[k]==colvar.rdflab[i_c] ){
+        colvar.ss0[k] /= (double) colvar.list[i_c][0];
+        for(i=0;i<colvar.natoms[k];i++){
+            colvar.myder[k][i][0] /= (double) colvar.list[i_c][0];
+            colvar.myder[k][i][1] /= (double) colvar.list[i_c][0];
+            colvar.myder[k][i][2] /= (double) colvar.list[i_c][0];
+        }
+     }
+  }
+
+}
+
+int PREFIX read_rdf( char **word, int count, t_plumed_input *input, FILE *fplog ) {
+  int i, iw, j, iat, help, rdflab, checkLists; 
+  double delta = 0.0, upBound, lowBound, width;
+
+  help=0;
+
+  // Deal with periodic boundary conditions
+  colvar.cell_pbc[count]=1; // default is PBC
+
+  iw=seek_word(word,"NOPBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 0;}
+  iw=seek_word(word,"PBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 1;} 
+
+  // This is the label for which rdf this bead is from
+  iw = seek_word(word,"RDF_LABEL");
+  if(iw>=0){ sscanf(word[iw+1],"%d",&rdflab); colvar.rdflab[count]=rdflab; }
+  else{ fprintf(fplog,"|- NEEDED RDF_LABEL KEYWORD FOR RDF\n"); help=1; }
+
+  // Now we check whether there are other beads from this rdf that have been read in
+  checkLists=-1; for(i=0;i<count;i++){ if( colvar.type_s[i]==47 && colvar.rdflab[i]==rdflab ){ checkLists=i; break; } }
+
+  // Get atoms involved in the rdf
+  iw = seek_word(word,"LIST");
+  if(iw>=0){
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+             j=plumed_get_group(word[iw+2],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][1]=j;
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR RDF\n"); help=1; }
+
+  // Check that the lists are consistent with other rdfs of this type
+  if( checkLists!=-1){
+    if( colvar.natoms[count]!=colvar.natoms[checkLists] ){
+      fprintf(fplog,"|- MISLABELED RDF: ATOM LIST SIZES DO NOT MATCH\n"); help=1;  
+    }
+    else{
+      for(i=0;i<colvar.natoms[count];i++){
+         if( colvar.cvatoms[count][i]!=colvar.cvatoms[checkLists][i] ){
+            fprintf(fplog,"|- MISLABELED RDF: ATOM LISTS DO NOT MATCH\n"); help=1;
+         }
+      }
+    }
+  }
+
+  // Get the start and end of this particular bead
+  iw = seek_word(word,"RANGE");
+  if(iw>=0){ sscanf(word[iw+1],"%lf",&lowBound); sscanf(word[iw+2],"%lf", &upBound); 
+     colvar.rdfBeadLower[count]=lowBound; colvar.rdfBeadUpper[count]=upBound;
+  } else{ fprintf(fplog,"|- NEEDED RANGE KEYWORD FOR RDF\n"); help=1;}
+
+  // Get the width of this bead
+  iw = seek_word(word,"WIDTH");
+  if(iw>=0){ sscanf(word[iw+1],"%lf",&width); 
+     colvar.rdfBeadWidth[count]=width;
+  } else{ fprintf(fplog,"|- NEEDED WIDTH KEYWORD FOR RDF\n"); help=1;}
+
+  // Choose whether or not to include the 4/3 pi ( r(i+1)**3 0 r(i)**3 ) normalization constant
+  // default is to not include this term.
+  iw = seek_word(word,"NORMALIZE");
+  if(iw>=0){ colvar.rdfNorm[count]=1; }
+  else{ colvar.rdfNorm[count]=0; }
+
+  if(help){
+     fprintf(fplog,"\n-RDF CV: WRONG SYNTAX\n");
+     fprintf(fplog,"e.g.:    \n");
+     fprintf(fplog,"RDF RDF_LABEL 1 LIST <gr1> <gr2> RANGE 2.0 3.0 WIDTH 1.5 \n");
+     fprintf(fplog,"RDF RDF_LABEL 1 LIST <gr1> <gr2> RANGE 2.0 3.0 WIDTH 1.5 \n");
+     fprintf(fplog,"gr1-> \n");
+     fprintf(fplog,"1 2 3 4  \n");
+     fprintf(fplog,"gr1<- \n");
+     fprintf(fplog,"gr2-> \n");
+     fprintf(fplog,"1 2 3 4  \n");
+     fprintf(fplog,"gr2<- \n");
+     fprintf(fplog,"         \n");
+     plumed_error("PluMed dead with errors: check log file");
+  }
+
+  // Resize derivatives array
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+
+  fprintf(fplog, "%1i-RDF BEAD OF (1st SET: %i ATOMS) WRT (2nd SET: %i ATOMS); \n", count+1, colvar.list[count][0], colvar.list[count][1]);
+  fprintf(fplog, "|--LOWER BOUND %f, UPPER BOUND %f, WIDTH %f \n", colvar.rdfBeadLower[count], colvar.rdfBeadUpper[count], colvar.rdfBeadWidth[count]);
+  
+  iat=0;
+  fprintf(fplog,"|- 1st SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][0];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 2nd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][1];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+
+  return colvar.natoms[count];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_rgyr.c dl_class_1.9/srcmod/Plumed/restraint_rgyr.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_rgyr.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_rgyr.c	2015-11-07 17:37:19.392604331 +0100
@@ -0,0 +1,364 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX radgyr_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int i, j, firstAtom;
+  rvec rcom, rdiff, pos0;
+  real totmass, Rg, mod_rij,tmp;
+  double gyration_tensor[3][3]; //gyration tensor must be calculated with double precision 
+  double trace;
+  double transf[3][3];  //transformation matrix
+  double principal_components[3];
+  double prefactor[3];
+  double det;
+  int pc_index;
+  real tX[3];
+  
+  totmass = Rg = trace = rcom[0] = rcom[1] = rcom[2] = 0.;
+
+  /* Initialise gyration tensor matrix */
+  for(i=0;i<3;i++)
+   for(j=0;j<3;j++)
+     gyration_tensor[i][j]=0.0;
+
+  firstAtom = colvar.cvatoms[i_c][0];
+  if (colvar.mm[i_c]==0) totmass += mtd_data->mass[firstAtom];   //mass-weighted
+  else                   totmass += 1.0;                         //non-weighted
+  for(i=0;i<3;i++) pos0[i] = mtd_data->pos[firstAtom][i];
+
+  /*Calculate center of mass/ geometrical center*/
+  for(i=1;i<colvar.natoms[i_c];i++){
+    firstAtom = colvar.cvatoms[i_c][i];
+    if (colvar.mm[i_c]==0) totmass += mtd_data->mass[firstAtom];
+    else                   totmass +=1.0; 
+    if(colvar.cell_pbc[i_c]) {
+      minimal_image(mtd_data->pos[firstAtom], pos0, &mod_rij, rdiff);
+      if (colvar.mm[i_c]==0) for(j=0;j<3;j++) rcom[j] += mtd_data->mass[firstAtom]*rdiff[j];
+      else                   for(j=0;j<3;j++) rcom[j] += rdiff[j];
+    } else {
+      if (colvar.mm[i_c]==0)  for(j=0;j<3;j++) rcom[j] += mtd_data->mass[firstAtom]*(mtd_data->pos[firstAtom][j]-pos0[j]);
+      else                    for(j=0;j<3;j++) rcom[j] += mtd_data->pos[firstAtom][j]-pos0[j];
+    }
+  }
+  for(j=0;j<3;j++) rcom[j] = rcom[j]/totmass+pos0[j];
+  
+  /* Calculate Rg / gyration tensor */
+  for(i=0;i<colvar.natoms[i_c];i++){
+    firstAtom = colvar.cvatoms[i_c][i];
+    if(colvar.cell_pbc[i_c]) {
+     minimal_image(mtd_data->pos[firstAtom], rcom, &mod_rij, rdiff);
+    } else {
+     for(j=0;j<3;j++) rdiff[j] = mtd_data->pos[firstAtom][j]-rcom[j];
+     mod_rij  = sqrt(rdiff[0]*rdiff[0]+rdiff[1]*rdiff[1]+rdiff[2]*rdiff[2]);    
+    }
+ 
+    if(colvar.nn[i_c]<2){    // calculate Rg directly, no tensor needed
+      if (colvar.mm[i_c]==0){
+             Rg += mtd_data->mass[firstAtom]*mod_rij*mod_rij;
+             for(j=0;j<3;j++) colvar.myder[i_c][i][j] = rdiff[j]*mtd_data->mass[firstAtom]; 
+      }
+      else{
+             Rg += mod_rij*mod_rij;
+             for(j=0;j<3;j++) colvar.myder[i_c][i][j] = rdiff[j];       
+      }
+    }else{
+      if (colvar.mm[i_c]==0){  //calculate gyration tensor
+             gyration_tensor[0][0]+=mtd_data->mass[firstAtom]*rdiff[0]*rdiff[0];
+             gyration_tensor[1][1]+=mtd_data->mass[firstAtom]*rdiff[1]*rdiff[1];
+             gyration_tensor[2][2]+=mtd_data->mass[firstAtom]*rdiff[2]*rdiff[2];
+             gyration_tensor[0][1]+=mtd_data->mass[firstAtom]*rdiff[0]*rdiff[1];
+             gyration_tensor[0][2]+=mtd_data->mass[firstAtom]*rdiff[0]*rdiff[2];
+             gyration_tensor[1][2]+=mtd_data->mass[firstAtom]*rdiff[1]*rdiff[2];
+      }
+      else{
+             gyration_tensor[0][0]+=rdiff[0]*rdiff[0];
+             gyration_tensor[1][1]+=rdiff[1]*rdiff[1];
+             gyration_tensor[2][2]+=rdiff[2]*rdiff[2];
+             gyration_tensor[0][1]+=rdiff[0]*rdiff[1];
+             gyration_tensor[0][2]+=rdiff[0]*rdiff[2];
+             gyration_tensor[1][2]+=rdiff[1]*rdiff[2];
+      }
+    }
+  }
+  
+  /*Evaluate gyration- and inertia- tensor based CV*/
+  if((colvar.nn[i_c]>1)&&(colvar.nn[i_c]<11)){
+      //dsyevj3(gyration_tensor,transf,principal_components); //diagonalize gyration tensor
+      rank3_to_ql77(gyration_tensor, transf, principal_components);
+      //sort eigenvalues and eigenvectors
+      if (principal_components[0]<principal_components[1]){
+      tmp=principal_components[0]; principal_components[0]=principal_components[1]; principal_components[1]=tmp;
+      for (i=0; i<3; i++){tmp=transf[i][0]; transf[i][0]=transf[i][1]; transf[i][1]=tmp;}
+      }
+      if (principal_components[1]<principal_components[2]){
+      tmp=principal_components[1]; principal_components[1]=principal_components[2]; principal_components[2]=tmp;
+      for (i=0; i<3; i++){tmp=transf[i][1]; transf[i][1]=transf[i][2]; transf[i][2]=tmp;}
+      }
+      if (principal_components[0]<principal_components[1]){
+      tmp=principal_components[0]; principal_components[0]=principal_components[1]; principal_components[1]=tmp;
+      for (i=0; i<3; i++){tmp=transf[i][0]; transf[i][0]=transf[i][1]; transf[i][1]=tmp;}      
+      }
+      //calculate determinant of transformation matrix
+      det=transf[0][0]*transf[1][1]*transf[2][2]+transf[0][1]*transf[1][2]*transf[2][0]+transf[0][2]*transf[1][0]*transf[2][1]- transf[0][2]*transf[1][1]*transf[2][0]-transf[0][1]*transf[1][0]*transf[2][2]-transf[0][0]*transf[1][2]*transf[2][1];
+      if (det<0) 
+	  for (j=0;j<3;j++) transf[j][2]=-transf[j][2]; //trasformation matrix for rotation must have positive determinant, otherwise multiply one column by (-1)
+      det=transf[0][0]*transf[1][1]*transf[2][2]+transf[0][1]*transf[1][2]*transf[2][0]+transf[0][2]*transf[1][0]*transf[2][1]- transf[0][2]*transf[1][1]*transf[2][0]-transf[0][1]*transf[1][0]*transf[2][2]-transf[0][0]*transf[1][2]*transf[2][1];	    
+      if (fabs(det-1)>0.001) plumed_error("Plumed Error: Cannot diagonalize gyration tensor\n"); //check again, if det(transf)!=1 something is wrong, die
+      prefactor[0]=prefactor[1]=prefactor[2]=0;
+      
+      if (colvar.nn[i_c]<5){        //GTPC_1, GTPC_2, GTPC_3 (S'_1, S'_2, S'_3 in paper )
+            pc_index=colvar.nn[i_c]-2; //index of principal component
+            colvar.ss0[i_c]=sqrt(principal_components[pc_index]/totmass);
+            if (colvar.ss0[i_c]>1e-6) prefactor[pc_index]=1.0/(totmass*colvar.ss0[i_c]); //some parts of derivate
+      }
+      else switch(colvar.nn[i_c]){
+	    case 8:        //the smallest principal radius of gyration
+                   colvar.ss0[i_c]=sqrt((principal_components[1]+principal_components[2])/totmass);
+		   if (colvar.ss0[i_c]>REAL_EPS){
+                   prefactor[1]=1.0/(totmass*colvar.ss0[i_c]);
+                   prefactor[2]=1.0/(totmass*colvar.ss0[i_c]);
+		   }
+                   break;
+	    case 9:       //the midle principal radius of gyration
+                   colvar.ss0[i_c]=sqrt((principal_components[0]+principal_components[2])/totmass);
+		   if (colvar.ss0[i_c]>REAL_EPS){
+                   prefactor[0]=1.0/(totmass*colvar.ss0[i_c]);
+                   prefactor[2]=1.0/(totmass*colvar.ss0[i_c]);
+		   }
+                   break;
+	    case 10:      //the largest principal radius of gyration
+                   colvar.ss0[i_c]=sqrt((principal_components[0]+principal_components[1])/totmass);
+		   if (colvar.ss0[i_c]>REAL_EPS){
+                   prefactor[0]=1.0/(totmass*colvar.ss0[i_c]);
+                   prefactor[1]=1.0/(totmass*colvar.ss0[i_c]);
+		   }
+                   break;             
+	    case 5:       //ASPHERICITY (b')
+                  colvar.ss0[i_c]=sqrt((principal_components[0]-0.5*(principal_components[1]+principal_components[2]))/totmass); 
+	          if (colvar.ss0[i_c]*totmass>REAL_EPS){   //avoid division by zero 
+                  prefactor[0]= 1.0/(totmass*colvar.ss0[i_c]);
+                  prefactor[1]=-0.5/(totmass*colvar.ss0[i_c]);
+                  prefactor[2]=-0.5/(totmass*colvar.ss0[i_c]);
+		  }
+		  break;
+      
+	    case 6:     //ACYLINDRICITY (c')
+                  colvar.ss0[i_c]=sqrt((principal_components[1]-principal_components[2])/totmass); 
+	          if (colvar.ss0[i_c]*totmass>REAL_EPS){   //avoid division by zero  
+                  prefactor[1]= 1.0/(totmass*colvar.ss0[i_c]);
+                  prefactor[2]=-1.0/(totmass*colvar.ss0[i_c]);
+		  }
+                  break;
+	    case 7:    //KAPPA2 - relative shape anisotropy
+                  trace=principal_components[0]+principal_components[1]+principal_components[2];
+                  tmp=principal_components[0]*principal_components[1]+ principal_components[1]*principal_components[2]+ principal_components[0]*principal_components[2]; 
+                  colvar.ss0[i_c]=1.0-3*(tmp/(trace*trace));
+		  if (colvar.ss0[i_c]>REAL_EPS){
+                  prefactor[0]= -3*((principal_components[1]+principal_components[2])-2*tmp/trace)/(trace*trace) *2;
+                  prefactor[1]= -3*((principal_components[0]+principal_components[2])-2*tmp/trace)/(trace*trace) *2;
+                  prefactor[2]= -3*((principal_components[0]+principal_components[1])-2*tmp/trace)/(trace*trace) *2;
+		  }
+                  break;
+	    default: break;
+      }      
+      /* Calculate the final part of the gradient and project it back to the original coordinate frame */
+      for(i=0;i<colvar.natoms[i_c];i++){
+                   firstAtom = colvar.cvatoms[i_c][i];
+                   if (colvar.cell_pbc[i_c]) {
+                             minimal_image(mtd_data->pos[firstAtom], rcom, &mod_rij, rdiff);
+                   } else {
+                   for (j=0;j<3;j++) rdiff[j] = mtd_data->pos[firstAtom][j]-rcom[j];
+                   }
+                   for (j=0;j<3;j++) tX[j]=transf[0][j]*rdiff[0]+transf[1][j]*rdiff[1]+transf[2][j]*rdiff[2]; //project atomic postional vectors to diagonalized frame
+		   /* Complete the gradient in diagonalized frame and back-project to original coordinate frame */  
+                   if (colvar.mm[i_c]==0) for (j=0;j<3;j++) colvar.myder[i_c][i][j]=mtd_data->mass[firstAtom]*(prefactor[0]*transf[j][0]*tX[0]+prefactor[1]*transf[j][1]*tX[1]+prefactor[2]*transf[j][2]*tX[2]);
+                   else                   for (j=0;j<3;j++) colvar.myder[i_c][i][j]=                          (prefactor[0]*transf[j][0]*tX[0]+prefactor[1]*transf[j][1]*tX[1]+prefactor[2]*transf[j][2]*tX[2]);
+        }
+  }
+
+/* Trace of the gyration tensor */
+    if(colvar.nn[i_c]==0){
+      colvar.ss0[i_c] = 2*Rg;
+      for(i=0;i<colvar.natoms[i_c];i++) {
+       for(j=0;j<3;j++) colvar.myder[i_c][i][j] *= 4;  
+      }
+/* Gyration radius */
+    }else if(colvar.nn[i_c]==1){
+      colvar.ss0[i_c] = sqrt(Rg/totmass);
+      for(i=0;i<colvar.natoms[i_c];i++) {
+       for(j=0;j<3;j++) colvar.myder[i_c][i][j] /= colvar.ss0[i_c]*totmass; 
+      }
+    }
+}
+
+//------------------------------------------------------------------------------------------------
+
+int PREFIX read_rgyr(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i, iw , j;
+  double delta = 0.0;
+  char string[400];
+  int help;
+
+  help=0;
+  colvar.nn[count] = 0;
+  colvar.mm[count] = 0; //0 = mass-weighted, other means no-weighted
+
+  iw=seek_word(word,"RGYR");
+  if(iw>=0)colvar.nn[count] = 1; //default
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0){
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR RGYR\n"); help=1;} 
+
+  iw=seek_word(word,"TYPE");
+  if(iw>0){
+    if(seek_word2(word,"TRACE",iw)>iw) colvar.nn[count] = 0;
+    if(seek_word2(word,"RGYR",iw)>iw)  colvar.nn[count] = 1;
+    if(seek_word2(word,"GTPC_1",iw)>iw)  colvar.nn[count] = 2;
+    if(seek_word2(word,"GTPC_2",iw)>iw)  colvar.nn[count] = 3;
+    if(seek_word2(word,"GTPC_3",iw)>iw)  colvar.nn[count] = 4;
+    if(seek_word2(word,"ASPHERICITY",iw)>iw) colvar.nn[count] = 5;    
+    if(seek_word2(word,"ACYLINDRICITY",iw)>iw) colvar.nn[count] = 6;        
+    if(seek_word2(word,"KAPPA2",iw)>iw) colvar.nn[count] = 7; 
+    if(seek_word2(word,"RGYR_3",iw)>iw)  colvar.nn[count] = 8;               
+    if(seek_word2(word,"RGYR_2",iw)>iw)  colvar.nn[count] = 9;
+    if(seek_word2(word,"RGYR_1",iw)>iw)  colvar.nn[count] = 10;
+
+
+  }
+
+  iw=seek_word(word,"PBC"); 
+  if(iw>0) colvar.cell_pbc[count] = 1;
+ 
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+
+  iw=seek_word(word,"MASS-WEIGHTED"); 
+  if(iw>0) colvar.mm[count] = 0;
+  
+  iw=seek_word(word,"NO-WEIGHTED"); 
+  if(iw>0) colvar.mm[count] = 1;  
+
+  if(help){
+          printf("%i \n",help);
+          fprintf(fplog, "\n-gyration/RGYR CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "gyration/RGYR LIST <g1> SIGMA 0.1 [PBC] [MASS-WEIGHTED (default) /NO-WEIGHTED]\n [TYPE RGYR (default)/TRACE/RGYR_1/RGYR_2/RGYR_3/GTPC_1/GTPC_2/GTPC_3/ASPHERICITY/ACYLINDRICITY/KAPPA2]\n");
+          fprintf(fplog, "         g1->            \n");
+          fprintf(fplog, "         6 10 16         \n");
+          fprintf(fplog, "         LOOP 20 30 2    \n");
+          fprintf(fplog, "         g1<-            \n");
+          fprintf(fplog, "                         \n");
+          plumed_error("PluMeD dead with errors: check log file");
+  }
+
+  colvar.type_s[count]   = 11;
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  if(colvar.nn[count] == 0)
+    fprintf(fplog,"%i-TRACE OF THE GYRATION TENSOR; ", count+1); 
+
+  if(colvar.nn[count] == 1)
+    fprintf(fplog,"%i-GYRATION RADIUS (Rg); ", count+1); 
+  
+  if(colvar.nn[count] == 2)
+    fprintf(fplog,"%i-THE LARGEST PRINCIPAL MOMENT OF THE GYRATION TENSOR (S'_1); ", count+1); 
+
+  if(colvar.nn[count] == 3)
+    fprintf(fplog,"%i-THE MIDDLE PRINCIPAL MOMENT OF THE GYRATION TENSOR (S'_2); ", count+1); 
+  
+  if(colvar.nn[count] == 4)
+    fprintf(fplog,"%i-THE SMALLEST PRINCIPAL MOMENT OF THE GYRATION TENSOR (S'_3); ", count+1); 
+    
+  if(colvar.nn[count] == 5)
+    fprintf(fplog,"%i-THE ASPHERICITY (b'); ", count+1); 
+
+  if(colvar.nn[count] == 6)
+    fprintf(fplog,"%i-THE ACYLINDRICITY (c'); ", count+1); 
+
+  if(colvar.nn[count] == 7)
+    fprintf(fplog,"%i-THE RELATIVE SHAPE ANISOTROPY (kappa^2); ", count+1); 
+
+  if(colvar.nn[count] == 8)
+    fprintf(fplog,"%i-THE SMALLEST PRINCIPAL RADIUS OF GYRATION (r_g3); ", count+1); 
+
+  if(colvar.nn[count] == 9)
+    fprintf(fplog,"%i-THE MIDDLE PRINCIPAL RADIUS OF GYRATION (r_g2); ", count+1);
+
+  if(colvar.nn[count] == 10)
+    fprintf(fplog,"%i-THE LARGEST PRINCIPAL RADIUS OF GYRATION (r_g1); ", count+1);
+
+  fprintf(fplog,"ATOMS INVOLVED: %i; ",colvar.natoms[count]);
+
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+  
+  if (colvar.cell_pbc[count]) {fprintf(fplog,"|- PBC is ON \n");}
+  else {fprintf(fplog,"|- PBC is OFF \n");} 
+  
+  if (colvar.mm[count]==0) {fprintf(fplog,"|- MASS-WEIGHTED \n");}
+  else {fprintf(fplog,"|- NO-WEIGHTED \n");}   
+
+  fprintf(fplog,"|- SET MEMBERS: ");
+  for(i=0;i<colvar.natoms[count];i++){fprintf(fplog," %d ",colvar.cvatoms[count][i]+1);if((i+1)%20==0)fprintf(fplog,"\n               ");}fprintf(fplog,"\n\n");
+
+  return colvar.natoms[count];
+}
+
+void PREFIX rank3_to_ql77(double in[3][3], double evector[3][3], double evalue[3]){
+ int i,j;
+ double ll[9];
+ double *evalue2;  
+ evalue2=(double *)malloc(3*sizeof(double));
+
+ for(i=0;i<3;i++) for(j=0;j<3;j++) ll[3*i+j]=in[i][j];
+
+// call diagonalization
+ ql77(3,ll,evalue2);
+
+//back to square representation: columns have eigenvectors
+ for(j=0;j<3;j++){
+    evalue[j]= evalue2[j];
+    for(i=0;i<3;i++) evector[i][j]= ll[3*j+i]; 
+ }
+ free(evalue2); 
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_spath.c dl_class_1.9/srcmod/Plumed/restraint_spath.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_spath.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_spath.c	2015-11-07 17:37:19.395604418 +0100
@@ -0,0 +1,5858 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+
+#include "metadyn.h"
+
+void  PREFIX spath_restraint(int i_c, struct mtd_data_s *mtd_data) {
+
+        int iat,i,ii,j;
+        real s,ci_vec,tmp1;
+        struct coordinates_frameset *pmy_coord1;
+        struct hybrid_frameset *hbd_pmy;
+        struct sz_data *pmy_sz;
+        struct cmap_inpack inpack;
+        struct cmap_outpack work;
+	real ds_temp_dr0[MAXFRAMES_PATH][3][MAXATOMS_PATH];
+	real ds_dcm[MAXFRAMES_PATH][MAXDIM_CMAP]; 
+	real ds_dr0[3][MAXATOMS_PATH]; 
+        int start_avg = 0; 
+        real ds_dr1[MAXFRAMES_PATH][3][MAXATOMS_PATH];
+        real dmsd_dr1[3][MAXATOMS_PATH];
+        int  tot_con;
+        real *save_err; 
+        int nneigh;
+
+        pmy_sz=&my_sz_list[ic_to_sz[i_c]];
+
+        // bernd alternative indexing:
+        // a separate implementation is preferred so to avoid strange quirks
+        if(pmy_sz->indexing_type==1){
+           // call bernd's routine: pass the pointer to the structure  
+           sbernd_restraint(i_c,mtd_data);
+           return ;  
+        }
+ 
+
+// neigh list ?
+        if((pmy_sz->neigh==1 && colvar.it%pmy_sz->neigh_time==0) || firstTime) {
+            //fprintf(mtd_data->fplog,"|- CALCULATING NEIGHBOUR LIST AT STEP %d\n",colvar.it);
+            for(i=0;i< pmy_sz->number;i++)pmy_sz->lneigh[i]=i;
+               nneigh=pmy_sz->number;
+               save_err=(real *)malloc(pmy_sz->number*sizeof(real));
+        }else {
+            nneigh=pmy_sz->nneigh;
+        }
+
+// delete vectors
+        for (i=0;i<3;i++){
+                for (j=0;j<colvar.natoms[i_c];j++) {
+                        ds_dr0[i][j]=0.;
+                }
+        }
+        ci_vec=0.;
+        s=0.;
+
+
+        if(pmy_sz->umb_on && (colvar.it-pmy_sz->umblagsteps>=0)) start_avg = 1;
+                                                               
+        if(strcmp(pmy_sz->path_type,"HYBRID") != 0){
+               for (i=0;i<colvar.natoms[i_c];i++){
+                     iat = colvar.cvatoms[i_c][i];
+                     inpack.r0[i][0] = mtd_data->pos[iat][0];
+                     inpack.r0[i][1] = mtd_data->pos[iat][1];
+                     inpack.r0[i][2] = mtd_data->pos[iat][2];
+              }
+        }
+        if(strcmp(pmy_sz->path_type,"CMAP") == 0){ 
+         tot_con=pmy_sz->my_cmap_pack.number+pmy_sz->my_cmap_pack.gnumber;
+         cmap_running(i_c, &inpack,&pmy_sz->my_cmap_pack);
+        }
+        
+        if(strcmp(pmy_sz->path_type,"HYBRID") == 0){ 
+            //retrive values of cv and derivatives (one set)
+            // assuming they are all the same for all the framesets (generally it is) 
+            // in case of distance where the comp weight is on the cv evaluation and not on the 
+            // distance acquire the points in CV space 
+            // eg: dist between two atoms-> collect the cvval (which is the coordinate) and the  
+            // eg: rmsd between two struct-> collect the actual coordinates (which is the coordinate) 
+            // note: if D is the distance function from the reference  
+            // d D(r_0,r)/dx= dD(r_0,r)/dr dr/dx 
+            //   
+            // in case of rmsd there is no need for chain rule as the derivative is directly calculated with quaternion
+            // d D(r_0,r)/dx via quaternion   (it's like dr/dx=1)
+            //
+            //
+			
+            hbd_collect_config(pmy_sz->hbd_running);  // this collect cv values and needed derivatives
+
+			hbd_collect_jacobian(pmy_sz->hbd_running,pmy_sz->mathybrid,pmy_sz->myinverse,mtd_data->fplog,1);
+
+			//calculates the projector
+			
+			//calc_projector_test  ( pmy_sz );
+			
+			// simple case of debugging of the metrics (need its own module)
+
+			if(pmy_sz->debug_metrics)test_hbd_metrics_new(pmy_sz->hbd_running,pmy_sz->hbd_frameset[0],&work,pmy_sz->mathybrid,mtd_data->fplog);
+
+			
+        }
+        for(ii=0;ii< nneigh;ii++){
+                i=pmy_sz->lneigh[ii];
+       
+                if(strcmp(pmy_sz->path_type,"CMAP") == 0){
+                 cmdist_eval(i_c, i,&inpack,&work,&pmy_sz->my_cmap_pack,start_avg); 
+                } 
+                if(strcmp(pmy_sz->path_type,"MSD") == 0){
+                   pmy_coord1=pmy_sz->frameset[i];
+                   msd_calculation(pmy_coord1,&inpack,&work,dmsd_dr1,pmy_sz->umb_on,pmy_sz->norot_on,pmy_sz->nocenter_on);
+                }
+                if(strcmp(pmy_sz->path_type,"DMSD") == 0){
+                 pmy_coord1=pmy_sz->frameset[i];
+                 dmsd_calculation(i_c,pmy_coord1,&inpack,&work,dmsd_dr1);
+                }
+                if(strcmp(pmy_sz->path_type,"HYBRID") == 0){
+                    hbd_pmy=pmy_sz->hbd_frameset[i];
+                    // calculate the distance between the two frames
+					//legacy code:
+                    //hbd_metrics(&pmy_sz->hbd_running,hbd_pmy,&work,pmy_sz->mathybrid);
+					//fprintf(mtd_data->fplog,"FRAME I= %3d\n",i);
+					//if(nneigh>5)check_hbd_vecmvec_ref(pmy_sz->hbd_running,pmy_sz->hbd_frameset[0],pmy_sz->hbd_frameset[1],pmy_sz->hbd_frameset[2],pmy_sz->hbd_frameset[3],pmy_sz->hbd_frameset[4],pmy_sz->mathybrid,mtd_data->fplog);
+				    hbd_metrics_new(pmy_sz->hbd_running,pmy_sz->hbd_frameset[i],&work,pmy_sz->mathybrid,mtd_data->fplog);
+					//EXIT();
+                }
+ 
+                //fprintf(mtd_data->fplog,"ERR %d %f \n",i,outpack.err);
+               // fflush(mtd_data->fplog);
+               if((pmy_sz->neigh==1 && colvar.it%pmy_sz->neigh_time==0) || firstTime ) save_err[i]=work.err;
+
+             // sqrt option
+                if(pmy_sz->sqrt_on){
+                  // if(work.err<1.e-6){
+                  //  char buf[1024];
+                  //  sprintf(buf,"PATH. Too small error: %f",work.err);
+                  //  plumed_error(buf);
+                  // }
+		   if(pmy_sz->targeted_on){
+                       pmy_sz->lambda=1./sqrt(work.err);
+                       if(work.err<1.e-15) pmy_sz->lambda=1.e-15;
+                   }
+                   if(work.err<1.e-15){
+                        tmp1=0.;
+                   }else{
+                        tmp1=(0.5/sqrt(work.err))*exp(-pmy_sz->lambda*sqrt(work.err));
+                   }
+                   ci_vec+=exp(-pmy_sz->lambda*sqrt(work.err));
+                   s+=(i+1.0)*exp(-pmy_sz->lambda*sqrt(work.err));
+                }else{
+                   //if(pmy_sz->lambda*outpack.err>1.e2)outpack.err=1.e2/pmy_sz->lambda; 
+                   tmp1=exp(-pmy_sz->lambda*work.err);
+                   ci_vec+=tmp1;
+                   s+=(i+1.0)*tmp1;
+                }
+ 
+				for(j=0;j<colvar.natoms[i_c];j++){
+					ds_temp_dr0[i][0][j]=(work.derr_dr0[0][j])*tmp1;
+					ds_temp_dr0[i][1][j]=(work.derr_dr0[1][j])*tmp1;
+					ds_temp_dr0[i][2][j]=(work.derr_dr0[2][j])*tmp1;
+					if((strcmp(pmy_sz->path_type,"MSD") == 0 || strcmp(pmy_sz->path_type,"DMSD") == 0) && start_avg){
+						ds_dr1[i][0][j]=(dmsd_dr1[0][j])*tmp1*pmy_sz->lambda;
+						ds_dr1[i][1][j]=(dmsd_dr1[1][j])*tmp1*pmy_sz->lambda;
+						ds_dr1[i][2][j]=(dmsd_dr1[2][j])*tmp1*pmy_sz->lambda;
+					}
+				}
+			
+                if(strcmp(pmy_sz->path_type,"CMAP") == 0 && start_avg){
+                 for(j=0;j<tot_con;j++){
+                         ds_dcm[i][j]=(work.derr_dcm[j])*tmp1*pmy_sz->lambda;
+                        } 
+                }
+	}
+
+        s=s/ci_vec;
+
+	for(j=0;j<colvar.natoms[i_c];j++){
+               for(ii=0;ii<nneigh;ii++){
+                       i=pmy_sz->lneigh[ii];
+        	       ds_dr0[0][j]+=(s-i-1.)*ds_temp_dr0[i][0][j]; 
+        	       ds_dr0[1][j]+=(s-i-1.)*ds_temp_dr0[i][1][j]; 
+        	       ds_dr0[2][j]+=(s-i-1.)*ds_temp_dr0[i][2][j]; 
+                       if((strcmp(pmy_sz->path_type,"MSD") == 0 || strcmp(pmy_sz->path_type,"DMSD") == 0) && start_avg){ 
+                        ds_dr1[i][0][j]=ds_dr1[i][0][j]*(s-i-1.)/ci_vec;
+                        ds_dr1[i][1][j]=ds_dr1[i][1][j]*(s-i-1.)/ci_vec;
+                        ds_dr1[i][2][j]=ds_dr1[i][2][j]*(s-i-1.)/ci_vec;
+
+                       }
+       	    	}
+                ds_dr0[0][j]=((pmy_sz->lambda)/ci_vec)*ds_dr0[0][j]; 
+       	    	ds_dr0[1][j]=((pmy_sz->lambda)/ci_vec)*ds_dr0[1][j]; 
+       	     	ds_dr0[2][j]=((pmy_sz->lambda)/ci_vec)*ds_dr0[2][j]; 
+	}
+
+        if(strcmp(pmy_sz->path_type,"CMAP") == 0 && start_avg){
+           for(i=0;i<pmy_sz->number;i++){           
+               for(j=0;j<tot_con;j++){
+          	        ds_dcm[i][j]=ds_dcm[i][j]*(s-i-1.)/ci_vec;
+		       }
+           }
+        }
+
+        for(i=0;i<colvar.natoms[i_c];i++) {
+          colvar.myder[i_c][i][0] = ds_dr0[0][i];
+          colvar.myder[i_c][i][1] = ds_dr0[1][i];
+          colvar.myder[i_c][i][2] = ds_dr0[2][i];
+			//fprintf(mtd_data->fplog,"V %12.6f %12.6f %12.6f\n",colvar.myder[i_c][i][0],colvar.myder[i_c][i][1],colvar.myder[i_c][i][2]); 
+
+        }
+
+        colvar.ss0[i_c]=s;
+
+#ifdef PATHREF_FINDIFF
+          for(j=0;j<colvar.natoms[i_c];j++){
+                 for(ii=0;ii<pmy_sz->number;ii++){
+                      pmy_sz->dpath_dr[0][j][ii]=0.; 
+                      pmy_sz->dpath_dr[1][j][ii]=0.; 
+                      pmy_sz->dpath_dr[2][j][ii]=0.; 
+                 }
+                 for(ii=0;ii<nneigh;ii++){
+                      i=pmy_sz->lneigh[ii];
+                      pmy_sz->dpath_dr[0][j][i]=ds_dr1[i][0][j]; 
+                      pmy_sz->dpath_dr[1][j][i]=ds_dr1[i][1][j]; 
+                      pmy_sz->dpath_dr[2][j][i]=ds_dr1[i][2][j]; 
+  
+                 } 
+          } 
+#endif  
+
+
+// neigh list? do quicksort and deallocate save_err
+        if((pmy_sz->neigh==1 && colvar.it%pmy_sz->neigh_time==0) || firstTime){
+             //   for(i=0;i<nneigh;i++)printf("BEFORE SORTING %d %f\n",pmy_sz->lneigh[i],save_err[i]);
+                realquicksort(save_err,pmy_sz->lneigh,0,nneigh-1);
+             //   for(i=0;i<nneigh;i++)printf("AFTER SORTING %d %f\n",pmy_sz->lneigh[i],save_err[i]);
+                free(save_err);
+        }
+
+
+
+        if(pmy_sz->umb_on==1){
+          if(strcmp(pmy_sz->path_type,"CMAP") == 0) mean_map(pmy_sz,ds_dcm,i_c,mtd_data->fplog); 
+          if(strcmp(pmy_sz->path_type,"MSD") == 0 || strcmp(pmy_sz->path_type,"DMSD") == 0) mean_rmsd(pmy_sz,ds_dr1,i_c,mtd_data->fplog); 
+        }
+        
+        return;
+}
+
+// ------------------------------------------------------------------------------------------------
+
+int PREFIX read_path(char **word, int count,t_plumed_input *input,FILE *fplog)
+{
+
+  int i,iw;
+  double lambda, tol;
+  double sigma = 0.0;
+  char file_maps[129];
+  char file_maps2[129];
+  char file_group[129];
+  char type[2];
+  struct sz_data *my_sz;
+  int path_help;
+  int neigh;
+
+  path_help=0; 
+  neigh=0;
+
+  my_sz=&(my_sz_list[nsz]);
+  ic_to_sz[count]=nsz;
+
+  my_sz->number = 0;
+  my_sz->lambda = 0.;                
+  my_sz->my_cmap_pack.logical_group = 0;
+  my_sz->umb_on = 0;
+  my_sz->grad_on = 0;
+  my_sz->targeted_on = 0;
+  my_sz->sqrt_on = 0;
+  my_sz->norot_on = 0;
+  my_sz->nocenter_on = 0;
+  // indexing type 0: From Branduardi
+  // indexing type 1: From Ensing
+  my_sz->indexing_type = 0;
+  my_sz->ievol = -1;
+  my_sz->reset = 0;
+  my_sz->fadefactor = 1.0;
+  my_sz->debug_metrics = 0;
+  my_sz->intraframe_dist=0;
+  my_sz->intraframe_diff=0;
+
+ 
+// targeted md ?
+  iw=seek_word(word,"TARGETED");
+  if(iw>=0) {
+      fprintf(fplog,"|- TARGETED MD: only one frame needed \n"); 
+      my_sz->targeted_on=1;
+     // my_sz->sqrt_on=1; // targeted is always square rooted
+  }
+// specific sqrt keyword
+  iw=seek_word(word,"SQRT");
+  if(iw>=0) {
+      fprintf(fplog,"|- SQRT enabled: the measure will be square rooted \n"); 
+      my_sz->sqrt_on=1;
+  }
+// type
+  iw=seek_word(word,"TYPE");
+  if(iw>=0) {
+      sscanf(word[iw+1],"%s",my_sz->path_type);
+  } else {
+      fprintf(fplog,"|- NEEDED \"TYPE\" KEWORD FOR PATH\n"); 
+      path_help=1; 
+  }
+// common stuff
+  // if targeted you dont need many frames 
+  if(my_sz->targeted_on==0){
+    
+     iw=seek_word(word,"NFRAMES");
+     if(iw>=0){
+         sscanf(word[iw+1],"%i", &my_sz->number); 
+     } else {
+         fprintf(fplog,"|- NEEDED \"NFRAMES\" KEYWORD FOR PATH\n"); 
+         path_help=1; 
+     }
+  } else { 
+     my_sz->number=1;
+  }
+  iw=seek_word(word,"ENSING");
+  if(iw>=0){
+          my_sz->indexing_type=1;
+  } 
+  iw=seek_word(word,"I_EVOL");
+  if(iw>=0){
+          sscanf(word[iw+1],"%i", &my_sz->ievol); 
+  } 
+  iw=seek_word(word,"RESET");
+  if(iw>=0){
+          my_sz->reset=1; 
+  } 
+  iw=seek_word(word,"FADEFACTOR");
+  if(iw>=0){
+      //sscanf(word[iw+1],"%f", &my_sz->fadefactor);   
+      my_sz->fadefactor=atof(word[iw+1]);
+  }
+  iw=seek_word(word,"DEBUGMETRICS");
+  if(iw>=0){
+		my_sz->debug_metrics=1;
+  }
+
+  // Bernd ensing path required to use a reset in the weights
+  if(my_sz->reset==1 && my_sz->indexing_type!=1 ) plumed_error("ENSING KEYWORD NEEDED TO RESET WEIGHTS");
+  // Bernd ensing path required to use a fadefactor
+  if(my_sz->fadefactor!=1.0 && my_sz->indexing_type!=1 ) plumed_error("ENSING KEYWORD NEEDED TO USE FADEFACTOR");
+
+  // if targeted  lambda can be simply 1.0 
+  if(my_sz->targeted_on==0){
+     iw=seek_word(word,"LAMBDA");
+     if(iw>=0){ 
+         sscanf(word[iw+1],"%lf", &lambda);
+#ifdef STANDALONE
+         lambda/=(mtd_data.ampli)*(mtd_data.ampli);
+#endif
+     } else {
+         if( my_sz->indexing_type==0){
+           fprintf(fplog,"|- NEEDED \"LAMBDA\" KEYWORD FOR PATH\n"); 
+           path_help=1; 
+         }
+     }
+  } else { 
+     lambda=1.0;
+  }
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &sigma);
+             colvar.delta_r[count]  = (real) sigma; }
+// rmsd parameters
+  iw=seek_word(word,"FRAMESET");
+  if(iw>=0) sscanf(word[iw+1],"%s", my_sz->names); 
+// cmap parameters
+  iw = seek_word(word,"INDEX");
+  if(iw>=0) sscanf(word[iw+1],"%s", file_maps);
+  iw = seek_word(word,"MAP");
+  if(iw>=0) sscanf(word[iw+1],"%s", file_maps2);
+  iw=seek_word(word,"GROUP");
+  if(iw>=0) {
+   sscanf(word[iw+1],"%s",file_group);
+   my_sz->my_cmap_pack.logical_group = 1;
+   }
+// UMBRELLA stuff
+  iw=seek_word(word,"UMB_LAG");
+  if(iw>=0) {
+    sscanf(word[iw+1],"%d",&(my_sz->umblagsteps));
+    my_sz->umb_on=1; 
+    my_sz->countperm=0;
+  }
+  iw=seek_word(word,"UMB_BLOCK");
+  if(iw>=0) sscanf(word[iw+1],"%d",&(my_sz->umbblocksize)); 
+  iw=seek_word(word,"UMB_STRIDE");
+  if(iw>=0) sscanf(word[iw+1],"%d",&(my_sz->umbstride));
+  iw=seek_word(word,"UMB_PERM");
+  if(iw>=0) sscanf(word[iw+1],"%d",&(my_sz->umbpermanency));
+  iw=seek_word(word,"UMB_TOL");
+  if(iw>=0) sscanf(word[iw+1],"%lf",&tol);
+  iw=seek_word(word,"NO_ROT");
+  if(iw>=0) my_sz->norot_on=1;
+  iw=seek_word(word,"NO_CENTER");
+  if(iw>=0) my_sz->nocenter_on=1;
+
+
+
+#ifdef PATHREF_FINDIFF
+    my_sz->umblagsteps=0;
+    my_sz->umbblocksize=10;
+    my_sz->umb_on=1;
+    my_sz->countperm=0;
+    my_sz->umbstride=1;
+    my_sz->umbpermanency=1000000;
+    tol=0.001;
+#endif
+// NEIGHBOUR LIST STUFF
+  my_sz->neigh=0;
+  my_sz->lneigh=(int *)malloc( MAXFRAMES_PATH * sizeof(int)); 
+  iw=seek_word(word,"NEIGHLIST");  
+  if(iw>=0) {
+       sscanf(word[iw+1],"%d",&(my_sz->neigh_time)); // time for list 
+       sscanf(word[iw+2],"%d",&(my_sz->nneigh));     // number of neighbours 
+       if(my_sz->nneigh>=my_sz->number){
+              my_sz->nneigh=my_sz->number;
+              my_sz->neigh=0;
+              for(i=0;i<my_sz->nneigh;i++)my_sz->lneigh[i]=i;
+              neigh=1;
+       }else {   
+              my_sz->neigh=1;
+              for(i=0;i<my_sz->nneigh;i++)my_sz->lneigh[i]=i;
+              neigh=2;
+       } 
+ 
+  } else {
+       my_sz->neigh=0;
+       my_sz->nneigh=my_sz->number;
+       for(i=0;i<my_sz->nneigh;i++)my_sz->lneigh[i]=i; 
+  } 
+
+
+  my_sz->lambda  = (real) lambda; 
+  my_sz->umbtolerance = (real) tol;
+
+  if(colvar.type_s[count]==30) strcpy(type,"S");
+  if(colvar.type_s[count]==31) strcpy(type,"Z");
+
+  if(path_help){
+         fprintf(fplog,"|- PATH/TARGETED SYNTAX:\n");
+         fprintf(fplog,"|- TYPE               : can be MSD/CMAP/DMSD\n");
+         fprintf(fplog,"|- NFRAMES            : the number of reference structures\n");
+         fprintf(fplog,"|- LAMBDA             : the common prefactor in the exponential equation for the path\n");
+         fprintf(fplog,"|- SIGMA              : hills width for this cv\n");
+         fprintf(fplog,"|- NEIGHLIST (opt.)   : neighlist on the closest frames    NEIGHLIST (ntimesteps) (nframes) \n");
+         fprintf(fplog,"|- ENSING   (opt.)    : Bernd Ensing's path \n");
+         fprintf(fplog,"|- I_EVOL   (opt.)    : update Bernd Ensing's path each ievol timesteps (only if ENSING is defined )\n");
+         fprintf(fplog,"|- RESET    (opt.)    : reset weights to zero every Bernd Ensing's path evolution \n");
+         fprintf(fplog,"|-                      (only if ENSING is defined )\n");
+         fprintf(fplog,"|- FADEFACTOR (opt.)  : fadefactor for weights in Bernd Ensing's path (only if ENSING is defined) \n");
+         fprintf(fplog,"|-                      Should be 0<=fadefactor<=1. Default=1.    \n");
+         fprintf(fplog,"|- .....many other keywords are specific to MSD/CMAP/DMSD paths... \n");
+         fprintf(fplog,"|- (MSD)   FRAMESET :base for frameset name pippo_ will look for pippo_1.pdb pippo_2.pdb etc...  \n");
+         fprintf(fplog,"|-     \n");
+         fprintf(fplog,"|- e.g.\n");
+         fprintf(fplog,"|- \n");
+         fprintf(fplog,"|- Z_PATH   TYPE MSD FRAMESET frame_ NFRAMES 1 LAMBDA 1.0 SIGMA 1.0 NEIGHLIST 10 5 \n");
+         fprintf(fplog,"|- \n");
+         fprintf(fplog,"|- S_PATH   TYPE MSD FRAMESET frame_ NFRAMES 1 LAMBDA 1.0 SIGMA 1.0 NEIGHLIST 10 5 \n");
+         fprintf(fplog,"|- \n");
+         fprintf(fplog,"|- TARGETED TYPE MSD FRAMESET frame.pdb SIGMA 1.0 \n");
+         fprintf(fplog,"|- \n");
+         fprintf(fplog,"|- S_PATH   TYPE MSD FRAMESET frame_ NFRAMES 10 ENSING  RESET FADEFACTOR 0.9 I_EVOL 10000 \n");
+         fprintf(fplog,"|- \n");
+ 
+         plumed_error("PluMeD dead with errors: check log file");
+  } 
+  if(strcmp(my_sz->path_type,"CMAP") != 0 && strcmp(my_sz->path_type,"MSD") != 0
+     && strcmp(my_sz->path_type,"DMSD") !=0 && strcmp(my_sz->path_type,"HYBRID") !=0 ){
+          char buf[1024];
+          sprintf(buf,"%s Unknown type of path!!",my_sz->path_type);
+          plumed_error(buf);
+  }
+  fprintf(fplog,"\n%1i-%s_PATH in %s space \n",count+1,type,my_sz->path_type);
+  fprintf(fplog,"|--NFRAMES %i ",my_sz->number);
+  if(my_sz->indexing_type==0)fprintf(fplog,"|--LAMBDA %f ",my_sz->lambda);
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+  if(strcmp(my_sz->path_type,"CMAP") == 0){
+   fprintf(fplog,"|--READING CONTACT MAPS INDEX FROM FILE %s AND VALUES FROM %s\n",file_maps,file_maps2); 
+   if(my_sz->my_cmap_pack.logical_group) fprintf(fplog,"|--AND GROUP FROM FILE %s \n",file_group);
+  }
+  if(strcmp(my_sz->path_type,"MSD") == 0 || strcmp(my_sz->path_type,"DMSD") == 0  || strcmp(my_sz->path_type,"HYBRID") == 0 ){
+   fprintf(fplog,"|--BASENAME FOR FRAMES %s \n",my_sz->names);
+  }
+	if(my_sz->debug_metrics)fprintf(fplog,"|- DEBUGGING THE METRICS \n");
+
+  if(neigh==0) fprintf(fplog,"|--NEIGHBOUR LIST OFF \n");  
+  if(neigh==1) fprintf(fplog,"|--NO NEED FOR NEIGHBOUR LIST: THE LIST APPEARS TOO LARGE \n");  
+  if(neigh==2) {fprintf(fplog,"|--NEIGHBOUR LIST ON : TIME FOR LIST: %d TSTEPS \n", my_sz->neigh_time);
+                fprintf(fplog,"|--                  : LIST LENGTH  : %d FRAMES \n", my_sz->nneigh); } 
+
+  
+  if(my_sz->number>MAXFRAMES_PATH)
+                plumed_error("Maximum number of frames in path CV exceeded. Increase MAXFRAMES_PATH and recompile");
+
+   if(my_sz->number==0)   plumed_error("NUMBER KEYWORD NEEDED FOR PATH");  
+   
+   // lambda needed only for traditional indexing style
+   if(my_sz->lambda==0. && my_sz->indexing_type==0 ) plumed_error("LAMBDA KEYWORD NEEDED FOR PATH");
+  
+
+   if(my_sz->umb_on){
+    fprintf(fplog,"|--MEAN EVALUATION ON %s IS ACTIVE\n",type);
+    fprintf(fplog,"|---LAGSTEPS %d - BLOCKSTEPS %d  - STRIDESTEPS %d  \n",my_sz->umblagsteps,my_sz->umbblocksize,my_sz->umbstride);
+    fprintf(fplog,"|---PERMSTEPS %d - TOLERANCESTEPS %lf \n",my_sz->umbpermanency,my_sz->umbtolerance);
+   }
+   if(my_sz->norot_on){
+    fprintf(fplog,"|--NO ROTATION OF REFERENCE/RUNNING FRAME\n");
+    if(strcmp(my_sz->path_type,"MSD") != 0) plumed_error("NO_ROT CAN BE USED ONLY WITH TYPE MSD");
+   }
+   if(my_sz->nocenter_on){
+    fprintf(fplog,"|--NO COM CENTERING OF REFERENCE/RUNNING FRAME\n");
+    if(strcmp(my_sz->path_type,"MSD") != 0) plumed_error("NO_CENTER CAN BE USED ONLY WITH TYPE MSD");
+    if(!my_sz->norot_on) plumed_error("NO_CENTER CAN BE USED ONLY IF NO_ROT IS ACTIVE");
+   }
+   switch (my_sz->indexing_type) {
+      case 0:
+        fprintf(fplog,"|--TRADITIONAL INDEXING STYLE FOR PATHWAY  IS ON\n");
+        break; 
+      case 1:
+        fprintf(fplog,"|--BERND ENSING PATHWAY INDEXING STYLE IS ON\n");
+        if(my_sz->ievol>0){ 
+           fprintf(fplog,"|--EVOLVE PATHWAY EACH %d TIMESTEPS\n",my_sz->ievol);
+        }else{
+           fprintf(fplog,"|--NEVER EVOLVE PATHWAY \n");
+        }
+        if(my_sz->fadefactor>=0.0 && my_sz->fadefactor<=1.0 ){ 
+           fprintf(fplog,"|--FADEFACTOR IS %f\n",my_sz->fadefactor);
+        }else{
+           plumed_error("|--FADEFACTOR VALUE NOT VALID \n");
+	}
+        switch (my_sz->reset){
+           case 1:
+             fprintf(fplog,"|--RESETING THE WEIGHTS EVERY BERND'S PATH EVOLUTION\n");
+             break; 
+           case 0:
+             fprintf(fplog,"|--NOT RESETING WEIGHTS DURING BERND PATH'S EVOLUTION\n");
+             break; 
+        } 
+        break; 
+      default:
+        plumed_error("|--UNKNOWN INDEXING STYLE\n");
+        break;
+ 
+   } 
+
+
+
+// case of CMAP path
+
+ if(strcmp(my_sz->path_type,"CMAP") == 0){
+   colvar.cell_pbc[count]=1; // default is PBC
+   iw=seek_word(word,"NOPBC");
+   if(iw>=0) {colvar.cell_pbc[count] = 0;}
+   iw=seek_word(word,"PBC");
+   if(iw>=0) {colvar.cell_pbc[count] = 1;}
+
+   if(colvar.cell_pbc[count]) fprintf(fplog,"|--DISTANCES WITH PBC \n");
+   else fprintf(fplog,"|--DISTANCES WITHOUT PBC \n");
+
+   read_sz_map(my_sz,file_maps,file_maps2,file_group,1,fplog);
+
+   colvar.natoms[count]   = my_sz->my_cmap_pack.atoms; 
+
+   snew(colvar.myder[count], colvar.natoms[count]);
+   snew(colvar.cvatoms[count], colvar.natoms[count]);
+
+   for(i=0;i<colvar.natoms[count];i++){
+     colvar.cvatoms[count][i] = my_sz->my_cmap_pack.list[i];
+   }
+ 
+   if(my_sz->umb_on){
+     my_sz->umb_map_block=float_3d_array_alloc(my_sz->my_cmap_pack.number+my_sz->my_cmap_pack.gnumber,my_sz->number,my_sz->umbblocksize);
+     my_sz->umb_map_avg=float_2d_array_alloc(my_sz->my_cmap_pack.number+my_sz->my_cmap_pack.gnumber,my_sz->number);
+     fprintf(fplog,"|---ALLOCATED for UMBRELLA STUFF %lf Kbytes \n",sizeof(real)*((real) ((my_sz->my_cmap_pack.number+
+                  my_sz->my_cmap_pack.gnumber)*my_sz->number*my_sz->umbblocksize)/1000));
+   }
+ }
+
+// RMSD/DRMS case 
+
+ if(strcmp(my_sz->path_type,"MSD") == 0 || strcmp(my_sz->path_type,"DMSD") == 0 ){
+
+   read_sz_rmsd(my_sz,fplog);
+
+   colvar.natoms[count]   = (my_sz->frameset[0])->natoms; 
+
+   snew(colvar.myder[count], colvar.natoms[count]);
+   snew(colvar.cvatoms[count], colvar.natoms[count]);
+
+   for(i=0;i<colvar.natoms[count];i++){
+     colvar.cvatoms[count][i] = ((my_sz->frameset[0])->atmnum[i])-1; 
+   }
+
+   if(my_sz->umb_on){
+     my_sz->umb_block=float_4d_array_alloc(3,(*my_sz->frameset[0]).natoms,my_sz->number,my_sz->umbblocksize);
+     my_sz->umb_avg=float_3d_array_alloc(3,(*my_sz->frameset[0]).natoms,my_sz->number);
+#ifdef PATHREF_FINDIFF 
+     fprintf(fplog,"|---ALLOCATING TEST ARRAYS \n");
+     my_sz->dpath_dr=float_3d_array_alloc(3,(*my_sz->frameset[0]).natoms,my_sz->number);
+     fprintf(fplog,"|---ALLOCATION DONE \n");
+#endif
+     fprintf(fplog,"|---ALLOCATED for UMBRELLA STUFF %lf Kbytes",sizeof(real)*((real) 3*((*my_sz->frameset[0]).natoms)*(my_sz->number)*(my_sz->umbblocksize)/1000));
+   }
+ }
+// HYBRID STRUCTURE: uses the definition of previous cvs
+ if(strcmp(my_sz->path_type,"HYBRID") == 0 ){
+    // read which cvs you want to hybridize  
+     iw=seek_word(word,"HYBRID");
+     if(iw>=0) {
+        int c,ii,*t1l,t1s=0, *t2l,t2s,jj;
+        ii=0;
+        while (1) { 
+             //      word[iw+1] is a word ???   
+             ii++;
+             c=*word[iw+ii];
+             if (isalpha(c)!=0 ){
+                 //printf("This is a word %s\n",word[iw+ii]); 
+                 break; 
+             } else {
+       //          printf("This is a number %s\n",word[iw+ii]); 
+                 if(t1s==0){ t1l=(int *)malloc(sizeof(int));
+                             sscanf(word[iw+ii],"%d", &t1l[0]);
+                 } else{ 
+                        t2s=t1s;t2l=(int *)malloc(t2s*sizeof(int));
+                        for(jj=0;jj<t1s;jj++){
+                              t2l[jj]=t1l[jj];
+                       }
+                       free(t1l);
+                       t1l=(int *)malloc((t1s+1)*sizeof(int)); 
+                       for(jj=0;jj<t1s;jj++){
+                              t1l[jj]=t2l[jj];
+                       }
+                       free(t2l);
+                       sscanf(word[iw+ii],"%d", &t1l[t1s]);
+                 } 
+                 t1s++;
+                 //for(jj=0;jj<t1s;jj++){printf("LL %d ",t1l[jj]);}; printf(" NN %d\n",t1s) ; 
+             } 
+        } 
+		 
+		//
+        // allocate and copy a specific structure
+        //
+		my_sz->nhybrid=t1s; // number of hybrid functions
+        my_sz->lhybrid=(int *)malloc(my_sz->nhybrid*sizeof(int));		// list of the ordinal of hybrid function to be called
+        my_sz->lcvhybrid=(int *)malloc(my_sz->nhybrid*sizeof(int));		// list of the ordinal of the cv to be used
+        for(ii=0;ii<my_sz->nhybrid;ii++){my_sz->lhybrid[ii]=t1l[ii];}   // list of the type of cv 
+		 
+        fprintf(fplog,"|--NUMBER OF HYBRID CVS= %d WHICH ARE ",my_sz->nhybrid);
+        for(jj=0;jj<my_sz->nhybrid;jj++){
+              fprintf(fplog,"CV %d ",my_sz->lhybrid[jj]);my_sz->lhybrid[jj]--;
+              if(my_sz->lhybrid[jj]>=count) plumed_error("|--WRONG INPUT: PUT THE HYBRID CV AFTER THE ONES YOU USE TO MAKE THE HYBRID\n");
+        };printf("\n"); 
+		//
+        // set the type of the representation for each cv  
+		//
+        for(jj=0;jj<my_sz->nhybrid;jj++){
+            int kk=my_sz->lhybrid[jj];
+            fprintf(fplog,"|- CVTYPE %d\n",colvar.type_s[kk]);my_sz->lcvhybrid[jj]=colvar.type_s[kk];
+            // parse the input and check if it is implemented  
+		}; 
+		 
+		//
+        // matrix of metrics: some variable count one, some others count more
+		// (dummy MSD is one cv per coordinate, just the difference and its derivative are interwined)
+		//
+		 
+     	colvar.natoms[count]=read_sz_hybrid(my_sz,fplog); 
+		 
+        snew(colvar.myder[count], colvar.natoms[count]);
+        snew(colvar.cvatoms[count], colvar.natoms[count]);
+
+        // assuming they are all the same for all the framesets (generally it is) 
+        for(i=0;i<colvar.natoms[count];i++){
+          colvar.cvatoms[count][i] = my_sz->hbd_frameset[0]->backtable[i]  ;
+			fprintf(fplog,"|- read_sz_hybrid: ATOM %d IS INVOLVED \n", my_sz->hbd_frameset[0]->backtable[i]);
+        }
+		 my_sz->mathybrid_blocks=NULL;
+     } else {
+		fprintf(fplog,"SOMETHING WENT WRONG \n");
+     }  
+	 // these are useful only when using an external script to retrieve various information
+	 iw=seek_word(word,"INTRAFRAME_DIST");
+     if(iw>=0) {
+		 if(strcmp(my_sz->path_type,"HYBRID") != 0 ){
+			 fprintf(fplog,"|- read_sz_path: INTRAFRAME_DIST is only for hybrid path \n");
+		 }
+		 // requires a set of matrices that should be equal to the number of frames
+		 my_sz->intraframe_dist=1;
+		 sscanf(word[iw+1],"%s",my_sz->intraframe_dist_inputfile); // the inputfile
+		 sscanf(word[iw+2],"%s",my_sz->intraframe_dist_outputfile); // the outputfile
+
+		 fprintf(fplog,"|- read_sz_path: INTRAFRAME_DIST is on\n");
+		 fprintf(fplog,"|- read_sz_path: and the matrix file taken from external source is: %s\n",my_sz->intraframe_dist_inputfile);
+		 fprintf(fplog,"|- read_sz_path: and the matrix file printed to : %s\n",my_sz->intraframe_dist_outputfile);
+		 fprintf(fplog,"|- read_sz_path: CALLING AND THEN DYING\n");
+		 calc_intraframe_dist( my_sz );
+		 EXIT();
+	 }
+	 iw=seek_word(word,"REPARAM");
+     if(iw>=0) {
+		 if(strcmp(my_sz->path_type,"HYBRID") != 0 ){
+			 fprintf(fplog,"|- read_sz_path: INTRAFRAME_DIST is only for hybrid path \n");
+		 }
+		 // assume only identity matrix as for reparametrization
+		 // allocate jacobian
+		 
+		 // allocate needed structures	
+		 init_bernd_evolution(&my_sz,count);
+		 
+		 // if you have one matrix per point then do it differently
+		 int iw2;
+		 iw2=seek_word(word,"MATRICES");
+		 
+		 if(iw2>=0) {
+			 char filenamematrices[200];
+			 strcpy(filenamematrices,word[iw2+1]);
+			 // call a specific routine that reads in the file, allocate and do the stuff
+			 fprintf(fplog,"|- read_sz_path: REPARAM is on\n");
+			 fprintf(fplog,"|- read_sz_path: each frame uses its own matrix from file %s\n",filenamematrices);
+
+			 reparam_with_multiple_matrix(my_sz,filenamematrices);
+			 
+			 
+			 // this closes the file that was opened by bernd evolution
+			 fclose(my_sz->fp_evol);
+
+		 }else{
+			 // use a simple diagonal matrix instead 	 
+			 int j;
+			 
+			 fprintf(fplog,"|- read_sz_path: FOUND %d CVS\n",my_sz->hbd_running->hbd_totcvs);
+			 for (i=0;i<my_sz->hbd_running->hbd_totcvs;i++){
+				 for (j=0;j<my_sz->hbd_running->hbd_totcvs;j++){
+					 my_sz->mathybrid[i][j]=0.;
+					 if(i==j)my_sz->mathybrid[i][j]=1.;
+				 }
+			 }
+			 
+			 reparam_bernd_path(my_sz);
+			 
+			 fclose(my_sz->fp_evol);
+			 
+		 }
+
+		 
+		 EXIT();
+		 
+	 }
+	 iw=seek_word(word,"INTRAFRAME_DIFF");
+     if(iw>=0) {
+		 my_sz->intraframe_diff=1;
+		 if(strcmp(my_sz->path_type,"HYBRID") != 0 ){
+			 fprintf(fplog,"|- read_sz_path: INTRAFRAME_DIFF is only for hybrid path \n");EXIT();
+		 }
+		 sscanf(word[iw+1],"%s",my_sz->intraframe_diff_outputfile); // the outputfile
+		 fprintf(fplog,"|- read_sz_path: INTRAFRAME_DIFF is on\n");
+		 fprintf(fplog,"|- read_sz_path: and the diff file is printed to : %s\n",my_sz->intraframe_diff_outputfile);
+		 fprintf(fplog,"|- read_sz_path: CALLING AND THEN DYING\n");
+		 calc_intraframe_diff( my_sz );
+		 EXIT();
+	 }
+	 iw=seek_word(word,"TWOFRAMES_DIFF");
+	 if(iw>=0) {
+
+		if(strcmp(my_sz->path_type,"HYBRID") != 0 ){
+			fprintf(fplog,"|- read_sz_path: INTRAFRAME_DIFF is only for hybrid path \n");EXIT();
+		}
+		int first=atoi(word[iw+1]);
+	    int second=atoi(word[iw+2]);
+		int reference=atoi(word[iw+3]);
+		fprintf(fplog,"|- read_sz_path: TWOFRAMES_DIFF chosen\n");
+		fprintf(fplog,"|- read_sz_path: will calculate the diff beteween frame %d and %d takin frame %d as ref\n",first,second,reference);
+		first--;
+		second--;
+		reference--;
+		struct hybrid_frameset *f_first,*f_second,*f_reference,*difference;
+		struct hybrid_elem *diff;
+		clone_hybrid_frameset(&difference,my_sz->hbd_frameset[0],1,mtd_data.fplog);
+		f_first=my_sz->hbd_frameset[first];
+		f_second=my_sz->hbd_frameset[second];
+		f_reference=my_sz->hbd_frameset[reference];
+		calc_diff_twoframes(f_first,f_second,f_reference,difference);
+		int j,k;
+		for(j=0;j< difference->hbd_nelem; j++){
+			 diff=difference->hbd_elem[j];
+			 for(k=0;k<diff->ncv;k++){
+				 fprintf(mtd_data.fplog,"|- TWOFRAMES DIFFERENCE ELEM %d CV %d IS %f\n",j,k,diff->ref_dist[k]);
+			 }
+		}
+
+		//EXIT();
+	 }
+	 iw=seek_word(word,"TWOFRAMES_DIST");
+	 if(iw>=0) {
+		 
+		 if(strcmp(my_sz->path_type,"HYBRID") != 0 ){
+			 fprintf(fplog,"|- read_sz_path: INTRAFRAME_DIST is only for hybrid path \n");EXIT();
+		 }
+		 int first=atoi(word[iw+1]);
+		 int second=atoi(word[iw+2]);
+		 char matrixfile[200];
+		 strcpy(matrixfile,word[iw+3]); //this is the filename for output 
+		 fprintf(fplog,"|- read_sz_path: TWOFRAMES_DIST chosen\n");
+		 fprintf(fplog,"|- read_sz_path: will calculate the dist beteween frame %d and %d \n",first,second);
+		 fprintf(fplog,"|- read_sz_path: input matrix chosen %s\n",matrixfile);
+		 first--;
+		 second--;
+
+		 calc_twoframe_dist(my_sz,first,second,matrixfile,mtd_data.fplog);
+
+		 
+		 //EXIT();
+	 }
+	 
+//     EXIT(); 
+ }
+         nsz++;
+
+         if(nsz>NMAX_PATH) plumed_error("TOO MANY PATH CVS. INCREASE NMAX_PATH and recompile");
+
+         fprintf(fplog,"\n");
+         return colvar.natoms[count];
+}
+
+
+// ------------------------------------------------------------------------------------------------
+
+int PREFIX read_sz_rmsd(struct sz_data *my_sz, FILE *fplog) {
+
+        int l,i,j,k,found;
+        char *str,ic[3],str2[100];
+        l=0;
+/*
+  * allocate the pointers
+ */
+        my_sz->frameset=(struct coordinates_frameset **)malloc((my_sz->number)*sizeof(struct coordinates_frameset *));
+        for(i=0;i< my_sz->number;i++){
+                my_sz->frameset[i]=(struct coordinates_frameset *)malloc(sizeof(struct coordinates_frameset)) ;
+        }
+
+/*
+ *  build names
+ */
+        str=&(my_sz->names[0]);
+        for (i=1;i<= my_sz->number ;i++){
+                strcpy(str2,my_sz->names);
+                if(my_sz->targeted_on==0){
+                     if(i<10){
+                      ic[0]='0'+i;
+                      ic[1]='\0';}
+                     else if(i<100) {
+                      ic[0]='0'+i/10 ;
+                      ic[1]='0'+i%10 ;
+                      ic[2]='\0';
+                     }
+                     else{
+                       plumed_error("|--read_sz_input: TOO MANY FRAMES REQUIRED FOR NAME BUILDING!");
+                     }
+                     strcat(str2,ic);
+                     strcat(str2,".pdb");
+                }
+                fprintf(fplog,"|--%s\n",str2);
+                read_sz_coord(str2,my_sz->frameset[i-1],fplog);
+        }
+
+/*
+ * check over that aligned atoms are the same ( this is requirement for rmsd routine
+ * so you don't have to reallocate everything everytime )
+ */
+       for (i=0;i< my_sz->number-1;i++){
+        for (j=i+1;j< my_sz->number;j++){
+         if( ( *my_sz->frameset[i] ) .nalign == ( *my_sz->frameset[j] ).nalign ){
+            for(k=0;k<(*my_sz->frameset[i]).nalign;k++){
+               found=0;
+               for(l=0;l<(*my_sz->frameset[j]).nalign;l++){
+                  if( (*my_sz->frameset[i]).align_to_frameset[k]==(*my_sz->frameset[j]).align_to_frameset[l] ){found++;}
+               }
+               if(found==0){fprintf(fplog,"|--ERROR: ATOM %d in frameset %d not found in frameset %d\n",(*my_sz->frameset[i]).align_to_frameset[k],i,j);EXIT();}
+               else if(found>1){fprintf(fplog,"|--ERROR: found multiple definition of %d in frameset %d not found in frameset %d\n",(*my_sz->frameset[i]).align_to_frameset[k],i,j);EXIT();}            }
+         }
+         else{fprintf(fplog,"|--ERROR : ALIGNMENT ATOMS IN THE FRAMESET %d AND %d ARE NOT THE SAME\n",i,j);EXIT();};
+        }
+       }
+// 
+// now write the backtable align_to_coord
+// 
+       for(l=0;l<my_sz->number;l++){// for each frameset in the set
+          j=0;
+          for(i=0;i<(*my_sz->frameset[l]).natoms;i++){//on all the atoms
+             if((*my_sz->frameset[l]).align[i]!=0.){ // only if this atom is used in the alignment
+                  (*my_sz->frameset[l]).align_to_coord[j]=i;
+                  j++;
+             }
+             (*my_sz->frameset[l]).frameset_to_coord[i]=i;
+           }
+       }
+       return 0;
+};
+
+// ------------------------------------------------------------------------------------------------
+
+int PREFIX read_sz_coord (char *filename, struct coordinates_frameset *p, FILE *fplog){
+
+
+    char string[400],sm[10],sm1[10];
+    char *str,remark[10],end[10],atom[5];
+    // new parsing
+    char x[12],y[12],z[12],occ[12],beta[12];
+    char ind[10], resid[10];
+    char name[10],resname[10],chain,hetatm[7] ;	
+	
+    real tmp0;
+    FILE *fp;
+    int i,l;
+
+    fp=fopen(filename,"r");
+    if (fp == NULL){
+       char buf[1024];
+       sprintf(buf,"UNSUCCESSFULL OPENING FOR FILE %s",filename);
+       plumed_error(buf);
+    }
+
+/* PDB
+ 
+         1         2         3         4         5         6         7         8
+
+12345678901234567890123456789012345678901234567890123456789012345678901234567890
+
+ATOM   4150  H   ALA A 431       8.674  16.036  12.858  1.00  0.00
+
+*/
+l=0;
+p->ndisplace=0;
+p->nalign=0;
+p->walign=0.;
+p->wdisplace=0.;
+p->simple=1;
+while(1){
+  readagain:
+  str=fgets(string,100,fp);
+  if(str==NULL)break;
+  if (feof(fp))break;
+
+  sscanf(str,"%3s",end);if(strstr(end,"END")!=NULL){break;};
+  sscanf(str,"%6s",remark);if(strstr(remark,"REMARK")!=NULL){goto readagain;};
+
+  // paste the atom field
+  strncpy(atom,string,4);atom[4]='\0';
+  strncpy(hetatm,string,6);hetatm[6]='\0';
+
+  if( (strstr(atom,"ATOM")!=NULL) || (strstr(hetatm,"HETATM")!=NULL) ) {
+      parse_fixwidth(str,  7, 11, ind);
+      parse_fixwidth(str, 13, 16, name);
+      parse_fixwidth(str, 18, 20, resname);
+      parse_fixwidth(str, 23, 26, resid);
+      //parse_fixwidth(str, 22, 22, &chain);
+      parse_fixwidth(str, 31, 38, x);
+      parse_fixwidth(str, 39, 46, y);
+      parse_fixwidth(str, 47, 54, z);
+      parse_fixwidth(str, 55, 60, occ);
+      parse_fixwidth(str, 61, 66, beta);
+      // old buggy parsing
+      // sscanf(str,"%s %d %s %s %d %lf %lf %lf %s %s",atom,&(p->atmnum[l]),(p->label[l]),(p->resname[l]),&(p->resid[l]),&x,&y,&z,sm,sm1);
+      p->atmnum[l]=atoi(ind);
+      p->resid[l]=atoi(resid);
+      p->pos[l][0]=atof(x);
+      p->pos[l][1]=atof(y);
+      p->pos[l][2]=atof(z);
+      strcpy(p->label[l],name);
+      strcpy(p->resname[l],resname);
+  
+      #if defined (PLUMED_GROMACS)
+      p->pos[l][0] /= 10.;
+      p->pos[l][1] /= 10.;
+      p->pos[l][2] /= 10.;
+      #endif
+      
+      #if defined (STANDALONE)
+      p->pos[l][0] *= mtd_data.ampli;
+      p->pos[l][1] *= mtd_data.ampli;
+      p->pos[l][2] *= mtd_data.ampli;
+      #endif
+  
+  //alignment
+      tmp0=atof(occ);
+      if(tmp0==0.){
+        p->align[l]=0.;
+      }
+      else{
+        p->align[l]=tmp0;
+        p->align_to_frameset[p->nalign]=l;
+        p->nalign++;
+        if(p->nalign>=MAXATOMS_RMSD) plumed_error("Number of atoms per frame in path CV exceeded. Increase MAXATOMS_RMSD in metadyn.h and recompile");
+        p->walign+=tmp0;
+      }
+      //displacement
+      tmp0=atof(beta);
+      if(tmp0==0.){
+        p->displace[l]=0;
+      }
+      else{
+        //p->displace[l]=1;
+        p->displace[l]=tmp0;
+        p->ndisplace++;
+        p->wdisplace+=tmp0;
+      }
+
+//      fprintf(fplog,"RESID NUM %5d  RESID %5d  RESNAME %4s LABEL %4s PX %12.6f PY %12.6f PZ %12.6f OC %12.6f BE %12.6f\n",p->atmnum[l],p->resid[l],p->resname[l],p->label[l],p->pos[l][0],p->pos[l][1],p->pos[l][2],p->align[l], p->displace[l]);
+
+      if( (p->displace[l]!=p->align[l]) || (p->displace[l]!=1.0) || (p->align[l]!=1.0)  )p->simple=0;
+      l++;
+      if(l>=MAXATOMS_PATH) plumed_error("Number of atoms per frame in path CV exceeded. Increase MAXATOMS_PATH in metadyn.h and recompile");
+   }
+}
+fclose(fp);
+p->natoms=l;
+fprintf(fplog,"|---FOUND %d ATOMS FOR DISPLACEMENT\n",p->ndisplace);
+fprintf(fplog,"|---TOTAL WEIGHT FOR  DISPLACEMENT %f\n",p->wdisplace);
+fprintf(fplog,"|---FOUND %d ATOMS FOR ALIGNMENT\n",p->nalign);
+fprintf(fplog,"|---TOTAL WEIGHT   FOR ALIGNMENT %f\n",p->walign);
+
+if(p->nalign==0){
+                   fprintf(fplog,"IT SEEMS YOU DONT  WANT TO ALIGN ANY ATOM\n");
+                    fprintf(fplog,"Your frameset should look like:\n");
+                    fprintf(fplog,"\n");
+                    fprintf(fplog,"                                                         the    the    \n");
+                    fprintf(fplog,"                                                         align  mea      \n");
+                    fprintf(fplog,"                                                         ment   sure     \n");
+                    fprintf(fplog,"                                                          |     |  \n");
+                    fprintf(fplog,"                                                          V     V  \n");
+                    fprintf(fplog,"ATOM   4150  H   ALA A 431       8.674  16.036  12.858  1.00  0.20\n");
+                    fprintf(fplog," .      .    .    .  .  .          .       .       .      .     .  \n");
+                    fprintf(fplog," .      .    .    .  .  .          .       .       .      .     .  \n");
+                    fprintf(fplog," .      .    .    .  .  .          .       .       .      .     .  \n");
+                    fprintf(fplog," .      .    .    .  .  .          .       .       .      .     .  \n");
+                    fprintf(fplog,"\n");
+                    fprintf(fplog,"\n");
+                    fprintf(fplog,"\n");
+                    fprintf(fplog,"\n");
+                    plumed_error("PluMeD dead with errors: check log file"); 
+                }
+if(p->ndisplace==0){
+                    fprintf(fplog,"IT SEEMS YOU DONT  WANT TO MEASURE THE DISPLACEMENT OF ANY ATOM\n");
+                    fprintf(fplog,"Your frameset should look like:\n");
+                    fprintf(fplog,"\n");
+                    fprintf(fplog,"                                                         the    the    \n");
+                    fprintf(fplog,"                                                         align  mea      \n");
+                    fprintf(fplog,"                                                         ment   sure     \n");
+                    fprintf(fplog,"                                                          |     |  \n");
+                    fprintf(fplog,"                                                          V     V  \n");
+                    fprintf(fplog,"ATOM   4150  H   ALA A 431       8.674  16.036  12.858  1.00  0.20\n");
+                    fprintf(fplog," .      .    .    .  .  .          .       .       .      .     .  \n");
+                    fprintf(fplog," .      .    .    .  .  .          .       .       .      .     .  \n");
+                    fprintf(fplog," .      .    .    .  .  .          .       .       .      .     .  \n");
+                    fprintf(fplog," .      .    .    .  .  .          .       .       .      .     .  \n");
+                    fprintf(fplog,"\n");
+                    fprintf(fplog,"\n");
+                    fprintf(fplog,"\n");
+                    fprintf(fplog,"\n");
+                    plumed_error("PluMeD dead with errors: check log file"); 
+                   }
+// find the back index ( from alignment to frameset )
+l=0;
+ for(i=0;i< p->natoms;i++){
+   if (p->align[i]==0.){p->frameset_to_align[i]=-1 ; } // if negative there's no position in the rmsd frame
+   else {p->frameset_to_align[i]=l;l++;}; // if >=0 then provides the index
+ }
+ if(p->simple){
+                    fprintf(fplog,"|-DOING SIMPLE ALIGNMENT: faster\n");
+                    fprintf(fplog,"\n");
+ }else {
+                    fprintf(fplog,"|-DOING DOUBLE ALIGNMENT: slower\n");
+                    fprintf(fplog,"\n");
+ }
+return 0;
+};
+
+// ------------------------------------------------------------------------------------------------
+
+void PREFIX read_sz_map(struct sz_data *my_sz, char file_maps[129], char file_maps2[129],
+                        char file_group[129], int read_mapfile, FILE *fplog){
+
+ FILE   *fmap;
+ int    i,ii,kk,jj,kkk;
+ char   stringa[200],end[10],tmpstring[8],tmp2string[8],*cmstring;
+ char   buf[1024];
+ double r0,cutoff,map,weight;
+
+// open INDEX file
+   fmap=fopen(file_maps,"r");
+   if(fmap == NULL){
+       char buf[1024];
+       sprintf(buf,"UNSUCCESSFULL OPENING FOR FILE %s",file_maps);
+       plumed_error(buf);
+   }
+
+   kk=0;
+   ii=0;
+   jj=0;
+   while(1){
+         cmstring=fgets(stringa,200,fmap);
+         if(cmstring==NULL){break;}
+         sscanf(cmstring,"%3s",end);if(strstr(end,"END")!=NULL){break;};
+         sscanf(cmstring,"%7s",tmpstring);if(strstr(tmpstring,"CONTACT")!=NULL){ii=ii+1;}
+         sscanf(cmstring,"%5s",tmp2string);if(strstr(tmp2string,"GROUP")!=NULL){jj=jj+1;}
+
+         sscanf(cmstring,"%7s %d %d %d %lf %d %d %lf %lf",tmpstring,&kkk,&(my_sz->my_cmap_pack.index1[kk]),
+                &(my_sz->my_cmap_pack.index2[kk]),&r0,&(my_sz->my_cmap_pack.nn[kk]),
+                &(my_sz->my_cmap_pack.nd[kk]),&cutoff,&weight);
+
+
+         my_sz->my_cmap_pack.index1[kk]--;
+         my_sz->my_cmap_pack.index2[kk]--;
+         my_sz->my_cmap_pack.r0[kk] = (real) r0;
+         my_sz->my_cmap_pack.cutoff[kk] = (real) cutoff;
+         my_sz->my_cmap_pack.weight[kk] = (real) weight;
+         kk=kk+1;
+         if(kk>=MAXDIM_CMAP) plumed_error("Number of contacts in path CV exceeded. Increase MAXDIM_CMAP in metadyn.h and recompile");
+        }
+
+   my_sz->my_cmap_pack.number=ii;
+   my_sz->my_cmap_pack.gnumber=jj;
+
+   fprintf(fplog,"|--%d atomic contacts / %d group contacts \n",my_sz->my_cmap_pack.number,my_sz->my_cmap_pack.gnumber);
+   fclose(fmap);
+
+   int iii=0;
+   if(read_mapfile==1){
+    fmap=fopen(file_maps2,"r");
+    if(fmap == NULL){
+      sprintf(buf,"UNSUCCESSFULL OPENING FOR FILE %s",file_maps2);
+      plumed_error(buf);
+    }
+
+    while(1){
+    kk=0;
+    while(1){
+      cmstring=fgets(stringa,200,fmap);
+      if(cmstring==NULL){break;}
+      sscanf(cmstring,"%3s",end);if(strstr(end,"END")!=NULL){break;};
+      sscanf(cmstring,"%d %d %d %lf",&kkk,&ii,&jj,&map);
+ 
+      my_sz->my_cmap_pack.cmap[iii][kk] = (real) map;
+ 
+      kk=kk+1;
+    }
+
+    if(cmstring==NULL){break;}
+    iii=iii+1;
+    }
+    if(iii!=my_sz->number){
+      sprintf(buf,"NUMBER OF FRAMES FOUND %d IS DIFFERENT FROM EXPECTED %d",iii,my_sz->number);
+      plumed_error(buf);
+    }
+    fclose(fmap);
+   }
+
+    if(my_sz->my_cmap_pack.logical_group){
+      fmap=fopen(file_group,"r");
+      if(fmap == NULL){
+       sprintf(buf,"UNSUCCESSFULL OPENING FOR FILE %s",file_group);
+       plumed_error(buf); 
+      }
+      while(1){
+       iii=0;
+       cmstring=fgets(stringa,200,fmap);
+       if(cmstring==NULL){break;}
+       char *result = NULL;
+       result = strtok( stringa, " \t" );
+       while( result != NULL ) {
+        if(iii==1) jj = atoi (result);
+        if(iii==2) my_sz->my_cmap_pack.group.numatom[jj-1] = atoi (result);
+        if(iii>2)  my_sz->my_cmap_pack.group.index[jj-1][iii-3] = atoi (result) - 1; 
+        result = strtok( NULL, " \t" );
+        iii=iii+1;
+       }
+      }
+      my_sz->my_cmap_pack.group.number=jj;
+      fclose(fmap);
+
+      printf("|--Reading GROUP file. Found %d groups \n",  my_sz->my_cmap_pack.group.number);
+      for(i=0;i<my_sz->my_cmap_pack.group.number;i++){
+       fprintf(fplog,"|--GROUP %d #ofATOMS %d \n",i+1,my_sz->my_cmap_pack.group.numatom[i]);
+       for(ii=0;ii<my_sz->my_cmap_pack.group.numatom[i];ii++){
+        fprintf(fplog,"|---AT %d \n", my_sz->my_cmap_pack.group.index[i][ii]+1);
+       }
+      }
+     } 
+     
+// Calculating number of atoms involved and creating the list
+// from ATOMIC contacts
+            ii=0;
+            if(my_sz->my_cmap_pack.number!=0){my_sz->my_cmap_pack.list[ii]=my_sz->my_cmap_pack.index1[0];}
+
+            for(iii=1;iii<my_sz->my_cmap_pack.number;iii++){
+             int flag=0;
+             for(kk=0;kk<=ii;kk++){
+              if(my_sz->my_cmap_pack.index1[iii]==my_sz->my_cmap_pack.list[kk]){flag=1;}
+             }
+             if(flag==0){
+             ii=ii+1;
+             my_sz->my_cmap_pack.list[ii]=my_sz->my_cmap_pack.index1[iii];
+             }
+            }
+
+           for(iii=0;iii<my_sz->my_cmap_pack.number;iii++){
+             int flag=0;
+             for(kk=0;kk<=ii;kk++){
+              if(my_sz->my_cmap_pack.index2[iii]==my_sz->my_cmap_pack.list[kk]){flag=1;}
+             }
+             if(flag==0){
+             ii=ii+1;
+             my_sz->my_cmap_pack.list[ii]=my_sz->my_cmap_pack.index2[iii];
+             }
+            }
+
+            if(my_sz->my_cmap_pack.number!=0){my_sz->my_cmap_pack.atoms=ii+1;}
+            else{my_sz->my_cmap_pack.atoms=0;}
+// From group
+
+ if(my_sz->my_cmap_pack.logical_group){
+           for(i=0;i<my_sz->my_cmap_pack.group.number;i++){
+            for(ii=0;ii<my_sz->my_cmap_pack.group.numatom[i];ii++){
+             kkk=my_sz->my_cmap_pack.group.index[i][ii];
+             int flag=0;
+                for(kk=0;kk<my_sz->my_cmap_pack.atoms;kk++){
+                 if(my_sz->my_cmap_pack.list[kk]==kkk){
+                  my_sz->my_cmap_pack.group.index_to_list[i][ii]=kk;
+                  flag=1;
+                 }
+                }
+              if(flag==0){
+               my_sz->my_cmap_pack.list[my_sz->my_cmap_pack.atoms]=kkk;
+               my_sz->my_cmap_pack.group.index_to_list[i][ii]=my_sz->my_cmap_pack.atoms;
+               my_sz->my_cmap_pack.atoms=my_sz->my_cmap_pack.atoms+1;
+              }
+            }
+           }
+  }
+
+
+            fprintf(fplog,"|--Total number of atoms involved %d \n",my_sz->my_cmap_pack.atoms);
+
+// creating connection between my_cmap_pack.list e my_cmap_pack.index_from
+
+           for(iii=0;iii<my_sz->my_cmap_pack.number;iii++){
+            for(i=0;i<my_sz->my_cmap_pack.atoms;i++){
+             if(my_sz->my_cmap_pack.index1[iii]==my_sz->my_cmap_pack.list[i]){my_sz->my_cmap_pack.index_from1[iii]=i;}
+             if(my_sz->my_cmap_pack.index2[iii]==my_sz->my_cmap_pack.list[i]){my_sz->my_cmap_pack.index_from2[iii]=i;}
+            }
+           }
+
+    return;
+
+}
+
+// ------------------------------------------------------------------------------------------------
+
+void PREFIX cmap_running(int i_c, struct cmap_inpack *inpack, struct cmap_pack *my_cmap_pack){
+
+       int mm,nn,i,j;
+       real dist,xp,xq;
+       rvec rij;
+
+// atomic contact
+
+       for(i=0;i<my_cmap_pack->number;i++){
+
+        mm=my_cmap_pack->index_from1[i];
+        nn=my_cmap_pack->index_from2[i];
+
+// CMAP AND PBC
+        if(colvar.cell_pbc[i_c]){
+          minimal_image(inpack->r0[mm], inpack->r0[nn], &dist, rij);
+        } else {
+          dist=sqrt(pow2(inpack->r0[mm][0]-inpack->r0[nn][0])+
+                    pow2(inpack->r0[mm][1]-inpack->r0[nn][1])+
+                    pow2(inpack->r0[mm][2]-inpack->r0[nn][2]));
+         };
+
+/* original implementation
+
+        dist=sqrt(pow2(inpack->r0[mm][0]-inpack->r0[nn][0])+
+                  pow2(inpack->r0[mm][1]-inpack->r0[nn][1])+
+                  pow2(inpack->r0[mm][2]-inpack->r0[nn][2]));
+*/
+
+        if (dist>my_cmap_pack->cutoff[i] || my_cmap_pack->weight[i]==0){
+             inpack->cmap[i]=0.;
+        }else{
+             if (fabs(dist/my_cmap_pack->r0[i]-1.0)<0.00001){
+              inpack->cmap[i]=(real) my_cmap_pack->nn[i]/my_cmap_pack->nd[i];
+             } else { 
+              power(dist/my_cmap_pack->r0[i],my_cmap_pack->nn[i],my_cmap_pack->nd[i],&xp,&xq);
+              inpack->cmap[i]=(1.-xp)/(1.-xq)*my_cmap_pack->weight[i];
+             }
+        }
+       }
+
+       if(my_cmap_pack->logical_group){
+// group contacts
+// evaluating center of mass
+
+        for(i=0;i<my_cmap_pack->group.number;i++){
+
+         my_cmap_pack->group.rcm[i][0]=0.;
+         my_cmap_pack->group.rcm[i][1]=0.;
+         my_cmap_pack->group.rcm[i][2]=0.;
+
+         for (j=0;j<my_cmap_pack->group.numatom[i];j++){
+          mm=my_cmap_pack->group.index_to_list[i][j];
+          my_cmap_pack->group.rcm[i][0] += inpack->r0[mm][0];
+          my_cmap_pack->group.rcm[i][1] += inpack->r0[mm][1];
+          my_cmap_pack->group.rcm[i][2] += inpack->r0[mm][2];
+         }
+
+         my_cmap_pack->group.rcm[i][0] /= (real) my_cmap_pack->group.numatom[i];
+         my_cmap_pack->group.rcm[i][1] /= (real) my_cmap_pack->group.numatom[i];
+         my_cmap_pack->group.rcm[i][2] /= (real) my_cmap_pack->group.numatom[i];
+
+       }
+
+
+// evaluating contacts
+
+        for(i=0;i<my_cmap_pack->gnumber;i++){
+
+         j=i+my_cmap_pack->number;
+         mm=my_cmap_pack->index1[j];
+         nn=my_cmap_pack->index2[j];
+
+// CMAP AND PBC
+        rvec rij;
+        if(colvar.cell_pbc[i_c]){
+          minimal_image(my_cmap_pack->group.rcm[mm], my_cmap_pack->group.rcm[nn], &dist, rij);
+        } else {
+         dist=sqrt(pow2(my_cmap_pack->group.rcm[mm][0]-my_cmap_pack->group.rcm[nn][0])+
+                   pow2(my_cmap_pack->group.rcm[mm][1]-my_cmap_pack->group.rcm[nn][1])+
+                   pow2(my_cmap_pack->group.rcm[mm][2]-my_cmap_pack->group.rcm[nn][2]));
+         };
+
+
+/* original implementation
+         dist=sqrt(pow2(my_cmap_pack->group.rcm[mm][0]-my_cmap_pack->group.rcm[nn][0])+
+                   pow2(my_cmap_pack->group.rcm[mm][1]-my_cmap_pack->group.rcm[nn][1])+
+                   pow2(my_cmap_pack->group.rcm[mm][2]-my_cmap_pack->group.rcm[nn][2]));
+*/ 
+
+         if (dist>my_cmap_pack->cutoff[j] || my_cmap_pack->weight[j]==0){
+             inpack->cmap[j]=0.;
+         }
+         else{
+            if(fabs(dist/my_cmap_pack->r0[j]-1.0)<0.00001){
+             inpack->cmap[j] = (real) my_cmap_pack->nn[j]/my_cmap_pack->nd[j];
+            } else {
+              power(dist/my_cmap_pack->r0[j],my_cmap_pack->nn[j],my_cmap_pack->nd[j],&xp,&xq);
+              inpack->cmap[j]=(1.-xp)/(1.-xq)*my_cmap_pack->weight[j];
+            }
+         }
+
+        }
+   }
+ }
+
+// ------------------------------------------------------------------------------------------------
+
+void PREFIX cmdist_eval(int i_c, int frame,struct cmap_inpack *inpack,struct cmap_outpack *work,
+                  struct cmap_pack *my_cmap_pack,int dr1_calc){
+
+       int    jj,k,i,j,ii,jjj,iii;
+       int    tot;
+
+       real tmp, dist_r0;
+       real tmp4_r0_0,tmp4_r0_1,tmp4_r0_2;
+       real tmp1_r0,tmp2_r0,tmp3_r0;
+       real tmp1,tmp2,tmp3;
+       real pow_P,pow_Q;
+       real R01;
+       int    P1,Q1;
+       rvec rij;
+
+       tmp=0.;
+       tot=my_cmap_pack->number+my_cmap_pack->gnumber;
+
+       for(i=0;i<tot;i++){
+          tmp=tmp+pow2(my_cmap_pack->cmap[frame][i]-inpack->cmap[i]);
+         }
+        work->err=tmp;
+
+
+                                      /* DERIVATIVE CALCULATION:respect to running frame and frameset */
+
+// setting derivatives to zero
+
+        for(k=0;k<my_cmap_pack->atoms;k++){
+             work->derr_dr0[0][k]=0.;
+             work->derr_dr0[1][k]=0.;
+             work->derr_dr0[2][k]=0.;
+        }
+
+
+           for(j=0;j<my_cmap_pack->number;j++){
+            if(my_cmap_pack->weight[j]!=0){
+              ii=my_cmap_pack->index_from1[j];
+              jj=my_cmap_pack->index_from2[j];
+
+// CMAP AND PBC
+             if(colvar.cell_pbc[i_c]){
+               minimal_image(inpack->r0[ii], inpack->r0[jj], &dist_r0, rij);
+             } else {
+               rij[0] = inpack->r0[ii][0]-inpack->r0[jj][0];
+               rij[1] = inpack->r0[ii][1]-inpack->r0[jj][1];
+               rij[2] = inpack->r0[ii][2]-inpack->r0[jj][2];
+               dist_r0=sqrt(pow2(inpack->r0[ii][0]-inpack->r0[jj][0])+
+                         pow2(inpack->r0[ii][1]-inpack->r0[jj][1])+
+                         pow2(inpack->r0[ii][2]-inpack->r0[jj][2]));
+             };
+/*
+              dist_r0=sqrt(pow2(inpack->r0[ii][0]-inpack->r0[jj][0])+pow2(inpack->r0[ii][1]-inpack->r0[jj][1])+pow2(inpack->r0[ii][2]-inpack->r0[jj][2]));
+*/
+              tmp1_r0=inpack->cmap[j]-my_cmap_pack->cmap[frame][j];
+              R01=my_cmap_pack->r0[j];
+              P1=my_cmap_pack->nn[j];
+              Q1=my_cmap_pack->nd[j];
+
+              if(fabs(dist_r0/R01-1.0)<0.00001){
+/* old
+               outpack->derr_dr0[0][ii]+=tmp1_r0*(inpack->r0[ii][0]-inpack->r0[jj][0])*P1*(P1-Q1)/Q1;
+               outpack->derr_dr0[1][ii]+=tmp1_r0*(inpack->r0[ii][1]-inpack->r0[jj][1])*P1*(P1-Q1)/Q1;
+               outpack->derr_dr0[2][ii]+=tmp1_r0*(inpack->r0[ii][2]-inpack->r0[jj][2])*P1*(P1-Q1)/Q1;
+               outpack->derr_dr0[0][jj]-=tmp1_r0*(inpack->r0[ii][0]-inpack->r0[jj][0])*P1*(P1-Q1)/Q1;
+               outpack->derr_dr0[1][jj]-=tmp1_r0*(inpack->r0[ii][1]-inpack->r0[jj][1])*P1*(P1-Q1)/Q1;
+               outpack->derr_dr0[2][jj]-=tmp1_r0*(inpack->r0[ii][2]-inpack->r0[jj][2])*P1*(P1-Q1)/Q1;
+*/
+// NEWPBC
+               work->derr_dr0[0][ii]+=tmp1_r0*rij[0]*P1*(P1-Q1)/Q1;
+               work->derr_dr0[1][ii]+=tmp1_r0*rij[1]*P1*(P1-Q1)/Q1;
+               work->derr_dr0[2][ii]+=tmp1_r0*rij[2]*P1*(P1-Q1)/Q1;
+               work->derr_dr0[0][jj]-=tmp1_r0*rij[0]*P1*(P1-Q1)/Q1;
+               work->derr_dr0[1][jj]-=tmp1_r0*rij[1]*P1*(P1-Q1)/Q1;
+               work->derr_dr0[2][jj]-=tmp1_r0*rij[2]*P1*(P1-Q1)/Q1;
+              }else{
+               power(dist_r0/R01,P1,Q1,&pow_P,&pow_Q);
+
+               tmp2_r0=(Q1*pow_Q*(1.-pow_P)-P1*pow_P*(1.-pow_Q))*R01/dist_r0*my_cmap_pack->weight[j];
+               tmp3_r0=R01*(1.-pow_Q)*(1.-pow_Q);
+/* old
+               tmp4_r0_0=(inpack->r0[ii][0]-inpack->r0[jj][0])/dist_r0;
+               tmp4_r0_1=(inpack->r0[ii][1]-inpack->r0[jj][1])/dist_r0;
+               tmp4_r0_2=(inpack->r0[ii][2]-inpack->r0[jj][2])/dist_r0;
+*/
+// NEWPBC
+               tmp4_r0_0=rij[0]/dist_r0;
+               tmp4_r0_1=rij[1]/dist_r0;
+               tmp4_r0_2=rij[2]/dist_r0;
+
+               tmp1=2*tmp1_r0*tmp2_r0*tmp4_r0_0/tmp3_r0;
+               tmp2=2*tmp1_r0*tmp2_r0*tmp4_r0_1/tmp3_r0;
+               tmp3=2*tmp1_r0*tmp2_r0*tmp4_r0_2/tmp3_r0;
+               work->derr_dr0[0][ii]+=tmp1;
+               work->derr_dr0[1][ii]+=tmp2;
+               work->derr_dr0[2][ii]+=tmp3;
+               work->derr_dr0[0][jj]-=tmp1;
+               work->derr_dr0[1][jj]-=tmp2;
+               work->derr_dr0[2][jj]-=tmp3;
+              }
+           }
+          }
+// case of group contact
+
+          if(my_cmap_pack->logical_group){
+           for(j=0;j<my_cmap_pack->gnumber;j++){
+
+            i=j+my_cmap_pack->number;
+            ii=my_cmap_pack->index1[i];
+            jj=my_cmap_pack->index2[i];
+
+// CMAP AND PBC
+	    if(colvar.cell_pbc[i_c]){
+	      minimal_image(my_cmap_pack->group.rcm[ii], my_cmap_pack->group.rcm[jj], &dist_r0, rij);
+	    } else {
+	      rij[0] = my_cmap_pack->group.rcm[ii][0]-my_cmap_pack->group.rcm[jj][0];
+	      rij[1] = my_cmap_pack->group.rcm[ii][1]-my_cmap_pack->group.rcm[jj][1];
+	      rij[2] = my_cmap_pack->group.rcm[ii][2]-my_cmap_pack->group.rcm[jj][2];
+              dist_r0=sqrt(pow2(my_cmap_pack->group.rcm[ii][0]-my_cmap_pack->group.rcm[jj][0])+
+                           pow2(my_cmap_pack->group.rcm[ii][1]-my_cmap_pack->group.rcm[jj][1])+
+                           pow2(my_cmap_pack->group.rcm[ii][2]-my_cmap_pack->group.rcm[jj][2]));
+	    };
+
+/*
+              dist_r0=sqrt(pow2(my_cmap_pack->group.rcm[ii][0]-my_cmap_pack->group.rcm[jj][0])+
+                           pow2(my_cmap_pack->group.rcm[ii][1]-my_cmap_pack->group.rcm[jj][1])+
+                           pow2(my_cmap_pack->group.rcm[ii][2]-my_cmap_pack->group.rcm[jj][2]));
+*/
+              tmp1_r0=inpack->cmap[i]-my_cmap_pack->cmap[frame][i];
+
+              R01=my_cmap_pack->r0[i];
+              P1=my_cmap_pack->nn[i];
+              Q1=my_cmap_pack->nd[i];
+
+              if(fabs(dist_r0/R01-1.0)<0.00001){
+               for(jjj=0;jjj<my_cmap_pack->group.numatom[ii];jjj++){
+                iii=my_cmap_pack->group.index_to_list[ii][jjj];
+/* old
+                outpack->derr_dr0[0][iii]+=tmp1_r0*(my_cmap_pack->group.rcm[ii][0]-my_cmap_pack->group.rcm[jj][0])*P1*(P1-Q1)/Q1/((real) my_cmap_pack->group.numatom[ii]);
+                outpack->derr_dr0[1][iii]+=tmp1_r0*(my_cmap_pack->group.rcm[ii][1]-my_cmap_pack->group.rcm[jj][1])*P1*(P1-Q1)/Q1/((real) my_cmap_pack->group.numatom[ii]);
+                outpack->derr_dr0[2][iii]+=tmp1_r0*(my_cmap_pack->group.rcm[ii][2]-my_cmap_pack->group.rcm[jj][2])*P1*(P1-Q1)/Q1/((real) my_cmap_pack->group.numatom[ii]);
+*/
+// NEWPBC
+                work->derr_dr0[0][iii]+=tmp1_r0*rij[0]*P1*(P1-Q1)/Q1/((real) my_cmap_pack->group.numatom[ii]);
+                work->derr_dr0[1][iii]+=tmp1_r0*rij[1]*P1*(P1-Q1)/Q1/((real) my_cmap_pack->group.numatom[ii]);
+                work->derr_dr0[2][iii]+=tmp1_r0*rij[2]*P1*(P1-Q1)/Q1/((real) my_cmap_pack->group.numatom[ii]);
+
+
+
+               }
+               for(jjj=0;jjj<my_cmap_pack->group.numatom[jj];jjj++){
+                iii=my_cmap_pack->group.index_to_list[jj][jjj];
+/* old
+                outpack->derr_dr0[0][iii]-=tmp1_r0*(my_cmap_pack->group.rcm[ii][0]-my_cmap_pack->group.rcm[jj][0])*P1*(P1-Q1)/Q1/((real) my_cmap_pack->group.numatom[jj]);
+                outpack->derr_dr0[1][iii]-=tmp1_r0*(my_cmap_pack->group.rcm[ii][1]-my_cmap_pack->group.rcm[jj][1])*P1*(P1-Q1)/Q1/((real) my_cmap_pack->group.numatom[jj]);
+                outpack->derr_dr0[2][iii]-=tmp1_r0*(my_cmap_pack->group.rcm[ii][2]-my_cmap_pack->group.rcm[jj][2])*P1*(P1-Q1)/Q1/((real) my_cmap_pack->group.numatom[jj]);
+*/
+// NEWPBC
+                work->derr_dr0[0][iii]-=tmp1_r0*rij[0]*P1*(P1-Q1)/Q1/((real) my_cmap_pack->group.numatom[jj]);
+                work->derr_dr0[1][iii]-=tmp1_r0*rij[1]*P1*(P1-Q1)/Q1/((real) my_cmap_pack->group.numatom[jj]);
+                work->derr_dr0[2][iii]-=tmp1_r0*rij[2]*P1*(P1-Q1)/Q1/((real) my_cmap_pack->group.numatom[jj]);
+               }
+              }else{
+               power(dist_r0/R01,P1,Q1,&pow_P,&pow_Q);
+
+               tmp2_r0=(Q1*pow_Q*(1.-pow_P)-P1*pow_P*(1.-pow_Q))*R01/dist_r0*my_cmap_pack->weight[i];
+               tmp3_r0=R01*(1.-pow_Q)*(1.-pow_Q);
+/* old
+               tmp4_r0_0=(my_cmap_pack->group.rcm[ii][0]-my_cmap_pack->group.rcm[jj][0])/dist_r0;
+               tmp4_r0_1=(my_cmap_pack->group.rcm[ii][1]-my_cmap_pack->group.rcm[jj][1])/dist_r0;
+               tmp4_r0_2=(my_cmap_pack->group.rcm[ii][2]-my_cmap_pack->group.rcm[jj][2])/dist_r0;
+*/
+// NEWPBC
+               tmp4_r0_0=rij[0]/dist_r0;
+               tmp4_r0_1=rij[1]/dist_r0;
+               tmp4_r0_2=rij[2]/dist_r0;
+
+
+               tmp1=2*tmp1_r0*tmp2_r0*tmp4_r0_0/tmp3_r0;
+               tmp2=2*tmp1_r0*tmp2_r0*tmp4_r0_1/tmp3_r0;
+               tmp3=2*tmp1_r0*tmp2_r0*tmp4_r0_2/tmp3_r0;
+
+               for(jjj=0;jjj<my_cmap_pack->group.numatom[ii];jjj++){
+                iii=my_cmap_pack->group.index_to_list[ii][jjj];
+                work->derr_dr0[0][iii]+=tmp1/((real) my_cmap_pack->group.numatom[ii]);
+                work->derr_dr0[1][iii]+=tmp2/((real) my_cmap_pack->group.numatom[ii]);
+                work->derr_dr0[2][iii]+=tmp3/((real) my_cmap_pack->group.numatom[ii]);
+               }
+               for(jjj=0;jjj<my_cmap_pack->group.numatom[jj];jjj++){
+                iii=my_cmap_pack->group.index_to_list[jj][jjj];
+                work->derr_dr0[0][iii]-=tmp1/((real) my_cmap_pack->group.numatom[jj]);
+                work->derr_dr0[1][iii]-=tmp2/((real) my_cmap_pack->group.numatom[jj]);
+                work->derr_dr0[2][iii]-=tmp3/((real) my_cmap_pack->group.numatom[jj]);
+               }
+              }
+           }
+          }
+
+           if(dr1_calc){
+             for(i=0;i<tot;i++){
+              work->derr_dcm[i]=-2.*(inpack->cmap[i]-my_cmap_pack->cmap[frame][i]);
+             }
+           }
+
+}
+
+// ------------------------------------------------------------------------------------------------
+
+real PREFIX pow2(real x){
+return x*x;
+}
+
+// ------------------------------------------------------------------------------------------------
+
+void PREFIX power(real x,int p,int q,real *xp,real *xq){
+     int i;
+     real tot;
+
+     tot=1;
+     if(p>=q){
+       for(i=1;i<=q;i++){
+        tot=tot*x;
+        }
+        *xq=tot;
+       for(i=q+1;i<=p;i++){
+        tot=tot*x;
+        }
+        *xp=tot;}
+     else{
+       for(i=1;i<=p;i++){
+        tot=tot*x;
+        }
+        *xp=tot;
+       for(i=p+1;i<=q;i++){
+        tot=tot*x;
+        }
+        *xq=tot;}
+}
+
+// ------------------------------------------------------------------------------------------------
+
+
+void  PREFIX msd_calculation(struct coordinates_frameset *pframeset,struct cmap_inpack *c_inpack,
+                             struct cmap_outpack *c_outpack,real dmsd_dr1[3][MAXATOMS_PATH],int der_frameref_on, int norot, int nocenter){
+
+        int j,l,k,m,n,o,degeneration;
+
+        real tmp0,tmp1,ndisplace,nalign,displace,align,walign,wdisplace;
+        real coeff[3][MAXATOMS_PATH];
+        real const1,const2; 
+        struct rmsd_inpack inpack;
+#ifdef RMSD_FULL
+	struct rmsd_outpack work;
+#else
+	struct rmsd_mini_outpack work;
+#endif
+
+			/* number of atoms */
+        nalign=pframeset->nalign;
+	inpack.natoms=pframeset->nalign;
+	inpack.totmass=pframeset->walign;
+                           /* transfer atoms from the current set */
+	for(k=0;k< pframeset->nalign;k++){
+                          l=pframeset->align_to_coord[k];
+                          inpack.r0[0][k]=c_inpack->r0[l][0];        
+                          inpack.r0[1][k]=c_inpack->r0[l][1];        
+                          inpack.r0[2][k]=c_inpack->r0[l][2];        
+                          //fprintf(mtd_data.fplog,"COORD0 %d  %d %12.6f %12.6f %12.6f\n",k,l,inpack.r0[0][k],inpack.r0[1][k],inpack.r0[2][k]);
+        }
+
+                        /* transfer the atoms in the frameset */
+        for(k=0;k<pframeset->nalign;k++){
+                          l=pframeset->align_to_frameset[k];
+                          inpack.r1[0][k]=pframeset->pos[l][0];
+                          inpack.r1[1][k]=pframeset->pos[l][1];
+                          inpack.r1[2][k]=pframeset->pos[l][2];
+                          inpack.mass[k]=pframeset->align[l]; // this contains the weight in mass avg
+                          //fprintf(mtd_data.fplog,"COORD1  %12.6f %12.6f %12.6f\n",inpack.r1[0][k],inpack.r1[1][k],inpack.r1[2][k]);
+        }
+#ifdef RMSD_FULL
+        rmsd_pack(inpack,&work,7,1);
+#else
+       if(norot) { // dont rotate the frameset: fast and easy 
+         rmsd_mini_pack_fake(inpack,&work,nocenter,pframeset->simple); 
+         if(pframeset->simple==1){
+               c_outpack->err=work.err;
+               for(k=0;k<pframeset->natoms;k++){
+                    for(l=0;l<3;l++){
+                        c_outpack->derr_dr0[l][k]=-work.derr_dr0[l][k];   
+                        if(der_frameref_on)  dmsd_dr1[l][k]=-work.derr_dr1[l][k];
+                        
+                    }
+               }
+               return;
+         }
+       } else { 
+           //  full rmsd through simple derivative  of the eigenvalue   
+           if(pframeset->simple==1){
+               rmsd_mini_pack(inpack,&work,7,1,1);
+               c_outpack->err=work.err*work.err;
+               /* DERIVATIVE CALCULATION:respect to running frame */
+               
+               for(k=0;k<pframeset->natoms;k++){
+                    for(l=0;l<3;l++){
+                        c_outpack->derr_dr0[l][k]=2.*work.err*work.derr_dr0[l][k];   
+                                    if(der_frameref_on){
+                                           dmsd_dr1[l][k]=2.*work.err*work.derr_dr1[l][k];   
+                                    }
+                    }
+               }
+               // simple RMSD finite difference test system
+               //rmsd_findiff_interface(inpack,&outpack);
+               return;
+            }else{
+               //  full rmsd through derivative of rotation matrix  
+               degeneration=rmsd_mini_pack(inpack,&work,7,0,1);
+               //rmsd_mini_pack_fake(inpack,&outpack,7);
+               // simple RMSD finite difference test system
+               //rmsd_findiff_interface(inpack,&outpack);
+            }
+        }	
+#endif
+        //fprintf(mtd_data.fplog,"ERROR_RMSD_PACK %f\n",outpack.err);	
+        //printf("ERROR_RMSD_PACK %f\n",outpack.err);	
+	//(*err)=outpack.err;
+                            /* check rotation and translation */
+
+        //                for(k=0;k<my_coord0.natoms;k++){
+        //                     my_coord0.pos[0][k]-=outpack.cmr0[0];
+        //                     my_coord0.pos[1][k]-=outpack.cmr0[1];
+        //                     my_coord0.pos[2][k]-=outpack.cmr0[2];
+	//		}
+
+        //                ll=init_pdb("current.pdb"); 
+        //                plot_pdb(ll,&my_coord0); 
+
+        //                mm=init_pdb("reference.pdb"); 
+        //                for(k=0;k<pframeset->natoms;k++){
+        //                     pframeset->pos[0][k]-=outpack.cmr1[0];
+        //                     pframeset->pos[1][k]-=outpack.cmr1[1];
+        //                     pframeset->pos[2][k]-=outpack.cmr1[2];
+	//		}
+        //                for(k=0;k<pframeset->natoms;k++){
+
+        //                     tmp1=pframeset->pos[0][k]*outpack.d[0][0]+
+        //                          pframeset->pos[1][k]*outpack.d[0][1]+
+        //                          pframeset->pos[2][k]*outpack.d[0][2];
+
+        //                     tmp2=pframeset->pos[0][k]*outpack.d[1][0]+
+        //                          pframeset->pos[1][k]*outpack.d[1][1]+
+        //                          pframeset->pos[2][k]*outpack.d[1][2];
+
+        //                     tmp3=pframeset->pos[0][k]*outpack.d[2][0]+
+        //                          pframeset->pos[1][k]*outpack.d[2][1]+
+        //                          pframeset->pos[2][k]*outpack.d[2][2];
+
+	//	             pframeset->pos[0][k]=tmp1;
+        //                     pframeset->pos[1][k]=tmp2;
+        //                     pframeset->pos[2][k]=tmp3;
+	//		}
+        //                plot_pdb(mm,pframeset); 
+        //                CkExit();
+                            /* REAL MSD CALCULATION */
+
+	tmp0=0.;
+	ndisplace=(real) pframeset->ndisplace; 
+	walign= pframeset->walign; 
+	wdisplace= pframeset->wdisplace; 
+	
+	for(k=0;k<pframeset->natoms;k++){
+		for(l=0;l<3;l++){
+			
+			displace= pframeset->displace[k]; 
+			align= pframeset->align[k]; 
+			tmp1=0.;
+			
+			// contribution from rotated reference frame //
+			for(m=0;m<3;m++){
+				tmp1-=work.d[l][m]*(pframeset->pos[k][m]-work.cmr1[m]);
+			}
+			
+			// contribution from running centered frame //
+			j=pframeset->frameset_to_coord[k]; 
+			tmp1+=(c_inpack->r0[j][l]-work.cmr0[l]); 
+			
+			
+			//printf("DISPLACED ATOM %d %f %f \n",k,tmp2,tmp1*tmp1);
+			coeff[l][k]=tmp1;// store coefficents for derivative usage// 
+			tmp0+=tmp1*tmp1*displace; //squared distance added//
+		}
+	}  
+	tmp0=tmp0/wdisplace;
+	
+	//printf("ERRR NEW %f \n",tmp0);
+	
+	c_outpack->err=tmp0;
+	
+	/* DERIVATIVE CALCULATION:respect to running frame */
+	for(k=0;k<pframeset->natoms;k++){
+		for(l=0;l<3;l++){
+			
+			displace= pframeset->displace[k]; 
+			align= pframeset->align[k]; 
+			
+			tmp1 =2.0*coeff[l][k]*displace/wdisplace ;
+			
+			const1=2.0*align/(walign*wdisplace);
+			
+			if(const1>0.){
+				for(o=0;o<pframeset->natoms;o++){
+					tmp1 -=const1*coeff[l][o]*pframeset->displace[o]; 
+				} 
+			}
+			
+			j=pframeset->frameset_to_align[k]; //index of the k atom passed to the rmsd routine
+			if(j>=0){
+				for(m=0;m<pframeset->natoms;m++){
+					// displace= pframeset->displace[m]; 
+					const1=2.* pframeset->displace[m]/wdisplace ;
+					for(n=0;n<3;n++){
+						tmp0=0.;
+						for(o=0;o<3;o++){
+							tmp0+=work.dd_dr0[n][o][l][j]*(pframeset->pos[m][o]-work.cmr1[o]);
+						}
+						tmp0*=-const1*coeff[n][m];
+						tmp1+=tmp0;    
+					}
+				}
+			}
+			c_outpack->derr_dr0[l][k]=tmp1;
+		}
+	}
+	
+	/* DERIVATIVE CALCULATION:respect to frameset  */
+	if(der_frameref_on){
+		for(k=0;k<pframeset->natoms;k++){
+			
+			j=pframeset->frameset_to_align[k]; //index of the k atom passed to the rmsd routine
+			
+			for(l=0;l<3;l++){
+				
+				tmp1=0.;
+				
+				if(j>=0){ // if it is an alignment atom
+					for(m=0;m<pframeset->natoms;m++){
+						const1=2.* pframeset->displace[m]/wdisplace ;
+						for(n=0;n<3;n++){
+							tmp0=0.;
+							for(o=0;o<3;o++){
+								tmp0+=work.dd_dr1[n][o][l][j]*
+								(pframeset->pos[m][o]-work.cmr1[o]);
+							}
+							tmp0*=-const1*coeff[n][m]; 
+							tmp1+= tmp0;    
+						}
+					}
+				}
+				
+				displace= pframeset->displace[k]; 
+				align= pframeset->align[k]; 
+				
+				tmp0=0.;
+				for(o=0;o<3;o++){
+					tmp0+=coeff[o][k]*work.d[o][l];
+				}
+				tmp1-=tmp0*2.*displace/wdisplace;
+				
+				if(j>=0){
+					tmp0=0.;
+					for(m=0;m<pframeset->natoms;m++){
+						for(o=0;o<3;o++){
+							tmp0+=coeff[o][m]*work.d[o][l]*pframeset->displace[m];
+						}
+					}
+					tmp1 += tmp0*2.*align/(walign*wdisplace);
+				}
+				
+				dmsd_dr1[l][k]=tmp1;
+			}
+		}
+	}
+	return;
+};
+
+// ------------------------------------------------------------------------------------------------
+
+
+int PREFIX rmsd_pack(struct rmsd_inpack inpack,struct rmsd_outpack *work,int iopt,int iopt2)
+{
+/* declarations */
+int i,j,k,l,p,ll,mm,nn,ii,ix,jx;
+real rrsq,xx,yy,zz,m[4][4],rr1[4],rr0[4];
+//cR double lambda[4],z[4][4],wk[20],s,q[4];
+real lambda[4],s,q[4];
+real dddq[3][3][4],gamma[3][3][3];
+real dm_r1[4][4][3],dm_r0[4][4][3];
+real dm_r1_store[4][4][3][MAXATOMS_RMSD];
+real dm_r0_store[4][4][3][MAXATOMS_RMSD];
+real derr_dr1_tmp[3][MAXATOMS_RMSD];
+real derr_dr0_tmp[3][MAXATOMS_RMSD];
+real dderr_dr1_dr1_tmp[3][MAXATOMS_RMSD][3][MAXATOMS_RMSD];
+real dderr_dr0_dr0_tmp[3][MAXATOMS_RMSD][3][MAXATOMS_RMSD];
+real dderr_dr1_dr0_tmp[3][MAXATOMS_RMSD][3][MAXATOMS_RMSD];
+real dderr_dr0_dr1_tmp[3][MAXATOMS_RMSD][3][MAXATOMS_RMSD];
+real pi1[3][3],pi0[3][3]; 
+real tmp1,tmp2,tmp3,tmp4,tmp5,tmp6;
+//cR int ier,arg1,arg2,arg3;
+real alpha_m1[3][3],alpha_m2[3][3],alpha_m3[3][3],alpha_m4[3][3];
+xx=0.;
+yy=0.;
+zz=0.;
+tmp1=0.;
+if(iopt==5 || iopt == 7 ){
+	for(i=0;i<inpack.natoms;i++){
+		xx+=inpack.r0[0][i]*inpack.mass[i];
+		yy+=inpack.r0[1][i]*inpack.mass[i];
+		zz+=inpack.r0[2][i]*inpack.mass[i];
+                tmp1+=inpack.mass[i];
+	}
+	xx=xx/((real) tmp1);
+	yy=yy/((real) tmp1);
+	zz=zz/((real) tmp1);
+};
+work->cmr0[0]=xx;
+work->cmr0[1]=yy;
+work->cmr0[2]=zz;
+for(i=0;i<inpack.natoms;i++){
+	work->r0p[0][i]=inpack.r0[0][i]-xx;
+	work->r0p[1][i]=inpack.r0[1][i]-yy;
+	work->r0p[2][i]=inpack.r0[2][i]-zz;
+}
+xx=0.;
+yy=0.;
+zz=0.;
+tmp1=0.;
+if(iopt==6 || iopt == 7 ){
+	for(i=0;i<inpack.natoms;i++){
+		xx+=inpack.r1[0][i]*inpack.mass[i];
+		yy+=inpack.r1[1][i]*inpack.mass[i];
+		zz+=inpack.r1[2][i]*inpack.mass[i];
+                tmp1+=inpack.mass[i]; 
+	};
+	xx=xx/((real) tmp1);
+	yy=yy/((real) tmp1);
+	zz=zz/((real) tmp1);
+
+};
+work->cmr1[0]=xx;
+work->cmr1[1]=yy;
+work->cmr1[2]=zz;
+for(i=0;i<inpack.natoms;i++){
+	work->r1p[0][i]=inpack.r1[0][i]-xx;
+	work->r1p[1][i]=inpack.r1[1][i]-yy;
+	work->r1p[2][i]=inpack.r1[2][i]-zz;
+}
+// CLEAN M MATRIX
+for(i=0;i<4;i++){
+	for(j=0;j<4;j++){
+          m[i][j]=0.;  
+	}
+}
+// ASSIGN MATRIX ELEMENTS
+for(i=0;i<inpack.natoms;i++){
+	
+        tmp1=sqrt(inpack.mass[i]); 
+        rr1[0]=work->r1p[0][i]*tmp1;
+        rr1[1]=work->r1p[1][i]*tmp1;
+        rr1[2]=work->r1p[2][i]*tmp1;
+        rr0[0]=work->r0p[0][i]*tmp1;
+        rr0[1]=work->r0p[1][i]*tmp1;
+        rr0[2]=work->r0p[2][i]*tmp1;
+	
+        rrsq=pow(rr0[0],2)+pow(rr0[1],2)+pow(rr0[2],2)+pow(rr1[0],2)+pow(rr1[1],2)+pow(rr1[2],2);
+     
+        m[0][0] +=  rrsq+2.*(-rr0[0]*rr1[0]-rr0[1]*rr1[1]-rr0[2]*rr1[2]);
+        m[1][1] +=  rrsq+2.*(-rr0[0]*rr1[0]+rr0[1]*rr1[1]+rr0[2]*rr1[2]);
+        m[2][2] +=  rrsq+2.*(+rr0[0]*rr1[0]-rr0[1]*rr1[1]+rr0[2]*rr1[2]);
+        m[3][3] +=  rrsq+2.*(+rr0[0]*rr1[0]+rr0[1]*rr1[1]-rr0[2]*rr1[2]);
+        m[0][1] += 2.*(-rr0[1]*rr1[2]+rr0[2]*rr1[1]);
+        m[0][2] += 2.*( rr0[0]*rr1[2]-rr0[2]*rr1[0]);
+        m[0][3] += 2.*(-rr0[0]*rr1[1]+rr0[1]*rr1[0]);
+        m[1][2] -= 2.*( rr0[0]*rr1[1]+rr0[1]*rr1[0]);
+        m[1][3] -= 2.*( rr0[0]*rr1[2]+rr0[2]*rr1[0]);
+        m[2][3] -= 2.*( rr0[1]*rr1[2]+rr0[2]*rr1[1]);
+
+};
+m[1][0] = m[0][1];
+m[2][0] = m[0][2];
+m[2][1] = m[1][2];
+m[3][0] = m[0][3];
+m[3][1] = m[1][3];
+m[3][2] = m[2][3];
+
+// DIAGONALIZE 
+
+ql77_driver(m,lambda);
+s=1.0;
+if(m[0][0]<0.)s=-1.;//correct for negative values (?)
+q[0]=s*m[0][0];
+q[1]=s*m[1][0];
+q[2]=s*m[2][0];
+q[3]=s*m[3][0];
+work->err=sqrt(lambda[0]/((real) inpack.natoms));
+if(lambda[0]==lambda[1]) plumed_error("DIAGONALIZATION: NON UNIQUE SOLUTION");
+
+if(iopt==0){return 0;}// JUST DIAGONALIZATION REQUIRED 
+
+/*
+ * Find the ROTATION matrix
+ */
+work->d[0][0]=q[0]*q[0]+q[1]*q[1]-q[2]*q[2]-q[3]*q[3]       ; 
+work->d[1][0]=2.0*(q[1]*q[2]-q[0]*q[3]);
+work->d[2][0]=2.0*(q[1]*q[3]+q[0]*q[2]);
+work->d[0][1]=2.0*(q[1]*q[2]+q[0]*q[3]);
+work->d[1][1]=q[0]*q[0]+q[2]*q[2]-q[1]*q[1]-q[3]*q[3];
+work->d[2][1]=2.0*(q[2]*q[3]-q[0]*q[1]);
+work->d[0][2]=2.0*(q[1]*q[3]-q[0]*q[2]);
+work->d[1][2]=2.0*(q[2]*q[3]+q[0]*q[1]);
+work->d[2][2]=q[0]*q[0]+q[3]*q[3]-q[1]*q[1]-q[2]*q[2];
+#ifdef EXTREME_DEBUG
+for (i=0;i<3;i++){
+printf("D_MATRIX %12.6f %12.6f %12.6f\n",work->d[i][0],work->d[i][1],work->d[i][2]);
+}
+#endif
+/* 
+ * first derivative in perturbation theory
+ */
+dddq[0][0][0]= 2.0*q[0];
+dddq[1][0][0]=-2.0*q[3];
+dddq[2][0][0]= 2.0*q[2];
+dddq[0][1][0]= 2.0*q[3];
+dddq[1][1][0]= 2.0*q[0];
+dddq[2][1][0]=-2.0*q[1];
+dddq[0][2][0]=-2.0*q[2];
+dddq[1][2][0]= 2.0*q[1];
+dddq[2][2][0]= 2.0*q[0];
+
+dddq[0][0][1]= 2.0*q[1];
+dddq[1][0][1]= 2.0*q[2];
+dddq[2][0][1]= 2.0*q[3];
+dddq[0][1][1]= 2.0*q[2];
+dddq[1][1][1]=-2.0*q[1];
+dddq[2][1][1]=-2.0*q[0];
+dddq[0][2][1]= 2.0*q[3];
+dddq[1][2][1]= 2.0*q[0];
+dddq[2][2][1]=-2.0*q[1];
+
+dddq[0][0][2]=-2.0*q[2];
+dddq[1][0][2]= 2.0*q[1];
+dddq[2][0][2]= 2.0*q[0];
+dddq[0][1][2]= 2.0*q[1];
+dddq[1][1][2]= 2.0*q[2];
+dddq[2][1][2]= 2.0*q[3];
+dddq[0][2][2]=-2.0*q[0];
+dddq[1][2][2]= 2.0*q[3];
+dddq[2][2][2]=-2.0*q[2];
+
+dddq[0][0][3]=-2.0*q[3];
+dddq[1][0][3]=-2.0*q[0];
+dddq[2][0][3]= 2.0*q[1];
+dddq[0][1][3]= 2.0*q[0];
+dddq[1][1][3]=-2.0*q[3];
+dddq[2][1][3]= 2.0*q[2];
+dddq[0][2][3]= 2.0*q[1];
+dddq[1][2][3]= 2.0*q[2];
+dddq[2][2][3]= 2.0*q[3];
+
+#ifdef EXTREME_DEBUG
+printf("\n");
+for(i=0;i<4;i++){
+	for(j=0;j<3;j++){
+		printf("MATR %12.6f %12.6f %12.6f\n",dddq[j][0][i],dddq[j][1][i],dddq[j][2][i]);
+	}
+        printf("\n");
+}
+#endif
+/*
+ * Build gamma 3x3x3 matrix
+ */
+for(i=0;i<3;i++){     //direction 
+    for(j=0;j<3;j++){     //direction 
+        for(k=0;k<3;k++){     //eigenvector number
+            gamma[i][j][k]=0.0;
+            for(l=0;l<4;l++){   //components of each eigenvector in pert. series
+              if(lambda[0]==lambda[k+1]){
+                 plumed_error("FOUND DEGENERACY IN RMSD_ESS ROUTINE");
+               /*  write(*,*)"FOUND DEGENERACY IN RMSD_ESS ROUTINE "
+                 write(*,*)"I'm DYING...."
+                 write(*,*)"COPYING STACK HERE "
+                 write(*,*)"R0"
+                 do ll=1,n
+                  write(*,'(f8.3,f8.3,f8.3)')r0(1,ll),r0(2,ll),r0(3,ll)
+                 enddo
+                 write(*,*)"R"
+                 do ll=1,n
+                  write(*,'(f8.3,f8.3,f8.3)')r(1,ll),r(2,ll),r(3,ll)
+                 enddo
+                 stop*/
+		 } 
+              else{
+                gamma[i][j][k]=gamma[i][j][k]+dddq[i][j][l]*m[l][k+1]/(lambda[0]-lambda[k+1]);
+	      }
+	    }
+	}
+
+    }	
+}
+#ifdef EXTREME_DEBUG
+for(i=0;i<3;i++){
+	for(j=0;j<3;j++){
+		printf("GAMM %12.6f %12.6f %12.6f\n",gamma[j][0][i],gamma[j][1][i],gamma[j][2][i]);
+	}
+        printf("\n");
+}
+#endif
+/* 
+ * Table of Derivative of the quaternion matrix respect to atom position
+ */
+for(i=0;i<inpack.natoms;i++){
+
+        tmp1=(inpack.mass[i]); 
+        rr1[0]=2.*work->r1p[0][i]*tmp1;
+        rr1[1]=2.*work->r1p[1][i]*tmp1;
+        rr1[2]=2.*work->r1p[2][i]*tmp1;
+        rr0[0]=2.*work->r0p[0][i]*tmp1;
+        rr0[1]=2.*work->r0p[1][i]*tmp1;
+        rr0[2]=2.*work->r0p[2][i]*tmp1;
+     
+
+#ifdef EXTREME_DEBUG
+        printf("ATOM %12.6f %12.6f %12.6f %12.6f %12.6f %12.6f \n",rr0[0],rr0[1],rr0[2],rr1[0],rr1[1],rr1[2]);
+#endif
+
+        dm_r1 [0][0][0]=(rr1[0]-rr0[0]);
+        dm_r1 [0][0][1]=(rr1[1]-rr0[1]);
+        dm_r1 [0][0][2]=(rr1[2]-rr0[2]);
+                      
+        dm_r1 [0][1][0]=0.;
+        dm_r1 [0][1][1]= rr0[2];
+        dm_r1 [0][1][2]=-rr0[1];
+                      
+        dm_r1 [0][2][0]=-rr0[2];
+        dm_r1 [0][2][1]= 0.;
+        dm_r1 [0][2][2]= rr0[0];
+                      
+        dm_r1 [0][3][0]= rr0[1];
+        dm_r1 [0][3][1]=-rr0[0];
+        dm_r1 [0][3][2]= 0.;
+                      
+        dm_r1 [1][1][0]=(rr1[0]-rr0[0]);
+        dm_r1 [1][1][1]=(rr1[1]+rr0[1]);
+        dm_r1 [1][1][2]=(rr1[2]+rr0[2]);
+                      
+        dm_r1 [1][2][0]=-rr0[1];
+        dm_r1 [1][2][1]=-rr0[0];
+        dm_r1 [1][2][2]= 0.;
+                      
+        dm_r1 [1][3][0]=-rr0[2];
+        dm_r1 [1][3][1]= 0.;
+        dm_r1 [1][3][2]=-rr0[0];
+                      
+        dm_r1 [2][2][0]=(rr1[0]+rr0[0]);
+        dm_r1 [2][2][1]=(rr1[1]-rr0[1]);
+        dm_r1 [2][2][2]=(rr1[2]+rr0[2]);
+                      
+        dm_r1 [2][3][0]=0.;
+        dm_r1 [2][3][1]=-rr0[2];
+        dm_r1 [2][3][2]=-rr0[1];
+                      
+        dm_r1 [3][3][0]=(rr1[0]+rr0[0]);
+        dm_r1 [3][3][1]=(rr1[1]+rr0[1]);
+        dm_r1 [3][3][2]=(rr1[2]-rr0[2]);
+/*
+  derivative respec to to the other vector
+ */
+        dm_r0 [0][0][0]=-(rr1[0]-rr0[0]);
+        dm_r0 [0][0][1]=-(rr1[1]-rr0[1]);
+        dm_r0 [0][0][2]=-(rr1[2]-rr0[2]);
+                      
+        dm_r0 [0][1][0]=0.       ;
+        dm_r0 [0][1][1]=-rr1[2];
+        dm_r0 [0][1][2]=rr1[1];
+                      
+        dm_r0 [0][2][0]= rr1[2];      
+        dm_r0 [0][2][1]= 0.;
+        dm_r0 [0][2][2]=-rr1[0];
+                      
+        dm_r0 [0][3][0]=-rr1[1] ;     
+        dm_r0 [0][3][1]= rr1[0];
+        dm_r0 [0][3][2]= 0.;
+                      
+        dm_r0 [1][1][0]=-(rr1[0]-rr0[0]);
+        dm_r0 [1][1][1]=(rr1[1]+rr0[1]);
+        dm_r0 [1][1][2]=(rr1[2]+rr0[2]);
+                      
+        dm_r0 [1][2][0]=-rr1[1];
+        dm_r0 [1][2][1]=-rr1[0];
+        dm_r0 [1][2][2]= 0.;
+                      
+        dm_r0 [1][3][0]=-rr1[2];
+        dm_r0 [1][3][1]= 0.;
+        dm_r0 [1][3][2]=-rr1[0];
+                      
+        dm_r0 [2][2][0]=(rr1[0]+rr0[0]);
+        dm_r0 [2][2][1]=-(rr1[1]-rr0[1]);
+        dm_r0 [2][2][2]=(rr1[2]+rr0[2]);
+                      
+        dm_r0 [2][3][0]=0.;
+        dm_r0 [2][3][1]=-rr1[2];
+        dm_r0 [2][3][2]=-rr1[1];
+                      
+        dm_r0 [3][3][0]=(rr1[0]+rr0[0]);
+        dm_r0 [3][3][1]=(rr1[1]+rr0[1]);
+        dm_r0 [3][3][2]=-(rr1[2]-rr0[2]);
+/*
+ * write the diagonal
+ */ 
+	for(j=0;j<3;j++){
+
+          dm_r1[1][0][j]=dm_r1[0][1][j];
+          dm_r1[2][0][j]=dm_r1[0][2][j];
+          dm_r1[3][0][j]=dm_r1[0][3][j];
+          dm_r1[2][1][j]=dm_r1[1][2][j];
+          dm_r1[3][1][j]=dm_r1[1][3][j];
+          dm_r1[3][2][j]=dm_r1[2][3][j];
+
+          dm_r0[1][0][j]=dm_r0[0][1][j];
+          dm_r0[2][0][j]=dm_r0[0][2][j];
+          dm_r0[3][0][j]=dm_r0[0][3][j];
+          dm_r0[2][1][j]=dm_r0[1][2][j];
+          dm_r0[3][1][j]=dm_r0[1][3][j];
+          dm_r0[3][2][j]=dm_r0[2][3][j];
+	  
+          for(ll=0;ll<4;ll++){
+          	for(mm=0;mm<4;mm++){
+          		dm_r0_store[ll][mm][j][i]=dm_r0[ll][mm][j];
+          		dm_r1_store[ll][mm][j][i]=dm_r1[ll][mm][j];
+		};
+	  };
+ 
+	}
+#ifdef EXTREME_DEBUG
+	for(k=0;k<4;k++){
+	for(l=0;l<4;l++){
+	 printf("DM_R0 %12.6f %12.6f %12.6f\n",dm_r0[k][l][0],dm_r0[k][l][1],dm_r0[k][l][2]);
+	}
+        printf("\n"); 
+        };
+        for(k=0;k<4;k++){
+	for(l=0;l<4;l++){
+          printf("DM_R1 %12.6f %12.6f %12.6f\n",dm_r1[k][l][0],dm_r1[k][l][1],dm_r1[k][l][2]);
+	}
+        printf("\n"); 
+        };
+#endif
+/*
+ * pi matrix : coefficents in per theory
+ */
+	for(j=0;j<3;j++){
+          pi1[0][j]=0.;
+          pi1[1][j]=0.;
+          pi1[2][j]=0.;
+          pi0[0][j]=0.;
+          pi0[1][j]=0.;
+          pi0[2][j]=0.;
+          work->derr_dr1 [j][i]=0.;
+          work->derr_dr0 [j][i]=0.;
+
+          for(k=0;k<4;k++){
+            for(l=0;l<4;l++){
+              work->derr_dr1[j][i]=work->derr_dr1[j][i]+q[k]*q[l]*dm_r1[l][k][j];
+              work->derr_dr0[j][i]=work->derr_dr0[j][i]+q[k]*q[l]*dm_r0[l][k][j];
+              for(mm=0;mm<3;mm++){
+                pi0[mm][j]+=m[k][mm+1]*dm_r0[l][k][j]*q[l];
+                pi1[mm][j]+=m[k][mm+1]*dm_r1[l][k][j]*q[l];  
+	      };
+	    };
+	  };
+          work->derr_dr1[j][i]=work->derr_dr1[j][i]/sqrt(4.*inpack.natoms*lambda[0]);
+          work->derr_dr0[j][i]=work->derr_dr0[j][i]/sqrt(4.*inpack.natoms*lambda[0]);
+	};
+	for(j=0;j<3;j++){
+		for (k=0;k<3;k++){
+			for(l=0;l<3;l++){	    
+              		work->dd_dr1[j][k][l][i]=0.;
+              		work->dd_dr0[j][k][l][i]=0.;
+			for(ii=0;ii<3;ii++){
+                  		work->dd_dr1[j][k][l][i]+=gamma[j][k][ii]*pi1[ii][l]; 
+                		work->dd_dr0[j][k][l][i]+=gamma[j][k][ii]*pi0[ii][l]; 
+				}
+			}
+		}
+	}
+}
+/*
+ * Check arrays
+ */
+#ifdef EXTREME_DEBUG
+for(i=0;i<inpack.natoms;i++){
+printf("DERR_DR0 %12.6f %12.6f %12.6f\n",work->derr_dr0[0][i],work->derr_dr0[1][i],work->derr_dr0[2][i]);
+}
+printf("\n");
+for(i=0;i<inpack.natoms;i++){
+printf("DERR_DR1 %12.6f %12.6f %12.6f\n",work->derr_dr1[0][i],work->derr_dr1[1][i],work->derr_dr1[2][i]);
+}
+for(i=0;i<inpack.natoms;i++){
+for(j=0;j<3;j++){
+for(k=0;k<3;k++){
+printf("DD_DR0 %12.6f %12.6f %12.6f\n",work->dd_dr0[j][k][0][i],work->dd_dr0[j][k][1][i],work->dd_dr0[j][k][2][i]);
+}}}
+for(i=0;i<inpack.natoms;i++){
+for(j=0;j<3;j++){
+for(k=0;k<3;k++){
+printf("DD_DR1 %12.6f %12.6f %12.6f\n",work->dd_dr1[j][k][0][i],work->dd_dr1[j][k][1][i],work->dd_dr1[j][k][2][i]);
+}}}
+#endif
+/*
+ * Second derivative if asked
+ *
+ *
+ */
+if(iopt2==2){
+/*
+ *   dr0 dr
+ */
+
+for(i=0;i<3;i++){      //  r0 atom component
+	for(k=0;k<inpack.natoms;k++){ // r0 atom index 
+		for (j=0;j<3;j++){//  r atom component
+        		for(l=0;l<inpack.natoms;l++){// r atom index
+            			work->dderr_dr0_dr0[i][k][j][l]=0.;
+            			work->dderr_dr0_dr1[i][k][j][l]=0.;
+            			work->dderr_dr1_dr0[i][k][j][l]=0.;
+            			work->dderr_dr1_dr1[i][k][j][l]=0.;
+            			for(p=1;p<4;p++){//eigenvector index 
+              				 tmp1=0.;
+            				 tmp2=0.;
+              				 tmp3=0.;
+              				 tmp4=0.;
+  		 	       		 for(nn=0;nn<4;nn++){//eigenvector component
+  		 	       		 	for(mm=0;mm<4;mm++){//eigenvector component
+                    					tmp1+=(m[nn][0]*dm_r0_store[nn][mm][i][k]*m[mm][p]);
+                    					tmp2+=(m[nn][0]*dm_r1_store[nn][mm][j][l]*m[mm][p]);
+                					tmp3+=(m[nn][0]*dm_r1_store[nn][mm][i][k]*m[mm][p]);
+                    					tmp4+=(m[nn][0]*dm_r0_store[nn][mm][j][l]*m[mm][p]);
+						}
+					 }
+              				 work->dderr_dr0_dr1[i][k][j][l]+=2.*tmp1*tmp2/(lambda[0]-lambda[p]);
+              				 work->dderr_dr1_dr0[i][k][j][l]+=2.*tmp3*tmp4/(lambda[0]-lambda[p]);
+               				 work->dderr_dr1_dr1[i][k][j][l]+=2.*tmp2*tmp3/(lambda[0]-lambda[p]);
+               				 work->dderr_dr0_dr0[i][k][j][l]+=2.*tmp1*tmp4/(lambda[0]-lambda[p]);
+				};
+
+/*
+ *  second order diagonal and semi-diagonal terms
+ */
+				if(k-l==0){ 
+					if(i-j==0){ 
+				
+						work->dderr_dr1_dr1[i][k][j][l]+=2.;
+              					work->dderr_dr0_dr0[i][k][j][l]+=2.;
+						if(i==0){
+               						tmp5=2.*(-pow(m[0][0],2) - pow(m[1][0],2) 
+									+pow(m[2][0],2) +pow(m[3][0],2));
+               						tmp6=tmp5;
+						}
+						if(i==1){
+							tmp5=2.0*(-pow(m[0][0],2)+ pow(m[1][0],2) 
+									-pow(m[2][0],2) +pow(m[3][0],2));
+							tmp6=tmp5;
+						}
+						
+              					if(i==2){
+						        tmp5=2.*(-pow(m[0][0],2) + pow(m[1][0],2) 
+									+ pow(m[2][0],2) -pow(m[3][0],2));
+               						tmp6=tmp5;
+						}
+
+					}
+					else{
+
+             					if( i==1 && j==0 ){// dy dx 
+                					tmp5=4.*(-m[0][0]*m[3][0]-m[1][0]*m[2][0]);
+                					tmp6=4.*( m[0][0]*m[3][0]-m[1][0]*m[2][0]);
+              					};
+             					if( i==2 && j==0 ){// dz dx 
+                                                        tmp5=4.*( m[0][0]*m[2][0]-m[1][0]*m[3][0]);
+              						tmp6=4.*(-m[0][0]*m[2][0]-m[1][0]*m[3][0]);
+						};
+             					if( i==0 && j==1 ){// dx dy 
+                					tmp5=4.*( m[0][0]*m[3][0]-m[1][0]*m[2][0]);
+                					tmp6=4.*(-m[0][0]*m[3][0]-m[1][0]*m[2][0]);
+						};
+             					if( i==2 && j==1 ){// dz dx 
+                					tmp5=4.*(-m[0][0]*m[1][0]-m[2][0]*m[3][0]);
+                					tmp6=4.*( m[0][0]*m[1][0]-m[2][0]*m[3][0]);
+						};
+             					if( i==0 && j==2 ){// dx dz 
+                					tmp5=4.*(-m[2][0]*m[0][0]-m[3][0]*m[1][0]);
+                					tmp6=4.*( m[2][0]*m[0][0]-m[3][0]*m[1][0]);
+              					};
+             					if( i==1 && j==2 ){// dy dz 
+                					tmp5=4.*( m[1][0]*m[0][0]-m[3][0]*m[2][0]);
+                					tmp6=4.*(-m[1][0]*m[0][0]-m[3][0]*m[2][0]);
+              					};
+
+					};
+            		 		work->dderr_dr1_dr0[i][k][j][l]+=tmp5;
+             				work->dderr_dr0_dr1[i][k][j][l]+=tmp6;
+				}; 
+            			work->dderr_dr0_dr1[i][k][j][l]=
+                                work->dderr_dr0_dr1[i][k][j][l]/(2.*sqrt(lambda[0]*((real) inpack.natoms)))
+                                 -sqrt(((real) inpack.natoms)/lambda[0])*work->derr_dr0[i][k]*work->derr_dr1[j][l];
+
+    			        work->dderr_dr1_dr0[i][k][j][l]=
+          			 work->dderr_dr1_dr0[i][k][j][l]/(2.*sqrt(lambda[0]*((real) inpack.natoms)))
+            			-sqrt(((real) inpack.natoms)/lambda[0])*work->derr_dr1[i][k]*work->derr_dr0[j][l];
+
+        		        work->dderr_dr1_dr1[i][k][j][l]=
+           			 work->dderr_dr1_dr1[i][k][j][l]/(2.*sqrt(lambda[0]*((real) inpack.natoms)))
+            			-sqrt(((real) inpack.natoms)/lambda[0])*work->derr_dr1[i][k]*work->derr_dr1[j][l];
+
+            			work->dderr_dr0_dr0[i][k][j][l]=
+          			 work->dderr_dr0_dr0[i][k][j][l]/(2.*sqrt(lambda[0]*((real) inpack.natoms)))
+           			 -sqrt(((real) inpack.natoms)/lambda[0])*work->derr_dr0[i][k]*work->derr_dr0[j][l];
+			};
+		};
+	};
+};
+};
+#ifdef EXTREME_DEBUG
+for(i=0;i<inpack.natoms;i++){
+	for(j=0;j<3;j++){
+		for(l=0;l<inpack.natoms;l++){
+			printf("DDERR_DR0_DR0 %12.6f %12.6f %12.6f\n",work->dderr_dr0_dr0[j][i][0][l],work->dderr_dr0_dr0[j][i][1][l],work->dderr_dr0_dr0[j][i][2][l]);
+		}
+	}
+	
+}
+for(i=0;i<inpack.natoms;i++){
+	for(j=0;j<3;j++){
+		for(l=0;l<inpack.natoms;l++){
+			printf("DDERR_DR1_DR1 %12.6f %12.6f %12.6f\n",work->dderr_dr1_dr1[j][i][0][l],work->dderr_dr1_dr1[j][i][1][l],work->dderr_dr1_dr1[j][i][2][l]);
+		}
+	}
+	
+}	
+for(i=0;i<inpack.natoms;i++){
+	for(j=0;j<3;j++){
+		for(l=0;l<inpack.natoms;l++){
+			printf("DDERR_DR0_DR1 %12.6f %12.6f %12.6f\n",work->dderr_dr0_dr1[j][i][0][l],work->dderr_dr0_dr1[j][i][1][l],work->dderr_dr0_dr1[j][i][2][l]);
+		}
+	}
+	
+}	
+for(i=0;i<inpack.natoms;i++){
+	for(j=0;j<3;j++){
+		for(l=0;l<inpack.natoms;l++){
+			printf("DDERR_DR1_DR0 %12.6f %12.6f %12.6f\n",work->dderr_dr1_dr0[j][i][0][l],work->dderr_dr1_dr0[j][i][1][l],work->dderr_dr1_dr0[j][i][2][l]);
+		}
+	}
+	
+}
+#endif
+/*
+ * Now correct for cm - hard part in 2nd derivative
+ *
+ */
+if(iopt==6 || iopt==7){
+	for(l=0;l<3;l++){
+		for(i=0;i<inpack.natoms;i++){
+                derr_dr1_tmp[l][i]=work->derr_dr1[l][i];
+			for(j=0;j<inpack.natoms;j++){
+                        	derr_dr1_tmp[l][i]-=(1./((real) inpack.natoms))*work->derr_dr1[l][j];
+			}
+		}	
+	}
+	for(l=0;l<3;l++){
+		for(i=0;i<inpack.natoms;i++){
+			work->derr_dr1[l][i]=derr_dr1_tmp[l][i];
+		}
+	}	
+}
+if(iopt==5 || iopt==7){
+	for(l=0;l<3;l++){
+		for(i=0;i<inpack.natoms;i++){
+                derr_dr0_tmp[l][i]=work->derr_dr0[l][i];
+			for(j=0;j<inpack.natoms;j++){
+                        	derr_dr0_tmp[l][i]-=(1./((real) inpack.natoms))*work->derr_dr0[l][j];
+			}
+		}	
+	}
+	for(l=0;l<3;l++){
+		for(i=0;i<inpack.natoms;i++){
+			work->derr_dr0[l][i]=derr_dr0_tmp[l][i];
+		}
+	}	
+}
+#ifdef EXTREME_DEBUG
+for(i=0;i<inpack.natoms;i++){
+printf("DERR_DR0 %12.6f %12.6f %12.6f\n",work->derr_dr0[0][i],work->derr_dr0[1][i],work->derr_dr0[2][i]);
+}
+for(i=0;i<inpack.natoms;i++){
+printf("DERR_DR1_CM %12.6f %12.6f %12.6f\n",work->derr_dr1[0][i],work->derr_dr1[1][i],work->derr_dr1[2][i]);
+}
+#endif
+if(iopt2==2){
+	if(iopt==6){//dr1 correction
+		for(ix=0;ix<3;ix++){	
+			for(jx=0;jx<3;jx++){	
+                                alpha_m1[ix][jx]=0.0;
+				for(i=0;i<inpack.natoms;i++){	
+					for(j=0;j<inpack.natoms;j++){	
+                                        alpha_m1[ix][jx]+=work->dderr_dr1_dr1[ix][i][jx][j];
+					}
+				}
+		        	alpha_m1[ix][jx]= alpha_m1[ix][jx]/(((real) inpack.natoms*inpack.natoms));
+			}
+		}
+		for(ix=0;ix<3;ix++){	
+			for(i=0;i<inpack.natoms;i++){	
+				for(jx=0;jx<3;jx++){	
+					for(j=0;j<inpack.natoms;j++){	
+						dderr_dr1_dr1_tmp[ix][i][jx][j]=work->dderr_dr1_dr1[ix][i][jx][j];
+						dderr_dr1_dr0_tmp[ix][i][jx][j]=work->dderr_dr0_dr1[ix][i][jx][j];
+						dderr_dr0_dr1_tmp[ix][i][jx][j]=work->dderr_dr1_dr0[ix][i][jx][j];
+						for(mm=0;mm<inpack.natoms;mm++){
+							dderr_dr1_dr0_tmp[ix][i][jx][j]-=
+								(1./((real) inpack.natoms))*work->dderr_dr1_dr0[ix][i][jx][mm];
+							dderr_dr0_dr1_tmp[ix][i][jx][j]-=
+								(1./((real) inpack.natoms))*work->dderr_dr0_dr1[ix][i][jx][mm];
+							dderr_dr1_dr1_tmp[ix][i][jx][j]-=
+								(1./((real) inpack.natoms))*
+						         	(work->dderr_dr1_dr1[ix][i][jx][mm]+work->dderr_dr1_dr1[ix][mm][jx][j]);
+						}
+						dderr_dr1_dr1_tmp[ix][i][jx][j]+=alpha_m1[ix][jx];
+
+					}
+				}
+			}
+
+		}
+		for(ix=0;ix<3;ix++){	
+			for(i=0;i<inpack.natoms;i++){	
+				for(jx=0;jx<3;jx++){	
+					for(j=0;j<inpack.natoms;j++){	
+						work->dderr_dr1_dr1[ix][i][jx][j]=dderr_dr1_dr1_tmp[ix][i][jx][j];
+						work->dderr_dr1_dr0[ix][i][jx][j]=dderr_dr1_dr0_tmp[ix][i][jx][j];
+						work->dderr_dr0_dr1[ix][i][jx][j]=dderr_dr0_dr1_tmp[ix][i][jx][j];
+					}
+				}
+			}
+		}	
+	}
+	else if(iopt==5){//dr0 correction
+		for(ix=0;ix<3;ix++){	
+			for(jx=0;jx<3;jx++){	
+                                alpha_m1[ix][jx]=0.0;
+				for(i=0;i<inpack.natoms;i++){	
+					for(j=0;j<inpack.natoms;j++){	
+                                        alpha_m1[ix][jx]+=work->dderr_dr0_dr0[ix][i][jx][j];
+					}
+				}
+		        	alpha_m1[ix][jx]= alpha_m1[ix][jx]/(((real) inpack.natoms*inpack.natoms));
+			}
+		}
+		for(ix=0;ix<3;ix++){	
+			for(i=0;i<inpack.natoms;i++){	
+				for(jx=0;jx<3;jx++){	
+					for(j=0;j<inpack.natoms;j++){	
+						dderr_dr0_dr0_tmp[ix][i][jx][j]=work->dderr_dr0_dr0[ix][i][jx][j];
+						dderr_dr1_dr0_tmp[ix][i][jx][j]=work->dderr_dr1_dr0[ix][i][jx][j];
+						dderr_dr0_dr1_tmp[ix][i][jx][j]=work->dderr_dr0_dr1[ix][i][jx][j];
+						for(mm=0;mm<inpack.natoms;mm++){
+							dderr_dr1_dr0_tmp[ix][i][jx][j]-=
+								(1./((real) inpack.natoms))*work->dderr_dr1_dr0[ix][i][jx][mm];
+							dderr_dr0_dr1_tmp[ix][i][jx][j]-=
+								(1./((real) inpack.natoms))*work->dderr_dr0_dr1[ix][i][jx][mm];
+							dderr_dr0_dr0_tmp[ix][i][jx][j]-=
+								(1./((real) inpack.natoms))*
+						         	(work->dderr_dr0_dr0[ix][i][jx][mm]+work->dderr_dr0_dr0[ix][mm][jx][j]);
+						}
+						dderr_dr0_dr0_tmp[ix][i][jx][j]+= alpha_m1[ix][jx];
+					}
+				}
+			}
+	
+		}
+		for(ix=0;ix<3;ix++){	
+			for(i=0;i<inpack.natoms;i++){	
+				for(jx=0;jx<3;jx++){	
+					for(j=0;j<inpack.natoms;j++){	
+						work->dderr_dr0_dr0[ix][i][jx][j]=dderr_dr0_dr0_tmp[ix][i][jx][j];
+						work->dderr_dr1_dr0[ix][i][jx][j]=dderr_dr1_dr0_tmp[ix][i][jx][j];
+						work->dderr_dr0_dr1[ix][i][jx][j]=dderr_dr0_dr1_tmp[ix][i][jx][j];
+					}
+				}
+			}
+		}	
+	}
+	else if(iopt==7){
+		for(ix=0;ix<3;ix++){	
+			for(jx=0;jx<3;jx++){	
+                                alpha_m1[ix][jx]=0.0;
+                                alpha_m2[ix][jx]=0.0;
+                                alpha_m3[ix][jx]=0.0;
+                                alpha_m4[ix][jx]=0.0;
+				for(i=0;i<inpack.natoms;i++){	
+					for(j=0;j<inpack.natoms;j++){	
+                                     		alpha_m1[ix][jx]+=work->dderr_dr0_dr0[ix][i][jx][j];
+                           	        	alpha_m2[ix][jx]+=work->dderr_dr1_dr1[ix][i][jx][j];
+                               			alpha_m3[ix][jx]+=work->dderr_dr0_dr1[ix][i][jx][j];
+                               	       	 	alpha_m4[ix][jx]+=work->dderr_dr1_dr0[ix][i][jx][j];
+					}
+				}
+		        	alpha_m1[ix][jx]= alpha_m1[ix][jx]/(((real) inpack.natoms*inpack.natoms));
+		        	alpha_m2[ix][jx]= alpha_m2[ix][jx]/(((real) inpack.natoms*inpack.natoms));
+		        	alpha_m3[ix][jx]= alpha_m3[ix][jx]/(((real) inpack.natoms*inpack.natoms));
+		        	alpha_m4[ix][jx]= alpha_m4[ix][jx]/(((real) inpack.natoms*inpack.natoms));
+			}
+		}
+		for(ix=0;ix<3;ix++){	
+			for(i=0;i<inpack.natoms;i++){	
+				for(jx=0;jx<3;jx++){	
+					for(j=0;j<inpack.natoms;j++){	
+						dderr_dr0_dr0_tmp[ix][i][jx][j]=work->dderr_dr0_dr0[ix][i][jx][j];
+						dderr_dr1_dr1_tmp[ix][i][jx][j]=work->dderr_dr1_dr1[ix][i][jx][j];
+						dderr_dr1_dr0_tmp[ix][i][jx][j]=work->dderr_dr1_dr0[ix][i][jx][j];
+						dderr_dr0_dr1_tmp[ix][i][jx][j]=work->dderr_dr0_dr1[ix][i][jx][j];
+						for(mm=0;mm<inpack.natoms;mm++){
+							dderr_dr0_dr0_tmp[ix][i][jx][j]-=
+								(1./((real) inpack.natoms))*
+						         	(work->dderr_dr0_dr0[ix][i][jx][mm]+work->dderr_dr0_dr0[ix][mm][jx][j]);
+							dderr_dr1_dr1_tmp[ix][i][jx][j]-=
+								(1./((real) inpack.natoms))*
+						         	(work->dderr_dr1_dr1[ix][i][jx][mm]+work->dderr_dr1_dr1[ix][mm][jx][j]);
+							dderr_dr0_dr1_tmp[ix][i][jx][j]-=
+								(1./((real) inpack.natoms))*
+						         	(work->dderr_dr0_dr1[ix][i][jx][mm]+work->dderr_dr0_dr1[ix][mm][jx][j]);
+							dderr_dr1_dr0_tmp[ix][i][jx][j]-=
+								(1./((real) inpack.natoms))*
+					         		(work->dderr_dr1_dr0[ix][i][jx][mm]+work->dderr_dr1_dr0[ix][mm][jx][j]);
+						}
+						dderr_dr0_dr0_tmp[ix][i][jx][j]+=alpha_m1[ix][jx];
+						dderr_dr1_dr1_tmp[ix][i][jx][j]+=alpha_m2[ix][jx];
+						dderr_dr0_dr1_tmp[ix][i][jx][j]+=alpha_m3[ix][jx];
+						dderr_dr1_dr0_tmp[ix][i][jx][j]+=alpha_m4[ix][jx];
+					}
+				}
+			}
+
+		}
+		for(ix=0;ix<3;ix++){	
+			for(i=0;i<inpack.natoms;i++){	
+				for(jx=0;jx<3;jx++){	
+					for(j=0;j<inpack.natoms;j++){	
+						work->dderr_dr0_dr0[ix][i][jx][j]=dderr_dr0_dr0_tmp[ix][i][jx][j];
+						work->dderr_dr1_dr1[ix][i][jx][j]=dderr_dr1_dr1_tmp[ix][i][jx][j];
+						work->dderr_dr1_dr0[ix][i][jx][j]=dderr_dr1_dr0_tmp[ix][i][jx][j];
+						work->dderr_dr0_dr1[ix][i][jx][j]=dderr_dr0_dr1_tmp[ix][i][jx][j];
+					}
+				}
+			}
+		}	
+
+	}
+}
+#ifdef EXTREME_DEBUG
+for(i=0;i<inpack.natoms;i++){
+	for(j=0;j<3;j++){
+		for(l=0;l<inpack.natoms;l++){
+			printf("DDERR_DR0_DR0_CM %12.6f %12.6f %12.6f\n",work->dderr_dr0_dr0[j][i][0][l],work->dderr_dr0_dr0[j][i][1][l],work->dderr_dr0_dr0[j][i][2][l]);
+		}
+	}
+	
+}
+for(i=0;i<inpack.natoms;i++){
+	for(j=0;j<3;j++){
+		for(l=0;l<inpack.natoms;l++){
+			printf("DDERR_DR1_DR1_CM %12.6f %12.6f %12.6f\n",work->dderr_dr1_dr1[j][i][0][l],work->dderr_dr1_dr1[j][i][1][l],work->dderr_dr1_dr1[j][i][2][l]);
+		}
+	}
+	
+}	
+for(i=0;i<inpack.natoms;i++){
+	for(j=0;j<3;j++){
+		for(l=0;l<inpack.natoms;l++){
+			printf("DDERR_DR0_DR1_CM %12.6f %12.6f %12.6f\n",work->dderr_dr0_dr1[j][i][0][l],work->dderr_dr0_dr1[j][i][1][l],work->dderr_dr0_dr1[j][i][2][l]);
+		}
+	}
+	
+}	
+for(i=0;i<inpack.natoms;i++){
+	for(j=0;j<3;j++){
+		for(l=0;l<inpack.natoms;l++){
+			printf("DDERR_DR1_DR0_CM %12.6f %12.6f %12.6f\n",work->dderr_dr1_dr0[j][i][0][l],work->dderr_dr1_dr0[j][i][1][l],work->dderr_dr1_dr0[j][i][2][l]);
+		}
+	}
+	
+}
+#endif
+
+return 0;
+}
+
+// ------------------------------------------------------------------------------------------------
+//
+// iopt=5 reset cm of r0
+// iopt=6 reset cm of r1
+// iopt=7 reset cm of r0 and r1
+// simple=1 correction on the eigenvalue rmsd only
+// simple=0 derivative of the rotation matrix 
+// simple=2 derivative of the rotation matrix  and eigenvalues
+// 
+
+int PREFIX rmsd_mini_pack(struct rmsd_inpack inpack,struct rmsd_mini_outpack *work,int iopt, int simple, int permissive)
+{
+/* declarations */
+int i,j,k,l,ll,mm,ii,iopt2;
+real rrsq,xx,yy,zz,m[4][4],rr1[4],rr0[4];
+real lambda[4],s,q[4],fact1,fact2;
+real dddq[3][3][4],gamma[3][3][3];
+real dm_r1[4][4][3],dm_r0[4][4][3];
+real dm_r1_store[4][4][3][MAXATOMS_RMSD];
+real dm_r0_store[4][4][3][MAXATOMS_RMSD];
+real derr_dr1_tmp[3][MAXATOMS_RMSD];
+real derr_dr0_tmp[3][MAXATOMS_RMSD];
+real pi1[3][3],pi0[3][3],tmp1,dnatoms; 
+real dd_dr_temp[3][3][3][MAXATOMS_RMSD];
+xx=0.;
+yy=0.;
+zz=0.;
+tmp1=0.;
+dnatoms=(inpack.natoms);
+if(iopt==5 || iopt == 7 ){
+	for(i=0;i<inpack.natoms;i++){
+		xx+=inpack.r0[0][i]*inpack.mass[i];
+		yy+=inpack.r0[1][i]*inpack.mass[i];
+		zz+=inpack.r0[2][i]*inpack.mass[i];
+//                tmp1+=inpack.mass[i];
+                // no mass weight
+//		xx+=inpack.r0[0][i];
+//		yy+=inpack.r0[1][i];
+//		zz+=inpack.r0[2][i];
+//      
+	}
+//	xx=xx/((real) tmp1);
+//	yy=yy/((real) tmp1);
+//	zz=zz/((real) tmp1);
+        xx=xx/(inpack.totmass);
+        yy=yy/(inpack.totmass);
+        zz=zz/(inpack.totmass);
+//        xx=xx/dnatoms;
+//        yy=yy/dnatoms;
+//        zz=zz/dnatoms;
+};
+work->cmr0[0]=xx;
+work->cmr0[1]=yy;
+work->cmr0[2]=zz;
+for(i=0;i<inpack.natoms;i++){
+	work->r0p[0][i]=inpack.r0[0][i]-xx;
+	work->r0p[1][i]=inpack.r0[1][i]-yy;
+	work->r0p[2][i]=inpack.r0[2][i]-zz;
+        // additional weighting 
+       	work->r0p[0][i]*=inpack.mass[i];
+	work->r0p[1][i]*=inpack.mass[i];
+	work->r0p[2][i]*=inpack.mass[i];
+
+ 
+}
+xx=0.;
+yy=0.;
+zz=0.;
+tmp1=0.;
+if(iopt==6 || iopt == 7 ){
+	for(i=0;i<inpack.natoms;i++){
+		xx+=inpack.r1[0][i]*inpack.mass[i];
+		yy+=inpack.r1[1][i]*inpack.mass[i];
+		zz+=inpack.r1[2][i]*inpack.mass[i];
+//              tmp1+=inpack.mass[i]; 
+//		xx+=inpack.r1[0][i];
+//		yy+=inpack.r1[1][i];
+//		zz+=inpack.r1[2][i];
+//      
+	};
+//	xx=xx/((real) tmp1);
+//	yy=yy/((real) tmp1);
+//	zz=zz/((real) tmp1);
+        xx=xx/(inpack.totmass);
+        yy=yy/(inpack.totmass);
+        zz=zz/(inpack.totmass);
+//        xx=xx/(dnatoms);
+//        yy=yy/(dnatoms);
+//        zz=zz/(dnatoms);
+
+};
+work->cmr1[0]=xx;
+work->cmr1[1]=yy;
+work->cmr1[2]=zz;
+for(i=0;i<inpack.natoms;i++){
+	work->r1p[0][i]=inpack.r1[0][i]-xx;
+	work->r1p[1][i]=inpack.r1[1][i]-yy;
+	work->r1p[2][i]=inpack.r1[2][i]-zz;
+        // additional weighting 
+	work->r1p[0][i]*=inpack.mass[i];
+	work->r1p[1][i]*=inpack.mass[i];
+	work->r1p[2][i]*=inpack.mass[i];
+
+}
+// CLEAN M MATRIX
+for(i=0;i<4;i++){
+	for(j=0;j<4;j++){
+          m[i][j]=0.;  
+	}
+}
+// ASSIGN MATRIX ELEMENTS
+for(i=0;i<inpack.natoms;i++){
+	
+        rr1[0]=work->r1p[0][i];
+        rr1[1]=work->r1p[1][i];
+        rr1[2]=work->r1p[2][i];
+        rr0[0]=work->r0p[0][i];
+        rr0[1]=work->r0p[1][i];
+        rr0[2]=work->r0p[2][i];
+	
+        rrsq=pow(rr0[0],2)+pow(rr0[1],2)+pow(rr0[2],2)+pow(rr1[0],2)+pow(rr1[1],2)+pow(rr1[2],2);
+     
+        m[0][0] +=  rrsq+2.*(-rr0[0]*rr1[0]-rr0[1]*rr1[1]-rr0[2]*rr1[2]);
+        m[1][1] +=  rrsq+2.*(-rr0[0]*rr1[0]+rr0[1]*rr1[1]+rr0[2]*rr1[2]);
+        m[2][2] +=  rrsq+2.*(+rr0[0]*rr1[0]-rr0[1]*rr1[1]+rr0[2]*rr1[2]);
+        m[3][3] +=  rrsq+2.*(+rr0[0]*rr1[0]+rr0[1]*rr1[1]-rr0[2]*rr1[2]);
+        m[0][1] += 2.*(-rr0[1]*rr1[2]+rr0[2]*rr1[1]);
+        m[0][2] += 2.*( rr0[0]*rr1[2]-rr0[2]*rr1[0]);
+        m[0][3] += 2.*(-rr0[0]*rr1[1]+rr0[1]*rr1[0]);
+        m[1][2] -= 2.*( rr0[0]*rr1[1]+rr0[1]*rr1[0]);
+        m[1][3] -= 2.*( rr0[0]*rr1[2]+rr0[2]*rr1[0]);
+        m[2][3] -= 2.*( rr0[1]*rr1[2]+rr0[2]*rr1[1]);
+
+};
+m[1][0] = m[0][1];
+m[2][0] = m[0][2];
+m[2][1] = m[1][2];
+m[3][0] = m[0][3];
+m[3][1] = m[1][3];
+m[3][2] = m[2][3];
+
+// DIAGONALIZE 
+int error;
+error=ql77_driver(m,lambda);
+s=1.0;
+if(m[0][0]<0.)s=-1.;//correct for negative values (?)
+q[0]=s*m[0][0];
+q[1]=s*m[1][0];
+q[2]=s*m[2][0];
+q[3]=s*m[3][0];
+work->err=sqrt(lambda[0]/(dnatoms));
+if (permissive!=1){
+	if(lambda[0]==lambda[1]) plumed_error("DIAGONALIZATION: NON UNIQUE SOLUTION");
+}else if (permissive==1) {
+	if(lambda[0]==lambda[1]) {fprintf(mtd_data.fplog,"|- WARNING: DEGENERACY IN THE DIAGONALIZATION...KEEP ON GOING!\n");} 
+}
+if(iopt==0){return 0;}// JUST DIAGONALIZATION REQUIRED 
+
+/*
+ * Find the ROTATION matrix
+ */
+work->d[0][0]=q[0]*q[0]+q[1]*q[1]-q[2]*q[2]-q[3]*q[3]       ; 
+work->d[1][0]=2.0*(q[1]*q[2]-q[0]*q[3]);
+work->d[2][0]=2.0*(q[1]*q[3]+q[0]*q[2]);
+work->d[0][1]=2.0*(q[1]*q[2]+q[0]*q[3]);
+work->d[1][1]=q[0]*q[0]+q[2]*q[2]-q[1]*q[1]-q[3]*q[3];
+work->d[2][1]=2.0*(q[2]*q[3]-q[0]*q[1]);
+work->d[0][2]=2.0*(q[1]*q[3]-q[0]*q[2]);
+work->d[1][2]=2.0*(q[2]*q[3]+q[0]*q[1]);
+work->d[2][2]=q[0]*q[0]+q[3]*q[3]-q[1]*q[1]-q[2]*q[2];
+#ifdef EXTREME_DEBUG
+for (i=0;i<3;i++){
+printf("D_MATRIX %12.6f %12.6f %12.6f\n",work->d[i][0],work->d[i][1],work->d[i][2]);
+}
+#endif
+/* 
+ * first derivative in perturbation theory
+ */
+dddq[0][0][0]= 2.0*q[0];
+dddq[1][0][0]=-2.0*q[3];
+dddq[2][0][0]= 2.0*q[2];
+dddq[0][1][0]= 2.0*q[3];
+dddq[1][1][0]= 2.0*q[0];
+dddq[2][1][0]=-2.0*q[1];
+dddq[0][2][0]=-2.0*q[2];
+dddq[1][2][0]= 2.0*q[1];
+dddq[2][2][0]= 2.0*q[0];
+
+dddq[0][0][1]= 2.0*q[1];
+dddq[1][0][1]= 2.0*q[2];
+dddq[2][0][1]= 2.0*q[3];
+dddq[0][1][1]= 2.0*q[2];
+dddq[1][1][1]=-2.0*q[1];
+dddq[2][1][1]=-2.0*q[0];
+dddq[0][2][1]= 2.0*q[3];
+dddq[1][2][1]= 2.0*q[0];
+dddq[2][2][1]=-2.0*q[1];
+
+dddq[0][0][2]=-2.0*q[2];
+dddq[1][0][2]= 2.0*q[1];
+dddq[2][0][2]= 2.0*q[0];
+dddq[0][1][2]= 2.0*q[1];
+dddq[1][1][2]= 2.0*q[2];
+dddq[2][1][2]= 2.0*q[3];
+dddq[0][2][2]=-2.0*q[0];
+dddq[1][2][2]= 2.0*q[3];
+dddq[2][2][2]=-2.0*q[2];
+
+dddq[0][0][3]=-2.0*q[3];
+dddq[1][0][3]=-2.0*q[0];
+dddq[2][0][3]= 2.0*q[1];
+dddq[0][1][3]= 2.0*q[0];
+dddq[1][1][3]=-2.0*q[3];
+dddq[2][1][3]= 2.0*q[2];
+dddq[0][2][3]= 2.0*q[1];
+dddq[1][2][3]= 2.0*q[2];
+dddq[2][2][3]= 2.0*q[3];
+
+#ifdef EXTREME_DEBUG
+printf("\n");
+for(i=0;i<4;i++){
+	for(j=0;j<3;j++){
+		printf("MATR %12.6f %12.6f %12.6f\n",dddq[j][0][i],dddq[j][1][i],dddq[j][2][i]);
+	}
+        printf("\n");
+}
+#endif
+int dump_zero;
+dump_zero=0;
+/*
+ * Build gamma 3x3x3 matrix
+ */
+for(i=0;i<3;i++){     //direction 
+    for(j=0;j<3;j++){     //direction 
+        for(k=0;k<3;k++){     //eigenvector number
+            gamma[i][j][k]=0.0;
+            for(l=0;l<4;l++){   //components of each eigenvector in pert. series
+              if(lambda[0]==lambda[k+1]){
+                if (permissive!=1){		
+                 plumed_error("FOUND DEGENERACY IN RMSD_ESS ROUTINE");
+                }else if (permissive==1){
+                  // give a signal to put the derivatives to zero
+		  dump_zero=1;
+                }
+              }else{
+                gamma[i][j][k]=gamma[i][j][k]+dddq[i][j][l]*m[l][k+1]/(lambda[0]-lambda[k+1]);
+	      }
+	    }
+	}
+
+    }	
+}
+// if this is set just put derivatives to zero in case of error=0. or degenerate eigenvalues 
+if(dump_zero==1){
+  fprintf(mtd_data.fplog,"|- WARNING: USING A FAKE VALUE FOR MSD \n"); 
+  for(i=0;i<inpack.natoms;i++){
+	for(j=0;j<3;j++){
+		work->derr_dr1[j][i]=0.;		
+		work->derr_dr0[j][i]=0.;		
+		for (k=0;k<3;k++){
+  			// ders of rotmatrix
+			for(l=0;l<3;l++){	    
+      				work->dd_dr1[j][k][l][i]=0.; 
+      				work->dd_dr0[j][k][l][i]=0.; 
+                        } 
+                } 
+        } 
+  } 
+  return 1;
+}
+#ifdef EXTREME_DEBUG
+for(i=0;i<3;i++){
+	for(j=0;j<3;j++){
+		printf("GAMM %12.6f %12.6f %12.6f\n",gamma[j][0][i],gamma[j][1][i],gamma[j][2][i]);
+	}
+        printf("\n");
+}
+#endif
+/* 
+ * Table of Derivative of the quaternion matrix respect to atom position
+ */
+fact1=sqrt(4.*dnatoms*lambda[0]);
+for(i=0;i<inpack.natoms;i++){
+
+        //tmp1=(inpack.mass[i]); 
+        tmp1=1.0; 
+        rr1[0]=2.*work->r1p[0][i]*tmp1;
+        rr1[1]=2.*work->r1p[1][i]*tmp1;
+        rr1[2]=2.*work->r1p[2][i]*tmp1;
+        rr0[0]=2.*work->r0p[0][i]*tmp1;
+        rr0[1]=2.*work->r0p[1][i]*tmp1;
+        rr0[2]=2.*work->r0p[2][i]*tmp1;
+     
+
+#ifdef EXTREME_DEBUG
+        printf("ATOM %12.6f %12.6f %12.6f %12.6f %12.6f %12.6f \n",rr0[0],rr0[1],rr0[2],rr1[0],rr1[1],rr1[2]);
+#endif
+
+        dm_r1 [0][0][0]=(rr1[0]-rr0[0]);
+        dm_r1 [0][0][1]=(rr1[1]-rr0[1]);
+        dm_r1 [0][0][2]=(rr1[2]-rr0[2]);
+                      
+        dm_r1 [0][1][0]=0.;
+        dm_r1 [0][1][1]= rr0[2];
+        dm_r1 [0][1][2]=-rr0[1];
+                      
+        dm_r1 [0][2][0]=-rr0[2];
+        dm_r1 [0][2][1]= 0.;
+        dm_r1 [0][2][2]= rr0[0];
+                      
+        dm_r1 [0][3][0]= rr0[1];
+        dm_r1 [0][3][1]=-rr0[0];
+        dm_r1 [0][3][2]= 0.;
+                      
+        dm_r1 [1][1][0]=(rr1[0]-rr0[0]);
+        dm_r1 [1][1][1]=(rr1[1]+rr0[1]);
+        dm_r1 [1][1][2]=(rr1[2]+rr0[2]);
+                      
+        dm_r1 [1][2][0]=-rr0[1];
+        dm_r1 [1][2][1]=-rr0[0];
+        dm_r1 [1][2][2]= 0.;
+                      
+        dm_r1 [1][3][0]=-rr0[2];
+        dm_r1 [1][3][1]= 0.;
+        dm_r1 [1][3][2]=-rr0[0];
+                      
+        dm_r1 [2][2][0]=(rr1[0]+rr0[0]);
+        dm_r1 [2][2][1]=(rr1[1]-rr0[1]);
+        dm_r1 [2][2][2]=(rr1[2]+rr0[2]);
+                      
+        dm_r1 [2][3][0]=0.;
+        dm_r1 [2][3][1]=-rr0[2];
+        dm_r1 [2][3][2]=-rr0[1];
+                      
+        dm_r1 [3][3][0]=(rr1[0]+rr0[0]);
+        dm_r1 [3][3][1]=(rr1[1]+rr0[1]);
+        dm_r1 [3][3][2]=(rr1[2]-rr0[2]);
+/*
+  derivative respec to to the other vector
+ */
+        dm_r0 [0][0][0]=-(rr1[0]-rr0[0]);
+        dm_r0 [0][0][1]=-(rr1[1]-rr0[1]);
+        dm_r0 [0][0][2]=-(rr1[2]-rr0[2]);
+                      
+        dm_r0 [0][1][0]=0.       ;
+        dm_r0 [0][1][1]=-rr1[2];
+        dm_r0 [0][1][2]=rr1[1];
+                      
+        dm_r0 [0][2][0]= rr1[2];      
+        dm_r0 [0][2][1]= 0.;
+        dm_r0 [0][2][2]=-rr1[0];
+                      
+        dm_r0 [0][3][0]=-rr1[1] ;     
+        dm_r0 [0][3][1]= rr1[0];
+        dm_r0 [0][3][2]= 0.;
+                      
+        dm_r0 [1][1][0]=-(rr1[0]-rr0[0]);
+        dm_r0 [1][1][1]=(rr1[1]+rr0[1]);
+        dm_r0 [1][1][2]=(rr1[2]+rr0[2]);
+                      
+        dm_r0 [1][2][0]=-rr1[1];
+        dm_r0 [1][2][1]=-rr1[0];
+        dm_r0 [1][2][2]= 0.;
+                      
+        dm_r0 [1][3][0]=-rr1[2];
+        dm_r0 [1][3][1]= 0.;
+        dm_r0 [1][3][2]=-rr1[0];
+                      
+        dm_r0 [2][2][0]=(rr1[0]+rr0[0]);
+        dm_r0 [2][2][1]=-(rr1[1]-rr0[1]);
+        dm_r0 [2][2][2]=(rr1[2]+rr0[2]);
+                      
+        dm_r0 [2][3][0]=0.;
+        dm_r0 [2][3][1]=-rr1[2];
+        dm_r0 [2][3][2]=-rr1[1];
+                      
+        dm_r0 [3][3][0]=(rr1[0]+rr0[0]);
+        dm_r0 [3][3][1]=(rr1[1]+rr0[1]);
+        dm_r0 [3][3][2]=-(rr1[2]-rr0[2]);
+/*
+ * write the diagonal
+ */ 
+	for(j=0;j<3;j++){
+
+          dm_r1[1][0][j]=dm_r1[0][1][j];
+          dm_r1[2][0][j]=dm_r1[0][2][j];
+          dm_r1[3][0][j]=dm_r1[0][3][j];
+          dm_r1[2][1][j]=dm_r1[1][2][j];
+          dm_r1[3][1][j]=dm_r1[1][3][j];
+          dm_r1[3][2][j]=dm_r1[2][3][j];
+
+          dm_r0[1][0][j]=dm_r0[0][1][j];
+          dm_r0[2][0][j]=dm_r0[0][2][j];
+          dm_r0[3][0][j]=dm_r0[0][3][j];
+          dm_r0[2][1][j]=dm_r0[1][2][j];
+          dm_r0[3][1][j]=dm_r0[1][3][j];
+          dm_r0[3][2][j]=dm_r0[2][3][j];
+	  
+          for(ll=0;ll<4;ll++){
+          	for(mm=0;mm<4;mm++){
+          		dm_r0_store[ll][mm][j][i]=dm_r0[ll][mm][j];
+          		dm_r1_store[ll][mm][j][i]=dm_r1[ll][mm][j];
+		};
+	  };
+ 
+	}
+#ifdef EXTREME_DEBUG
+	for(k=0;k<4;k++){
+	for(l=0;l<4;l++){
+	 printf("DM_R0 %12.6f %12.6f %12.6f\n",dm_r0[k][l][0],dm_r0[k][l][1],dm_r0[k][l][2]);
+	}
+        printf("\n"); 
+        };
+        for(k=0;k<4;k++){
+	for(l=0;l<4;l++){
+          printf("DM_R1 %12.6f %12.6f %12.6f\n",dm_r1[k][l][0],dm_r1[k][l][1],dm_r1[k][l][2]);
+	}
+        printf("\n"); 
+        };
+#endif
+/*
+ * pi matrix : coefficents in per theory
+ */
+	for(j=0;j<3;j++){
+          pi1[0][j]=0.;
+          pi1[1][j]=0.;
+          pi1[2][j]=0.;
+          pi0[0][j]=0.;
+          pi0[1][j]=0.;
+          pi0[2][j]=0.;
+          work->derr_dr1 [j][i]=0.;
+          work->derr_dr0 [j][i]=0.;
+
+          for(k=0;k<4;k++){
+            for(l=0;l<4;l++){
+              work->derr_dr1[j][i]=work->derr_dr1[j][i]+q[k]*q[l]*dm_r1[l][k][j];
+              work->derr_dr0[j][i]=work->derr_dr0[j][i]+q[k]*q[l]*dm_r0[l][k][j];
+              for(mm=0;mm<3;mm++){
+                pi0[mm][j]+=m[k][mm+1]*dm_r0[l][k][j]*q[l];
+                pi1[mm][j]+=m[k][mm+1]*dm_r1[l][k][j]*q[l];  
+	      };
+	    };
+	  };
+          work->derr_dr1[j][i]=work->derr_dr1[j][i]/fact1;
+          work->derr_dr0[j][i]=work->derr_dr0[j][i]/fact1;
+
+	};
+	for(j=0;j<3;j++){
+		for (k=0;k<3;k++){
+			for(l=0;l<3;l++){	    
+              		work->dd_dr1[j][k][l][i]=0.;
+              		work->dd_dr0[j][k][l][i]=0.;
+			for(ii=0;ii<3;ii++){
+                  		work->dd_dr1[j][k][l][i]+=gamma[j][k][ii]*pi1[ii][l]; 
+                		work->dd_dr0[j][k][l][i]+=gamma[j][k][ii]*pi0[ii][l]; 
+				}
+			}
+		}
+	}
+}
+/*
+ * Check arrays
+ */
+#ifdef EXTREME_DEBUG
+for(i=0;i<inpack.natoms;i++){
+printf("DERR_DR0 %12.6f %12.6f %12.6f\n",work->derr_dr0[0][i],work->derr_dr0[1][i],work->derr_dr0[2][i]);
+}
+printf("\n");
+for(i=0;i<inpack.natoms;i++){
+printf("DERR_DR1 %12.6f %12.6f %12.6f\n",work->derr_dr1[0][i],work->derr_dr1[1][i],work->derr_dr1[2][i]);
+}
+for(i=0;i<inpack.natoms;i++){
+for(j=0;j<3;j++){
+for(k=0;k<3;k++){
+printf("DD_DR0 %12.6f %12.6f %12.6f\n",work->dd_dr0[j][k][0][i],work->dd_dr0[j][k][1][i],work->dd_dr0[j][k][2][i]);
+}}}
+for(i=0;i<inpack.natoms;i++){
+for(j=0;j<3;j++){
+for(k=0;k<3;k++){
+printf("DD_DR1 %12.6f %12.6f %12.6f\n",work->dd_dr1[j][k][0][i],work->dd_dr1[j][k][1][i],work->dd_dr1[j][k][2][i]);
+}}}
+#endif
+/*
+ * Now correct for cm - hard part in 2nd derivative
+ *
+ */
+if(iopt==6 || iopt==7){
+        // don't correct for the rot matrix: only for error calc
+        if(simple>0){
+		for(l=0;l<3;l++){
+			for(i=0;i<inpack.natoms;i++){
+				fact2=inpack.mass[i]/(inpack.totmass);
+                                //--> derr_dr1_tmp[l][i]=outpack->derr_dr1[l][i];
+                                derr_dr1_tmp[l][i]=inpack.mass[i]*work->derr_dr1[l][i];
+				for(j=0;j<inpack.natoms;j++){
+                                	//--> derr_dr1_tmp[l][i]-=(inpack.mass[i]/(inpack.totmass))*outpack->derr_dr1[l][j];
+                                	derr_dr1_tmp[l][i]-=inpack.mass[j]*fact2*work->derr_dr1[l][j];
+				}
+			}	
+		}
+		for(l=0;l<3;l++){
+			for(i=0;i<inpack.natoms;i++){
+				work->derr_dr1[l][i]=derr_dr1_tmp[l][i];
+			}
+		}	
+        }
+        if(simple==2 || simple==0){
+        // correct the rotation matrix
+		for(i=0;i<3;i++){
+			for(j=0;j<3;j++){
+			    for(k=0;k<3;k++){
+                                for(l=0;l<inpack.natoms;l++){
+                                   //--> dd_dr_temp[i][j][k][l]=outpack->dd_dr1[i][j][k][l];
+                                   dd_dr_temp[i][j][k][l]=inpack.mass[l]*work->dd_dr1[i][j][k][l];
+                                   tmp1=inpack.mass[l]/inpack.totmass; 
+                                   for(mm=0;mm <inpack.natoms;mm++){
+                                     //--> dd_dr_temp[i][j][k][l]-=outpack->dd_dr1[i][j][k][mm]*tmp1; 
+                                     dd_dr_temp[i][j][k][l]-=work->dd_dr1[i][j][k][mm]*tmp1*inpack.mass[mm]; 
+                                   }
+                                }
+                            }	
+  	  	       	}	
+                }
+		for(i=0;i<3;i++){
+			for(j=0;j<3;j++){
+			    for(k=0;k<3;k++){
+                                for(l=0;l<inpack.natoms;l++){
+                                   work->dd_dr1[i][j][k][l]=dd_dr_temp[i][j][k][l];
+                                }
+                            }	
+  	  	       	}	
+                }
+        }
+	
+}
+if(iopt==5 || iopt==7){
+        if(simple>0){
+		for(l=0;l<3;l++){
+			for(i=0;i<inpack.natoms;i++){
+                                //--> derr_dr0_tmp[l][i]=outpack->derr_dr0[l][i];
+				fact2=inpack.mass[i]/(inpack.totmass);
+                                derr_dr0_tmp[l][i]=inpack.mass[i]*work->derr_dr0[l][i];
+				for(j=0;j<inpack.natoms;j++){
+                                	//--> derr_dr0_tmp[l][i]-=(inpack.mass[i]/(inpack.totmass))*outpack->derr_dr0[l][j];
+                                	derr_dr0_tmp[l][i]-=inpack.mass[j]*fact2*work->derr_dr0[l][j];
+				}
+			}	
+		}
+		for(l=0;l<3;l++){
+			for(i=0;i<inpack.natoms;i++){
+				work->derr_dr0[l][i]=derr_dr0_tmp[l][i];
+			}
+		}	
+        }
+        if(simple==2 || simple==0){
+		for(i=0;i<3;i++){
+			for(j=0;j<3;j++){
+			    for(k=0;k<3;k++){
+                                for(l=0;l<inpack.natoms;l++){
+                                   //--> dd_dr_temp[i][j][k][l]=outpack->dd_dr0[i][j][k][l];
+                                   dd_dr_temp[i][j][k][l]=inpack.mass[l]*work->dd_dr0[i][j][k][l];
+                                   tmp1=inpack.mass[l]/inpack.totmass; 
+                                   for(mm=0;mm <inpack.natoms;mm++){
+                                     //--> dd_dr_temp[i][j][k][l]-=outpack->dd_dr0[i][j][k][mm]*tmp1; 
+                                     dd_dr_temp[i][j][k][l]-=work->dd_dr0[i][j][k][mm]*tmp1*inpack.mass[mm]; 
+                                   }
+                                }
+                            }	
+  	  	       	}	
+                }
+		for(i=0;i<3;i++){
+			for(j=0;j<3;j++){
+			    for(k=0;k<3;k++){
+                                for(l=0;l<inpack.natoms;l++){
+                                   work->dd_dr0[i][j][k][l]=dd_dr_temp[i][j][k][l];
+                                }
+                            }	
+  	  	       	}	
+                }
+	}
+}
+#ifdef EXTREME_DEBUG
+for(i=0;i<inpack.natoms;i++){
+printf("DERR_DR0 %12.6f %12.6f %12.6f\n",work->derr_dr0[0][i],work->derr_dr0[1][i],work->derr_dr0[2][i]);
+}
+for(i=0;i<inpack.natoms;i++){
+printf("DERR_DR1_CM %12.6f %12.6f %12.6f\n",work->derr_dr1[0][i],work->derr_dr1[1][i],work->derr_dr1[2][i]);
+}
+#endif
+return 0;
+}
+
+// ------------------------------------------------------------------------------------------------
+
+int PREFIX ql77_driver(real m[][4],real* lambda){
+int i,j,ok;
+double ll[16];
+double *lambda2;
+lambda2=(double *)malloc(4*sizeof(double));
+for(i=0;i<4;i++){
+//lambda2[i]=0.;
+ for(j=0;j<4;j++){
+	 ll[4*i+j]=m[i][j]; }};
+#ifdef EXTREME_DEBUG
+for(i=0;i<4;i++){
+         printf("M_MATRIX %12.6f %12.6f %12.6f %12.6f\n",m[i][0],m[i][1],m[i][2],m[i][3]) ;  
+}
+#endif
+ok=ql77(4,ll,lambda2);
+#ifdef EXTREME_DEBUG
+printf("EIGV %f %f %f %f\n",lambda2[0],lambda2[1],lambda2[2],lambda2[3]);
+#endif
+//back to square representation: columns have eigenvectors
+        for(j=0;j<4;j++){
+            lambda[j]=lambda2[j]; 
+	    for(i=0;i<4;i++){
+		 m[i][j]=ll[4*j+i]; 
+            }
+	};
+free(lambda2); 
+return ok;
+};
+int PREFIX ql77 (int n,double *x,double *d)
+{
+  int i,j,k,l,ni;
+  double *e,h,g,f,b,s,p,r,c,absp;
+  double totwork,work;
+
+  const double eps=7.e-14,tol=1.e-30;
+
+  e=(double *)malloc(n*sizeof(double));
+
+  int danger;
+  danger=0;
+
+  totwork = 0;
+  for(ni=1; ni<n; ni++)
+    totwork += pow((double) n-ni,3);
+
+  work=0;
+  for(ni=1; (ni < n); ni++) {
+    i=n-ni;
+    l=i-1;
+    h=0.0;                                                          
+    g=x[i+n*(i-1)];
+    if (l > 0) {
+      for(k=0; (k<l); k++) 
+	h=h+x[i+n*k]*x[i+n*k];
+      s=h+g*g;
+      if (s < tol)
+	h=0.0;
+      else if (h > 0.0) { 
+	l=l+1;
+	f=g;
+	g=sqrt(s);
+	g=-g;
+	h=s-f*g;                                                           
+	x[i+n*(i-1)]=f-g;
+	f=0.0;
+	for(j=0; (j<l); j++) {
+	  x[j+n*i]=x[i+n*j]/h;
+          if ( fabs(h) < tol ) {danger=1; fprintf(mtd_data.fplog,"|- WARNING: PROBLEM WITH DIAGONALIZATION...KEEP ON GOING!\n");} 
+	  s=0.0;
+	  for(k=0; (k<=j); k++)
+	    s=s+x[j+n*k]*x[i+n*k];
+	  for(k=j+1; (k<l); k++)
+	    s=s+x[k+n*j]*x[i+n*k];
+	  e[j]=s/h;
+	  f=f+s*x[j+n*i];
+	}
+	f=f/(h+h);
+	for(j=0; (j<l); j++) 
+	  e[j]=e[j]-f*x[i+n*j];
+	for(j=0; (j<l); j++) {
+	  f=x[i+n*j];
+	  s=e[j];
+	  for(k=0; (k<=j); k++)
+	    x[j+n*k]=x[j+n*k]-f*e[k]-x[i+n*k]*s;
+	}
+      }
+    }
+    d[i]=h;
+    e[i-1]=g;
+
+    work += pow((double) n-ni,3);
+  }
+  if (danger==1){
+    for(i=0; (i<n); i++) {
+      d[i] = 0.0;
+      for(j=0; (j<n); j++) {
+	x[j+n*i] = 0.0 ;
+        if(i==j){
+	  x[j+n*i] = 1.0 ;
+        }  
+      }
+    }
+    free(e);
+    return 0;
+  }
+ 
+
+  /*
+   *  accumulation of transformation matrix and intermediate d vector
+   */
+  
+  d[0]=x[0];
+  x[0]=1.0;
+
+  work=0;
+  for(i=1; (i<n); i++) {
+    if (d[i] > 0.0) {
+      for(j=0; (j<i); j++) {
+	s=0.0;
+	for(k=0; (k<i); k++) 
+	  s=s+x[i+n*k]*x[k+n*j];
+	for(k=0; (k<i); k++)
+	  x[k+n*j]=x[k+n*j]-s*x[k+n*i];
+      }
+    }
+    d[i]=x[i+n*i];
+    x[i+n*i]=1.0;
+    for(j=0; (j<i); j++) {
+      x[i+n*j]=0.0;
+      x[j+n*i]=0.0;
+    }
+    work += pow((double) i,3);
+  }
+
+  /*
+   *  ql iterates
+   */
+
+  b=0.0;
+  f=0.0;
+  e[n-1]=0.0;
+  totwork += pow((double) n,3);
+  work=0;
+  for(l=0; (l<n); l++) {
+    h=eps*(fabs(d[l])+fabs(e[l]));
+    if (h > b) 
+      b=h;                                                   
+    for(j=l; (j<n); j++) {
+      if(fabs(e[j]) <= b) 
+	break;
+    }
+    if (j != l) { 
+      do {
+	g=d[l];
+	p=(d[l+1]-g)*0.5/e[l];
+	r=sqrt(p*p+1.0);
+	if(p < 0.0)
+	  p=p-r;
+	else
+	  p=p+r;
+	d[l]=e[l]/p;
+	h=g-d[l];                                                     
+	for(i=l+1; (i<n); i++)
+	  d[i]=d[i]-h;                                                       
+	f=f+h;                                                             
+	p=d[j];
+	c=1.0;
+	s=0.0;
+	for(ni=l; (ni<j); ni++) {
+	  i=l+j-1-ni;
+	  g=c*e[i];
+	  h=c*p;
+	  if(fabs(p) >= fabs(e[i])) {
+	    c=e[i]/p;
+	    r=sqrt(c*c+1.0);
+	    e[i+1]=s*p*r;
+	    s=c/r;
+	    c=1.0/r;
+	  } else {
+	    c=p/e[i];
+	    r=sqrt(c*c+1.0);
+	    e[i+1]=s*e[i]*r;
+	    s=1.0/r;
+	    c=c/r;
+	  }
+	  p=c*d[i]-s*g;
+	  d[i+1]=h+s*(c*g+s*d[i]);
+	  for(k=0; (k<n); k++) {
+	    h=x[k+n*(i+1)];
+	    x[k+n*(i+1)]=x[k+n*i]*s+h*c;
+	    x[k+n*i]=x[k+n*i]*c-h*s;
+	  }
+	}
+	e[l]=s*p;
+	d[l]=c*p;
+      } while (fabs(e[l]) > b); 
+    }
+    d[l]=d[l]+f;
+
+    work += pow((double) n-l,3);
+  }
+
+  /*
+   *  put eigenvalues and eigenvectors in 
+   *  desired ascending order
+   */
+
+ 
+  for(i=0; (i<n-1); i++) {
+    k    = i;
+    p    = d[i];
+    absp = fabs(d[i]);
+    for(j=i+1; (j<n); j++) {
+      if(fabs(d[j]) < absp) {
+	k    = j;
+	p    = d[j];
+	absp = fabs(d[j]);
+      }
+    }
+    if (k != i) {
+      d[k] = d[i];
+      d[i] = p;
+      for(j=0; (j<n); j++) {
+	p        = x[j+n*i];
+	x[j+n*i] = x[j+n*k];
+	x[j+n*k] = p;
+      }
+    }
+  }
+
+	  free(e);
+ 	  return 1;	
+	}
+
+//-----------------------------------------------------------------------------------------------------
+
+void PREFIX dmsd_calculation(int i_c,struct coordinates_frameset *pframeset,struct cmap_inpack *c_inpack,
+                             struct cmap_outpack *c_outpack,real dmsd_dr1[3][MAXATOMS_PATH]){
+
+    int i,j,ix;
+    rvec rij,rij0;
+    real mod_rij,mod_rij0, drmsd, fact;
+
+    drmsd = 0.;
+    for(i=0;i<colvar.natoms[i_c];i++) for(ix=0;ix<3;ix++) {c_outpack->derr_dr0[ix][i] = dmsd_dr1[ix][i] = 0.;} 
+
+  
+    for(i=0;i<colvar.natoms[i_c]-1;i++) {
+     for(j=i+1;j<colvar.natoms[i_c];j++) {
+      minimal_image(c_inpack->r0[i], c_inpack->r0[j], &mod_rij, rij);
+      minimal_image(pframeset->pos[i], pframeset->pos[j], &mod_rij0, rij0);
+      drmsd += (mod_rij-mod_rij0)*(mod_rij-mod_rij0);
+      for(ix=0;ix<3;ix++) {
+        c_outpack->derr_dr0[ix][i] +=  rij[ix]*(mod_rij-mod_rij0)/mod_rij;
+        c_outpack->derr_dr0[ix][j] += -rij[ix]*(mod_rij-mod_rij0)/mod_rij;
+        dmsd_dr1[ix][i] += -rij0[ix]*(mod_rij-mod_rij0)/mod_rij0;
+        dmsd_dr1[ix][j] +=  rij0[ix]*(mod_rij-mod_rij0)/mod_rij0;
+      }
+     }
+    } 
+
+   fact = 2./((real)colvar.natoms[i_c]*((real)colvar.natoms[i_c]-1.));
+
+   c_outpack->err = drmsd * fact; 
+
+   for(i=0;i<colvar.natoms[i_c];i++) {
+    c_outpack->derr_dr0[0][i] *= 2.*fact;
+    c_outpack->derr_dr0[1][i] *= 2.*fact;
+    c_outpack->derr_dr0[2][i] *= 2.*fact; 
+    dmsd_dr1[0][i] *= 2.*fact;
+    dmsd_dr1[1][i] *= 2.*fact;
+    dmsd_dr1[2][i] *= 2.*fact;
+   }
+
+}
+
+int PREFIX read_sz_hybrid(struct sz_data *my_sz, FILE *fplog) {
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+
+// ------------------------------------------------------------------------------------------------
+
+
+int PREFIX  hbd_read_simple (  FILE *myfile, FILE *fplog, const char *istring, struct  hybrid_elem *elem, int hasfile){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+
+int PREFIX  hbd_read_msd (  FILE *myfile, FILE *fplog, struct hybrid_elem *elem , int hasfile){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+
+int  PREFIX  hbd_collect_config ( struct hybrid_frameset *running  ) {
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+
+/*
+ * Just simple copy the value and the derivative
+ */
+void  PREFIX  hbd_copy_simple (struct hybrid_elem *elem ) {
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+void  PREFIX  hbd_copy_msd ( struct hybrid_elem *elem ) {
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+
+
+int PREFIX rmsd_mini_pack_fake(struct rmsd_inpack inpack,struct rmsd_mini_outpack *work, int nocenter, int simple)
+{
+/* declarations */
+int i,j,k,l,ll,mm,ii;
+real rrsq,xx,yy,zz,m[4][4],rr1[4],rr0[4];
+real lambda[4],s,q[4];
+real pi1[3][3],pi0[3][3],tmp1,dnatoms; 
+xx=0.;
+yy=0.;
+zz=0.;
+tmp1=0.;
+//         printf("FAKE \n");
+dnatoms=(inpack.natoms);
+if(!nocenter) {// if you dont need to center no prob...
+	for(i=0;i<inpack.natoms;i++){
+		xx+=inpack.r0[0][i]*inpack.mass[i];
+		yy+=inpack.r0[1][i]*inpack.mass[i];
+		zz+=inpack.r0[2][i]*inpack.mass[i];
+	}
+        xx=xx/(inpack.totmass);
+        yy=yy/(inpack.totmass);
+        zz=zz/(inpack.totmass);
+
+}
+work->cmr0[0]=xx;
+work->cmr0[1]=yy;
+work->cmr0[2]=zz;
+for(i=0;i<inpack.natoms;i++){
+	work->r0p[0][i]=inpack.r0[0][i]-xx;
+	work->r0p[1][i]=inpack.r0[1][i]-yy;
+	work->r0p[2][i]=inpack.r0[2][i]-zz;
+}
+xx=0.;
+yy=0.;
+zz=0.;
+tmp1=0.;
+if(!nocenter) { // if you dont need to center no prob...
+	for(i=0;i<inpack.natoms;i++){
+		xx+=inpack.r1[0][i]*inpack.mass[i];
+		yy+=inpack.r1[1][i]*inpack.mass[i];
+		zz+=inpack.r1[2][i]*inpack.mass[i];
+	};
+        xx=xx/(inpack.totmass);
+        yy=yy/(inpack.totmass);
+        zz=zz/(inpack.totmass);
+}
+work->cmr1[0]=xx;
+work->cmr1[1]=yy;
+work->cmr1[2]=zz;
+for(i=0;i<inpack.natoms;i++){
+	work->r1p[0][i]=inpack.r1[0][i]-xx;
+	work->r1p[1][i]=inpack.r1[1][i]-yy;
+	work->r1p[2][i]=inpack.r1[2][i]-zz;
+}
+/*
+ * Find the ROTATION matrix
+ */
+work->d[0][0]=1.0 ; 
+work->d[1][0]=0.0 ;
+work->d[2][0]=0.0 ;
+work->d[0][1]=0.0 ;
+work->d[1][1]=1.0 ;
+work->d[2][1]=0.0 ;
+work->d[0][2]=0.0 ;
+work->d[1][2]=0.0 ;
+work->d[2][2]=1.0 ;
+
+// error
+if(simple){
+        work->err=0.;     
+	for(l=0;l<3;l++){
+		for(i=0;i<inpack.natoms;i++){
+                   work->err+=inpack.mass[i]*(work->r0p[l][i]-work->r1p[l][i])*(work->r0p[l][i]-work->r1p[l][i]);
+                }
+        }
+        work->err/=(inpack.totmass);
+//        printf("ERR %f\n",outpack->err);
+/*
+ * derivative 
+ *
+ */
+	for(l=0;l<3;l++){
+		for(i=0;i<inpack.natoms;i++){
+                        work->derr_dr1[l][i]=-(2.*inpack.mass[i]/(inpack.totmass))*(work->r1p[l][i]-work->r0p[l][i]); 
+                        if(!nocenter){
+				for(j=0;j<inpack.natoms;j++){
+                                       work->derr_dr1[l][i]+=(2.*inpack.mass[j]/(inpack.totmass))*inpack.mass[i]/inpack.totmass*(work->r1p[l][j]-work->r0p[l][j]);
+				}
+                        }
+//                	printf("DER %d DIR %d : %f\n",i,l,outpack->derr_dr1[l][i]);   
+		}	
+	}
+	for(l=0;l<3;l++){
+		for(i=0;i<inpack.natoms;i++){
+                        work->derr_dr0[l][i]=(2.*inpack.mass[i]/(inpack.totmass))*(work->r1p[l][i]-work->r0p[l][i]); 
+                        if(!nocenter){
+				for(j=0;j<inpack.natoms;j++){
+                                       work->derr_dr0[l][i]-=(2.*inpack.mass[j]/(inpack.totmass))*inpack.mass[i]/inpack.totmass*(work->r1p[l][j]-work->r0p[l][j]);
+				}
+                        }
+//                	printf("DER %d DIR %d : %f\n",i,l,outpack->derr_dr0[l][i]);   
+		}	
+	}
+          
+}
+for(i=0;i<3;i++){
+	for(j=0;j<3;j++){
+	    for(k=0;k<3;k++){
+                for(l=0;l<inpack.natoms;l++){
+                   work->dd_dr1[i][j][k][l]=0.;
+                   work->dd_dr0[i][j][k][l]=0.;
+                }
+            }	
+       	}	
+}
+	
+	
+return 0;
+}
+int PREFIX rmsd_findiff_interface(struct rmsd_inpack inpack,struct rmsd_mini_outpack *work){
+fprintf(mtd_data.fplog,"Entering rmsd finite difference test system\n");
+fprintf(mtd_data.fplog,"-------------------------------------------\n");
+fprintf(mtd_data.fplog,"TEST1: derivative of the value (derr_dr0/derr_dr1)\n");
+// test 1
+int i,j,k,l,m;
+real step=1.e-7,olderr,delta; 
+real derr_dr1[3][MAXATOMS_RMSD];
+real derr_dr0[3][MAXATOMS_RMSD];
+real dd_dr0[3][3][3][MAXATOMS_RMSD];
+real dd_dr1[3][3][3][MAXATOMS_RMSD];
+real oldd[3][3];
+// get initial value of the error and derivative of it 
+rmsd_mini_pack(inpack,work,7,1,0);
+fprintf(mtd_data.fplog,"INITIAL ERROR VALUE: %f FOR %d ATOMS\n",work->err,inpack.natoms);
+olderr=work->err;
+// store the derivative
+for(j=0;j<3;j++){
+for(i=0;i<inpack.natoms;i++){
+derr_dr1[j][i]=work->derr_dr1[j][i];
+derr_dr0[j][i]=work->derr_dr0[j][i];
+}
+}
+rmsd_mini_pack(inpack,work,7,0,0);
+for(l=0;l<3;l++){
+for(m=0;m<3;m++){
+oldd[l][m]=work->d[l][m];
+for(j=0;j<3;j++){
+for(i=0;i<inpack.natoms;i++){
+dd_dr1[l][m][j][i]=work->dd_dr1[l][m][j][i];
+dd_dr0[l][m][j][i]=work->dd_dr0[l][m][j][i];
+}
+}
+}
+}
+fprintf(mtd_data.fplog,"TESTING: derr_dr1 \n");
+for(j=0;j<3;j++){
+   for(i=0;i<inpack.natoms;i++){
+       // random displacement
+       delta=(drand48()-0.5)*2*step;
+       inpack.r1[j][i]+=delta; 
+       rmsd_mini_pack(inpack,work,7,2,0);
+       inpack.r1[j][i]-=delta; 
+       switch(j){
+         case 0:
+            fprintf(mtd_data.fplog,"TESTING: X  %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,derr_dr1[j][i],(work->err-olderr)/delta,derr_dr1[j][i]-(work->err-olderr)/delta);break;
+         case 1:
+            fprintf(mtd_data.fplog,"TESTING: Y  %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,derr_dr1[j][i],(work->err-olderr)/delta,derr_dr1[j][i]-(work->err-olderr)/delta);break;
+         case 2:
+            fprintf(mtd_data.fplog,"TESTING: Z  %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,derr_dr1[j][i],(work->err-olderr)/delta,derr_dr1[j][i]-(work->err-olderr)/delta);break;
+      
+       }    
+   }
+}
+fprintf(mtd_data.fplog,"TESTING: derr_dr0 \n");
+for(j=0;j<3;j++){
+   for(i=0;i<inpack.natoms;i++){
+       // random displacement
+       delta=(drand48()-0.5)*2*step;
+       inpack.r0[j][i]+=delta; 
+       rmsd_mini_pack(inpack,work,7,2,0);
+       inpack.r0[j][i]-=delta; 
+       switch(j){
+         case 0:
+            fprintf(mtd_data.fplog,"TESTING: X  %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,derr_dr0[j][i],(work->err-olderr)/delta,derr_dr0[j][i]-(work->err-olderr)/delta);break;
+         case 1:
+            fprintf(mtd_data.fplog,"TESTING: Y  %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,derr_dr0[j][i],(work->err-olderr)/delta,derr_dr0[j][i]-(work->err-olderr)/delta);break;
+         case 2:
+            fprintf(mtd_data.fplog,"TESTING: Z  %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,derr_dr0[j][i],(work->err-olderr)/delta,derr_dr0[j][i]-(work->err-olderr)/delta);break;
+       }    
+   }
+}
+fprintf(mtd_data.fplog,"TESTING: dd_dr0 \n");
+for(l=0;l<3;l++){
+  for(m=0;m<3;m++){
+    for(j=0;j<3;j++){
+       for(i=0;i<inpack.natoms;i++){
+           // random displacement
+           delta=(drand48()-0.5)*2*step;
+           inpack.r0[j][i]+=delta; 
+           rmsd_mini_pack(inpack,work,7,2,0);
+           inpack.r0[j][i]-=delta; 
+           switch(j){
+             case 0:
+                fprintf(mtd_data.fplog,"TESTING: DD_DR0 [ %d ][ %d ]:  X %d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",l,m,i,dd_dr0[l][m][j][i],(work->d[l][m]- oldd[l][m])/delta,dd_dr0[l][m][j][i]-(work->d[l][m]- oldd[l][m])/delta);break;
+             case 1:
+                fprintf(mtd_data.fplog,"TESTING: DD_DR0 [ %d ][ %d ]:  Y %d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",l,m,i,dd_dr0[l][m][j][i],(work->d[l][m]- oldd[l][m])/delta,dd_dr0[l][m][j][i]-(work->d[l][m]- oldd[l][m])/delta);break;
+             case 2:
+                fprintf(mtd_data.fplog,"TESTING: DD_DR0 [ %d ][ %d ]:  Z %d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",l,m,i,dd_dr0[l][m][j][i],(work->d[l][m]- oldd[l][m])/delta,dd_dr0[l][m][j][i]-(work->d[l][m]- oldd[l][m])/delta);break;
+
+
+           }    
+       }
+    }
+  }
+}
+fprintf(mtd_data.fplog,"TESTING: dd_dr1 \n");
+for(l=0;l<3;l++){
+  for(m=0;m<3;m++){
+    for(j=0;j<3;j++){
+       for(i=0;i<inpack.natoms;i++){
+           // random displacement
+           delta=(drand48()-0.5)*2*step;
+           inpack.r1[j][i]+=delta; 
+           rmsd_mini_pack(inpack,work,7,2,0);
+           inpack.r1[j][i]-=delta; 
+           switch(j){
+             case 0:
+                fprintf(mtd_data.fplog,"TESTING: DD_DR1 [ %d ][ %d ]:  X %d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",l,m,i,dd_dr1[l][m][j][i],(work->d[l][m]- oldd[l][m])/delta,dd_dr1[l][m][j][i]-(work->d[l][m]- oldd[l][m])/delta);break;
+             case 1:
+                fprintf(mtd_data.fplog,"TESTING: DD_DR1 [ %d ][ %d ]:  Y %d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",l,m,i,dd_dr1[l][m][j][i],(work->d[l][m]- oldd[l][m])/delta,dd_dr1[l][m][j][i]-(work->d[l][m]- oldd[l][m])/delta);break;
+             case 2:
+                fprintf(mtd_data.fplog,"TESTING: DD_DR1 [ %d ][ %d ]:  Z %d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",l,m,i,dd_dr1[l][m][j][i],(work->d[l][m]- oldd[l][m])/delta,dd_dr1[l][m][j][i]-(work->d[l][m]- oldd[l][m])/delta);break;
+
+
+           }    
+       }
+    }
+  }
+}
+EXIT();
+return 0 ;
+};
+void PREFIX pathref_findiff(int i_c, struct mtd_data_s *mtd_data){
+fprintf(mtd_data->fplog,"Entering PATH finite difference test system\n");
+fprintf(mtd_data->fplog,"-------------------------------------------\n");
+fprintf(mtd_data->fplog,"TEST1: derivative of the value (dpathvar/d_r_ref)\n");
+// test 1
+int i,j,k,l,m,nneigh,ii;
+struct sz_data *pmy_sz;
+real step=1.e-9,oldpath,delta,newpath; 
+// retrieve and store the derivative
+real dpath_dr0[3][MAXATOMS_RMSD][MAXFRAMES_PATH];
+pmy_sz=&my_sz_list[ic_to_sz[i_c]];
+oldpath=colvar.ss0[i_c];
+nneigh=pmy_sz->nneigh;
+for(j=0;j<colvar.natoms[i_c];j++){
+       for(ii=0;ii<pmy_sz->number;ii++){
+            dpath_dr0[0][j][ii]=0.;
+            dpath_dr0[1][j][ii]=0.;
+            dpath_dr0[2][j][ii]=0.;
+       }
+       for(ii=0;ii<nneigh;ii++){
+            i=pmy_sz->lneigh[ii];
+            dpath_dr0[0][j][i]=pmy_sz->dpath_dr[0][j][i];
+            dpath_dr0[1][j][i]=pmy_sz->dpath_dr[1][j][i];
+            dpath_dr0[2][j][i]=pmy_sz->dpath_dr[2][j][i];
+       }
+}
+
+// for each frame: 
+for(ii=0;ii<nneigh;ii++){
+         i=pmy_sz->lneigh[ii];
+         // random displacement
+         delta=(drand48()-0.5)*2*step;
+         // for each atom
+         for(k=0;k<pmy_sz->frameset[i]->natoms;k++){         
+         for(l=0;l<3;l++){         
+// change a bit the reference 
+             pmy_sz->frameset[i]->pos[k][l]+=delta; 
+             if(colvar.type_s[i_c]==30)spath_restraint(i_c, mtd_data); 
+             if(colvar.type_s[i_c]==31)zpath_restraint(i_c, mtd_data); 
+             newpath=colvar.ss0[i_c];
+// recalculate the variable 
+             pmy_sz->frameset[i]->pos[k][l]-=delta; 
+             switch(l){ 
+                case 0:  fprintf(mtd_data->fplog,"TESTING: NFR %d X %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,k,dpath_dr0[l][k][i],(newpath-oldpath)/delta,dpath_dr0[l][k][i]-(newpath-oldpath)/delta);break;
+                case 1:  fprintf(mtd_data->fplog,"TESTING: NFR %d Y %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,k,dpath_dr0[l][k][i],(newpath-oldpath)/delta,dpath_dr0[l][k][i]-(newpath-oldpath)/delta);break;
+                case 2:  fprintf(mtd_data->fplog,"TESTING: NFR %d Z %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,k,dpath_dr0[l][k][i],(newpath-oldpath)/delta,dpath_dr0[l][k][i]-(newpath-oldpath)/delta);break;
+             }
+// print the output 
+         } 
+         } 
+}
+fprintf(mtd_data->fplog,"exiting PATH test system\n");
+EXIT();
+}; 
+void  PREFIX sbernd_restraint(int i_c, struct mtd_data_s *mtd_data){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+// 
+//  (v1-v2)_ref_v3 ' M (v4-v5)_ref_v6  is calculated and derivatives therein 
+// 
+// allo=0 do not allocate: the vectors should be already there 
+// allo=1 allocate the vectors for the derivative
+//
+real PREFIX hbd_vecmvec_ref(struct hybrid_frameset *v1,  struct hybrid_frameset *v2, 
+							struct hybrid_frameset *v3,  struct hybrid_frameset *v4,
+							struct hybrid_frameset *v5,  struct hybrid_frameset *v6,							
+							real **mat , real *dv1dcv,  real *dv2dcv,  real *dv3dcv,  
+							real *dv4dcv, real *dv5dcv,  real *dv6dcv, FILE *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+
+// allocate the things for path evolution
+void PREFIX init_bernd_evolution  ( struct sz_data **pmy_sz , int i_c){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+void PREFIX do_bernd_evolution  ( struct sz_data *pmy_sz ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+void PREFIX reparam_bernd_path ( struct sz_data *pmy_sz ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+//// v1=v2+dr(v3-v4)_v2
+void PREFIX do_step_bernd (  struct hybrid_frameset *v1 , struct hybrid_frameset *v2, real **mat, real dr, struct hybrid_frameset *v3 ,struct hybrid_frameset *v4 ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+int PREFIX read_msd( char **word, int count, t_plumed_input *input, FILE *fplog ) {
+	int iw,i,help;
+	FILE *fp;
+	struct pdb *mypdb;
+	char *filename;
+	help=0;
+	iw=seek_word(word,"PDB");
+	if(iw>=0) {
+		fprintf(fplog,"\n%1i-MSD variable: \n",count+1);
+		fprintf(fplog,"|- MSD READER: PDB KEYWORD FOUND\n");
+		// open the file and check existence
+		filename=word[iw+1];
+		fp=fopen(filename,"r");
+		if (fp == NULL){
+			char buf[1024];
+			fprintf(fplog,"|- MSD READER: UNSUCCESSFULL OPENING FOR FILE %s\n",filename);
+			EXIT();
+		}else{
+			fprintf(fplog,"|- MSD READER: NOW OPENING  FILE %s \n",filename);
+			//
+			// now call a simple pdb reader with streamline and retrieve the pdb infos 	
+			// 
+			read_pdb(&(colvar.rmsd_container[count].mypdb),fp,fplog);
+			//
+			// call the allocator to the work array
+			// take the elements and check if the rmsd work array is sufficient
+			//
+			readapt_rmsd_work_array(colvar.rmsd_container[count].mypdb->natoms,fplog);
+
+			fprintf(fplog,"|- MSD READER: PDB FILE HAS %d ATOMS \n",colvar.rmsd_container[count].mypdb->natoms);	
+
+			//	
+			// call the allocator for the storage: store the pdb into the rmsd_container
+			//
+			copy_pdb_into_rmsd_container( *(colvar.rmsd_container[count].mypdb), &(colvar.rmsd_container[count]),fplog);
+						
+			// copy the pdb into the metadynamics work arrays
+			
+			colvar.natoms[count]   = colvar.rmsd_container[count].mypdb->natoms;
+			
+			snew(colvar.myder[count], colvar.natoms[count]);
+			snew(colvar.cvatoms[count], colvar.natoms[count]);
+			
+			for(i=0;i<colvar.natoms[count];i++){
+				colvar.cvatoms[count][i] = colvar.rmsd_container[count].mypdb->index[i]-1; // from pdb to c indexing
+			}
+			//count++;
+		}
+
+	}else{ fprintf(fplog,"|- MSD READER:  NEEDED PDB KEYWORD FOR MSD IN HYBRID PATH\n"); help=1;}
+	// find the sigma
+	real sigma;
+	iw=seek_word(word,"SIGMA");
+	if(iw>=0){ sscanf(word[iw+1],"%lf", &sigma);
+		colvar.delta_r[count]  = (real) sigma; }
+	
+	iw=seek_word(word,"DUMMY");
+	if(iw>=0){ 
+		fprintf(fplog,"|- MSD READER: ------------------------------------WARNING!!!!-------------------------------------\n");
+		fprintf(fplog,"|- MSD READER: DUMMY VARIABLE, WILL NOT MAKE A REAL DYNAMICS BUT KEEP TRACK OF INDEXES (FOR HYBRID)\n");
+		fprintf(fplog,"|- MSD READER: WHATEVER DERIVATIVE WILL BE PUT TO ZERO\n");
+		fprintf(fplog,"|- MSD READER: ------------------------------------------------------------------------------------\n");
+
+		colvar.rmsd_container[count].dummy=1;
+	}else{
+		colvar.rmsd_container[count].dummy=0;	
+	}
+
+	iw=seek_word(word,"DREF");
+	if(iw>=0){ 
+                sscanf(word[iw+1],"%i", & colvar.rmsd_container[count].dref_freq);	
+		fprintf(fplog,"|- MSD READER: ------------------------------------------------------------------------------------\n");
+		fprintf(fplog,"|- MSD READER: DREF: dump the coordinate respect to each component\n");
+		fprintf(fplog,"|- MSD READER:       dumping_frequency is %d \n",colvar.rmsd_container[count].dref_freq);
+		fprintf(fplog,"|- MSD READER: ------------------------------------------------------------------------------------\n");
+	        char dername[200]; 
+		char *str,ic[3],str2[100];
+                if(count+1<10){
+                 ic[0]='0'+count+1;
+                 ic[1]='\0';}
+                else if(count+1<100) {
+                 ic[0]='0'+(count+1)/10 ;
+                 ic[1]='0'+(count+1)%10 ;
+                 ic[2]='\0';
+                }
+                else{
+                  plumed_error("|--msd reader: TOO MANY FRAMES REQUIRED FOR NAME BUILDING!");
+                }
+		strcpy(colvar.rmsd_container[count].dreffile,"dref_");
+		strcat(colvar.rmsd_container[count].dreffile,ic);
+		strcat(colvar.rmsd_container[count].dreffile,".dat");
+		colvar.rmsd_container[count].fpdreffile=fopen(colvar.rmsd_container[count].dreffile,"w");
+		colvar.rmsd_container[count].dref=1;
+	}else{
+		colvar.rmsd_container[count].dref=0;	
+	}
+
+	if(help){
+		fprintf(fplog,"|- MSD:\n");
+		fprintf(fplog,"|- This is a fake cv useful to point to the atoms which are \n");
+		fprintf(fplog,"|- involved into a path CV with rmsd. It does not have any\n");
+		fprintf(fplog,"|- meaning\n");
+		fprintf(fplog,"|- It requires a PDB file.\n");
+		fprintf(fplog,"|- Position are ignored. Only atom indexes, beta and occupancy matter\n");
+		fprintf(fplog,"|- \n");
+		EXIT();
+	}
+	if (logical.do_hills){
+		if (colvar.delta_r[count]>0){
+			fprintf(fplog,"|- MSD READER: SIGMA %f\n",colvar.delta_r[count]);
+        }
+	}
+	else fprintf(fplog,"\n");
+	
+	//EXIT();
+
+	return colvar.natoms[count];
+};
+// the general pdb parser
+int PREFIX read_pdb(struct pdb **mypdb, FILE *myfile, FILE *fplog){
+	FILE *initpos;
+	fpos_t pos;
+	int i,j,k;
+	char *str,string[200],end[3],remark[6],atom[5],hetatm[7];
+	// save the initial address 
+	fgetpos (myfile,&pos);
+    // now keep on reading
+	// goto up to the bottom of the file up to the "END" or "TER" or "EOF"
+	// and count the atoms
+	i=0;
+	while(1){
+	readagain:
+		str=fgets(string,180,myfile);
+        if(str==NULL)break;
+		//fprintf(fplog,"LINE %s \n",string);
+		strncpy(end,string,3);
+		if(strstr(end,"END")!=NULL){break;}; 
+		if(strstr(end,"TER")!=NULL){break;}; 
+		strncpy(atom,string,4);atom[4]='\0';
+		strncpy(hetatm,string,6);hetatm[6]='\0';
+		if( (strstr(atom,"ATOM")!=NULL) || (strstr(hetatm,"HETATM")!=NULL) ) {
+			//fprintf(fplog,"FOUND ATOM %s \n",string);
+			// do first a count of atoms:
+			i++;
+		}
+		goto readagain;
+    } 	
+	fprintf(fplog,"|- read_pdb: FOUND %d NATOMS\n",i);
+	// allocate structures
+	allocate_pdb(mypdb,i);
+	fprintf(fplog,"|- read_pdb: ALLOCATED NATOMS %d \n",(*mypdb)->natoms);
+	//now go back and assign the elements
+	//reset to the initial address
+    //return 1;
+    
+	fsetpos (myfile, &pos);
+	i=0;
+	char x[12],y[12],z[12],occ[12],beta[12];
+//	char ind[5], resid[4];
+//	char name[4],resname[3],chain ;
+	char ind[10], resid[10];
+	char name[10],resname[10],chain ;	
+	while(1){
+	readagain2:
+		str=fgets(string,200,myfile);
+	//	fprintf(fplog,"NLINE %s \n",string);
+		strncpy(end,string,3);
+		if(strstr(end,"END")!=NULL){break;}; 
+		if(strstr(end,"TER")!=NULL){break;}; 
+		//sscanf(str,"%6s",remark);
+		strncpy(atom,string,4);atom[4]='\0';
+		strncpy(hetatm,string,6);hetatm[6]='\0';
+		if( (strstr(atom,"ATOM")!=NULL) || (strstr(hetatm,"HETATM")!=NULL) ) {
+			// now do a serious parsing and assign the elements
+//			12345678901234567890123456789012345678901234567890123456789012345678901234567890
+//			
+//			ATOM   4150  H   ALA A 431       8.674  16.036  12.858  1.00  0.00
+//
+//			COLUMNS        DATA  TYPE    FIELD        DEFINITION
+//			-------------------------------------------------------------------------------------
+//			1 -  6        Record name   "ATOM  "
+//			7 - 11        Integer       serial       Atom  serial number.
+//			13 - 16        Atom          name         Atom name.
+//			17             Character     altLoc       Alternate location indicator.
+//			18 - 20        Residue name  resName      Residue name.
+//			22             Character     chainID      Chain identifier.
+//			23 - 26        Integer       resSeq       Residue sequence number.
+//			27             AChar         iCode        Code for insertion of residues.
+//			31 - 38        Real(8.3)     x            Orthogonal coordinates for X in Angstroms.
+//			39 - 46        Real(8.3)     y            Orthogonal coordinates for Y in Angstroms.
+//			47 - 54        Real(8.3)     z            Orthogonal coordinates for Z in Angstroms.
+//			55 - 60        Real(6.2)     occupancy    Occupancy.
+//			61 - 66        Real(6.2)     tempFactor   Temperature  factor.
+//			77 - 78        LString(2)    element      Element symbol, right-justified.
+//			79 - 80        LString(2)    charge       Charge  on the atom.
+//			
+			
+//			//now implement a fixed width parser since the c parser does not allows it
+			parse_fixwidth(str,  7, 11, ind);
+			parse_fixwidth(str, 13, 16, name);
+			parse_fixwidth(str, 18, 20, resname);
+			parse_fixwidth(str, 23, 26, resid);
+			//parse_fixwidth(str, 22, 22, &chain);
+			parse_fixwidth(str, 31, 38, x);
+			parse_fixwidth(str, 39, 46, y);
+			parse_fixwidth(str, 47, 54, z);
+			parse_fixwidth(str, 55, 60, occ);
+			parse_fixwidth(str, 61, 66, beta);
+
+//			fprintf(fplog,"IND %s NAME %s RES %s ID %s  X %s Y %s Z %s O %s B %s\n",ind,name,resname,resid,x,y,z,occ,beta);
+//			
+			(*mypdb)->index[i]=atoi(ind);
+			(*mypdb)->resid[i]=atoi(resid);
+			(*mypdb)->x[i]=atof(x);
+			(*mypdb)->y[i]=atof(y);
+			(*mypdb)->z[i]=atof(z);
+			(*mypdb)->beta[i]=atof(beta);
+			(*mypdb)->occ[i]=atof(occ);
+			strcpy((*mypdb)->name[i],name);
+			strcpy((*mypdb)->resname[i],resname);
+//			//(*mypdb).chain[i]=&chain;
+//		
+//			fprintf(fplog,"S_IND %d NAME %s RES %s ID %d  X %f Y %f Z %f O %f B %f\n",(*mypdb)->index[i],(*mypdb)->name[i],(*mypdb)->resname[i],(*mypdb)->resid[i],(*mypdb)->x[i],(*mypdb)->y[i],(*mypdb)->z[i],(*mypdb)->occ[i],(*mypdb)->beta[i]);
+//			
+			i++;
+		}
+		goto readagain2;
+    } 		
+    fprintf(fplog,"|- read_pdb : READ IN %d NATOMS\n",(*mypdb)->natoms);
+
+	//    deallocate_pdb(*mypdb);
+//    fprintf(fplog,"|- PDB READER: DEALLOCATED\n");
+
+	// fprintf(fplog,"ALLOCATED NATOMS %d \n",(*mypdb)->natoms);
+	// read in
+	
+	return 1;
+};
+// this allocate the structure and report its pointer
+int PREFIX allocate_pdb(struct pdb **mypdb, int i){
+    int j;
+	(*mypdb)=(struct pdb *)malloc(sizeof(struct pdb));
+	(*mypdb)->natoms=i;
+	(*mypdb)->x=(real *)malloc(i*sizeof(real));
+	(*mypdb)->y=(real *)malloc(i*sizeof(real));
+	(*mypdb)->z=(real *)malloc(i*sizeof(real));
+	(*mypdb)->beta=(real *)malloc(i*sizeof(real));
+	(*mypdb)->occ=(real *)malloc(i*sizeof(real));
+	(*mypdb)->index=(int *)malloc(i*sizeof(int));
+	(*mypdb)->resid=(int *)malloc(i*sizeof(int));
+	(*mypdb)->name=(char **)malloc(i* sizeof(char *));
+	(*mypdb)->resname=(char **)malloc(i* sizeof(char *));
+	(*mypdb)->chain=(char **)malloc(i* sizeof(char *));
+	for(j=0;j<i;j++){
+	  // allocate chars
+		(*mypdb)->name[j]=(char *)malloc(4*sizeof(char));
+		(*mypdb)->resname[j]=(char *)malloc(4*sizeof(char));
+		(*mypdb)->chain[j]=(char *)malloc(4*sizeof(char));
+	}
+	//fprintf(mtd_data.fplog,"|- allocate_pdb: ALLOCATING %d ATOMS IN PDB\n",(*mypdb)->natoms);
+	return 1;
+};
+int PREFIX deallocate_pdb(struct pdb *mypdb){
+    int i;
+	// free all the pointed elements
+	//fprintf(mtd_data.fplog,"|- deallocate_pdb: DEALLOCATING %d ATOMS IN PDB\n",(*mypdb).natoms);
+	free((*mypdb).index);
+	free((*mypdb).resid);
+	free((*mypdb).x);
+	free((*mypdb).y);
+	free((*mypdb).z);
+	free((*mypdb).occ);
+	free((*mypdb).beta);
+	for(i=0;i<(*mypdb).natoms;i++){
+		free((*mypdb).name[i]);
+		free((*mypdb).resname[i]);
+		free((*mypdb).chain[i]);
+	}
+	free((*mypdb).name);
+	free((*mypdb).resname);
+	free((*mypdb).chain);
+	// free the pointer
+	free(mypdb);
+	return 1;
+};
+// this is a fixed width reader with indexing starting from  1
+void PREFIX parse_fixwidth(char *str,int i, int j, char *str2){
+	int ii,jj,kk;
+	kk=0;
+	for(ii=i-1;ii<=j-1;ii++){
+		str2[kk]=str[ii];
+		//strncpy(&str2[kk],&str[ii],1);
+		kk++;
+	}
+	str2[kk]='\0';
+	//strcpy(&str2[kk],'\0');
+};
+/*
+ * this allocate/reallocate rmsd work array
+ * so that rmsd is all dynamcal
+ *
+ */
+void PREFIX readapt_rmsd_work_array(int natoms, FILE *fplog){
+	int i,j;
+	if(natoms>rmsd_workstruct.maxsize)
+	{
+		// 
+		fprintf(fplog,"|- NEED TO REALLOCATE RMSD WORK ARRAY FROM %d to %d ELEMENTS\n",rmsd_workstruct.natoms,natoms);
+		// allocate for the first time
+		if(rmsd_workstruct.maxsize!=0){
+			// reallocate a suitable array
+			// free first
+			free(rmsd_workstruct.align);
+			free(rmsd_workstruct.lalign);
+			free(rmsd_workstruct.displace);
+			free(rmsd_workstruct.ldisplace);
+			free_2dr_array_alloc(rmsd_workstruct.r0p,0); // the second is a fake for compatibility
+			free_2dr_array_alloc(rmsd_workstruct.r1p,0);
+			free_2dr_array_alloc(rmsd_workstruct.r0p_rotated,0);
+			free_2dr_array_alloc(rmsd_workstruct.r1p_rotated,0);
+			free_2dr_array_alloc(rmsd_workstruct.r0,0);
+			free_2dr_array_alloc(rmsd_workstruct.r1,0);
+			free_2dr_array_alloc(rmsd_workstruct.derr_dr0,0);
+			free_2dr_array_alloc(rmsd_workstruct.derr_dr1,0);
+			free_4dr_array_alloc(rmsd_workstruct.dd_dr0,3,3,3);
+			free_4dr_array_alloc(rmsd_workstruct.dd_dr1,3,3,3);
+			free_4dr_array_alloc(rmsd_workstruct.dm_r0_store,4,4,3);
+			free_4dr_array_alloc(rmsd_workstruct.dm_r1_store,4,4,3);
+			free_2dr_array_alloc(rmsd_workstruct.array_3_n,0);
+			free_4dr_array_alloc(rmsd_workstruct.dd_dr_temp,3,3,3);
+
+		}
+		rmsd_workstruct.align=(real *)malloc(natoms*sizeof(real));
+		rmsd_workstruct.displace=(real *)malloc(natoms*sizeof(real));
+		rmsd_workstruct.lalign=(int *)malloc(natoms*sizeof(int));
+		rmsd_workstruct.ldisplace=(int *)malloc(natoms*sizeof(int));
+		rmsd_workstruct.r0p=float_2d_array_alloc(3,natoms);
+		rmsd_workstruct.r1p=float_2d_array_alloc(3,natoms);
+		rmsd_workstruct.r0p_rotated=float_2d_array_alloc(3,natoms);
+		rmsd_workstruct.r1p_rotated=float_2d_array_alloc(3,natoms);
+		rmsd_workstruct.r0=float_2d_array_alloc(3,natoms);
+		rmsd_workstruct.r1=float_2d_array_alloc(3,natoms);
+		rmsd_workstruct.derr_dr0=float_2d_array_alloc(3,natoms);
+		rmsd_workstruct.derr_dr1=float_2d_array_alloc(3,natoms);
+		rmsd_workstruct.dd_dr0=float_4d_array_alloc(3,3,3,natoms);
+		rmsd_workstruct.dd_dr1=float_4d_array_alloc(3,3,3,natoms);
+		
+		rmsd_workstruct.dm_r1_store=float_4d_array_alloc(4,4,3,natoms);
+		rmsd_workstruct.dm_r0_store=float_4d_array_alloc(4,4,3,natoms);
+		rmsd_workstruct.dd_dr_temp=float_4d_array_alloc(3,3,3,natoms);
+		rmsd_workstruct.array_3_n=float_2d_array_alloc(3,natoms);
+		
+		rmsd_workstruct.maxsize=natoms;
+	}else{
+		fprintf(fplog,"|- NO NEED TO REALLOCATE RMSD WORK ARRAY: REQUESTED SIZE OF  %d IS LOWER THAN ACTUAL %d\n ELEMENTS\n",natoms,rmsd_workstruct.maxsize);
+	}
+};
+void PREFIX readapt_rmsd_work_array_secondder(int natoms, FILE *fplog){
+	int i,j;
+	// check the first derivative first
+	readapt_rmsd_work_array_secondder(natoms,fplog);
+	// now do the second der
+	if(natoms>rmsd_workstruct.maxsize_secondder)
+	{
+		// 
+		fprintf(fplog,"|- 2nd DER: NEED TO REALLOCATE RMSD WORK ARRAY FROM %d to %d\n ELEMENTS\n",rmsd_workstruct.natoms,natoms);
+		// allocate for the first time
+		if(rmsd_workstruct.maxsize_secondder!=0){
+			// reallocate a suitable array
+			// free first
+			free_4dr_array_alloc(rmsd_workstruct.dderr_dr1_dr1,3,rmsd_workstruct.maxsize_secondder,3);
+			free_4dr_array_alloc(rmsd_workstruct.dderr_dr1_dr0,3,rmsd_workstruct.maxsize_secondder,3);
+			free_4dr_array_alloc(rmsd_workstruct.dderr_dr0_dr1,3,rmsd_workstruct.maxsize_secondder,3);
+			free_4dr_array_alloc(rmsd_workstruct.dderr_dr0_dr0,3,rmsd_workstruct.maxsize_secondder,3);
+		}
+		rmsd_workstruct.dderr_dr1_dr1=float_4d_array_alloc(3,natoms,3,natoms);
+		rmsd_workstruct.dderr_dr1_dr0=float_4d_array_alloc(3,natoms,3,natoms);
+		rmsd_workstruct.dderr_dr0_dr1=float_4d_array_alloc(3,natoms,3,natoms);
+		rmsd_workstruct.dderr_dr0_dr0=float_4d_array_alloc(3,natoms,3,natoms);
+		rmsd_workstruct.maxsize_secondder=natoms;
+	}else{
+		fprintf(fplog,"|- 2nd DER: NO NEED TO REALLOCATE RMSD WORK ARRAY: REQUESTED SIZE OF  %d IS LOWER THAN ACTUAL %d\n ELEMENTS\n",natoms,rmsd_workstruct.natoms);
+	}
+	
+	
+};
+void PREFIX allocate_rmsd_container(struct rmsd_container_t *rmsd_container,int i){
+	rmsd_container->align=(real *)malloc(i*sizeof(real));
+	rmsd_container->displace=(real *)malloc(i*sizeof(real));
+};
+void PREFIX copy_pdb_into_rmsd_container(struct pdb mypdb, struct rmsd_container_t *rmsd_container,FILE *fplog){
+	int natoms, i,simple,nalign,ndisplace;
+	real walign,wdislpace;
+	natoms=mypdb.natoms;
+	fprintf(fplog,"|- PDB HAS %d ATOMS\n",natoms);
+
+	rmsd_container->align=(real *)malloc(natoms*sizeof(real));
+	rmsd_container->displace=(real *)malloc(natoms*sizeof(real));
+	rmsd_container->ldisplace=(int *)malloc(natoms*sizeof(int));
+	rmsd_container->lalign=(int *)malloc(natoms*sizeof(int));
+
+	rmsd_container->x=(real *)malloc(natoms*sizeof(real));
+	rmsd_container->y=(real *)malloc(natoms*sizeof(real));
+	rmsd_container->z=(real *)malloc(natoms*sizeof(real));
+	rmsd_container->index=(int *)malloc(natoms*sizeof(int));
+
+	
+	walign=0.;wdislpace=0.;simple=1;nalign=0;ndisplace=0;
+	rmsd_container->natoms=natoms;
+	for(i=0;i<natoms;i++){
+		rmsd_container->x[i]=mypdb.x[i];
+		rmsd_container->y[i]=mypdb.y[i];
+		rmsd_container->z[i]=mypdb.z[i];
+		rmsd_container->index[i]=mypdb.index[i]-1;
+		rmsd_container->align[i]=mypdb.occ[i];
+		rmsd_container->displace[i]=mypdb.beta[i];
+		if(rmsd_container->align[i]!=rmsd_container->displace[i])simple=0;
+		// assign various weight function 
+		walign+=rmsd_container->align[i];
+		wdislpace+=rmsd_container->displace[i];
+		if(rmsd_container->align[i]!=0.){
+			rmsd_container->lalign[nalign]=i;
+			nalign++;
+		}
+		if(rmsd_container->displace[i]!=0.){
+			rmsd_container->ldisplace[ndisplace]=i;
+			ndisplace++;
+		}
+	};
+	rmsd_container->ndisplace=ndisplace;
+	rmsd_container->nalign=nalign;
+	rmsd_container->walign=walign;
+	rmsd_container->wdisplace=wdislpace;
+
+	fprintf(fplog,"|- FOUND %d ATOMS FOR ALIGNMENT\n",nalign);
+	fprintf(fplog,"|- FOUND %d ATOMS FOR DISPLACEMENT\n",ndisplace);
+	if(simple==1){
+		fprintf(fplog,"|- ALIGN AND DISPLACE ARE IDENTICAL: WILL USE FASTER SIMPLE ALIGNMENT\n");
+	}else{
+		fprintf(fplog,"|- ALIGN AND DISPLACE ARE NOT IDENTICAL: WILL USE SLOWER ALIGNMENT\n");	
+	}
+	
+};
+void PREFIX msd_restraint(int i_c, struct mtd_data_s *mtd_data){
+	int i,j,iat;
+	//fprintf(mtd_data->fplog,"|- ENTERED THE MSD ROUTINE: I_C IS %d\n",i_c);
+	//
+	// get the actual position and copy them into the work array
+	// probably faster by copying only the pointers? but then you don't need the allocation
+	//
+	rmsd_workstruct.natoms=colvar.rmsd_container[i_c].natoms;
+	for (i=0;i<colvar.natoms[i_c];i++){
+		iat = colvar.cvatoms[i_c][i];
+		// the running structure r0
+		//fprintf(mtd_data->fplog,"|- ATOM %d ID %d : X %f\n",i,iat,mtd_data->pos[iat][0]);
+		rmsd_workstruct.r0[0][i] = mtd_data->pos[iat][0];
+		rmsd_workstruct.r0[1][i] = mtd_data->pos[iat][1];
+		rmsd_workstruct.r0[2][i] = mtd_data->pos[iat][2];
+		//fprintf(mtd_data->fplog,"|- ATOM %d : X %f Y %f Z %f\n",i,rmsd_workstruct.r0[0][i],rmsd_workstruct.r0[1][i],rmsd_workstruct.r0[2][i]);
+		// the reference structure r1
+		rmsd_workstruct.r1[0][i] = colvar.rmsd_container[i_c].x[i];
+		rmsd_workstruct.r1[1][i] = colvar.rmsd_container[i_c].y[i];
+		rmsd_workstruct.r1[2][i] = colvar.rmsd_container[i_c].z[i];
+		// align and displace
+		rmsd_workstruct.align[i]=colvar.rmsd_container[i_c].align[i];
+		rmsd_workstruct.displace[i]=colvar.rmsd_container[i_c].displace[i];
+		rmsd_workstruct.lalign[i]=colvar.rmsd_container[i_c].lalign[i];
+		rmsd_workstruct.ldisplace[i]=colvar.rmsd_container[i_c].ldisplace[i];
+	}
+	rmsd_workstruct.ndisplace=colvar.rmsd_container[i_c].ndisplace;
+	rmsd_workstruct.nalign=colvar.rmsd_container[i_c].nalign;
+	rmsd_workstruct.simple=colvar.rmsd_container[i_c].simple;
+	
+
+	// do the real calculation
+	// opts:
+	//  -do the derivative respect to the ref struct
+	//  -use the rotation matrix
+	//  -use the geometric center correction
+	//
+	// all the output structs are in the rmsd workarray
+	//
+	if(colvar.rmsd_container[i_c].dummy){
+		// exploit this vector that should not be used anyway 
+		colvar.ss0[i_c]=0.;
+		for(j=0;j<3;j++) {	
+			for(i=0;i<colvar.natoms[i_c];i++) {
+				iat= colvar.cvatoms[i_c][i];
+//				colvar.myder[i_c][i][j] = 0.;
+				colvar.myder[i_c][i][j] = mtd_data->pos[iat][j];
+
+			}
+		}
+	}else{
+		
+		msd_calculation_dynamic(&rmsd_workstruct,colvar.rmsd_container[i_c].dref,1,1);
+		
+		// copy the result into derivative module
+		colvar.ss0[i_c]=rmsd_workstruct.err;
+		for(j=0;j<3;j++) {	
+			for(i=0;i<colvar.natoms[i_c];i++) {
+				colvar.myder[i_c][i][j] = rmsd_workstruct.derr_dr0[j][i];
+			}
+		}
+
+		if(colvar.rmsd_container[i_c].dref){
+			// calculate derivatives now	
+			if(colvar.it%colvar.rmsd_container[i_c].dref_freq==0){
+			fprintf(colvar.rmsd_container[i_c].fpdreffile,"NEWSET\n");
+				for(i=0;i<colvar.natoms[i_c];i++) {
+					for(j=0;j<3;j++) {	
+						 fprintf(colvar.rmsd_container[i_c].fpdreffile,"%12.6f ",rmsd_workstruct.derr_dr1[j][i]);
+					}
+					fprintf(colvar.rmsd_container[i_c].fpdreffile,"\n");
+				}
+			}
+		}
+	}
+// clean the structures (now dummy) 
+	clean_rmsd_work_array(&rmsd_workstruct);
+	
+	//fprintf(mtd_data->fplog,"|- EXITED MSD  ROUTINE\n");
+	//EXIT();
+};
+void  PREFIX msd_calculation_dynamic(struct rmsd_workstruct_s *work,int der_frameref_on, int do_rot, int do_center){
+	//fprintf(mtd_data.fplog,"|- ENTERED THE RMSD_DYNAMIC ROUTINE\n");
+	
+	//
+	// finite difference tests
+	//
+	//rmsd_dynamic_findiff_interface(work);
+	//EXIT();
+	
+	
+	if(do_rot) { 
+		// fast version to get simple alignment
+		if(work->simple){
+			// do the alignment and 
+			// -do the weighted centering
+			// -do der respct reference frame r1
+			// -avoid der respect to rotation matrix 
+			// msd_core_dynamic_simple(struct rmsd_workstruct_s *work,int do_center, int do_frameref_der, int do_rotmat_der)
+			msd_core_dynamic_simple(work,do_center,der_frameref_on,0);
+		}else{
+			// slow version: calculate the measure respect to a different set of atoms
+			// -do the weighted centering
+			// -calculate der respect to rotation matrix
+			// -avoid der respect reference frame
+			msd_core_dynamic_simple(work,do_center,der_frameref_on,1);
+			// then use it into a different structure
+			msd_core_dynamic_weighted(work,do_center,0);
+		}		
+	}else{
+		// the simplest case: no rotation needed
+		msd_core_dynamic_norot(work,do_center); 
+	}
+	
+	//fprintf(mtd_data.fplog,"|- EXITED THE RMSD_DYNAMIC ROUTINE\n");
+};	
+void  PREFIX msd_core_dynamic_norot(struct rmsd_workstruct_s *work, int do_center){
+	//fprintf(mtd_data.fplog,"|- ENTERED THE RMSD_DYNAMIC_NOROT ROUTINE\n");
+	real xx[3], totalign, totdisplace;
+	int natoms,i,j,k,l;
+
+	natoms=work->natoms;
+	totalign=0.;
+	for(i=0;i<work->nalign;i++){
+		k=work->lalign[i];
+		totalign+=work->align[k];
+	}
+	//
+	// recenter r0
+	//
+	for(j=0;j<3;j++)xx[j]=0.;
+	if(do_center) {// if you dont need to center no prob...
+		for(j=0;j<3;j++){
+			for(i=0;i<work->nalign;i++){
+				k=work->lalign[i];
+				xx[j]+=work->r0[j][k]*work->align[k];
+				//fprintf(mtd_data.fplog,"|-R0 DIR %d AT  %d P %f \n",j,k,work->r0[j][k]);
+			}
+		}
+		for(j=0;j<3;j++)xx[j]=xx[j]/(totalign);
+		
+	}
+	for(j=0;j<3;j++)work->cmr0[j]=xx[j];
+	
+	// shift the position of all the atoms
+	for(i=0;i<natoms;i++){
+		for(j=0;j<3;j++)work->r0p[j][i]=work->r0[j][i]-xx[j];
+	}
+	
+	//
+	// recenter the r1 structure now
+	//	
+	for(j=0;j<3;j++)xx[j]=0.;
+	if(do_center) {// if you dont need to center no prob...
+		for(j=0;j<3;j++){
+			for(i=0;i<work->nalign;i++){
+				k=work->lalign[i];
+				xx[j]+=work->r1[j][k]*work->align[k];
+				//fprintf(mtd_data.fplog,"|-R1 DIR %d AT  %d P %f \n",j,k,work->r1[j][k]);
+			}
+		}
+		for(j=0;j<3;j++)xx[j]=xx[j]/(totalign);
+		
+	}
+	for(j=0;j<3;j++)work->cmr1[j]=xx[j];
+	
+	// shift the position of all the atoms
+	for(i=0;i<natoms;i++){
+		for(j=0;j<3;j++)work->r1p[j][i]=work->r1[j][i]-xx[j];
+	}
+	
+
+	/*
+	 * Identity in the ROTATION matrix
+	 */
+	
+	work->d[0][0]=1.0 ; 
+	work->d[0][1]=0.0 ; 
+	work->d[0][2]=0.0 ; 
+	work->d[1][0]=0.0 ; 
+	work->d[1][1]=1.0 ; 
+	work->d[1][2]=0.0 ; 
+	work->d[2][0]=0.0 ; 
+	work->d[2][1]=0.0 ; 
+	work->d[2][2]=1.0 ; 
+
+	work->err=0.;     
+	totdisplace=0.;
+	for(i=0;i<work->ndisplace;i++){
+		k=work->ldisplace[i];
+		totdisplace+=work->displace[k];
+	}
+	
+	for(l=0;l<3;l++){
+		for(i=0;i<work->ndisplace;i++){
+			k=work->ldisplace[i];	
+			//fprintf(mtd_data.fplog,"POS1 %d %d : R0P %f R1P %f \n",k,l,work->r0p[l][k],work->r1p[l][k]);
+			work->err+=work->displace[k]*(work->r0p[l][k]-work->r1p[l][k])*(work->r0p[l][k]-work->r1p[l][k]);
+		}
+	}
+	work->err/=totdisplace;
+	
+	//fprintf(mtd_data.fplog,"|- ERR %f\n",work->err);
+	/*
+	 * derivative 
+	 *
+	 */
+	for(l=0;l<3;l++){
+		for(i=0;i<work->natoms;i++){
+			work->derr_dr1[l][i]=-(2.*work->displace[i]/(totdisplace))*(work->r0p[l][i]-work->r1p[l][i]); 
+			if(do_center){
+				for(j=0;j<work->natoms;j++){
+					work->derr_dr1[l][i]+=(2.*work->align[i]*work->displace[j]/(totalign*totdisplace))*(work->r0p[l][j]-work->r1p[l][j]);
+				}
+			}
+			//                	printf("DER %d DIR %d : %f\n",i,l,outpack->derr_dr1[l][i]);   
+		}	
+	}
+	
+	for(l=0;l<3;l++){
+		for(i=0;i<work->natoms;i++){
+			work->derr_dr0[l][i]=(2.*work->displace[i]/(totdisplace))*(work->r0p[l][i]-work->r1p[l][i]); 
+			if(do_center){
+				for(j=0;j<work->natoms;j++){
+					work->derr_dr0[l][i]-=(2.*work->align[i]*work->displace[j]/(totalign*totdisplace))*(work->r0p[l][j]-work->r1p[l][j]);
+				}
+			}
+			//                	printf("DER %d DIR %d : %f\n",i,l,outpack->derr_dr0[l][i]);   
+		}	
+	}
+	
+	for(i=0;i<3;i++){
+		for(j=0;j<3;j++){
+			for(k=0;k<3;k++){
+                for(l=0;l<work->natoms;l++){
+					work->dd_dr1[i][j][k][l]=0.;
+					work->dd_dr0[i][j][k][l]=0.;
+                }
+            }	
+       	}	
+	}
+	
+	//fprintf(mtd_data.fplog,"|- EXITING THE RMSD_DYNAMIC_NOROT ROUTINE\n");
+};
+//
+// core routine that uses the dynamically allocated structure
+//
+// note that is R1 to be overlapped ON R0 !!!!!!!!!!
+//
+void  PREFIX msd_core_dynamic_simple(struct rmsd_workstruct_s *work,int do_center, int do_frameref_der, int do_rotmat_der){
+	//fprintf(mtd_data.fplog,"|- ENTERED THE RMSD_DYNAMIC_SIMPLE ROUTINE\n");
+	real xx[3], totalign, totdisplace, s, tmp1, fact1, fact2;
+	//
+	// needed workarray for quaternion: the array needed with natom dimensions are
+	// allocated in the rmsd_workstruct
+	//
+	real m[4][4],rr1[4],rr0[4],q[4],lambda[4],dddq[4][4][4],gamma[3][3][3],rrsq;
+	real dm_r1[4][4][3],dm_r0[4][4][3];
+	real pi1[3][3],pi0[3][3];
+	int natoms,i,j,k,l,ii,ll,jj,mm,n,nn,iii;
+	
+	//
+	// recenter r0
+	//
+	natoms=work->natoms;
+	totalign=0.;
+	for(i=0;i<work->nalign;i++){
+		k=work->lalign[i];
+		totalign+=work->align[k];
+	}
+	for(j=0;j<3;j++)xx[j]=0.;
+	if(do_center) {// if you dont need to center no prob...
+		for(j=0;j<3;j++){
+			for(i=0;i<work->nalign;i++){
+				k=work->lalign[i];
+				xx[j]+=work->r0[j][k]*work->align[k];
+				//fprintf(mtd_data.fplog,"|-R0 DIR %d AT  %d P %f \n",j,k,work->r0[j][k]);
+			}
+		}
+		for(j=0;j<3;j++)xx[j]=xx[j]/(totalign);
+	}
+	for(j=0;j<3;j++)work->cmr0[j]=xx[j];
+	
+	// shift the position of all the atoms
+	for(i=0;i<natoms;i++){
+		for(j=0;j<3;j++)work->r0p[j][i]=work->r0[j][i]-xx[j];
+	}
+	//fprintf(mtd_data.fplog,"|-NATOMS %d\n",natoms);
+//	for(i=0;i<natoms;i++){
+//		//for(j=0;j<3;j++)fprintf(mtd_data.fplog,"|-R0P DIR %d AT  %d P %f \n",i,j,work->r0p[j][i]);
+//		fprintf(mtd_data.fplog,"ATOM    %3d    C ALA     1      %8.3f%8.3f%8.3f\n",i+1,work->r0p[0][i],work->r0p[1][i],work->r0p[2][i]);
+//	}
+//	fprintf(mtd_data.fplog,"END\n");
+	
+	
+	//
+	// recenter the r1 structure now
+	//	
+	for(j=0;j<3;j++)xx[j]=0.;
+	if(do_center) {// if you dont need to center no prob...
+		for(j=0;j<3;j++){
+			for(i=0;i<work->nalign;i++){
+				k=work->lalign[i];
+				xx[j]+=work->r1[j][k]*work->align[k];
+				//fprintf(mtd_data.fplog,"|-R1 DIR %d AT  %d P %f \n",j,k,work->r1[j][k]);
+			}
+		}
+		for(j=0;j<3;j++)xx[j]=xx[j]/(totalign);
+	}
+	for(j=0;j<3;j++)work->cmr1[j]=xx[j];
+	
+	// shift the position of ALL the atoms
+	for(i=0;i<natoms;i++){
+		for(j=0;j<3;j++)work->r1p[j][i]=work->r1[j][i]-xx[j];
+	}
+//	for(i=0;i<natoms;i++){
+//		for(j=0;j<3;j++)fprintf(mtd_data.fplog,"|-R1P DIR %d AT  %d P %f  R1  %f\n",i,j,work->r1p[j][i],work->r1[j][i]);
+//		fprintf(mtd_data.fplog,"ATOM    %3d    C ALA     1      %8.3f%8.3f%8.3f\n",i+1,work->r0p[0][i],work->r0p[1][i],work->r0p[2][i]);
+//
+//	}
+//	fprintf(mtd_data.fplog,"END\n");
+
+	fflush(mtd_data.fplog);
+	
+	//
+	// start with the real calculation
+	//
+	
+	// CLEAN M MATRIX
+	for(i=0;i<4;i++){
+		for(j=0;j<4;j++){
+			m[i][j]=0.;  
+		}
+	}
+	
+	// ASSIGN MATRIX ELEMENTS USING ONLY THE ATOMS INVOLVED IN ALIGNMENT
+	for(i=0;i<work->nalign;i++){
+		
+		k=work->lalign[i];
+        tmp1=work->align[k];
+		
+		// adopt scaled coordinates
+		
+		rr1[0]=work->r1p[0][k]*tmp1;
+        rr1[1]=work->r1p[1][k]*tmp1;
+        rr1[2]=work->r1p[2][k]*tmp1;
+        rr0[0]=work->r0p[0][k]*tmp1;
+        rr0[1]=work->r0p[1][k]*tmp1;
+        rr0[2]=work->r0p[2][k]*tmp1;
+		
+        rrsq=(pow(rr0[0],2)+pow(rr0[1],2)+pow(rr0[2],2)+pow(rr1[0],2)+pow(rr1[1],2)+pow(rr1[2],2));
+		
+        m[0][0] +=  rrsq+2.*(-rr0[0]*rr1[0]-rr0[1]*rr1[1]-rr0[2]*rr1[2]);
+        m[1][1] +=  rrsq+2.*(-rr0[0]*rr1[0]+rr0[1]*rr1[1]+rr0[2]*rr1[2]);
+        m[2][2] +=  rrsq+2.*(+rr0[0]*rr1[0]-rr0[1]*rr1[1]+rr0[2]*rr1[2]);
+        m[3][3] +=  rrsq+2.*(+rr0[0]*rr1[0]+rr0[1]*rr1[1]-rr0[2]*rr1[2]);
+        m[0][1] += 2.*(-rr0[1]*rr1[2]+rr0[2]*rr1[1]);
+        m[0][2] += 2.*( rr0[0]*rr1[2]-rr0[2]*rr1[0]);
+        m[0][3] += 2.*(-rr0[0]*rr1[1]+rr0[1]*rr1[0]);
+        m[1][2] -= 2.*( rr0[0]*rr1[1]+rr0[1]*rr1[0]);
+        m[1][3] -= 2.*( rr0[0]*rr1[2]+rr0[2]*rr1[0]);
+        m[2][3] -= 2.*( rr0[1]*rr1[2]+rr0[2]*rr1[1]);
+		
+	};
+	m[1][0] = m[0][1];
+	m[2][0] = m[0][2];
+	m[2][1] = m[1][2];
+	m[3][0] = m[0][3];
+	m[3][1] = m[1][3];
+	m[3][2] = m[2][3];
+	
+	// check if you might expect something strange
+
+	// DIAGONALIZE : minimize the distance respect to the scaled coordinates
+	
+	ql77_driver(m,lambda);
+	s=1.0;
+	if(m[0][0]<0.)s=-1.;//correct for negative values (?)
+	q[0]=s*m[0][0];
+	q[1]=s*m[1][0];
+	q[2]=s*m[2][0];
+	q[3]=s*m[3][0];
+	work->err=lambda[0]/totalign;
+	//fprintf(mtd_data.fplog,"|- ERR: %f \n",work->err);
+	if(lambda[0]==lambda[1]) plumed_error("DIAGONALIZATION: NON UNIQUE SOLUTION");
+	
+	/*
+	 * the ROTATION matrix
+	 */
+	
+	work->d[0][0]=q[0]*q[0]+q[1]*q[1]-q[2]*q[2]-q[3]*q[3]       ; 
+	work->d[1][0]=2.0*(q[1]*q[2]-q[0]*q[3]);
+	work->d[2][0]=2.0*(q[1]*q[3]+q[0]*q[2]);
+	work->d[0][1]=2.0*(q[1]*q[2]+q[0]*q[3]);
+	work->d[1][1]=q[0]*q[0]+q[2]*q[2]-q[1]*q[1]-q[3]*q[3];
+	work->d[2][1]=2.0*(q[2]*q[3]-q[0]*q[1]);
+	work->d[0][2]=2.0*(q[1]*q[3]-q[0]*q[2]);
+	work->d[1][2]=2.0*(q[2]*q[3]+q[0]*q[1]);
+	work->d[2][2]=q[0]*q[0]+q[3]*q[3]-q[1]*q[1]-q[2]*q[2];
+
+	/* 
+	 * first derivative in perturbation theory : derivative of the rotation matrix respect to the 
+	 * quternion vectors
+	 */
+
+	dddq[0][0][0]= 2.0*q[0];
+	dddq[1][0][0]=-2.0*q[3];
+	dddq[2][0][0]= 2.0*q[2];
+	dddq[0][1][0]= 2.0*q[3];
+	dddq[1][1][0]= 2.0*q[0];
+	dddq[2][1][0]=-2.0*q[1];
+	dddq[0][2][0]=-2.0*q[2];
+	dddq[1][2][0]= 2.0*q[1];
+	dddq[2][2][0]= 2.0*q[0];
+	
+	dddq[0][0][1]= 2.0*q[1];
+	dddq[1][0][1]= 2.0*q[2];
+	dddq[2][0][1]= 2.0*q[3];
+	dddq[0][1][1]= 2.0*q[2];
+	dddq[1][1][1]=-2.0*q[1];
+	dddq[2][1][1]=-2.0*q[0];
+	dddq[0][2][1]= 2.0*q[3];
+	dddq[1][2][1]= 2.0*q[0];
+	dddq[2][2][1]=-2.0*q[1];
+	
+	dddq[0][0][2]=-2.0*q[2];
+	dddq[1][0][2]= 2.0*q[1];
+	dddq[2][0][2]= 2.0*q[0];
+	dddq[0][1][2]= 2.0*q[1];
+	dddq[1][1][2]= 2.0*q[2];
+	dddq[2][1][2]= 2.0*q[3];
+	dddq[0][2][2]=-2.0*q[0];
+	dddq[1][2][2]= 2.0*q[3];
+	dddq[2][2][2]=-2.0*q[2];
+	
+	dddq[0][0][3]=-2.0*q[3];
+	dddq[1][0][3]=-2.0*q[0];
+	dddq[2][0][3]= 2.0*q[1];
+	dddq[0][1][3]= 2.0*q[0];
+	dddq[1][1][3]=-2.0*q[3];
+	dddq[2][1][3]= 2.0*q[2];
+	dddq[0][2][3]= 2.0*q[1];
+	dddq[1][2][3]= 2.0*q[2];
+	dddq[2][2][3]= 2.0*q[3];
+	/*
+	 * Build gamma 3x3x3 matrix
+	 */
+	for(i=0;i<3;i++){     //direction 
+		for(j=0;j<3;j++){     //direction 
+			for(k=0;k<3;k++){     //eigenvector number
+				gamma[i][j][k]=0.0;
+				for(l=0;l<4;l++){   //components of each eigenvector in pert. series
+					if(lambda[0]==lambda[k+1]){
+						fprintf(mtd_data.fplog,"|- FOUND DEGENERACY IN RMSD_ESS ROUTINE \n");
+						fprintf(mtd_data.fplog,"|- I'm DYING....\n");
+						fprintf(mtd_data.fplog,"|- COPYING STACK HERE \n");
+						fprintf(mtd_data.fplog,"|- R0\n");
+						for(ll=0;ll<natoms;ll++)fprintf(mtd_data.fplog,"|- %f %f %f \n",work->r0p[0][ll],work->r0p[1][ll],work->r0p[2][ll]);
+						fprintf(mtd_data.fplog,"|- R1\n");
+						for(ll=0;ll<natoms;ll++)fprintf(mtd_data.fplog,"|- %f %f %f \n",work->r1p[0][ll],work->r1p[1][ll],work->r1p[2][ll]);
+						plumed_error("FOUND DEGENERACY IN RMSD_ESS ROUTINE");
+					} 
+					else{
+						gamma[i][j][k]  +=  dddq[i][j][l]*m[l][k+1]/(lambda[0]-lambda[k+1]);
+					}
+				}
+			}
+			
+		}	
+	}
+	
+	//fprintf(mtd_data.fplog,"|- STAGE 1 \n");
+
+	  
+	// clean up the rotation matrix for all the atoms
+	// probably not needed
+	for(j=0;j<3;j++){
+		for (k=0;k<3;k++){
+			for(l=0;l<3;l++){	  
+				for(i=0;i<work->natoms;i++){
+					work->dd_dr1[j][k][l][i]=0.;
+					work->dd_dr0[j][k][l][i]=0.;
+					work->dd_dr_temp[j][k][l][i]=0.;
+				}
+			}
+		}
+	}  
+	// clean up the derivatives
+	for(l=0;l<3;l++){	  
+		for(i=0;i<work->natoms;i++){
+			work->derr_dr1[l][i]=0.;
+			work->derr_dr0[l][i]=0.;
+			work->array_3_n[l][i]=0.;
+		}
+	}
+	
+		/* 
+	 * Table of Derivative of the quaternion matrix respect to atom position: needed only if simple
+	 * alignment is required and no correction respect to the rotation matrix is wanted
+	 */
+		
+  for(iii=0;iii<work->nalign;iii++){
+	  
+	  i=work->lalign[iii];
+	  tmp1=work->align[i];
+
+	  // once again: derivative respect to scaled distance
+	  
+	  rr1[0]=2.*work->r1p[0][i]*tmp1;
+	  rr1[1]=2.*work->r1p[1][i]*tmp1;
+	  rr1[2]=2.*work->r1p[2][i]*tmp1;
+	  rr0[0]=2.*work->r0p[0][i]*tmp1;
+	  rr0[1]=2.*work->r0p[1][i]*tmp1;
+	  rr0[2]=2.*work->r0p[2][i]*tmp1;
+	  
+	  
+	  dm_r1 [0][0][0]=(rr1[0]-rr0[0]);
+	  dm_r1 [0][0][1]=(rr1[1]-rr0[1]);
+	  dm_r1 [0][0][2]=(rr1[2]-rr0[2]);
+	  
+	  dm_r1 [0][1][0]=0.;
+	  dm_r1 [0][1][1]= rr0[2];
+	  dm_r1 [0][1][2]=-rr0[1];
+	  
+	  dm_r1 [0][2][0]=-rr0[2];
+	  dm_r1 [0][2][1]= 0.;
+	  dm_r1 [0][2][2]= rr0[0];
+	  
+	  dm_r1 [0][3][0]= rr0[1];
+	  dm_r1 [0][3][1]=-rr0[0];
+	  dm_r1 [0][3][2]= 0.;
+	  
+	  dm_r1 [1][1][0]=(rr1[0]-rr0[0]);
+	  dm_r1 [1][1][1]=(rr1[1]+rr0[1]);
+	  dm_r1 [1][1][2]=(rr1[2]+rr0[2]);
+	  
+	  dm_r1 [1][2][0]=-rr0[1];
+	  dm_r1 [1][2][1]=-rr0[0];
+	  dm_r1 [1][2][2]= 0.;
+	  
+	  dm_r1 [1][3][0]=-rr0[2];
+	  dm_r1 [1][3][1]= 0.;
+	  dm_r1 [1][3][2]=-rr0[0];
+	  
+	  dm_r1 [2][2][0]=(rr1[0]+rr0[0]);
+	  dm_r1 [2][2][1]=(rr1[1]-rr0[1]);
+	  dm_r1 [2][2][2]=(rr1[2]+rr0[2]);
+	  
+	  dm_r1 [2][3][0]=0.;
+	  dm_r1 [2][3][1]=-rr0[2];
+	  dm_r1 [2][3][2]=-rr0[1];
+	  
+	  dm_r1 [3][3][0]=(rr1[0]+rr0[0]);
+	  dm_r1 [3][3][1]=(rr1[1]+rr0[1]);
+	  dm_r1 [3][3][2]=(rr1[2]-rr0[2]);
+	  /*
+	   derivative respec to to the other vector
+	   */
+	  dm_r0 [0][0][0]=-(rr1[0]-rr0[0]);
+	  dm_r0 [0][0][1]=-(rr1[1]-rr0[1]);
+	  dm_r0 [0][0][2]=-(rr1[2]-rr0[2]);
+	  
+	  dm_r0 [0][1][0]=0.       ;
+	  dm_r0 [0][1][1]=-rr1[2];
+	  dm_r0 [0][1][2]=rr1[1];
+	  
+	  dm_r0 [0][2][0]= rr1[2];      
+	  dm_r0 [0][2][1]= 0.;
+	  dm_r0 [0][2][2]=-rr1[0];
+	  
+	  dm_r0 [0][3][0]=-rr1[1] ;     
+	  dm_r0 [0][3][1]= rr1[0];
+	  dm_r0 [0][3][2]= 0.;
+	  
+	  dm_r0 [1][1][0]=-(rr1[0]-rr0[0]);
+	  dm_r0 [1][1][1]=(rr1[1]+rr0[1]);
+	  dm_r0 [1][1][2]=(rr1[2]+rr0[2]);
+	  
+	  dm_r0 [1][2][0]=-rr1[1];
+	  dm_r0 [1][2][1]=-rr1[0];
+	  dm_r0 [1][2][2]= 0.;
+	  
+	  dm_r0 [1][3][0]=-rr1[2];
+	  dm_r0 [1][3][1]= 0.;
+	  dm_r0 [1][3][2]=-rr1[0];
+	  
+	  dm_r0 [2][2][0]=(rr1[0]+rr0[0]);
+	  dm_r0 [2][2][1]=-(rr1[1]-rr0[1]);
+	  dm_r0 [2][2][2]=(rr1[2]+rr0[2]);
+	  
+	  dm_r0 [2][3][0]=0.;
+	  dm_r0 [2][3][1]=-rr1[2];
+	  dm_r0 [2][3][2]=-rr1[1];
+	  
+	  dm_r0 [3][3][0]=(rr1[0]+rr0[0]);
+	  dm_r0 [3][3][1]=(rr1[1]+rr0[1]);
+	  dm_r0 [3][3][2]=-(rr1[2]-rr0[2]);
+	  /*
+	   * write the diagonal
+	   */ 
+	  
+	  for(j=0;j<3;j++){
+		  
+		  dm_r1[1][0][j]=dm_r1[0][1][j];
+		  dm_r1[2][0][j]=dm_r1[0][2][j];
+		  dm_r1[3][0][j]=dm_r1[0][3][j];
+		  dm_r1[2][1][j]=dm_r1[1][2][j];
+		  dm_r1[3][1][j]=dm_r1[1][3][j];
+		  dm_r1[3][2][j]=dm_r1[2][3][j];
+		  
+		  dm_r0[1][0][j]=dm_r0[0][1][j];
+		  dm_r0[2][0][j]=dm_r0[0][2][j];
+		  dm_r0[3][0][j]=dm_r0[0][3][j];
+		  dm_r0[2][1][j]=dm_r0[1][2][j];
+		  dm_r0[3][1][j]=dm_r0[1][3][j];
+		  dm_r0[3][2][j]=dm_r0[2][3][j];
+		  
+		  for(ll=0;ll<4;ll++){
+			  for(mm=0;mm<4;mm++){
+				  work->dm_r0_store[ll][mm][j][i]=dm_r0[ll][mm][j];
+				  work->dm_r1_store[ll][mm][j][i]=dm_r1[ll][mm][j];
+			  };
+		  };
+	  };
+	  /*
+	   * pi matrix : coefficents in per theory
+	   */
+
+	  for(j=0;j<3;j++){
+		  pi1[0][j]=0.;
+		  pi1[1][j]=0.;
+		  pi1[2][j]=0.;
+		  pi0[0][j]=0.;
+		  pi0[1][j]=0.;
+		  pi0[2][j]=0.;
+		  work->derr_dr1[j][i]=0.;
+		  work->derr_dr0[j][i]=0.;
+		  
+		  for(k=0;k<4;k++){
+			  for(l=0;l<4;l++){
+				  work->derr_dr1[j][i]=work->derr_dr1[j][i]+q[k]*q[l]*dm_r1[l][k][j];
+				  work->derr_dr0[j][i]=work->derr_dr0[j][i]+q[k]*q[l]*dm_r0[l][k][j];
+				  for(mm=0;mm<3;mm++){
+					  pi0[mm][j]+=m[k][mm+1]*dm_r0[l][k][j]*q[l];
+					  pi1[mm][j]+=m[k][mm+1]*dm_r1[l][k][j]*q[l];  
+				  };
+			  };
+		  };
+		  work->derr_dr1[j][i]=work->derr_dr1[j][i]/totalign;
+		  work->derr_dr0[j][i]=work->derr_dr0[j][i]/totalign;
+		  
+	  };
+	//fprintf(mtd_data.fplog,"|- STAGE 2c \n");
+
+	  for(j=0;j<3;j++){
+		  for (k=0;k<3;k++){
+			  for(l=0;l<3;l++){	    
+				  work->dd_dr1[j][k][l][i]=0.;
+				  work->dd_dr0[j][k][l][i]=0.;
+				  for(ii=0;ii<3;ii++){
+					  work->dd_dr1[j][k][l][i]+=gamma[j][k][ii]*pi1[ii][l]; 
+					  work->dd_dr0[j][k][l][i]+=gamma[j][k][ii]*pi0[ii][l]; 
+				  }
+			  }
+		  }
+	  }
+  }
+	
+	
+	// end of the calculation of the derivative of the rotation matrix
+	
+	/*
+	 * Now correct for center of mass: only if needed 
+	 *
+	 */
+		//
+		// correction for r1 frame
+		//
+	if(do_frameref_der){
+		for(l=0;l<3;l++){
+			for(k=0;k<work->nalign;k++){
+				i=work->lalign[k];
+				work->array_3_n[l][i]=work->align[i]*work->derr_dr1[l][i];
+				tmp1=work->align[i]/totalign; 
+				if(do_center){		
+					for(jj=0;jj<work->nalign;jj++){
+						j=work->lalign[jj];
+						work->array_3_n[l][i]-=tmp1*work->align[j]*work->derr_dr1[l][j];
+					}
+				}
+				
+			}
+		}
+		for(l=0;l<3;l++){
+			for(k=0;k<work->nalign;k++){
+				i=work->lalign[k];
+				work->derr_dr1[l][i]=work->array_3_n[l][i];
+			}
+		}	
+	}
+	//
+	// correction for r0 frame
+	//
+	for(l=0;l<3;l++){
+		for(k=0;k<work->nalign;k++){
+			i=work->lalign[k];
+			work->array_3_n[l][i]=work->align[i]*work->derr_dr0[l][i];
+			tmp1=work->align[i]/totalign; 
+			if(do_center){		
+				for(jj=0;jj<work->nalign;jj++){
+					j=work->lalign[jj];
+					work->array_3_n[l][i]-=tmp1*work->align[j]*work->derr_dr0[l][j];
+				}
+			}
+		}
+	}
+	for(l=0;l<3;l++){
+		for(k=0;k<work->nalign;k++){
+			i=work->lalign[k];
+			work->derr_dr0[l][i]=work->array_3_n[l][i];
+		}
+	}	
+	//
+	// correction for the rotation matrix: r1 frame
+	//
+	if(do_frameref_der && do_rotmat_der){
+		for(i=0;i<3;i++){
+			for(j=0;j<3;j++){
+				for(k=0;k<3;k++){
+					for(ll=0;ll<work->nalign;ll++){
+						l=work->lalign[ll];
+						work->dd_dr_temp[i][j][k][l]=work->align[l]*work->dd_dr1[i][j][k][l];
+						tmp1=work->align[l]/totalign; 
+						if(do_center){		
+							for(nn=0;nn<work->nalign;nn++){
+								n=work->lalign[nn];
+								work->dd_dr_temp[i][j][k][l]-=work->dd_dr1[i][j][k][n]*tmp1*work->align[n]; 
+							}
+						}
+						
+					}
+				}	
+			}	
+		}
+		for(i=0;i<3;i++){
+			for(j=0;j<3;j++){
+				for(k=0;k<3;k++){
+					for(ll=0;ll<work->nalign;ll++){
+						l=work->lalign[ll];
+						work->dd_dr1[i][j][k][l]=work->dd_dr_temp[i][j][k][l];
+					}
+				}	
+			}	
+		}
+	}
+	//
+	// correction for the rotation matrix: r0 frame
+	//
+	if(do_rotmat_der){
+		for(i=0;i<3;i++){
+			for(j=0;j<3;j++){
+				for(k=0;k<3;k++){
+					for(ll=0;ll<work->nalign;ll++){
+						l=work->lalign[ll];
+						work->dd_dr_temp[i][j][k][l]=work->align[l]*work->dd_dr0[i][j][k][l];
+						tmp1=work->align[l]/totalign; 
+						if(do_center){		
+							for(nn=0;nn<work->nalign;nn++){
+								n=work->lalign[nn];
+								work->dd_dr_temp[i][j][k][l]-=work->dd_dr0[i][j][k][n]*tmp1*work->align[n]; 
+							}
+						}
+					}
+				}	
+			}	
+		}
+		for(i=0;i<3;i++){
+			for(j=0;j<3;j++){
+				for(k=0;k<3;k++){
+					for(ll=0;ll<work->nalign;ll++){
+						l=work->lalign[ll];
+						work->dd_dr0[i][j][k][l]=work->dd_dr_temp[i][j][k][l];
+					}
+				}	
+			}	
+		}
+	}
+	// write the rotated frames
+//	for(i=0;i<natoms;i++){
+//		fprintf(mtd_data.fplog,"ATOM %6d  C   ALA     1    %8.3f%8.3f%8.3f  1.00  1.00\n",i+1,work->r0p[0][i],work->r0p[1][i],work->r0p[2][i]);
+//	}
+//	fprintf(mtd_data.fplog,"END\n");
+//	
+//	for(i=0;i<natoms;i++){
+//		fprintf(mtd_data.fplog,"ATOM %6d  C   ALA     2    %8.3f%8.3f%8.3f  1.00  1.00\n",i+1,work->r1p[0][i],work->r1p[1][i],work->r1p[2][i]);
+//	}
+//	fprintf(mtd_data.fplog,"END\n");
+//	
+	for(i=0;i<natoms;i++){
+		work->r1p_rotated[0][i]=work->d[0][0]*work->r1p[0][i]+
+								work->d[0][1]*work->r1p[1][i]+
+								work->d[0][2]*work->r1p[2][i];
+		work->r1p_rotated[1][i]=work->d[1][0]*work->r1p[0][i]+
+								work->d[1][1]*work->r1p[1][i]+
+								work->d[1][2]*work->r1p[2][i];
+		work->r1p_rotated[2][i]=work->d[2][0]*work->r1p[0][i]+
+								work->d[2][1]*work->r1p[1][i]+
+								work->d[2][2]*work->r1p[2][i];
+//		fprintf(mtd_data.fplog,"ATOM %6d  C   ALA     2    %8.3f%8.3f%8.3f  1.00  1.00\n",i+1,work->r1p_rotated[0][i],work->r1p_rotated[1][i],work->r1p_rotated[2][i]);
+
+	}
+//	fprintf(mtd_data.fplog,"END\n");
+//	EXIT();
+	// invert the matrix
+	real det;
+	det= work->d[0][0]*(work->d[2][2]*work->d[1][1]-work->d[2][1]*work->d[1][2])
+		-work->d[1][0]*(work->d[2][2]*work->d[0][1]-work->d[2][1]*work->d[0][2])
+		+work->d[2][0]*(work->d[1][2]*work->d[0][1]-work->d[1][1]*work->d[0][2]);
+	
+						
+	work->dinv[0][0]= (work->d[2][2]*work->d[1][1]-work->d[2][1]*work->d[1][2])/det;//a22a11-a21a12
+	work->dinv[0][1]=-(work->d[2][2]*work->d[0][1]-work->d[2][1]*work->d[0][2])/det;//-(a22a01-a21a02)
+	work->dinv[0][2]= (work->d[1][2]*work->d[0][1]-work->d[1][1]*work->d[0][2])/det;//a12a01-a11a02
+	
+	work->dinv[1][0]=-(work->d[2][2]*work->d[1][0]-work->d[2][0]*work->d[1][2])/det;  //-(a22a10-a20a12)
+	work->dinv[1][1]= (work->d[2][2]*work->d[0][0]-work->d[2][0]*work->d[0][2])/det;	// 	a22a00-a20a02
+	work->dinv[1][2]=-(work->d[1][2]*work->d[0][0]-work->d[1][0]*work->d[0][2])/det;	// 	-(a12a00-a10a02)
+			
+	work->dinv[2][0]= (work->d[2][1]*work->d[1][0]-work->d[2][0]*work->d[1][1])/det;  //  a21a10-a20a11
+	work->dinv[2][1]=-(work->d[2][1]*work->d[0][0]-work->d[2][0]*work->d[0][1])/det;	//	-(a21a00-a20a01)		
+	work->dinv[2][2]= (work->d[1][1]*work->d[0][0]-work->d[1][0]*work->d[0][1])/det;  //a11a00-a10a01
+	
+//	for(i=0;i<3;i++){
+//		fprintf(mtd_data.fplog,"MAT ");
+//		for(j=0;j<3;j++){
+//			real v=0.;
+//			for(ii=0;ii<3;ii++){
+//				//for(jj=0;jj<3;jj++){
+//				v+=work->d[i][ii]*work->dinv[ii][j];
+//				//}
+//			}
+//			fprintf(mtd_data.fplog," %12.6f ",v);
+//
+//		}
+//		fprintf(mtd_data.fplog,"\n");
+//	}
+	for(i=0;i<natoms;i++){
+		work->r0p_rotated[0][i]=work->dinv[0][0]*work->r0p[0][i]+
+								work->dinv[0][1]*work->r0p[1][i]+
+								work->dinv[0][2]*work->r0p[2][i];
+		work->r0p_rotated[1][i]=work->dinv[1][0]*work->r0p[0][i]+
+								work->dinv[1][1]*work->r0p[1][i]+
+								work->dinv[1][2]*work->r0p[2][i];
+		work->r0p_rotated[2][i]=work->dinv[2][0]*work->r0p[0][i]+
+								work->dinv[2][1]*work->r0p[1][i]+
+								work->dinv[2][2]*work->r0p[2][i];
+		// ATOM      1  C   ALA     2      -1.132   0.547  -0.390  0.50  0.50
+		//fprintf(mtd_data.fplog,"ATOM %6d  C   ALA     1    %8.3f%8.3f%8.3f  1.00  1.00\n",i+1,work->r0p_rotated[0][i],work->r0p_rotated[1][i],work->r0p_rotated[2][i]);
+				
+	}
+	//fprintf(mtd_data.fplog,"END\n");
+	
+	//fprintf(mtd_data.fplog,"|- EXITED THE RMSD_DYNAMIC_SIMPLE ROUTINE\n");
+};
+void PREFIX msd_core_dynamic_weighted(struct rmsd_workstruct_s *work,int do_center, int do_frameref_der){
+	//fprintf(mtd_data.fplog,"|- ENTERING THE RMSD_DYNAMIC_WEIGHTED ROUTINE\n");
+	
+	real tmp0,tmp1,walign,wdisplace,ndisplace,const1;
+	int  i,j,k,l,m,n,o,oo,mm,kk;
+	
+	// found various weight
+	ndisplace=(real) work->ndisplace; 
+	walign=0.;
+	for(i=0;i<work->nalign;i++){
+		k=work->lalign[i];
+		walign+=work->align[k];
+	}
+	work->walign=walign;
+
+	wdisplace=0.;
+	for(i=0;i<work->ndisplace;i++){
+		k=work->ldisplace[i];
+		wdisplace+=work->displace[k];
+	}
+	work->wdisplace=wdisplace;
+	
+	tmp0=0.;
+	for(kk=0;kk<work->ndisplace;kk++){
+		k=work->ldisplace[kk];
+		for(l=0;l<3;l++){
+			
+			tmp1=0.;
+			// contribution from rotated reference frame //
+			for(m=0;m<3;m++){
+				tmp1-=work->d[l][m]*work->r1p[m][k];
+			}
+			
+			// contribution from running centered frame //
+			tmp1+= work->r0p[l][k];  
+			//fprintf(mtd_data.fplog,"WEIGHTED %3d COMP %1d VAL %f\n",k,l,tmp1*sqrt(work->displace[k]/wdisplace));
+			
+			work->array_3_n[l][k]=tmp1; // store coefficents for derivative usage// 
+			tmp0+=tmp1*tmp1*work->displace[k]; //squared distance added//
+		}
+	}  
+	tmp0=tmp0/wdisplace;
+	
+    //fprintf(mtd_data.fplog,"|- ERRR NEW %f \n",tmp0);
+	
+	work->err=tmp0;
+
+	/* DERIVATIVE CALCULATION:respect to running frame */
+	for(k=0;k<work->natoms;k++){
+		for(l=0;l<3;l++){
+			
+			tmp1 =2.0*work->array_3_n[l][k]*work->displace[k]/wdisplace ;
+			
+			const1=2.0*work->align[k]/(walign*wdisplace);
+			
+			if(const1!=0.){
+				for(oo=0;oo<work->ndisplace;oo++){
+					o=work->ldisplace[oo];
+					tmp1 -=const1*work->array_3_n[l][o]*work->displace[o]; 
+				} 
+			}
+			
+				for(mm=0;mm<work->ndisplace;mm++){
+					m=work->ldisplace[mm];
+					const1=2.* work->displace[m]/wdisplace ;
+					for(n=0;n<3;n++){
+						tmp0=0.;
+						for(o=0;o<3;o++){
+							tmp0+=work->dd_dr0[n][o][l][k]*work->r1p[o][m];
+						}
+						tmp0*=-const1*work->array_3_n[n][m];
+						
+						tmp1+=tmp0;
+					}
+				}
+			
+			work->derr_dr0[l][k]=tmp1;
+			
+		}
+	}
+
+	if(do_frameref_der){
+		for(k=0;k<work->natoms;k++){
+			for(l=0;l<3;l++){
+				/////////////////////////////////////				
+				tmp1=0.;
+				for(mm=0;mm<work->ndisplace;mm++){
+					m=work->ldisplace[mm];
+					const1=2.* work->displace[m]/wdisplace ;
+					for(n=0;n<3;n++){
+						tmp0=0.;
+						for(o=0;o<3;o++){
+							tmp0+=work->dd_dr1[n][o][l][k]*work->r1p[o][m];
+						}
+						tmp0*=-const1*work->array_3_n[n][m];
+						tmp1+= tmp0;  
+					}
+					
+				}
+				
+				tmp0=0.;
+				for(o=0;o<3;o++){
+							tmp0+=work->array_3_n[o][k]*work->d[o][l];
+				}
+				tmp1+=-tmp0*2.*work->displace[k]/wdisplace;
+				
+				
+				tmp0=0.;
+				for(mm=0;mm<work->ndisplace;mm++){
+					m=work->ldisplace[mm];
+					for(o=0;o<3;o++){
+						tmp0+=work->array_3_n[o][m]*work->d[o][l]*work->displace[m];
+					}
+				}
+				tmp1 += tmp0*2.*work->align[k]/(walign*wdisplace);
+				
+				work->derr_dr1[l][k]=tmp1;
+				
+				/////////////////////////////////////
+			}
+		}
+	}
+
+	//fprintf(mtd_data.fplog,"|- EXITED THE RMSD_DYNAMIC_WEIGHTED ROUTINE\n");
+}
+void PREFIX rmsd_dynamic_findiff_interface(struct rmsd_workstruct_s *work){
+	fprintf(mtd_data.fplog,"|- ENTERED THE RMSD_DYNAMIC_FINDIFF ROUTINE\n");
+	fprintf(mtd_data.fplog,"Entering rmsd finite difference test system\n");
+	fprintf(mtd_data.fplog,"-------------------------------------------\n");
+	fprintf(mtd_data.fplog,"TEST1: derivative of the value (derr_dr0/derr_dr1)\n");
+	// test 1
+	int i,j,k,l,m, weighted;
+	real step=1.e-7,olderr,delta; 
+	real derr_dr1[3][MAXATOMS_RMSD];
+	real derr_dr0[3][MAXATOMS_RMSD];
+	real dd_dr0[3][3][3][MAXATOMS_RMSD];
+	real dd_dr1[3][3][3][MAXATOMS_RMSD];
+	real oldd[3][3];
+	weighted=1;
+	// get initial value of the error and derivative of it 
+	msd_core_dynamic_simple(work,1,1,1);
+	if(weighted)msd_core_dynamic_weighted(work,1,1);
+	//msd_core_dynamic_norot(work,1); 
+
+	fprintf(mtd_data.fplog,"INITIAL ERROR VALUE: %f FOR %d ATOMS\n",work->err,work->natoms);
+	olderr=work->err;
+	// store the derivative
+	for(j=0;j<3;j++){
+		for(i=0;i<work->natoms;i++){
+			derr_dr1[j][i]=work->derr_dr1[j][i];
+			derr_dr0[j][i]=work->derr_dr0[j][i];
+		}
+	}
+	for(l=0;l<3;l++){
+		for(m=0;m<3;m++){
+			oldd[l][m]=work->d[l][m];
+			for(j=0;j<3;j++){
+				for(i=0;i<work->natoms;i++){
+					dd_dr1[l][m][j][i]=work->dd_dr1[l][m][j][i];
+					dd_dr0[l][m][j][i]=work->dd_dr0[l][m][j][i];
+				}
+			}
+		}
+	}
+	fprintf(mtd_data.fplog,"TESTING: derr_dr1 \n");
+	for(j=0;j<3;j++){
+		for(i=0;i<work->natoms;i++){
+			// random displacement
+			delta=(drand48()-0.5)*2*step;
+			work->r1[j][i]+=delta; 
+			msd_core_dynamic_simple(work,1,1,1);
+			if(weighted)msd_core_dynamic_weighted(work,1,1);
+			//msd_core_dynamic_norot(work,1); 
+
+			work->r1[j][i]-=delta; 
+			switch(j){
+				case 0:
+					fprintf(mtd_data.fplog,"TESTING: X  %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,derr_dr1[j][i],(work->err-olderr)/delta,derr_dr1[j][i]-(work->err-olderr)/delta);break;
+				case 1:
+					fprintf(mtd_data.fplog,"TESTING: Y  %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,derr_dr1[j][i],(work->err-olderr)/delta,derr_dr1[j][i]-(work->err-olderr)/delta);break;
+				case 2:
+					fprintf(mtd_data.fplog,"TESTING: Z  %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,derr_dr1[j][i],(work->err-olderr)/delta,derr_dr1[j][i]-(work->err-olderr)/delta);break;
+					
+			}    
+		}
+	}
+	//EXIT();
+	fprintf(mtd_data.fplog,"TESTING: derr_dr0 \n");
+	for(j=0;j<3;j++){
+		for(i=0;i<work->natoms;i++){
+			// random displacement
+			delta=(drand48()-0.5)*2*step;
+			work->r0[j][i]+=delta; 
+			msd_core_dynamic_simple(work,1,1,1);
+			if(weighted)msd_core_dynamic_weighted(work,1,1);
+			work->r0[j][i]-=delta; 
+			switch(j){
+				case 0:
+					fprintf(mtd_data.fplog,"TESTING: X  %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,derr_dr0[j][i],(work->err-olderr)/delta,derr_dr0[j][i]-(work->err-olderr)/delta);break;
+				case 1:
+					fprintf(mtd_data.fplog,"TESTING: Y  %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,derr_dr0[j][i],(work->err-olderr)/delta,derr_dr0[j][i]-(work->err-olderr)/delta);break;
+				case 2:
+					fprintf(mtd_data.fplog,"TESTING: Z  %4d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",i,derr_dr0[j][i],(work->err-olderr)/delta,derr_dr0[j][i]-(work->err-olderr)/delta);break;
+					
+			}    
+		}
+	}
+	fprintf(mtd_data.fplog,"TESTING: dd_dr0 \n");
+	for(l=0;l<3;l++){
+		for(m=0;m<3;m++){
+			for(j=0;j<3;j++){
+				for(i=0;i<work->natoms;i++){
+					// random displacement
+					delta=(drand48()-0.5)*2*step;
+					work->r0[j][i]+=delta; 
+					msd_core_dynamic_simple(work,1,1,1);
+					if(weighted)msd_core_dynamic_weighted(work,1,1);
+					work->r0[j][i]-=delta; 
+					switch(j){
+						case 0:
+							fprintf(mtd_data.fplog,"TESTING: DD_DR0 [ %d ][ %d ]:  X %d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",l,m,i,dd_dr0[l][m][j][i],(work->d[l][m]- oldd[l][m])/delta,dd_dr0[l][m][j][i]-(work->d[l][m]- oldd[l][m])/delta);break;
+						case 1:
+							fprintf(mtd_data.fplog,"TESTING: DD_DR0 [ %d ][ %d ]:  Y %d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",l,m,i,dd_dr0[l][m][j][i],(work->d[l][m]- oldd[l][m])/delta,dd_dr0[l][m][j][i]-(work->d[l][m]- oldd[l][m])/delta);break;
+						case 2:
+							fprintf(mtd_data.fplog,"TESTING: DD_DR0 [ %d ][ %d ]:  Z %d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",l,m,i,dd_dr0[l][m][j][i],(work->d[l][m]- oldd[l][m])/delta,dd_dr0[l][m][j][i]-(work->d[l][m]- oldd[l][m])/delta);break;
+							
+							
+					}    
+				}
+			}
+		}
+	}
+	fprintf(mtd_data.fplog,"TESTING: dd_dr1 \n");
+	for(l=0;l<3;l++){
+		for(m=0;m<3;m++){
+			for(j=0;j<3;j++){
+				for(i=0;i<work->natoms;i++){
+					// random displacement
+					delta=(drand48()-0.5)*2*step;
+					work->r1[j][i]+=delta; 
+					msd_core_dynamic_simple(work,1,1,1);
+					if(weighted)msd_core_dynamic_weighted(work,1,1);
+					work->r1[j][i]-=delta; 
+					switch(j){
+						case 0:
+							fprintf(mtd_data.fplog,"TESTING: DD_DR1 [ %d ][ %d ]:  X %d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",l,m,i,dd_dr1[l][m][j][i],(work->d[l][m]- oldd[l][m])/delta,dd_dr1[l][m][j][i]-(work->d[l][m]- oldd[l][m])/delta);break;
+						case 1:
+							fprintf(mtd_data.fplog,"TESTING: DD_DR1 [ %d ][ %d ]:  Y %d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",l,m,i,dd_dr1[l][m][j][i],(work->d[l][m]- oldd[l][m])/delta,dd_dr1[l][m][j][i]-(work->d[l][m]- oldd[l][m])/delta);break;
+						case 2:
+							fprintf(mtd_data.fplog,"TESTING: DD_DR1 [ %d ][ %d ]:  Z %d ANAL %18.9f NUMER %18.9f DELTA %18.9f\n",l,m,i,dd_dr1[l][m][j][i],(work->d[l][m]- oldd[l][m])/delta,dd_dr1[l][m][j][i]-(work->d[l][m]- oldd[l][m])/delta);break;
+							
+					}    
+				}
+			}
+		}
+	}
+	EXIT();
+	
+	fprintf(mtd_data.fplog,"|- EXITED THE RMSD_DYNAMIC_FINDIFF ROUTINE\n");
+};
+// after you use the struct make sure that you delete the structs that are not overwritten
+void PREFIX clean_rmsd_work_array(struct rmsd_workstruct_s *work){
+	int i,j,k,l;
+	// always overwritten
+	// r0p, r1p,cmr0,cmr1,align,displace,lalign,ldisplace,dd_dr1,dd_dr0,derr_dr1,derr_dr0
+	//for (i=0;i<work->maxsize;i++){
+	
+	//}
+
+};
+// need already allocated pdb
+void PREFIX copy_pdb (struct pdb *source, struct pdb *sink, FILE *fplog){
+	int i,j,k;
+	//deallocate_pdb(sink);
+	//allocate_pdb(&sink,source->natoms);
+	sink->natoms=source->natoms;
+	for(i=0;i<source->natoms;i++){
+		sink->x[i]=source->x[i];
+		sink->y[i]=source->y[i];
+		sink->z[i]=source->z[i];
+		sink->beta[i]=source->beta[i];
+		sink->occ[i]=source->occ[i];
+		sink->index[i]=source->index[i];
+		sink->resid[i]=source->resid[i];
+		strcpy(sink->name[i],source->name[i]);
+		strcpy(sink->resname[i],source->resname[i]);
+	}
+
+};
+int  PREFIX hbd_collect_jacobian ( struct hybrid_frameset *running, real ** mathybrid ,real ** myinverse, FILE *fplog , int absval){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+// finite difference test for the general metrics 
+void PREFIX check_hbd_vecmvec_ref(struct hybrid_frameset *r1,struct hybrid_frameset *r2,struct hybrid_frameset *r3,struct hybrid_frameset *r4,struct hybrid_frameset *r5,struct hybrid_frameset *r6,real **matrix, FILE  *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+int PREFIX hbd_metrics_new ( struct hybrid_frameset *running , struct hybrid_frameset *reference , struct cmap_outpack *outpack, real **matrix, FILE  *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}; 
+//
+// a simple utility that performs matrix inversion
+//
+int PREFIX matinverse (real **a, real **id, int n, FILE *fplog) 
+{
+	int   i, j,k;                    
+	int   s;                       // index for elimination
+	int   pindex;                  // Pivotindex
+	int   error = 0;              // errorflag
+	real f;                      // multiply fact
+	const real Epsilon = 0.0000001;   // limit
+	real Maximum;                // max
+	int pivot = 1;
+	
+	real** asave;
+	asave=float_2d_array_alloc(n,n);
+	for (i = 0; i < n; i++) {
+		for (j = 0; j < n; j++)
+		{
+			asave[i][j] =a[i][j]; 
+		}
+	}
+	
+	// build id matrix
+	for (i = 0; i < n; i++) {
+		for (j = 0; j < n; j++)
+		{
+			id[i][j] = 0.0;
+			if (i == j)
+				id[i][j] = 1.0;
+		}
+	}
+	s = 0;
+	do {
+		Maximum = fabs(a[s][s]);
+		if (pivot) // find the highest in the coulumn
+		{
+			pindex = s ; 
+			for (i = s+1; i < n; i++)
+				if (fabs(a[i][s]) > Maximum) {
+					Maximum = fabs(a[i][s]) ;
+					pindex = i;
+				}
+		}
+		error = (Maximum < Epsilon);
+		
+		if (error) break;     
+		
+		if (pivot)
+		{
+			if (pindex != s)  
+			{ double h; // swap two rows with the pivot
+				for (j = s ; j < n; j++) {
+					h = a[s][j];
+					a[s][j] = a[pindex][j];
+					a[pindex][j]= h;
+				}
+				for (j = 0 ; j < n; j++) {
+					h = id[s][j];
+					id[s][j] = id[pindex][j];
+					id[pindex][j]= h;						
+				}
+			}
+		}
+		// normalize to one the chosen row
+		f = a[s][s];
+		for (j = s; j < n; j++){
+			a[s][j]  = a[s][j] / f;
+		}
+		for (j = 0; j < n; j++){
+			id[s][j] = id[s][j] / f;
+		}
+		
+		//subtract the pivot row* a factor 
+		for (i = 0; i < n; i++ ) {
+			if (i != s) 
+			{
+				f = -a[i][s];                 
+				for (j = s; j < n ; j++) {   
+					a[i][j] += f*a[s][j];
+				}
+				for (j = 0; j < n ; j++) {  
+					id[i][j] += f*id[s][j];
+				}
+			}
+		}
+		s++;
+	} while ( s < n ) ;
+	
+	if (error) 
+	{
+		fprintf(fplog,"Inverse: Matrix is singular\n");
+		return 0; 
+	}
+	
+//	fprintf(fplog,"TEST \n");
+//	for(i=0;i<n;i++){
+//		for(j=0;j<n;j++){
+//			f=0.;
+//			for(k=0;k<n;k++)f+=asave[i][k]*id[k][j];
+//			if(f<0.000000001){f=0;}
+//			fprintf(fplog,"%6.2f ",f);
+//
+//		}
+//		fprintf(fplog,"\n");$
+//	}
+//	fprintf(fplog,"INVMAT \n");
+//
+//	for(i=0;i<n;i++){
+//		for(j=0;j<n;j++){
+//			fprintf(fplog,"%6.2f ",id[i][j]);}
+//		fprintf(fplog,"\n");
+//	}		
+	return 1;  
+};
+
+/*
+ * a cloning routine for hybrid frameset and all the stuff in there
+ */
+void PREFIX clone_hybrid_frameset(struct hybrid_frameset **sink,struct hybrid_frameset *source,  int need_alloc_diff, FILE *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+void PREFIX destroy_hybrid_frameset(struct hybrid_frameset *sink, FILE *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+void PREFIX clone_hybrid_elem(struct hybrid_elem **sink,struct hybrid_elem *source, int need_alloc_diff, FILE *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+void PREFIX destroy_hybrid_elem(struct hybrid_elem *sink, FILE *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+/*
+ * This simply makes the difference between a single cv element and returns the value and the derivative in the
+ * difference vector allocated 
+ */
+void PREFIX simple_elem_diff(struct hybrid_elem *diff,struct hybrid_elem  *e1,struct hybrid_elem  *e2,struct hybrid_elem  *e3, FILE *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+void PREFIX msd_elem_diff(struct hybrid_elem *diff,struct hybrid_elem  *e1,struct hybrid_elem  *e2,struct hybrid_elem  *e3, FILE *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+void PREFIX check_msd_elem_diff(struct hybrid_elem *diff,struct hybrid_elem *v1, struct hybrid_elem *v2, struct hybrid_elem *v3, FILE *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+// needs a special debugging routine since the depency on overlapping atoms should be taken into account
+// as independent
+void PREFIX test_hbd_metrics_new(struct hybrid_frameset *r1 , struct hybrid_frameset *r2 , struct cmap_outpack *outpack, real **matrix, FILE  *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+
+// 
+//  (v1-v2)_ref_v3 ' M (v1-v2)_ref_v3   is calculated 
+//  you should already provide an allocated distance frameset (use "clone" clone_hybrid_frameset(&d1,v1,1,fplog) with specific flag )
+//
+real PREFIX hbd_distanddiff_ref(struct hybrid_frameset *v1,  struct hybrid_frameset *v2, struct hybrid_frameset *v3, 
+							real **mat , real *dv1dcv,  real *dv2dcv,  real *dv3dcv,struct hybrid_frameset *d1,  
+							FILE *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+void PREFIX dump_frameset_formatted  ( struct sz_data *pmy_sz ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+void PREFIX hbd_dump_simple( struct hybrid_elem *elem , FILE *fp ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+void PREFIX hbd_dump_msd( struct hybrid_elem *elem , FILE *fp ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+void PREFIX dump_frameset_unformatted  ( struct sz_data *pmy_sz ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+void PREFIX read_couplingmatrix  ( char **word, t_plumed_input *input,FILE *fplog ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+/*
+ * this performs the calculation of the couplingmatrix
+ */
+void PREFIX calc_couplingmatrix  ( int istep ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+// this routine calculates the maragliano vanden-eijnden projector
+void PREFIX calc_projector_test  ( struct sz_data *pmy_sz ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+void PREFIX calc_intraframe_dist( struct sz_data *pmy_sz ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+void PREFIX calc_intraframe_diff( struct sz_data *pmy_sz ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+
+void PREFIX calc_diff_twoframes(struct hybrid_frameset *v1,  struct hybrid_frameset *v2, struct hybrid_frameset *v3,struct hybrid_frameset *d1 ){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+void PREFIX calc_twoframe_dist( struct sz_data *pmy_sz , int first, int second,  char *matrixfile, FILE *fplog){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
+void PREFIX reparam_with_multiple_matrix( struct sz_data *pmy_sz , char *filename){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+void PREFIX point_to_matrix(int i,struct sz_data *my_sz){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_sprint.c dl_class_1.9/srcmod/Plumed/restraint_sprint.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_sprint.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_sprint.c	2015-11-07 17:37:19.398604505 +0100
@@ -0,0 +1,362 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX sprint_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int firstAtom, secondAtom, i, j, k, ix;
+  int nn = colvar.nn[i_c], mm = colvar.mm[i_c], nat = colvar.natoms[i_c];
+  int ind_atom = colvar.intpar[i_c][0];
+  int n_distinct_masses = colvar.intpar[i_c][1];
+  int list_atoms[nat], list_atoms2[nat], ind_sorted;
+  rvec rij;
+  real sqrtn=sqrt( (real) nat);
+  real num, iden, mod_rij, rdist, func, dfunc, rNdist, rMdist;
+  real ncoord, r_0[n_distinct_masses][n_distinct_masses], d_0[n_distinct_masses][n_distinct_masses];
+  real threshold;
+  threshold=pow(0.00001,1./(nn-mm));
+  real cm_vec[nat*nat];
+  real tmp1, tmp2, tmp3, tmpcv[nat], tmpmass[nat];
+  int compute_cm;
+  int element[nat];
+
+// based on masses, label element: useful for pair-specific r_0 and d_0
+  for(i=0;i<nat;i++){
+    for(j=0;j<n_distinct_masses;j++){
+      if(mtd_data->mass[colvar.cvatoms[i_c][i]] == colvar.realpar[i_c][j][0]) {
+        element[i]=j; 
+      }    
+    }
+  }
+// fill matrix of pair-specific r_0 and d_0
+  k=0;
+  for(i=0;i<n_distinct_masses;i++){
+    for(j=i;j<n_distinct_masses;j++){
+      r_0[i][j]=colvar.realpar[i_c][k][1]; 
+      r_0[j][i]=colvar.realpar[i_c][k][1]; 
+      d_0[i][j]=colvar.realpar[i_c][k][2]; 
+      d_0[j][i]=colvar.realpar[i_c][k][2]; 
+      k++;
+//      printf("||||| i j r_0 d_0 = %i %i %f %f\n",i,j,r_0[i][j],d_0[i][j]); // debug
+    }
+  }
+
+  for (i=0;i<nat;i++) { for (ix=0;ix<3;ix++) { colvar.myder[i_c][i][ix]=0.; } }
+    
+  // check if cm and gradients have been already computed
+  compute_cm=1;
+  if(sprint_data.nat==nat){ // atoms number and index must match
+    compute_cm=0;
+    for (i=0;i<nat;i++) {
+      if (colvar.cvatoms[i_c][i]!=colvar.cvatoms[sprint_data.icv][i]) { compute_cm=1; }
+    }
+    if (sprint_data.step!=colvar.it) { compute_cm=1; } // step must match
+    if (logical.debug) { compute_cm=1; }
+  }
+
+                       ////////////////
+  if (compute_cm==1) { // compute_cm //
+                       ////////////////
+
+//  printf("STEP %d CV %d : COMPUTING CM AND GRADIENTS!\n",colvar.it,i_c); // DEBUG
+  // initialize backup variables
+  if (sprint_data.lambda != NULL) { free_1dr_array_alloc(sprint_data.lambda); }
+  if (sprint_data.cm     != NULL) { free_2dr_array_alloc(sprint_data.cm,sprint_data.nat); }
+  if (sprint_data.grad   != NULL) { free_3dr_array_alloc(sprint_data.grad,sprint_data.nat,sprint_data.nat); }
+  sprint_data.nat=nat;
+  sprint_data.icv=i_c;
+  sprint_data.step=colvar.it;
+  sprint_data.lambda=float_1d_array_alloc(nat);
+  sprint_data.cm    =float_2d_array_alloc(nat,nat);
+  sprint_data.grad  =float_3d_array_alloc(nat,nat,3);
+
+  // compute the contact matrix and gradients
+  for (i=0;i<nat;i++) { sprint_data.cm[i][i]=0.; for (ix=0;ix<3;ix++) { sprint_data.grad[i][i][ix]=0.; } }
+  for (i=0;i<nat-1;i++) { // loop over cm
+    for (j=i+1;j<nat;j++) { // loop over cm
+      // compute distance i-j
+      firstAtom =colvar.cvatoms[i_c][i];
+      secondAtom=colvar.cvatoms[i_c][j];
+      if(colvar.cell_pbc[i_c]){
+        minimal_image(mtd_data->pos[firstAtom], mtd_data->pos[secondAtom], &mod_rij, rij);
+      } else {
+        rij[0] = mtd_data->pos[firstAtom][0]-mtd_data->pos[secondAtom][0];
+        rij[1] = mtd_data->pos[firstAtom][1]-mtd_data->pos[secondAtom][1];
+        rij[2] = mtd_data->pos[firstAtom][2]-mtd_data->pos[secondAtom][2];
+        mod_rij = sqrt(rij[0]*rij[0]+rij[1]*rij[1]+rij[2]*rij[2]);
+      }
+//      printf("___ i j ei ej r_0 d_0 = %4i %4i %4i %4i %8.3f %8.3f\n",i,j,element[i],element[j],r_0[element[i]][element[j]],d_0[element[i]][element[j]]);  // debug
+      // compute switching function
+      rdist = (mod_rij-d_0[element[i]][element[j]])/r_0[element[i]][element[j]];
+      /* analitic limit of the switching function */
+      if(rdist<=0.){
+        ncoord=1.;
+        dfunc=0.;
+      }else if(rdist>0.999999 && rdist<1.000001){
+        ncoord=nn/mm;
+        dfunc=0.5*nn*(nn-mm)/mm;
+      }else if(rdist>threshold){
+        ncoord=0.;
+        dfunc=0.;
+      }else{
+        rNdist = pow(rdist, nn-1);
+        rMdist = pow(rdist, mm-1);
+        num = 1.-rNdist*rdist;
+        iden = 1./(1.-rMdist*rdist);
+        func = num*iden;
+        ncoord = func;
+        dfunc = ((-nn*rNdist*iden)+(func*(iden*mm)*rMdist))/(mod_rij*r_0[element[i]][element[j]]);
+      }
+      sprint_data.cm[i][j]=ncoord; sprint_data.cm[j][i]=ncoord; // contact matrix 
+      for(ix=0;ix<3;ix++) {
+        sprint_data.grad[i][j][ix] =  dfunc*rij[ix]; // = d cm_ij / d R_i = -d cm_ij / d R_j
+        sprint_data.grad[j][i][ix] = -dfunc*rij[ix]; // = d cm_ji / d R_j = -d cm_ji / d R_i
+	// in restraint_coord would be:   colvar.myder[i_c][i][ix] += +dfunc*rij[ix];
+	// in restraint_coord would be:   colvar.myder[i_c][j][ix] += -dfunc*rij[ix];
+      }
+    } // end of loop over cm
+  } // end of loop over cm
+ 
+  // diagonalize the cm using routine ql77 in file restraint_spath.c
+  for(i=0;i<nat;i++){
+    for(j=0;j<nat;j++){
+      cm_vec[nat*i+j]=sprint_data.cm[i][j]; // put matrix in a vector ...
+    }
+  }
+  ql77(nat,cm_vec,sprint_data.lambda); // eigenvalues are sorted in ascending order
+  for(j=0;j<nat;j++){
+    for(i=0;i<nat;i++){
+      sprint_data.cm[i][j]=cm_vec[nat*j+i]; // ... and back to matrix: columns are eigenvectors
+    }
+  }
+
+  // make positive the principal eigenvector
+  for(i=0;i<nat;i++){ sprint_data.cm[i][nat-1]=fabs(sprint_data.cm[i][nat-1]); }
+
+    ////////////////////
+  } // end compute_cm //
+    ////////////////////
+
+//  if (compute_cm==0){printf("STEP %d CV %d : NOT COMPUTING CM AND GRADIENTS!\n",colvar.it,i_c);} // DEBUG
+//  printf("xxx eigenvalues    : ");for(i=0;i<nat;i++)printf("%4.2f ",sprint_data.lambda[i]);printf("\n"); //DEBUG
+//  printf("xxx max eigenvector: ");for(i=0;i<nat;i++)printf("%4.2f ",sprint_data.cm[i][nat-1]);printf("\n"); //DEBUG
+
+
+  // the CV
+  for(i=0;i<nat;i++){ tmpcv[i]=sprint_data.cm[i][nat-1]; list_atoms[i]=i; 
+//debug printf("i v %4d %8.4f\n",i,tmpcv[i]); 
+  }
+
+  // sort all atoms based on CV, irrespective of element
+  realquicksort(tmpcv,list_atoms,0,nat-1);
+//  for(i=0;i<nat;i++){ printf("i listatoms tmpcv cv[listatoms] = %4d %4d %8.4f %8.4f\n",i,list_atoms[i],tmpcv[i],sprint_data.cm[list_atoms[i]][nat-1]); } //debug
+
+  // sort based on mass (arrange in groups: one sorted group per element)
+  if(n_distinct_masses>1){
+    for (i=0;i<nat;i++){ tmpmass[i]=mtd_data->mass[colvar.cvatoms[i_c][list_atoms[i]]]; }
+    k=-1;
+    for (j=0;j<n_distinct_masses;j++){
+      for(i=0;i<nat;i++){
+        if(tmpmass[i]==colvar.realpar[i_c][j][0]){
+          k++; list_atoms2[k]=list_atoms[i];      
+//          printf("i listatoms2 mass[listatoms2] cv[listatoms] = %4d %4d %8.4f %8.4f\n",k,list_atoms2[k],mtd_data->mass[colvar.cvatoms[i_c][list_atoms2[k]]],sprint_data.cm[list_atoms2[k]][nat-1]); //debug
+        }
+      }
+    }
+    for (i=0;i<nat;i++){ list_atoms[i]=list_atoms2[i]; }
+  }
+
+  // now the list is properly sorted
+  ind_sorted=list_atoms[ind_atom];
+//debug  printf("indatom indsorted = %4d %4d\n",ind_atom,ind_sorted);
+//old colvar.ss0[i_c] = sprint_data.lambda[nat-1]*sqrtn*sprint_data.cm[ind_atom][nat-1]; 
+  colvar.ss0[i_c] = sprint_data.lambda[nat-1]*sqrtn*sprint_data.cm[ind_sorted][nat-1]; 
+
+  // the gradients
+  for (i=0;i<nat-1;i++) { // loop over cm
+    for (j=i+1;j<nat;j++) { // loop over cm
+       tmp1=2.*sprint_data.cm[i][nat-1]*sprint_data.cm[j][nat-1]; 	// d lambda_N / d a_ij
+       tmp2=0.; 			 	                // d v_ii^N / d a_ij
+       for(k=0;k<nat-1;k++){
+         tmp2+=sprint_data.cm[ind_sorted][k]*(sprint_data.cm[i][k]*sprint_data.cm[j][nat-1]+sprint_data.cm[j][k]*sprint_data.cm[i][nat-1])/(sprint_data.lambda[nat-1]-sprint_data.lambda[k]);
+       }
+       tmp3=tmp1*sprint_data.cm[ind_sorted][nat-1]+sprint_data.lambda[nat-1]*tmp2; // derivative of product lambda_N*v_ii^N
+       for(ix=0;ix<3;ix++){
+         colvar.myder[i_c][i][ix]+=sqrtn*tmp3*sprint_data.grad[i][j][ix];
+         colvar.myder[i_c][j][ix]-=sqrtn*tmp3*sprint_data.grad[i][j][ix];
+       }
+     } // loop over cm
+   } // loop over cm
+}
+
+//--------------------------------------------------------------------------------------------------------------
+
+int PREFIX read_sprint(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i, iw, iat, j, k, help, n_distinct_masses, npairs_r0, npairs_d0;
+  double r_0, d_0;
+  double delta = 0.0;
+  real threshold, value;
+
+  help=0;
+  d_0=0.;
+  npairs_d0=0;
+
+  colvar.cell_pbc[count]=1; // default is PBC
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0){
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+  } else{ fprintf(fplog,"|- NEEDED LIST KEYWORD FOR SPRINT\n"); help=1;}
+
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+  iw=seek_word(word,"NN");
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.nn[count]); } else { fprintf(fplog,"|- NEEDED NN KEYWORD FOR SPRINT\n"); help=1;}
+  iw=seek_word(word,"MM");
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.mm[count]);} else { fprintf(fplog,"|- NEEDED MM KEYWORD FOR SPRINT\n"); help=1;}
+
+  iw=seek_word(word,"R_0");
+  if(iw>=0) { 
+    sscanf(word[iw+1],"%i", &npairs_r0); // number of pairs of elements (e.g. for hydrocarbons =3: C-C, C-H, H-H)
+    if(npairs_r0>10){ fprintf(fplog,"ERROR: TOO MANY ELEMENT PAIRS !!!\n"); help=1; }
+    for(i=0;i<npairs_r0;i++){
+      // order: for atoms A B C -> A-A, A-B, A-C, B-B, B-C, C-C
+      sscanf(word[iw+2+i],"%lf", &r_0);
+      colvar.realpar[count][i][1] = (real) r_0;
+    }
+  } else { fprintf(fplog,"|- NEEDED R_0 KEYWORD FOR SPRINT\n"); help=1;}
+
+  iw=seek_word(word,"D_0");
+  if(iw>=0) { 
+    sscanf(word[iw+1],"%i", &npairs_d0); // number of pairs of elements (e.g. for hydrocarbons =3: C-C, C-H, H-H)
+    if(npairs_d0!=npairs_r0){ fprintf(fplog,"ERROR: ELEMENT PAIRS MUST BE THE SAME FOR R_0 AND D_0 !!!\n"); help=1; }
+    for(i=0;i<npairs_d0;i++){
+      // order: for atoms A B C -> A-A, A-B, A-C, B-B, B-C, C-C
+      sscanf(word[iw+2+i],"%lf", &d_0);
+      colvar.realpar[count][i][2] = (real) d_0;
+    }
+  }
+
+  iw=seek_word(word,"NOPBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 0;}
+  iw=seek_word(word,"PBC");
+  if(iw>=0) {colvar.cell_pbc[count] = 1;}
+  iw=seek_word(word,"INDEX"); // which atom to bias
+  if(iw>=0) { sscanf(word[iw+1],"%i", &colvar.intpar[count][0]); } 
+  else { fprintf(fplog,"|- ERROR: NEEDED INDEX KEYWORD FOR SPRINT\n"); help=1;}
+  if (colvar.intpar[count][0]<1||colvar.intpar[count][0]>colvar.natoms[count]) { 
+    fprintf(fplog,"|- ERROR: THE ATOM INDEX MUST BE BETWEEN 1 AND %i\n",colvar.natoms[count]); help=1; }
+
+  if(help){
+          fprintf(fplog, "\n- SPRINT CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "SPRINT LIST <g1> NN 8 MM 16 R_0 1 0.7 SIGMA 1.0 INDEX 1\n");
+          fprintf(fplog, "         g1->    \n");
+          fprintf(fplog, "            1 2 3 4 5 6 7 8 9 10\n");
+          fprintf(fplog, "         g1<-    \n");
+          fprintf(fplog, "       \n");
+          fprintf(stderr, "PluMed dead with errors: check log file  \n");
+          EXIT(); 
+  }
+
+//  colvar.r_0[count]      = (real) r_0;
+//  colvar.d_0[count]      = (real) d_0;
+  colvar.type_s[count]   = 55;
+
+  fprintf(fplog, "%1i-SPRINT; ATOMS INVOLVED: %i; ", count+1, colvar.natoms[count]);
+  if(colvar.cell_pbc[count]) fprintf(fplog, " PBC ON");
+  else                       fprintf(fplog, " PBC OFF");
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+  fprintf(fplog, "|--FUNCTIONAL FORM: (1-((dist_mat_rmsd-d_0)/r_0)^n) / (1-((dist_mat_rmsd-d_0)/r_0)^m) \n");
+  fprintf(fplog, "|--PARAMETERS: n= %i m= %i index=%i\n", colvar.nn[count], colvar.mm[count], colvar.intpar[count][0]);
+  fprintf(fplog, "|--  R_0 = "); for(i=0;i<npairs_r0;i++){ fprintf(fplog, "%f ",colvar.realpar[count][i][1]); }; fprintf(fplog, "\n");
+  fprintf(fplog, "|--  D_0 = "); for(i=0;i<npairs_r0;i++){ fprintf(fplog, "%f ",colvar.realpar[count][i][2]); }; fprintf(fplog, "\n");
+  threshold=pow(0.00001,1./(colvar.nn[count]-colvar.mm[count]));
+  value=(1.-pow(threshold,colvar.nn[count]))/(1.-pow(threshold,colvar.mm[count]));
+  fprintf(fplog, "|--CUTOFF VALUE: %f\n",value);
+  // find largest r_0, d_0
+  r_0=0.; d_0=0.;
+  for(i=0;i<npairs_r0;i++){
+    if(colvar.realpar[count][i][1]>r_0){ r_0=colvar.realpar[count][i][1]; }
+    if(colvar.realpar[count][i][2]>d_0){ d_0=colvar.realpar[count][i][2]; }
+  }
+  fprintf(fplog, "|--CUTOFF DISTANCE: %f (LARGEST R_0 D_0 = %f %f)\n",threshold*r_0+d_0,r_0,d_0);
+
+  colvar.intpar[count][0]--; // in C arrays start from zero...
+
+  iat=0;
+  fprintf(fplog,"|- SET MEMBERS: ");
+  for(i=0;i<colvar.natoms[count];i++){fprintf(fplog," %d ",colvar.cvatoms[count][i]+1);if((i+1)%20==0)fprintf(fplog,"\n               ");}fprintf(fplog,"\n");
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  sprint_data.nat=0; // useful later to know wether to compute cm and gradients...
+
+  fprintf(fplog,"|- ATOM MASSES: ");
+  for(i=0;i<colvar.natoms[count];i++){
+    fprintf(fplog, "%5d %9.4f  ",colvar.cvatoms[count][i]+1,mtd_data.mass[colvar.cvatoms[count][i]]);
+  } fprintf(fplog,"\n");
+  // store distinct atomic masses in the vector colvar.realpar[count][:][0]
+  n_distinct_masses=1;
+  colvar.realpar[count][0][0]=mtd_data.mass[colvar.cvatoms[count][0]];
+  for(i=1;i<colvar.natoms[count];i++){
+    k=0;
+    for(j=0;j<n_distinct_masses;j++){
+      if(mtd_data.mass[colvar.cvatoms[count][i]] != colvar.realpar[count][j][0]){
+        k++;
+      }
+    }
+    if(k==n_distinct_masses) {
+      n_distinct_masses++; 
+      colvar.realpar[count][n_distinct_masses-1][0]=mtd_data.mass[colvar.cvatoms[count][i]];
+    }
+  }
+  colvar.intpar[count][1]=n_distinct_masses;
+// check that enough r_0, d_0 are given
+  if(npairs_r0 != (n_distinct_masses*(n_distinct_masses+1))/2) {
+    fprintf(fplog, "ERROR: IF N IS THE NUMBER OF DISTINCT ELEMENTS (MASSES) THEN YOU NEED N*(N+1)/2 R_0 PAIRS!!!\n");
+    EXIT(); 
+  }
+  fprintf(fplog,"|- DISTINCT ATOM MASSES (NUMBER, VALUES): %2d ",n_distinct_masses);
+  for(i=0;i<n_distinct_masses;i++){
+    fprintf(fplog, "%9.4f  ",colvar.realpar[count][i][0]);
+  } fprintf(fplog,"\n\n");
+
+  return colvar.natoms[count]; 
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_torsion.c dl_class_1.9/srcmod/Plumed/restraint_torsion.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_torsion.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_torsion.c	2015-11-07 17:37:19.401604592 +0100
@@ -0,0 +1,219 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX torsion_restraint(int i_c, struct mtd_data_s *mtd_data)
+{
+  int i, j, iat, k;
+  real myp[4][3], totmasse[4], d[4][3];
+  int t1, t2, t3, ix;
+  rvec vp1, vp2, vp3;
+  real pi, psi, nv1, nv2, n21, sc1, sc2;
+  real twopi, in21, sign, cos_psi, sin_psi;
+  rvec r01, r21, r23, m, n;
+ 
+  twopi = M_2PI;
+  pi = M_PI;
+
+  totmasse[0] = totmasse[1] = totmasse[2] = totmasse[3] = 0.;
+  myp[0][0] = myp[0][1] = myp[0][2] = 0.;
+  myp[1][0] = myp[1][1] = myp[1][2] = 0.;
+  myp[2][0] = myp[2][1] = myp[2][2] = 0.;
+  myp[3][0] = myp[3][1] = myp[3][2] = 0.;
+  k = 0;
+
+  for(j=0;j<4;j++) {
+    for(i=0;i<colvar.list[i_c][j];i++){
+      iat = colvar.cvatoms[i_c][k];
+      myp[j][0] += mtd_data->mass[iat]*mtd_data->pos[iat][0];
+      myp[j][1] += mtd_data->mass[iat]*mtd_data->pos[iat][1];
+      myp[j][2] += mtd_data->mass[iat]*mtd_data->pos[iat][2];
+      totmasse[j] += mtd_data->mass[iat];
+      k++;
+    }
+    myp[j][0] /= totmasse[j];
+    myp[j][1] /= totmasse[j];
+    myp[j][2] /= totmasse[j];
+  }
+
+#if defined (PLUMED_GROMACS)
+#if defined (PLUMED_GROMACS45)
+  psi = dih_angle(myp[0],myp[1],myp[2],myp[3],&mtd_data->metapbc,r01,r21,r23,m,n,
+              &sign,&t1,&t2,&t3);
+#else
+  psi = dih_angle(myp[0],myp[1],myp[2],myp[3],&mtd_data->metapbc,r01,r21,r23,m,n,
+              &cos_psi,&sign,&t1,&t2,&t3);
+#endif
+#else
+  psi = dih_angle(myp[0],myp[1],myp[2],myp[3],r01,r21,r23,m,n,
+              &cos_psi,&sign);
+#endif
+
+  oprod(r01,r21,vp1);
+  oprod(r21,r23,vp2);
+  oprod(vp1,vp2,vp3);
+
+  if (psi >= pi) psi -= twopi;
+  else if(psi < -pi) psi += twopi;
+
+  nv1=norm(vp1);
+  nv2=norm(vp2);
+  n21=norm(r21);
+
+  sc1=iprod(r01,r21);
+  sc2=iprod(r23,r21);
+
+  in21=1./(n21*n21);
+
+  sc1 = sc1*in21;
+  sc2 = sc2*in21;
+
+  for(i=0;i<3;++i) {
+    d[0][i]= -n21 * vp1[i] / (nv1*nv1);
+    d[3][i]=  n21 * vp2[i] / (nv2*nv2);
+    d[1][i]=  (sc1-1.0)*d[0][i] - sc2*d[3][i];
+    d[2][i]=  (sc2-1.0)*d[3][i] - sc1*d[0][i];
+  }
+
+  // Now we do appropriate multiplication of the derivatives to get what we are interested in
+  if( colvar.doTrig[i_c]==0 ){ colvar.ss0[i_c] = psi; }
+  else if( colvar.doTrig[i_c]==1 ){
+     cos_psi=cos( psi );
+     for(i=0;i<3;++i){d[0][i]*= cos_psi; d[3][i]*= cos_psi; d[1][i]*= cos_psi; d[2][i]*= cos_psi;}
+     colvar.ss0[i_c] = sin( psi );
+  }
+  else if( colvar.doTrig[i_c]==2 ){
+     sin_psi=-sin( psi );
+     for(i=0;i<3;++i){d[0][i]*= sin_psi; d[3][i]*= sin_psi; d[1][i]*= sin_psi; d[2][i]*= sin_psi;}
+     colvar.ss0[i_c] = cos( psi );
+  }
+  else{ plumed_error("No trigonometric mode defined in torsion restraint"); }
+
+  k=0;
+  for(j=0;j<4;j++) {
+    for(i=0;i<colvar.list[i_c][j];i++){
+      iat = colvar.cvatoms[i_c][k];
+      for(ix=0;ix<3;ix++) colvar.myder[i_c][k][ix] = -d[j][ix]*mtd_data->mass[iat]/totmasse[j];
+      k++;
+    }
+  }
+
+}
+
+//-----------------------------------------------------------------------------------------------------------------
+
+int PREFIX read_torsion(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i, iat, j, iw, help;
+  double delta = 0.0;
+  char string[400];
+  help=0;
+
+  colvar.doTrig[count]=0;    // Default is to do no trigonometry (raw torsion)
+
+  iw = seek_word(word,"LIST");
+  if(iw>=0) {
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+             j=plumed_get_group(word[iw+2],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][1]=j;
+             j=plumed_get_group(word[iw+3],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][2]=j;
+             j=plumed_get_group(word[iw+4],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][3]=j;
+  } else { fprintf(fplog,"|- NEEDED LIST KEYWORD FOR TORSION\n"); help=1;}
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+
+    if(help){
+          fprintf(fplog, "\n-TORSION CV: WRONG SYNTAX\n");
+          fprintf(fplog, "e.g.:     \n");
+          fprintf(fplog, "TORSION LIST <g1> <g2> <g3> <g4> SIGMA 0.1\n");
+          fprintf(fplog, "         g1->    \n");
+          fprintf(fplog, "         6 10    \n");
+          fprintf(fplog, "         g1<-    \n");
+          fprintf(fplog, "                 \n");
+          fprintf(fplog, "         g2->    \n");
+          fprintf(fplog, "         8 15 21 \n");
+          fprintf(fplog, "         g2<-    \n");
+          fprintf(fplog, "                 \n");
+          fprintf(fplog, "         g3->    \n");
+          fprintf(fplog, "         23 29 31\n");
+          fprintf(fplog, "         g3<-    \n");
+          fprintf(fplog, "                 \n");
+          fprintf(fplog, "         g4->    \n");
+          fprintf(fplog, "         1 2     \n");
+          fprintf(fplog, "         g3<-    \n"); 
+          plumed_error("PluMeD dead with errors: check log file");          
+  }
+  iw=seek_word(word,"SIN");
+  if(iw>=0){ colvar.doTrig[count]=1; }
+  iw=seek_word(word,"COS");
+  if(iw>=0){ colvar.doTrig[count]=2; }
+
+  colvar.type_s[count]   = 5;
+
+  if(colvar.doTrig[count]==0){
+    fprintf(fplog, "\n%1i-TORSION: (1st SET: %i ATOMS), (2nd SET: %i ATOMS), (3rd SET: %i ATOMS) , (4th SET: %i ATOMS); ", count+1, 
+      colvar.list[count][0], colvar.list[count][1], colvar.list[count][2], colvar.list[count][3]);
+  }
+  if(colvar.doTrig[count]==1){
+    fprintf(fplog, "\n%1i-SINE OF TORSION: (1st SET: %i ATOMS), (2nd SET: %i ATOMS), (3rd SET: %i ATOMS) , (4th SET: %i ATOMS); ", count+1,
+      colvar.list[count][0], colvar.list[count][1], colvar.list[count][2], colvar.list[count][3]);
+  }
+  if(colvar.doTrig[count]==2){
+    fprintf(fplog, "\n%1i-COSINE OF TORSION: (1st SET: %i ATOMS), (2nd SET: %i ATOMS), (3rd SET: %i ATOMS) , (4th SET: %i ATOMS); ", count+1,
+      colvar.list[count][0], colvar.list[count][1], colvar.list[count][2], colvar.list[count][3]);
+  }
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+  iat=0;
+  fprintf(fplog,"|- 1st SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][0];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 2nd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][1];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 3rd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][2];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 4th SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][3];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  return colvar.natoms[count];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_waterbridge.c dl_class_1.9/srcmod/Plumed/restraint_waterbridge.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_waterbridge.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_waterbridge.c	2015-11-07 17:37:19.404604679 +0100
@@ -0,0 +1,216 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+//-----------------------------------------------------------------------------
+// COLVAR = number of water molecules bridging between two groups of atoms
+// \sum_w \sum_a \sum_b n_aw*n_bw   (w in OW, a in group A, b in group B)
+//-----------------------------------------------------------------------------
+
+#include "metadyn.h"
+
+void PREFIX waterbridge_restraint(int i_c, struct mtd_data_s *mtd_data) 
+{
+  int firstAtom, secondAtom, middleAtom, i, j, k, ix;
+  rvec rik, rjk;
+  real mod_rik, mod_rjk, s_rik, s_rjk;
+  real num, den, func1, dfunc1, func2, dfunc2;
+  real r_0 = colvar.r_0[i_c];
+  real r_safe;
+  int nn = colvar.nn[i_c];
+  int mm = colvar.mm[i_c];
+  int bdoneik;
+  real ncoord = 0., ncoord_tmp;
+
+  func1 = 0; func2 = 0; dfunc1 = 0; dfunc2 = 0;
+  r_safe = r_0*4.; 
+
+  for(i=0;i<colvar.natoms[i_c];i++) {
+    colvar.myder[i_c][i][0] = 0.;
+    colvar.myder[i_c][i][1] = 0.;
+    colvar.myder[i_c][i][2] = 0.;
+  }  
+
+  // k identifies water atoms
+  for(k=colvar.list[i_c][0]+colvar.list[i_c][1];k<colvar.natoms[i_c];k++){
+    middleAtom = colvar.cvatoms[i_c][k];
+    ncoord_tmp = 0.;
+    for (i=0;i<colvar.list[i_c][0];i++) {
+      firstAtom = colvar.cvatoms[i_c][i];
+      // n_ik and gradients are not yet calculated
+      bdoneik = 0;
+      minimal_image(mtd_data->pos[firstAtom], mtd_data->pos[middleAtom], &mod_rik, rik);
+      // calculation continues only if i is near to k
+      if(mod_rik < r_safe) {
+        for(j=colvar.list[i_c][0];j<colvar.list[i_c][0]+colvar.list[i_c][1];j++) {
+          secondAtom = colvar.cvatoms[i_c][j];
+          minimal_image(mtd_data->pos[secondAtom], mtd_data->pos[middleAtom], &mod_rjk, rjk);
+          // calculation continues only if j is near to k
+          if(mod_rjk < r_safe) {
+            // n_ik and gradients are calculated if undone before
+            if(bdoneik==0) {
+              s_rik = mod_rik/r_0;
+              num = (1.-pow(s_rik, nn));
+              den = (1.-pow(s_rik, mm));
+              func1 = num/den;
+              dfunc1 = (-nn*pow(s_rik,nn-1)/den+num/den/den*mm*pow(s_rik,mm-1))/mod_rik/r_0;
+              bdoneik = 1;
+            }
+            // n_jk and gradients are calculated
+            s_rjk = mod_rjk/r_0;
+            num = (1.-pow(s_rjk, nn));
+            den = (1.-pow(s_rjk, mm));
+            func2 = num/den;
+            dfunc2 = (-nn*pow(s_rjk,nn-1)/den+num/den/den*mm*pow(s_rjk,mm-1))/mod_rjk/r_0;
+
+            // final result
+            ncoord += func1*func2;
+            ncoord_tmp += func1*func2;
+
+            // dfunc : force (-derivative)
+            for(ix=0;ix<3;ix++) { 
+              colvar.myder[i_c][i][ix] += dfunc1*rik[ix]*func2;
+              colvar.myder[i_c][j][ix] += dfunc2*rjk[ix]*func1;
+              colvar.myder[i_c][k][ix] -= dfunc1*rik[ix]*func2 + dfunc2*rjk[ix]*func1;
+            }
+          }
+        }
+      }
+    }
+  }
+
+  colvar.ss0[i_c] = ncoord;
+
+}
+
+//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
+
+int PREFIX read_waterbridge(char **word, int count, t_plumed_input *input, FILE *fplog)
+{
+  int i, iat, iw, j, k;
+  double delta = 0.0;
+  double r_0;
+  char string[400];
+  int help;
+  help = 0;
+
+
+  iw=seek_word(word,"LIST");
+  if(iw>=0) { 
+             j=plumed_get_group(word[iw+1],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][0]=j;
+             j=plumed_get_group(word[iw+2],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][1]=j;
+             j=plumed_get_group(word[iw+3],&colvar.cvatoms[count],colvar.natoms[count],input,fplog);
+             colvar.natoms[count]+=j;
+             colvar.list[count][2]=j;
+  } else { fprintf(fplog,"|- NEEDED LIST KEYWORD FOR WATERBRIDGE\n"); help=1;}
+  iw=seek_word(word,"SIGMA");
+  if(iw>=0){ sscanf(word[iw+1],"%lf", &delta);
+             colvar.delta_r[count]  = (real) delta; }
+  iw=seek_word(word,"NN");
+  if(iw>=0) { 
+      sscanf(word[iw+1],"%i", &colvar.nn[count]);
+  } else {
+    fprintf(fplog,"|- NEEDED NN KEYWORD FOR WATERBRIDGE\n");
+    help=1;
+  }
+  iw=seek_word(word,"MM");
+  if(iw>=0) { 
+      sscanf(word[iw+1],"%i", &colvar.mm[count]);
+  } else {
+    fprintf(fplog,"|- NEEDED MM KEYWORD FOR WATERBRIDGE\n");
+    help=1;
+  }
+  iw=seek_word(word,"R_0");
+  if(iw>=0) { 
+     sscanf(word[iw+1],"%lf", &r_0);
+  } else {
+    fprintf(fplog,"|- NEEDED R_0 KEYWORD FOR WATERBRIDGE\n");
+    help=1;
+  }
+
+   if(help){
+         fprintf(fplog,"|- WATERBRIDGE SYNTAX:\n");
+         fprintf(fplog,"|- LIST               : groups name\n");
+         fprintf(fplog,"|- NN                 : switching function parameter\n");
+         fprintf(fplog,"|- MM                 : switching function parameter\n");
+         fprintf(fplog,"|- R_0                : switching function parameter\n");
+         fprintf(fplog,"|- SIGMA              : hills width for this cv\n");
+         fprintf(fplog,"e.g. \n");
+         fprintf(fplog,"WATERBRIDGE LIST <type1> <type2> <solvent> NN 8 MM 12 R_0 4.0 SIGMA 0.1 \n");
+         fprintf(fplog, "         type1->    \n");
+         fprintf(fplog, "         6 10    \n");
+         fprintf(fplog, "         type1<-    \n");
+         fprintf(fplog, "                 \n");
+         fprintf(fplog, "         type2->    \n");
+         fprintf(fplog, "         8 15 21 \n");
+         fprintf(fplog, "         type2<-    \n");
+         fprintf(fplog, "                 \n");
+         fprintf(fplog, "         solvent->    \n");
+         fprintf(fplog, "         LOOP 100 1000 3\n");
+         fprintf(fplog, "         solvent<-    \n");
+         plumed_error("PluMeD dead with errors: check log file");
+  }
+
+  colvar.type_s[count] = 20;
+  colvar.r_0[count]      = (real) r_0; 
+  
+  fprintf(fplog, "\n%1i-WATERBRIDGE: (1st SET: %i ATOMS), (2nd SET: %i ATOMS), (3rd SET: %i ATOMS); ", count+1,
+    colvar.list[count][0], colvar.list[count][1], colvar.list[count][2]);
+  if (logical.do_hills) fprintf(fplog," SIGMA %f\n",colvar.delta_r[count]);
+  else fprintf(fplog,"\n"); 
+  iat=0;
+  fprintf(fplog,"|- 1st SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][0];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 2nd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][1];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n");
+  fprintf(fplog,"|- 3rd SET MEMBERS: ");
+  for(i=0;i<colvar.list[count][2];i++){fprintf(fplog," %d ",colvar.cvatoms[count][iat++]+1);if((i+1)%20==0)fprintf(fplog,"\n                    ");}fprintf(fplog,"\n\n");
+
+  snew(colvar.myder[count], colvar.natoms[count]);
+
+  // checking for repeated atoms
+  for(k=0;k<colvar.list[count][2];k++) {
+    for(i=0;i<colvar.list[count][0]+colvar.list[count][1];i++) {
+      if(colvar.cvatoms[count][i]==colvar.cvatoms[count][colvar.list[count][0]+colvar.list[count][1]+k]) {
+       char buf[1024];
+       sprintf(buf, "WATERBRIDGE: atom %d is a water oxygen",colvar.cvatoms[count][i]);
+       plumed_error(buf); 
+      }
+    }
+  }
+
+  return colvar.list[count][0]+colvar.list[count][1];
+}
diff -urN dl_class_1.9.orig/srcmod/Plumed/restraint_zpath.c dl_class_1.9/srcmod/Plumed/restraint_zpath.c
--- dl_class_1.9.orig/srcmod/Plumed/restraint_zpath.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/restraint_zpath.c	2015-11-07 17:37:19.407604766 +0100
@@ -0,0 +1,544 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void  PREFIX zpath_restraint(int i_c, struct mtd_data_s *mtd_data) {
+
+        int iat,i,j;
+        real z,ci_vec,tmp1;
+        struct coordinates_frameset *pmy_coord1;
+        struct sz_data *pmy_sz;
+        struct hybrid_frameset *hbd_pmy;
+        struct cmap_inpack inpack;
+        struct cmap_outpack outpack;
+        real dz_dr0[3][MAXATOMS_PATH];
+        real dz_dcm[MAXFRAMES_PATH][MAXDIM_CMAP];
+        real dz_dr1[MAXFRAMES_PATH][3][MAXATOMS_PATH];
+        real dmsd_dr1[3][MAXATOMS_PATH];
+        int   start_avg = 0;
+        int    tot_con;    
+        real *save_err; 
+        int nneigh,ii;
+
+        pmy_sz=&my_sz_list[ic_to_sz[i_c]];
+
+        // bernd alternative indexing:
+        // a separate implementation is preferred so to avoid strange quirks
+        if(pmy_sz->indexing_type==1){
+           // call bernd's routine: pass the pointer to the structure  
+           zbernd_restraint(i_c,mtd_data);
+           return;  
+        }
+ 
+
+// neigh list ?
+        if((pmy_sz->neigh==1 && colvar.it%pmy_sz->neigh_time==0) || firstTime )  {
+            //fprintf(mtd_data->fplog,"|- CALCULATING NEIGHBOUR LIST AT STEP %d\n",colvar.it);
+            for(i=0;i< pmy_sz->number;i++)pmy_sz->lneigh[i]=i;
+               nneigh=pmy_sz->number;
+               save_err=(real *)malloc(pmy_sz->number*sizeof(real));
+        }else {
+            nneigh=pmy_sz->nneigh;
+        }
+
+
+
+        for (i=0;i<3;i++){
+                for (j=0;j<colvar.natoms[i_c];j++) {
+                        dz_dr0[i][j]=0.;
+                }
+        }
+
+        ci_vec=0.;
+
+   	for (i=0;i<colvar.natoms[i_c];i++){
+            iat = colvar.cvatoms[i_c][i];
+       	    inpack.r0[i][0] = mtd_data->pos[iat][0];
+            inpack.r0[i][1] = mtd_data->pos[iat][1];
+            inpack.r0[i][2] = mtd_data->pos[iat][2];
+	}
+
+
+
+        if(pmy_sz->umb_on && (colvar.it-pmy_sz->umblagsteps>=0)) start_avg = 1;  
+
+        if(strcmp(pmy_sz->path_type,"CMAP") == 0){
+         tot_con=pmy_sz->my_cmap_pack.number+pmy_sz->my_cmap_pack.gnumber;
+         cmap_running(i_c, &inpack,&pmy_sz->my_cmap_pack);
+        }
+
+        if(strcmp(pmy_sz->path_type,"HYBRID") == 0){ 
+			
+            hbd_collect_config(pmy_sz->hbd_running);  // this collect cv values and needed derivatives
+			
+			hbd_collect_jacobian(pmy_sz->hbd_running,pmy_sz->mathybrid,pmy_sz->myinverse,mtd_data->fplog,1);
+			
+			// simple case of debugging of the metrics (need its own module)
+			
+			if(pmy_sz->debug_metrics)test_hbd_metrics_new(pmy_sz->hbd_running,pmy_sz->hbd_frameset[0],&outpack,pmy_sz->mathybrid,mtd_data->fplog);
+	
+        }
+
+//   fprintf(mtd_data->fplog,"ENTERING_MEASURE\n");
+//                fflush(mtd_data->fplog);
+ 
+        for(ii=0;ii< nneigh;ii++){
+                i=pmy_sz->lneigh[ii];
+
+                //fprintf(mtd_data->fplog,"PRE RMSD %d %d\n",i,pmy_sz->lneigh[ii]);
+                //fflush(mtd_data->fplog);
+ 
+                if(strcmp(pmy_sz->path_type,"CMAP") == 0){
+                 cmdist_eval(i_c, i,&inpack,&outpack,&pmy_sz->my_cmap_pack,start_avg);
+                }
+                if(strcmp(pmy_sz->path_type,"MSD") == 0){
+                 pmy_coord1=pmy_sz->frameset[i];
+                 msd_calculation(pmy_coord1,&inpack,&outpack,dmsd_dr1,pmy_sz->umb_on,pmy_sz->norot_on,pmy_sz->nocenter_on);
+                }
+                if(strcmp(pmy_sz->path_type,"DMSD") == 0){
+                 pmy_coord1=pmy_sz->frameset[i];
+                 dmsd_calculation(i_c,pmy_coord1,&inpack,&outpack,dmsd_dr1);
+                }                
+                if(strcmp(pmy_sz->path_type,"HYBRID") == 0){
+                 hbd_pmy=pmy_sz->hbd_frameset[i];
+                 //hbd_metrics(&pmy_sz->hbd_running,hbd_pmy,&outpack,pmy_sz->mathybrid);
+				hbd_metrics_new(pmy_sz->hbd_running,pmy_sz->hbd_frameset[i],&outpack,pmy_sz->mathybrid,mtd_data->fplog);
+
+                }
+ 
+             //   fprintf(mtd_data->fplog,"ERR %d %f \n",i,outpack.err);
+                fflush(mtd_data->fplog);
+ 
+             // in case you are calculating the neigh list 
+                if((pmy_sz->neigh==1 && colvar.it%pmy_sz->neigh_time==0)|| firstTime) save_err[i]=outpack.err;
+
+             // sqrt option
+                if(pmy_sz->sqrt_on){
+                   //if(outpack.err<1.e-6){
+                   // char buf[1024];
+                   // sprintf(buf,"PATH. Too small error: %f",outpack.err);
+                   // plumed_error(buf);
+                   //}
+                   if(pmy_sz->targeted_on){
+                       pmy_sz->lambda=1./sqrt(outpack.err);
+		       if(outpack.err<1.e-15) pmy_sz->lambda=1.e-15;
+                   }  
+                   if(outpack.err<1.e-15){ 
+                   	tmp1=0.;
+                   }else{
+                   	tmp1=(0.5/sqrt(outpack.err))*exp(-pmy_sz->lambda*sqrt(outpack.err));
+                   } 
+		   ci_vec+=exp(-pmy_sz->lambda*sqrt(outpack.err));
+                }else{
+	           //if(pmy_sz->lambda*outpack.err>1.e2)outpack.err=1.e2/pmy_sz->lambda;		 
+                  if(pmy_sz->targeted_on){
+                        pmy_sz->lambda=1./(outpack.err);
+                        if(outpack.err<1.e-15) pmy_sz->lambda=1.e-15;
+                   }  
+                   tmp1=exp(-pmy_sz->lambda*outpack.err);
+		   ci_vec+=tmp1;
+                }
+                for(j=0;j<colvar.natoms[i_c];j++){
+                        dz_dr0[0][j]+=tmp1*outpack.derr_dr0[0][j];
+                        dz_dr0[1][j]+=tmp1*outpack.derr_dr0[1][j];
+                        dz_dr0[2][j]+=tmp1*outpack.derr_dr0[2][j];
+                        if((strcmp(pmy_sz->path_type,"MSD") == 0 || strcmp(pmy_sz->path_type,"DMSD") == 0) && start_avg){ 
+                         dz_dr1[i][0][j]=(dmsd_dr1[0][j])*tmp1;
+                         dz_dr1[i][1][j]=(dmsd_dr1[1][j])*tmp1;
+                         dz_dr1[i][2][j]=(dmsd_dr1[2][j])*tmp1;
+                        }
+                }
+                if(strcmp(pmy_sz->path_type,"CMAP") == 0 && start_avg){ 
+                 for(j=0;j<tot_con;j++){
+                          dz_dcm[i][j]=(outpack.derr_dcm[j])*tmp1;
+                        }
+                 }
+        }
+
+//   fprintf(mtd_data->fplog,"EXITING_MEASURE\n");
+//                fflush(mtd_data->fplog);
+ 
+        z=-(1./pmy_sz->lambda)*log(ci_vec);
+
+#ifdef STANDALONE
+        z/=(mtd_data->ampli)*(mtd_data->ampli);
+#endif
+
+        for(j=0;j<colvar.natoms[i_c];j++){
+                dz_dr0[0][j]=(1./ci_vec) *dz_dr0[0][j];
+                dz_dr0[1][j]=(1./ci_vec) *dz_dr0[1][j];
+                dz_dr0[2][j]=(1./ci_vec) *dz_dr0[2][j];
+#ifdef STANDALONE
+                dz_dr0[0][j]/=(mtd_data->ampli)*(mtd_data->ampli);
+                dz_dr0[1][j]/=(mtd_data->ampli)*(mtd_data->ampli);
+                dz_dr0[2][j]/=(mtd_data->ampli)*(mtd_data->ampli);
+#endif
+
+                 if((strcmp(pmy_sz->path_type,"MSD") == 0 || strcmp(pmy_sz->path_type,"DMSD") == 0) && start_avg){ 
+                  for(ii=0;ii<nneigh;ii++){
+                       i=pmy_sz->lneigh[ii];
+                       dz_dr1[i][0][j]=dz_dr1[i][0][j]/ci_vec;
+                       dz_dr1[i][1][j]=dz_dr1[i][1][j]/ci_vec;
+                       dz_dr1[i][2][j]=dz_dr1[i][2][j]/ci_vec;
+#ifdef STANDALONE
+                       dz_dr1[i][0][j]/=(mtd_data->ampli)*(mtd_data->ampli);
+                       dz_dr1[i][1][j]/=(mtd_data->ampli)*(mtd_data->ampli);
+                       dz_dr1[i][2][j]/=(mtd_data->ampli)*(mtd_data->ampli);
+#endif
+                  }
+                }
+        }
+
+         if(strcmp(pmy_sz->path_type,"CMAP") == 0 && start_avg){ 
+           for(ii=0;ii<nneigh;ii++){
+               i=pmy_sz->lneigh[ii];
+               for(j=0;j<tot_con;j++){
+                  dz_dcm[i][j]=dz_dcm[i][j]/ci_vec;
+               }
+           }
+        }
+
+
+        for(i=0;i<colvar.natoms[i_c];i++) {
+          colvar.myder[i_c][i][0] = dz_dr0[0][i];
+          colvar.myder[i_c][i][1] = dz_dr0[1][i];
+          colvar.myder[i_c][i][2] = dz_dr0[2][i];
+        }
+
+        colvar.ss0[i_c]=z;
+
+        // neigh list? do quicksort and deallocate save_err
+       if((pmy_sz->neigh==1 && colvar.it%pmy_sz->neigh_time==0)|| firstTime) {
+             //   for(i=0;i<nneigh;i++)printf("BEFORE SORTING %d %f\n",pmy_sz->lneigh[i],save_err[i]);
+                realquicksort(save_err,pmy_sz->lneigh,0,nneigh-1);
+             //   for(i=0;i<nneigh;i++)printf("AFTER SORTING %d %f\n",pmy_sz->lneigh[i],save_err[i]);
+                free(save_err);
+        }
+
+
+        if(pmy_sz->umb_on==1){
+          if(strcmp(pmy_sz->path_type,"CMAP") == 0) mean_map(pmy_sz,dz_dcm,i_c,mtd_data->fplog);
+          if(strcmp(pmy_sz->path_type,"MSD") == 0 || strcmp(pmy_sz->path_type,"DMSD") == 0) mean_rmsd(pmy_sz,dz_dr1,i_c,mtd_data->fplog);
+#ifdef PATHREF_FINDIFF
+          //fprintf(mtd_data->fplog,"|---FILLING TEST ARRAYS \n");
+          for(j=0;j<colvar.natoms[i_c];j++){
+                 for(ii=0;ii<pmy_sz->number;ii++){
+                      pmy_sz->dpath_dr[0][j][ii]=0.; 
+                      pmy_sz->dpath_dr[1][j][ii]=0.; 
+                      pmy_sz->dpath_dr[2][j][ii]=0.; 
+                 }
+                 for(ii=0;ii<nneigh;ii++){
+                      i=pmy_sz->lneigh[ii];
+                      pmy_sz->dpath_dr[0][j][i]=dz_dr1[i][0][j]; 
+                      pmy_sz->dpath_dr[1][j][i]=dz_dr1[i][1][j]; 
+                      pmy_sz->dpath_dr[2][j][i]=dz_dr1[i][2][j]; 
+                 } 
+          } 
+          //fprintf(mtd_data->fplog,"|---FILLING TEST ARRAYS DONE \n");
+#endif 
+        }
+
+        return;
+}
+
+
+// ------------------------------------------------------------------------------------------------
+
+ void PREFIX mean_rmsd(struct sz_data *pmy_sz, real dCV_dr1[MAXFRAMES_PATH][3][MAXATOMS_PATH],
+                        int i_c, FILE *fplog){
+
+   real tmp1,tmp2,tmp3,tmp4;
+   int i,j,k,l;  
+   FILE   *fp;
+   fp=NULL; 
+
+
+          if( (logical.steer[i_c] != 1) && (logical.cnstr[i_c] != 1) )
+            plumed_error("UMBRELLA MUST BE USED TOGHETER WITH STEER KEYWORD");
+
+          if(!colvar.it){
+                  // printf("UMB: INIT\n");
+                   kill_me[i_c]=0;
+                   for(i=0;i<3;i++){
+                     for(j=0;j<(*pmy_sz->frameset[0]).natoms;j++){
+                       for(k=0;k< pmy_sz->number;k++){
+                         for(l=0;l<pmy_sz->umbblocksize;l++){
+                          pmy_sz->umb_block[i][j][k][l]=0.;
+                         }
+                       }
+                     }
+                   }  
+                   for(i=0;i<3;i++){
+                     for(j=0;j<(*pmy_sz->frameset[0]).natoms;j++){
+                       for(k=0;k< pmy_sz->number;k++){
+                          pmy_sz->umb_avg[i][j][k]=0.;
+                       }
+                     }
+                   }  
+                   pmy_sz->umbcount=0;
+          }
+          // END OF INITIZIALIZATION
+          if(  (colvar.it-pmy_sz->umblagsteps>=0)  &&  ((colvar.it-pmy_sz->umblagsteps)%pmy_sz->umbstride==0)  ){
+             //printf("UMB: ACQUIRE %d\n",colvar.it);
+             pmy_sz->umbcount++;
+             l=pmy_sz->umbcount%pmy_sz->umbblocksize;
+             //cout<<"UMBCOUNT "<<pmy_sz->umbcount<<endl;
+             for(i=0;i<3;i++){
+                for(j=0;j<(*pmy_sz->frameset[0]).natoms;j++){
+                  for(k=0;k< pmy_sz->number;k++){
+                     tmp1=2.*cvsteer.spring[i_c]*(colvar.ss0[i_c]-cvsteer.pos[i_c])*dCV_dr1[k][i][j];    
+                     pmy_sz->umb_avg[i][j][k]      +=tmp1 ; 
+                     pmy_sz->umb_block[i][j][k][l]  =pmy_sz->umb_avg[i][j][k]/((real) pmy_sz->umbcount) ; 
+                  }
+                }
+             }  
+             /*evaluate convergence and make a dump only when the block is full*/ 
+
+             if( (pmy_sz->umbcount>=pmy_sz->umbblocksize) && (pmy_sz->umbcount%pmy_sz->umbblocksize == 0) ){
+                   //printf("UMB: THE_BLOCK_IS_FULL-> EVALUATING CONVERGENCE %d\n",colvar.it);
+                     
+                     tmp3=0.;
+                     tmp4=0.;
+                     for(i=0;i<3;i++){
+                         for(j=0;j<(*pmy_sz->frameset[0]).natoms;j++){
+                             for(k=0;k< pmy_sz->number;k++){
+                               tmp3+=pow(pmy_sz->umb_avg[i][j][k]/((real) pmy_sz->umbcount),2);    
+                             }
+                         }
+                     } 
+                     tmp3=sqrt(tmp3);
+                     tmp2=0.;
+                     for(l=0;l<pmy_sz->umbblocksize;l++){
+                       tmp1=0.;
+                       tmp4=0.; 
+                       for(i=0;i<3;i++){
+                         for(j=0;j<(*pmy_sz->frameset[0]).natoms;j++){
+                             for(k=0;k< pmy_sz->number;k++){
+                               tmp1+=pmy_sz->umb_block[i][j][k][l]*(pmy_sz->umb_avg[i][j][k]/((real) pmy_sz->umbcount));    
+                               tmp4+=pow(pmy_sz->umb_block[i][j][k][l],2);    
+                             }
+                         }
+                       } 
+                       tmp4=sqrt(tmp4);
+                       tmp2+=pow(tmp1/(tmp3*tmp4),2);
+                     } 
+                     tmp2=tmp2/((real) pmy_sz->umbblocksize); // mean of the projections
+                     /* FILE PRINTOUT */
+                     if(pmy_sz->umbcount==pmy_sz->umbblocksize){
+                      if(colvar.type_s[i_c] == 30) fp=fopen((mtd_data.ionode?"umbrella_evol_s.dat":"/dev/null"),"w");
+                      if(colvar.type_s[i_c] == 31) fp=fopen((mtd_data.ionode?"umbrella_evol_a.dat":"/dev/null"),"w");
+                     } else {
+                      if(colvar.type_s[i_c] == 30) fp=fopen((mtd_data.ionode?"umbrella_evol_s.dat":"/dev/null"),"a");
+                      if(colvar.type_s[i_c] == 31) fp=fopen((mtd_data.ionode?"umbrella_evol_a.dat":"/dev/null"),"a");
+                     }
+ 
+                     if(fp!=NULL){
+                          //printf("UMB: WRITEOUT \n");
+                          for(k=0;k<pmy_sz->number ;k++){
+                                fprintf(fp,"%% TRAJ %d\n",k+1);
+                                for(j=0;j<(*pmy_sz->frameset[0]).natoms;j++){
+                                    fprintf(fp,"%15.8e %15.8e %15.8e\n",pmy_sz->umb_avg[0][j][k]/((real) pmy_sz->umbcount),
+                                                                        pmy_sz->umb_avg[1][j][k]/((real) pmy_sz->umbcount),
+                                                                        pmy_sz->umb_avg[2][j][k]/((real) pmy_sz->umbcount));
+				}
+                          }
+                          fprintf(fp,"\n\n");
+                          fclose(fp);
+                     }
+                     else { fprintf(fplog,"ERROR IN OPENING THE UMBRELLA FILE \n"); }
+
+                     // criteria for stop
+                     if(colvar.type_s[i_c] == 30)  fprintf(fplog,"PROJECTION_SS VALUE %lf PERM %d \n",sqrt((1.-tmp2)*(1.-tmp2)),pmy_sz->countperm);
+                     if(colvar.type_s[i_c] == 31)  fprintf(fplog,"PROJECTION_ZZ VALUE %lf PERM %d \n",sqrt((1.-tmp2)*(1.-tmp2)),pmy_sz->countperm); 
+                     if( sqrt((1.-tmp2)*(1.-tmp2))<pmy_sz->umbtolerance){
+                       pmy_sz->countperm++;
+                       if(pmy_sz->countperm >= pmy_sz->umbpermanency){
+                              kill_me[i_c]=1;
+                              /* Decide wether kill the calculation or wait for others  check kill_me vector*/
+                              i=0;
+                              j=0;
+                              for(k=0;k<nsz;k++){
+                                    if(kill_me[k]>=0)i++;
+                                    if(kill_me[k]>0)j++;
+                              }
+                              // IF KILL_ME == NUMBER OF VARIABLES ON WHICH CALCULATE THE VALUE THEN DUMP AND KILL
+                              if(i==j) {
+                               fprintf(fplog,"** VECTOR CONVERGED !! Exiting... \n");
+                               EXIT(); 
+                              } 
+                       }  
+                     }
+                     else{
+                       pmy_sz->countperm=0;
+                       kill_me[i_c]=0;
+                     }
+           
+             } 
+
+          }
+
+      return;          
+}
+
+// ------------------------------------------------------------------------------------------------
+
+ void PREFIX mean_map(struct sz_data *pmy_sz, real dCV_dcm[MAXFRAMES_PATH][MAXDIM_CMAP],
+                        int i_c, FILE *fplog){
+
+   real tmp1,tmp2,tmp3,tmp4;
+   int    i,j,k,l;  
+   FILE   *fp;
+   int    tot_con;
+   fp=NULL;
+
+
+          if( (logical.steer[i_c]) != 1  && (logical.cnstr[i_c] != 1) )
+            plumed_error("UMBRELLA MUST BE USED TOGHETER WITH STEER KEYWORD");
+
+          tot_con=pmy_sz->my_cmap_pack.number+pmy_sz->my_cmap_pack.gnumber;
+          
+          if(!colvar.it){
+                   kill_me[i_c]=0;
+                     for(j=0;j<tot_con;j++){
+                       for(k=0;k<pmy_sz->number;k++){
+                         for(l=0;l<pmy_sz->umbblocksize;l++){
+                          pmy_sz->umb_map_block[j][k][l]=0.;
+                         }
+                       }
+                     }
+                     for(j=0;j<tot_con;j++){
+                       for(k=0;k<pmy_sz->number;k++){
+                          pmy_sz->umb_map_avg[j][k]=0.;
+                       }
+                     }
+                   pmy_sz->umbcount=0;
+          }
+          // END OF INITIALIZATION
+          if(  (colvar.it-pmy_sz->umblagsteps>=0)  &&  ((colvar.it-pmy_sz->umblagsteps)%pmy_sz->umbstride==0)  ){
+                                  
+             pmy_sz->umbcount++;
+             l=pmy_sz->umbcount%pmy_sz->umbblocksize;
+
+                for(j=0;j<tot_con;j++){
+                  for(k=0;k<pmy_sz->number;k++){
+                     tmp1=cvsteer.spring[i_c]*(colvar.ss0[i_c]-cvsteer.pos[i_c])*dCV_dcm[k][j];    
+                     pmy_sz->umb_map_avg[j][k]      +=tmp1 ; 
+                     pmy_sz->umb_map_block[j][k][l]  =pmy_sz->umb_map_avg[j][k]/((real) pmy_sz->umbcount) ; 
+                  }
+                }
+             /*evaluate convergence only when the block is full*/ 
+             if( (pmy_sz->umbcount>=pmy_sz->umbblocksize) && (pmy_sz->umbcount%pmy_sz->umbblocksize == 0) ){
+                     tmp3=0.;
+                     tmp4=0.;
+                         for(j=0;j<tot_con;j++){
+                             for(k=0;k<pmy_sz->number;k++){
+                               tmp3+=pow(pmy_sz->umb_map_avg[j][k]/((real) pmy_sz->umbcount),2);    
+                             }
+                         }
+                     tmp3=sqrt(tmp3);
+                     tmp2=0.;
+                     for(l=0;l<pmy_sz->umbblocksize;l++){
+                       tmp1=0.;
+                       tmp4=0.; 
+                         for(j=0;j<tot_con;j++){
+                             for(k=0;k<pmy_sz->number;k++){
+                               tmp1+=pmy_sz->umb_map_block[j][k][l]*(pmy_sz->umb_map_avg[j][k]/((real) pmy_sz->umbcount));    
+                               tmp4+=pow(pmy_sz->umb_map_block[j][k][l],2);    
+                             }
+                         }
+                       tmp4=sqrt(tmp4);
+                       tmp2+=pow(tmp1/(tmp3*tmp4),2);
+                     } 
+                     tmp2=tmp2/((real) pmy_sz->umbblocksize); // mean of the projections
+                     /* FILE PRINTOUT */
+                     if(pmy_sz->umbcount==pmy_sz->umbblocksize){
+                      if(colvar.type_s[i_c] == 30) fp=fopen("umbrella_evol_s.dat","w");
+                      if(colvar.type_s[i_c] == 31) fp=fopen("umbrella_evol_a.dat","w");
+                     } else {
+                      if(colvar.type_s[i_c] == 30) fp=fopen("umbrella_evol_s.dat","a");
+                      if(colvar.type_s[i_c] == 31) fp=fopen("umbrella_evol_a.dat","a");
+                     }
+ 
+                     if(fp!=NULL){
+                          for(k=0;k<pmy_sz->number ;k++){
+                                fprintf(fp,"%% TRAJ %d\n",k+1);
+                                for(j=0;j<tot_con;j++){
+                                    fprintf(fp,"%15.8e \n",pmy_sz->umb_map_avg[j][k]/((real) pmy_sz->umbcount));
+				}
+                          }
+                          fprintf(fp,"\n\n");
+                          fclose(fp);
+                     }
+                     else { fprintf(fplog,"ERROR IN OPENING THE UMBRELLA FILE \n"); }
+
+                     // criteria for stop
+                     if(colvar.type_s[i_c] == 30)  fprintf(fplog,"PROJECTION_SS VALUE %lf PERM %d \n",sqrt((1.-tmp2)*(1.-tmp2)),pmy_sz->countperm);
+                     if(colvar.type_s[i_c] == 31)  fprintf(fplog,"PROJECTION_ZZ VALUE %lf PERM %d \n",sqrt((1.-tmp2)*(1.-tmp2)),pmy_sz->countperm);
+
+                     if( sqrt((1.-tmp2)*(1.-tmp2))<pmy_sz->umbtolerance){
+                       pmy_sz->countperm++;
+                       if(pmy_sz->countperm >= pmy_sz->umbpermanency){
+                              kill_me[i_c]=1;
+                              /* Decide wether kill the calculation or wait for others  check kill_me vector*/
+                              i=0;
+                              j=0;
+                              for(k=0;k<nsz;k++){
+                                    if(kill_me[k]>=0)i++;
+                                    if(kill_me[k]>0)j++;
+                              }
+                              // IF KILL_ME == NUMBER OF VARIABLES ON WHICH CALCULATE THE VALUE THEN DUMP AND KILL
+                              if(i==j) {
+                               fprintf(fplog,"** VECTOR CONVERGED !! Exiting... \n");
+                               EXIT(); 
+                              }
+                       }  
+                     }
+                     else{
+                       pmy_sz->countperm=0;
+                       kill_me[i_c]=0;
+                     }
+           
+             } 
+
+          }
+
+      return;          
+}
+void  PREFIX zbernd_restraint(int i_c, struct mtd_data_s *mtd_data){
+//AVOID
+	  char buf[1024];
+          sprintf(buf,"THIS FEATURE HAS BEEN REMOVED. SORRY! ");
+          plumed_error(buf);
+};
+
diff -urN dl_class_1.9.orig/srcmod/Plumed/testderivatives.c dl_class_1.9/srcmod/Plumed/testderivatives.c
--- dl_class_1.9.orig/srcmod/Plumed/testderivatives.c	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/Plumed/testderivatives.c	2015-11-07 17:37:19.410604854 +0100
@@ -0,0 +1,627 @@
+/*
+*******************************************************************************
+*                                                                             *
+*                                PLUMED                                       *
+*   A Portable Plugin for Free Energy Calculations with Molecular Dynamics    *
+*                              VERSION 1.3                                    *
+*                                                                             *
+*******************************************************************************
+*
+*  
+*  Copyright (c) 2008-2011 The PLUMED team.
+*  See http://www.plumed-code.org for more information. 
+*
+*  This file is part of PLUMED.
+*
+*  PLUMED is free software: you can redistribute it and/or modify
+*  it under the terms of the GNU Lesser General Public License as 
+*  published by the Free Software Foundation, either version 3 of 
+*  the License, or (at your option) any later version.
+*
+*  PLUMED is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  GNU Lesser General Public License for more details.
+*
+*  You should have received a copy of the GNU Lesser General
+*  Public License along with PLUMED.  
+*  If not, see <http://www.gnu.org/licenses/>.
+*
+*  For more info, see:  http://www.plumed-code.org
+*  or subscribe to plumed-users@googlegroups.com
+*
+*/
+#include "metadyn.h"
+
+void PREFIX test_derivatives(struct mtd_data_s *mtd_data)
+{
+  rvec testforce;
+  real teststep = 0.0001, invstep = 10000., val1, val2, diff, analder;
+  int i_c, ix, i, j, iat, flag, killflag;
+
+  // Check for bespoke CVs - we have a separate test derivatives for these
+#ifdef CVS
+  flag=0; for(i_c=0;i_c<colvar.nconst;i_c++){ if(colvar.type_s[i_c]==46){flag=1;} }
+  if(flag==1){ bespoke_test_derivatives( mtd_data ); abort(); }
+#endif
+	
+  killflag=0;
+  for(i_c=0;i_c<colvar.nconst;i_c++) {
+     if(colvar.type_s[i_c]==49){ histogram_testderivatives(i_c,mtd_data); killflag=1; }
+  }
+  if(killflag==1){ printf("WARNING: only debugging histogram derivatives\n"); abort(); }
+
+  for(i_c=0;i_c<colvar.nconst;i_c++) {
+	  printf("DEBUGGING CV %d -----------------------------\n",i_c);
+    for(i=0;i<colvar.natoms[i_c];i++) {
+      iat = colvar.cvatoms[i_c][i];
+      for(ix=0;ix<3;ix++) {
+        mtd_data->pos[iat][ix] += teststep;
+        switch(colvar.type_s[i_c]){
+          case 1: dist_restraint(i_c, mtd_data); break;		
+          case 2: mindist_restraint(i_c, mtd_data); break;                   
+          case 3: coord_restraint(i_c, mtd_data); break;                     
+          case 4: angle_restraint(i_c, mtd_data); break;                     
+          case 5: torsion_restraint(i_c, mtd_data); break;           
+          case 6: alfabeta_restraint(i_c, mtd_data); break;                  
+          case 7: hbonds_restraint(i_c, mtd_data); break;                    
+          case 8: dipole_restraint(i_c, mtd_data); break;            
+          case 11: radgyr_restraint(i_c, mtd_data); break;           
+          case 16: dihcor_restraint(i_c, mtd_data); break;
+          case 20: waterbridge_restraint(i_c, mtd_data); break;              
+          case 30: spath_restraint_testder(i_c, mtd_data); break;
+          case 31: zpath_restraint_testder(i_c, mtd_data); break;
+          case 32: position_restraint(i_c, mtd_data); break;
+          case 33: elstpot_restraint(i_c, mtd_data); break;
+          case 34: puckering_restraint(i_c, mtd_data); break;
+          case 36: helix_restraint(i_c, mtd_data); break;
+          case 37: alpharmsd_restraint(i_c, mtd_data); break;
+          case 38: antibetarmsd_restraint(i_c, mtd_data); break;
+          case 39: parabetarmsd_restraint(i_c, mtd_data); break;
+          //case 40: camshift_restraint(i_c, mtd_data); break;
+          //case 41: camshiftens_restraint(i_c, mtd_data); break;
+          case 42: pca_restraint(i_c, mtd_data); break;
+          case 45: cmap_restraint(i_c, mtd_data); break;
+          case 47: rdf_restraint(i_c, 0, mtd_data); break;
+          case 50: poly_restraint_testder(i_c, mtd_data); break;
+          case 51: func_restraint_testder(i_c, mtd_data); break;
+          case 52: adf_restraint(i_c, 0, mtd_data); break;
+		  case 53: msd_restraint(i_c, mtd_data); break;
+          case 55: sprint_restraint(i_c, mtd_data); break; 
+
+        }
+	logical.not_same_step=0;
+        val1 = colvar.ss0[i_c];
+        mtd_data->pos[iat][ix] += -2.*teststep;
+        switch(colvar.type_s[i_c]){
+          case 1: dist_restraint(i_c, mtd_data); break;
+          case 2: mindist_restraint(i_c, mtd_data); break;           
+          case 3: coord_restraint(i_c, mtd_data); break;                
+          case 4: angle_restraint(i_c, mtd_data); break;                 
+          case 5: torsion_restraint(i_c, mtd_data); break;              
+          case 6: alfabeta_restraint(i_c, mtd_data); break;             
+          case 7: hbonds_restraint(i_c, mtd_data); break;               
+          case 8: dipole_restraint(i_c, mtd_data); break;               
+          case 11: radgyr_restraint(i_c, mtd_data); break;              
+          case 16: dihcor_restraint(i_c, mtd_data); break;              
+          case 20: waterbridge_restraint(i_c, mtd_data); break;      
+		  case 30: spath_restraint_testder(i_c, mtd_data); break;		
+          case 31: zpath_restraint_testder(i_c, mtd_data); break;
+          case 32: position_restraint(i_c, mtd_data); break;
+          case 33: elstpot_restraint(i_c, mtd_data); break;
+          case 34: puckering_restraint(i_c, mtd_data); break;
+          case 36: helix_restraint(i_c, mtd_data); break;
+          case 37: alpharmsd_restraint(i_c, mtd_data); break;
+          case 38: antibetarmsd_restraint(i_c, mtd_data); break;
+          case 39: parabetarmsd_restraint(i_c, mtd_data); break;
+          //case 40: camshift_restraint(i_c, mtd_data); break;
+          //case 41: camshiftens_restraint(i_c, mtd_data); break;
+          case 42: pca_restraint(i_c, mtd_data); break;
+          case 45: cmap_restraint(i_c, mtd_data); break;
+          case 47: rdf_restraint(i_c, 0, mtd_data); break; 
+          case 50: poly_restraint_testder(i_c, mtd_data); break;
+          case 51: func_restraint_testder(i_c, mtd_data); break;
+          case 52: adf_restraint(i_c, 0, mtd_data); break;
+		  case 53: msd_restraint(i_c, mtd_data); break;
+          case 55: sprint_restraint(i_c, mtd_data); break; 
+
+        }
+        val2 = colvar.ss0[i_c];
+        testforce[ix] = 0.5*((val1*invstep)-(val2*invstep));
+        if(colvar.type_s[i]==5 || ( colvar.type_s[i]==34 && colvar.type[i]==2 )) {
+           diff = val1-val2;
+           if(diff>M_PI) diff-=2.*M_PI;
+           else if(diff<-M_PI) diff+=2.*M_PI;
+           testforce[ix] = 0.5*(diff*invstep);
+        }
+        mtd_data->pos[iat][ix] += teststep;
+        switch(colvar.type_s[i_c]){
+          case 1: dist_restraint(i_c, mtd_data); break;
+          case 2: mindist_restraint(i_c, mtd_data); break;                               
+          case 3: coord_restraint(i_c, mtd_data); break;                
+          case 4: angle_restraint(i_c, mtd_data); break;                
+          case 5: torsion_restraint(i_c, mtd_data); break;              
+          case 6: alfabeta_restraint(i_c, mtd_data); break;             
+          case 7: hbonds_restraint(i_c, mtd_data); break;               
+          case 8: dipole_restraint(i_c, mtd_data); break;               
+          case 11: radgyr_restraint(i_c, mtd_data); break;              
+          case 16: dihcor_restraint(i_c, mtd_data); break;              
+          case 20: waterbridge_restraint(i_c, mtd_data); break;                          
+          case 30: spath_restraint_testder(i_c, mtd_data); break;
+          case 31: zpath_restraint_testder(i_c, mtd_data); break;
+          case 32: position_restraint(i_c, mtd_data); break;
+          case 33: elstpot_restraint(i_c, mtd_data); break;
+          case 34: puckering_restraint(i_c, mtd_data); break;
+          case 36: helix_restraint(i_c, mtd_data); break;
+          case 37: alpharmsd_restraint(i_c, mtd_data); break;
+          case 38: antibetarmsd_restraint(i_c, mtd_data); break;
+          case 39: parabetarmsd_restraint(i_c, mtd_data); break;
+          //case 40: camshift_restraint(i_c, mtd_data); break;
+          //case 41: camshiftens_restraint(i_c, mtd_data); break;
+          case 42: pca_restraint(i_c, mtd_data); break;
+          case 47: rdf_restraint(i_c, 0, mtd_data); break;
+          case 50: poly_restraint_testder(i_c, mtd_data); break;
+          case 51: func_restraint_testder(i_c, mtd_data); break;
+          case 52: adf_restraint(i_c, 0, mtd_data); break;
+		  case 53: msd_restraint(i_c, mtd_data); break;
+          case 55: sprint_restraint(i_c, mtd_data); break; 
+
+        }
+// analytic derivative: the same atom may be given in input more than once
+        analder=0.;
+        for(j=0;j<colvar.natoms[i_c];j++) {
+          if(colvar.cvatoms[i_c][j]==iat) {
+            analder+=colvar.myder[i_c][j][ix];
+          }
+        }
+        printf("atom %5i[%i] ** analytic %15.10f ** numeric %15.10f *** DELTA %15.10f *** DPERCENT %12.3f\n",
+                iat, ix, analder, testforce[ix], analder-testforce[ix],100.*(analder-testforce[ix])/analder);
+      }  
+    }
+  }
+}
+
+#ifdef RECONMETAD  
+#ifndef DRIVER
+void PREFIX test_recon_derivatives(struct mtd_data_s *mtd_data)
+{
+  rvec testforce;
+  real teststep = 0.0001, invstep = 10000., diff, analder; // Qanalder;
+  double val1, val2 ;
+  int i_c,i_oc, ix, i, j, iat, it;
+  double welikedupes_s[colvar.nconst], recon_der[colvar.nconst];
+
+  // Initialize recon metadynamics plugin for testing
+  for(i_c=0;i_c<colvar.nconst;i_c++) { // Loop over all cvs
+      switch(colvar.type_s[i_c]){
+        case 1: dist_restraint(i_c, mtd_data); break;
+        case 2: mindist_restraint(i_c, mtd_data); break;
+        case 3: coord_restraint(i_c, mtd_data); break;
+        case 4: angle_restraint(i_c, mtd_data); break;
+        case 5: torsion_restraint(i_c, mtd_data); break;
+        case 6: alfabeta_restraint(i_c, mtd_data); break;
+        case 7: hbonds_restraint(i_c, mtd_data); break;
+        case 8: dipole_restraint(i_c, mtd_data); break;
+        case 11: radgyr_restraint(i_c, mtd_data); break;
+        case 16: dihcor_restraint(i_c, mtd_data); break;
+        case 20: waterbridge_restraint(i_c, mtd_data); break;
+        case 30: spath_restraint(i_c, mtd_data); break;
+        case 31: zpath_restraint(i_c, mtd_data); break;
+        case 32: position_restraint(i_c, mtd_data); break;
+        case 33: elstpot_restraint(i_c, mtd_data); break;
+        case 34: puckering_restraint(i_c, mtd_data); break;
+        case 36: helix_restraint(i_c, mtd_data); break;
+        case 37: alpharmsd_restraint(i_c, mtd_data); break;
+        case 38: antibetarmsd_restraint(i_c, mtd_data); break;
+        case 39: parabetarmsd_restraint(i_c, mtd_data); break;
+        //case 40: camshift_restraint(i_c, mtd_data); break;
+        //case 41: camshiftens_restraint(i_c, mtd_data); break;
+        case 42: pca_restraint(i_c, mtd_data); break;
+        case 45: cmap_restraint(i_c, mtd_data); break;
+        case 47: rdf_restraint(i_c, 0, mtd_data); break;
+        case 50: poly_restraint_testder(i_c, mtd_data); break;
+        case 51: func_restraint_testder(i_c, mtd_data); break;
+        case 52: adf_restraint(i_c, 0, mtd_data); break; 
+		case 53: msd_restraint(i_c, mtd_data); break;
+        case 55: sprint_restraint(i_c, mtd_data); break; 
+
+      }
+  }
+
+  for(it=0;it<colvar.nconst;++it) welikedupes_s[it]=colvar.ss0[it];
+  setup_test_recon( colvar.nconst, welikedupes_s, myreconObj );
+
+  for(i_oc=0;i_oc<colvar.nconst;i_oc++) {    // Loop over all atoms in all cvs
+      for(i=0;i<colvar.natoms[i_oc];i++) {   //  "    "    "   "    "   "   "
+          iat = colvar.cvatoms[i_oc][i];
+          for(ix=0;ix<3;ix++) {              // Loop over all coordinates 
+              mtd_data->pos[iat][ix] += teststep;
+              for(i_c=0;i_c<colvar.nconst;i_c++) { // Loop over all cvs
+                  switch(colvar.type_s[i_c]){
+                    case 1: dist_restraint(i_c, mtd_data); break;
+                    case 2: mindist_restraint(i_c, mtd_data); break;
+                    case 3: coord_restraint(i_c, mtd_data); break;
+                    case 4: angle_restraint(i_c, mtd_data); break;
+                    case 5: torsion_restraint(i_c, mtd_data); break;
+                    case 6: alfabeta_restraint(i_c, mtd_data); break;
+                    case 7: hbonds_restraint(i_c, mtd_data); break;
+                    case 8: dipole_restraint(i_c, mtd_data); break;
+                    case 11: radgyr_restraint(i_c, mtd_data); break;
+                    case 16: dihcor_restraint(i_c, mtd_data); break;
+                    case 20: waterbridge_restraint(i_c, mtd_data); break;
+                    case 30: spath_restraint(i_c, mtd_data); break;
+                    case 31: zpath_restraint(i_c, mtd_data); break;
+                    case 32: position_restraint(i_c, mtd_data); break;
+                    case 33: elstpot_restraint(i_c, mtd_data); break;
+                    case 34: puckering_restraint(i_c, mtd_data); break;
+                    case 36: helix_restraint(i_c, mtd_data); break;
+                    case 37: alpharmsd_restraint(i_c, mtd_data); break;
+                    case 38: antibetarmsd_restraint(i_c, mtd_data); break;
+                    case 39: parabetarmsd_restraint(i_c, mtd_data); break;
+                    //case 40: camshift_restraint(i_c, mtd_data); break;
+                    //case 41: camshiftens_restraint(i_c, mtd_data); break;
+                    case 42: pca_restraint(i_c, mtd_data); break;
+                    case 45: cmap_restraint(i_c, mtd_data); break;
+                    case 47: rdf_restraint(i_c, 0, mtd_data); break;
+                    case 50: poly_restraint_testder(i_c, mtd_data); break;
+                    case 51: func_restraint_testder(i_c, mtd_data); break;
+                    case 52: adf_restraint(i_c, 0, mtd_data); break; 
+					case 53: msd_restraint(i_c, mtd_data); break;
+                    case 55: sprint_restraint(i_c, mtd_data); break; 
+
+                  }
+              }
+              // Now P and Q using recon plugin
+              for(it=0;it<colvar.nconst;++it) welikedupes_s[it]=colvar.ss0[it];
+              recon_calc_cv( colvar.nconst, welikedupes_s, &val1, myreconObj);
+
+              mtd_data->pos[iat][ix] += -2.*teststep;
+              for(i_c=0;i_c<colvar.nconst;i_c++) {
+                  switch(colvar.type_s[i_c]){
+                   case 1: dist_restraint(i_c, mtd_data); break;
+                   case 2: mindist_restraint(i_c, mtd_data); break;
+                   case 3: coord_restraint(i_c, mtd_data); break;
+                   case 4: angle_restraint(i_c, mtd_data); break;
+                   case 5: torsion_restraint(i_c, mtd_data); break;
+                   case 6: alfabeta_restraint(i_c, mtd_data); break;
+                   case 7: hbonds_restraint(i_c, mtd_data); break;
+                   case 8: dipole_restraint(i_c, mtd_data); break;
+                   case 11: radgyr_restraint(i_c, mtd_data); break;
+                   case 16: dihcor_restraint(i_c, mtd_data); break;
+                   case 20: waterbridge_restraint(i_c, mtd_data); break;
+                   case 30: spath_restraint(i_c, mtd_data); break;
+                   case 31: zpath_restraint(i_c, mtd_data); break;
+                   case 32: position_restraint(i_c, mtd_data); break;
+                   case 33: elstpot_restraint(i_c, mtd_data); break;
+                   case 34: puckering_restraint(i_c, mtd_data); break;
+                   case 36: helix_restraint(i_c, mtd_data); break;
+                   case 37: alpharmsd_restraint(i_c, mtd_data); break;
+                   case 38: antibetarmsd_restraint(i_c, mtd_data); break;
+                   case 39: parabetarmsd_restraint(i_c, mtd_data); break;
+                   //case 40: camshift_restraint(i_c, mtd_data); break;
+                   //case 41: camshiftens_restraint(i_c, mtd_data); break;
+                   case 42: pca_restraint(i_c, mtd_data); break;
+                   case 45: cmap_restraint(i_c, mtd_data); break;
+                   case 47: rdf_restraint(i_c, 0, mtd_data); break;
+                   case 50: poly_restraint_testder(i_c, mtd_data); break;
+                   case 51: func_restraint_testder(i_c, mtd_data); break;
+                   case 52: adf_restraint(i_c, 0, mtd_data); break;
+				   case 53: msd_restraint(i_c, mtd_data); break;
+                   case 55: sprint_restraint(i_c, mtd_data); break; 
+
+                   }
+       
+              }
+              // Now P and Q using recon plugin
+              for(it=0;it<colvar.nconst;++it) welikedupes_s[it]=colvar.ss0[it];
+              recon_calc_cv( colvar.nconst, welikedupes_s, &val2, myreconObj); 
+
+              testforce[ix] = 0.5*((val1*invstep)-(val2*invstep));
+            
+              mtd_data->pos[iat][ix] += teststep;
+              for(i_c=0;i_c<colvar.nconst;i_c++) {
+                  switch(colvar.type_s[i_c]){
+                    case 1: dist_restraint(i_c, mtd_data); break;
+                    case 2: mindist_restraint(i_c, mtd_data); break;
+                    case 3: coord_restraint(i_c, mtd_data); break;
+                    case 4: angle_restraint(i_c, mtd_data); break;
+                    case 5: torsion_restraint(i_c, mtd_data); break;
+                    case 6: alfabeta_restraint(i_c, mtd_data); break;
+                    case 7: hbonds_restraint(i_c, mtd_data); break;
+                    case 8: dipole_restraint(i_c, mtd_data); break;
+                    case 11: radgyr_restraint(i_c, mtd_data); break;
+                    case 16: dihcor_restraint(i_c, mtd_data); break;
+                    case 20: waterbridge_restraint(i_c, mtd_data); break;
+                    case 30: spath_restraint(i_c, mtd_data); break;
+                    case 31: zpath_restraint(i_c, mtd_data); break;
+                    case 32: position_restraint(i_c, mtd_data); break;
+                    case 33: elstpot_restraint(i_c, mtd_data); break;
+                    case 34: puckering_restraint(i_c, mtd_data); break;
+                    case 36: helix_restraint(i_c, mtd_data); break;
+                    case 37: alpharmsd_restraint(i_c, mtd_data); break;
+                    case 38: antibetarmsd_restraint(i_c, mtd_data); break;
+                    case 39: parabetarmsd_restraint(i_c, mtd_data); break;
+                    //case 40: camshift_restraint(i_c, mtd_data); break;
+                    //case 41: camshiftens_restraint(i_c, mtd_data); break;
+                    case 42: pca_restraint(i_c, mtd_data); break;
+                    case 45: cmap_restraint(i_c, mtd_data); break;
+                    case 47: rdf_restraint(i_c, 0, mtd_data); break;
+                    case 50: poly_restraint_testder(i_c, mtd_data); break;
+                    case 51: func_restraint_testder(i_c, mtd_data); break;
+                    case 52: adf_restraint(i_c, 0, mtd_data); break;
+					case 53: msd_restraint(i_c, mtd_data); break;
+                    case 55: sprint_restraint(i_c, mtd_data); break; 
+
+                   }
+              }
+              for(it=0;it<colvar.nconst;++it) welikedupes_s[it]=colvar.ss0[it];
+              recon_derivatives( colvar.nconst,  welikedupes_s, recon_der , myreconObj );
+
+              analder=0;                  
+              for(i_c=0;i_c<colvar.nconst;i_c++) { 
+                  for(j=0;j<colvar.natoms[i_c];j++) {
+                      if(colvar.cvatoms[i_c][j]==iat) {
+                        analder+=recon_der[i_c]*colvar.myder[i_c][j][ix];
+                      }
+                  }
+              }
+              printf("Force atom %5i[%i] ** analytic %15.10f ** numeric %15.10f *** DELTA %15.10f\n",
+                iat, ix, analder, testforce[ix], analder-testforce[ix]);
+        }
+     }
+  }
+
+}
+#endif
+#endif
+
+void PREFIX debug_derivatives(struct mtd_data_s *mtd_data,int print){
+  static int first=1;
+  static rvec** pos=NULL;
+  static rvec** der=NULL;
+  static rvec** previous_pos=NULL;
+  static rvec** previous_der=NULL;
+  static real* integral;
+  int icv,i,j,ncv,iat;
+  static FILE* debug_file=NULL;
+
+  ncv = colvar.nconst;
+  if(first){
+    snew(integral,ncv);
+    snew(pos,ncv);
+    snew(der,ncv);
+    snew(previous_pos,ncv);
+    snew(previous_der,ncv);
+    for(icv=0;icv<ncv;icv++){
+      integral[icv]=colvar.ss0[icv];
+      snew(pos[icv],colvar.natoms[icv]);
+      snew(der[icv],colvar.natoms[icv]);
+      snew(previous_pos[icv],colvar.natoms[icv]);
+      snew(previous_der[icv],colvar.natoms[icv]);
+    }
+  }
+
+  for(icv=0;icv<ncv;icv++){
+    for(i=0;i<colvar.natoms[icv];i++){
+      iat = colvar.cvatoms[icv][i];
+      for(j=0;j<3;j++){
+        der[icv][i][j]=colvar.myder[icv][i][j];
+        pos[icv][i][j]=mtd_data->pos[iat][j];
+      }
+    }
+  }
+
+  if(!first){
+    for(icv=0;icv<ncv;icv++){
+      for(i=0;i<colvar.natoms[icv];i++){
+        for(j=0;j<3;j++){
+          integral[icv]+=
+          0.5*(der[icv][i][j]+previous_der[icv][i][j])*(pos[icv][i][j]-previous_pos[icv][i][j]);
+        }
+      }
+    }
+  }
+
+  if(print){
+    if(!debug_file) debug_file = fopen((mtd_data->ionode?"DEBUG":"/dev/null"), "w");
+    fprintf(debug_file, "%10.3f", mtd_data->time);
+    for(icv=0;icv<colvar.nconst;icv++) fprintf(debug_file, "   %10.8f", integral[icv]-colvar.ss0[icv]);
+    fprintf(debug_file, "\n");
+    fflush(debug_file);
+  }
+
+  for(icv=0;icv<ncv;icv++){
+    for(i=0;i<colvar.natoms[icv];i++){
+      for(j=0;j<3;j++){
+        previous_der[icv][i][j]=der[icv][i][j];
+        previous_pos[icv][i][j]=pos[icv][i][j];
+      }
+    }
+  }
+
+  first=0;
+};
+
+
+// in the POLY CV, we need to recompute the CV involved in each terms,
+// we do this by calling the appropriate _restraint functions before the 
+// poly_restraint call.
+void PREFIX poly_restraint_testder(int i_c, struct mtd_data_s *mtd_data){
+  int i, jcv;
+  //printf("poly_restraint_testder for cv=%d\n",i_c);
+  // loop over the CVs involved in the calculation of the polynomial and recalculate them 
+  i=0;
+  if(1) while(colvar.intpar[i_c][i]>=0){
+     jcv = colvar.intpar[i_c][i];
+     // printf("poly_restraint recalculating cv=%d\n",jcv);
+     switch(colvar.type_s[jcv]){
+          case 1: dist_restraint(jcv, mtd_data); break;
+          case 2: mindist_restraint(jcv, mtd_data); break;
+          case 3: coord_restraint(jcv, mtd_data); break;
+          case 4: angle_restraint(jcv, mtd_data); break;
+          case 5: torsion_restraint(jcv, mtd_data); break;
+          case 6: alfabeta_restraint(jcv, mtd_data); break;
+          case 7: hbonds_restraint(jcv, mtd_data); break;
+          case 8: dipole_restraint(jcv, mtd_data); break;
+          case 11: radgyr_restraint(jcv, mtd_data); break;
+          case 16: dihcor_restraint(jcv, mtd_data); break;
+          case 20: waterbridge_restraint(jcv, mtd_data); break;
+          case 30: spath_restraint(jcv, mtd_data); break;
+          case 31: zpath_restraint(jcv, mtd_data); break;
+          case 32: position_restraint(jcv, mtd_data); break;
+          case 33: elstpot_restraint(jcv, mtd_data); break;
+          case 34: puckering_restraint(jcv, mtd_data); break;
+          case 36: helix_restraint(jcv, mtd_data); break;
+          case 37: alpharmsd_restraint(jcv, mtd_data); break;
+          case 38: antibetarmsd_restraint(jcv, mtd_data); break;
+          case 39: parabetarmsd_restraint(jcv, mtd_data); break;
+          //case 40: camshift_restraint(i_c, mtd_data); break;
+          //case 41: camshiftens_restraint(i_c, mtd_data); break;
+          case 42: pca_restraint(jcv, mtd_data); break;
+          case 45: cmap_restraint(jcv, mtd_data); break;
+          case 47: rdf_restraint(jcv, 0, mtd_data); break;
+          // recursively
+          case 50: poly_restraint_testder(jcv, mtd_data); break;
+          case 51: func_restraint_testder(jcv, mtd_data); break;
+          case 52: adf_restraint(i_c, 0, mtd_data); break;
+		  case 53: msd_restraint(i_c, mtd_data); break;
+          case 55: sprint_restraint(i_c, mtd_data); break; 
+
+     }
+  i++;
+  }
+  //we are ready to calculate the values for the polynomial CV
+  //printf("poly_restraint cv(%d)=%f\n", i_c,colvar.ss0[i_c]);
+  poly_restraint(i_c, mtd_data);  
+}
+void PREFIX func_restraint_testder(int i_c, struct mtd_data_s *mtd_data){
+  int i, jcv;
+#ifdef HAVE_MATHEVAL
+   struct mathfunction_s *myfunc;
+   myfunc=&mathfunction[i_c];
+  //printf("func_restraint_testder for cv=%d\n",i_c);
+  // loop over the CVs involved in the calculation of the polynomial and recalculate them 
+  for (i = 0; i < myfunc->count; i++){
+     jcv = myfunc->indcvs[i] ; 
+     // printf("func_restraint recalculating cv=%d\n",jcv);
+     switch(colvar.type_s[jcv]){
+          case 1: dist_restraint(jcv, mtd_data); break;
+          case 2: mindist_restraint(jcv, mtd_data); break;
+          case 3: coord_restraint(jcv, mtd_data); break;
+          case 4: angle_restraint(jcv, mtd_data); break;
+          case 5: torsion_restraint(jcv, mtd_data); break;
+          case 6: alfabeta_restraint(jcv, mtd_data); break;
+          case 7: hbonds_restraint(jcv, mtd_data); break;
+          case 8: dipole_restraint(jcv, mtd_data); break;
+          case 11: radgyr_restraint(jcv, mtd_data); break;
+          case 16: dihcor_restraint(jcv, mtd_data); break;
+          case 20: waterbridge_restraint(jcv, mtd_data); break;
+          case 30: spath_restraint(jcv, mtd_data); break;
+          case 31: zpath_restraint(jcv, mtd_data); break;
+          case 32: position_restraint(jcv, mtd_data); break;
+          case 33: elstpot_restraint(jcv, mtd_data); break;
+          case 34: puckering_restraint(jcv, mtd_data); break;
+          case 36: helix_restraint(jcv, mtd_data); break;
+          case 37: alpharmsd_restraint(jcv, mtd_data); break;
+          case 38: antibetarmsd_restraint(jcv, mtd_data); break;
+          case 39: parabetarmsd_restraint(jcv, mtd_data); break;
+          //case 40: camshift_restraint(i_c, mtd_data); break;
+          //case 41: camshiftens_restraint(i_c, mtd_data); break;
+          case 42: pca_restraint(jcv, mtd_data); break;
+          case 45: cmap_restraint(jcv, mtd_data); break;
+          case 47: rdf_restraint(jcv, 0, mtd_data); break;
+          // recursively
+          case 50: poly_restraint_testder(jcv, mtd_data); break;
+          case 51: func_restraint_testder(jcv, mtd_data); break;
+          case 52: adf_restraint(i_c, 0, mtd_data); break;
+ 		  case 53: msd_restraint(i_c, mtd_data); break;
+          case 55: sprint_restraint(i_c, mtd_data); break; 
+
+     }
+  }
+  //we are ready to calculate the values for the polynomial CV
+  //printf("func_restraint cv(%d)=%f\n", i_c,colvar.ss0[i_c]);
+  func_restraint(i_c, mtd_data);  
+#endif
+}
+void PREFIX spath_restraint_testder(int i_c, struct mtd_data_s *mtd_data){
+	// get the pointer
+	int i,j,cvindex;
+	struct sz_data *pmy_sz;
+	struct hybrid_frameset *running;
+	struct hybrid_elem *elem;
+	pmy_sz=&my_sz_list[ic_to_sz[i_c]];
+	// if hybrid then recalculate forcibly all the needed cvs
+	if(strcmp(pmy_sz->path_type,"HYBRID") == 0){
+			running=pmy_sz->hbd_running;
+			for (i=0;i< running->hbd_nelem;i++){ // for each element
+				elem=running->hbd_elem[i];
+				cvindex=elem->cvindex;
+				switch(elem->cvtype){
+					case 1:
+						dist_restraint(cvindex,mtd_data);
+						break;
+					case 3:
+						coord_restraint(cvindex,mtd_data);
+						break;
+					case 4:
+						angle_restraint(cvindex,mtd_data);
+						break;
+					case 5:
+						torsion_restraint(cvindex,mtd_data);
+						break;
+					case 53:
+						msd_restraint(cvindex,mtd_data);
+						break;
+					default:
+						printf("THIS TEST FOR THE HYBRID PATH IS NOT IMPLEMENTED\n");EXIT();break;	
+						
+				}
+			}
+			// hybrid path: check separately.		
+	}
+	// this holds in every case
+	spath_restraint(i_c, mtd_data); 
+}
+void PREFIX zpath_restraint_testder(int i_c, struct mtd_data_s *mtd_data){
+	// get the pointer
+	int i,j,cvindex;
+	struct sz_data *pmy_sz;
+	struct hybrid_frameset *running;
+	struct hybrid_elem *elem;
+	pmy_sz=&my_sz_list[ic_to_sz[i_c]];
+	// if hybrid then recalculate forcibly all the needed cvs
+	if(strcmp(pmy_sz->path_type,"HYBRID") == 0){
+			
+			running=pmy_sz->hbd_running;
+			for (i=0;i< running->hbd_nelem;i++){ // for each element
+				elem=running->hbd_elem[i];
+				cvindex=elem->cvindex;
+				switch(elem->cvtype){
+					case 1:
+						dist_restraint(cvindex,mtd_data);
+						break;
+					case 3:
+						coord_restraint(cvindex,mtd_data);
+						break;
+					case 4:
+						angle_restraint(cvindex,mtd_data);
+						break;
+					case 5:
+						torsion_restraint(cvindex,mtd_data);
+						break;
+					case 53:
+						msd_restraint(cvindex,mtd_data);
+						break;
+					default:
+						printf("THIS TEST FOR THE HYBRID PATH IS NOT IMPLEMENTED\n");EXIT();break;	
+						
+				}
+			}
+	}
+		// hybrid path: check separately.		
+	 // this holds in every case
+	zpath_restraint(i_c, mtd_data); 
+		
+}
+		
diff -urN dl_class_1.9.orig/srcmod/pmf_module.f dl_class_1.9/srcmod/pmf_module.f
--- dl_class_1.9.orig/srcmod/pmf_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/pmf_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,1911 @@
+      module pmf_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining potential of mean force arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    oct 2003
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use ensemble_tools_module
+      use lf_motion_module
+      use lf_rotation1_module
+      use parse_module
+      use property_module
+      use setup_module
+      use shake_module
+      use vv_motion_module
+      use utility_module
+      
+      implicit none
+      
+      integer npmf
+      real(8) prmpmf,pmfnrm
+      real(8), allocatable :: pmfwght(:)
+      integer, allocatable :: numpmf(:)
+      integer, allocatable :: indpmf(:)
+      integer, allocatable :: listpm(:)
+      integer, allocatable :: lstpmt(:)
+      integer, allocatable :: lstpmf(:,:)
+      
+      dimension npmf(2),pmfnrm(2)
+      
+      save npmf,prmpmf,pmfnrm,pmfwght,numpmf,indpmf,listpm
+      save lstpmt,lstpmf
+      
+      contains
+      
+      subroutine alloc_pmf_arrays(idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for allocating pmf arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    oct 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=6
+      
+      integer i,idnode,fail
+      dimension fail(nnn)
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (pmfwght(mxspmf),stat=fail(1))
+      allocate (indpmf(mxspmf),stat=fail(2))
+      allocate (numpmf(mxtmls),stat=fail(3))
+      allocate (listpm(mxpmf),stat=fail(4))
+      allocate (lstpmt(mxpmf),stat=fail(5))
+      allocate (lstpmf(mxspmf,mspmf),stat=fail(6))
+      
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1210)
+      enddo
+      
+      do i=1,mxtmls
+        numpmf(i)=0
+      enddo
+      
+      end subroutine alloc_pmf_arrays
+      
+      subroutine define_pmf(safe,idnode,itmols,nspmf)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining pmf units
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe
+      integer idnode,itmols,nspmf,ipmf,jpmf,iatm1,idum
+      real(8) wght
+      
+      numpmf(itmols)=1
+      prmpmf=dblstr(record,lenrec,idum)
+      
+      if(idnode.eq.0) then
+        write(nrite,"(/,1x,' PMF      bondlength :',
+     x    5x,f20.10)") prmpmf
+        write(nrite,
+     x    "(/,/,12x,'unit, site and weight details:'
+     x    ,/,/,16x,'unit',6x,'index',5x,'weight')")
+      endif
+      
+      do ipmf=1,2
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        call strip(record,lenrec)
+        call lowcase(record,lenrec)
+        if(.not.findstring('pmf unit',record,idum))
+     x    call error(idnode,462)
+        npmf(ipmf)=intstr(record,lenrec,idum)
+        
+        do jpmf=1,npmf(ipmf)
+          
+          call getrec(safe,idnode,nfield)
+          if(.not.safe)return
+          
+          iatm1=intstr(record,lenrec,idum)
+          wght=dblstr(record,lenrec,idum)
+          if(wght.le.1.d-10) wght=1.d0
+          
+          nspmf=nspmf+1
+          
+          if(nspmf.gt.mxspmf) call error(idnode,460)
+          
+          indpmf(nspmf)=iatm1
+          pmfwght(nspmf)=wght
+          
+          if(idnode.eq.0) then
+            
+            if(jpmf.eq.1) then
+              write(nrite,"(16x,i5,i10,f12.6)")
+     x          ipmf,indpmf(nspmf),pmfwght(nspmf)
+            else
+              write(nrite,"(21x,i10,f12.6)")
+     x          indpmf(nspmf),pmfwght(nspmf)
+            endif
+            
+          endif
+          
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine define_pmf
+      
+      subroutine pmf_vectors
+     x  (img,nspmf,imcon,cell,xxx,yyy,zzz,xxt,yyt,zzt,xxa,yya,zza,
+     x  dxp,dyp,dzp)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing vectors for PMF calculations
+c     
+c     copyright - daresbury laboratory
+c     adapted by w.smith october 2005
+c     original by t.forester aug 1995
+c     
+c     set variable img true for PBC shifted vectors
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical img
+      integer nspmf,imcon,k,jj,kk,ipmf,i,i1,i2
+      
+      real(8) xxx(mxatms),yyy(mxatms),zzz(mxatms)
+      real(8) xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      real(8) xxa(2,mspmf),yya(2,mspmf),zza(2,mspmf)
+      real(8) dxp(mspmf),dyp(mspmf),dzp(mspmf),cell(9)
+      
+      do k=1,nspmf
+        
+        jj=0
+        kk=0
+        
+c     calculate difference vectors
+        
+        do ipmf=1,2
+          
+          i1=lstpmf(jj+1,k)
+          
+c     position difference vectors
+          
+          do i=1,npmf(ipmf)
+            
+            jj=jj+1
+            i2=lstpmf(jj,k)
+            xxt(i)=xxx(i2)-xxx(i1)
+            yyt(i)=yyy(i2)-yyy(i1)
+            zzt(i)=zzz(i2)-zzz(i1)
+            
+          enddo
+          
+c     correct for periodic images - assume less than half box length
+          
+          if(img)call images(imcon,0,1,npmf(ipmf),cell,xxt,yyt,zzt)
+          
+c     create weighted coordinate
+          
+          xxa(ipmf,k)=0.d0
+          yya(ipmf,k)=0.d0
+          zza(ipmf,k)=0.d0
+          
+          do i=1,npmf(ipmf)
+            
+            kk=kk+1
+            xxa(ipmf,k)=xxa(ipmf,k)+pmfwght(kk)*xxt(i)
+            yya(ipmf,k)=yya(ipmf,k)+pmfwght(kk)*yyt(i)
+            zza(ipmf,k)=zza(ipmf,k)+pmfwght(kk)*zzt(i)
+            
+          enddo
+          
+          xxa(ipmf,k)=xxa(ipmf,k)/pmfnrm(ipmf)+xxx(i1)
+          yya(ipmf,k)=yya(ipmf,k)/pmfnrm(ipmf)+yyy(i1)
+          zza(ipmf,k)=zza(ipmf,k)/pmfnrm(ipmf)+zzz(i1)
+          
+        enddo
+        
+        dxp(k)=xxa(2,k)-xxa(1,k)
+        dyp(k)=yya(2,k)-yya(1,k)
+        dzp(k)=zza(2,k)-zza(1,k)
+        
+      enddo
+      
+c     periodic boundary condition for pmf vectors
+      
+      if(img)call images(imcon,0,1,nspmf,cell,dxp,dyp,dzp)
+      
+      return
+      end subroutine pmf_vectors
+      
+      subroutine pmflf
+     x  (safe,safep,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x  ntcons,nspmf,ntpmf,engke,tolnce,tstep,vircon,virpmf)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics. Verlet leapfrog With RD-SHAKE
+c     and PMF_SHAKE - for potential of mean force calculations.
+c     
+c     parallel replicated data version : block data
+c     adapted from dl_poly routine nve_1.f
+c     
+c     copyright - daresbury laboratory 1995
+c     author  - t.forester aug 1995
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=8
+      
+      logical safe,lshmov,safep,unsafe,img
+      integer idnode,imcon,mxnode,natms,nscons,ntcons,nspmf,ntpmf
+      integer fail,iatm0,iatm1,i,j,k,jj,ii,ipmf,icyc
+      real(8) engke,tolnce,tstep,vircon,virpmf,strpmf,summas
+      real(8) rstep,viracc,strkin,strcon
+      
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: xxa(:,:),yya(:,:),zza(:,:)
+      real(8), allocatable :: dxp(:),dyp(:),dzp(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      dimension strpmf(9),strcon(9),strkin(9),summas(2),fail(nnn)
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(1))
+      allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(2))
+      allocate(xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(3))
+      allocate(uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(4))
+      allocate(xxa(2,mspmf),yya(2,mspmf),zza(2,mspmf),stat=fail(5))
+      allocate(dxp(mspmf),dyp(mspmf),dzp(mspmf),stat=fail(6))
+      allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+      allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(8))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1220)
+      enddo
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     constraint virials
+      
+      vircon=0.d0
+      virpmf=0.d0
+      
+c     temporary stress tensor accumulators
+      
+      do i=1,9
+        
+        strcns(i)=0.d0
+        strpmf(i)=0.d0
+        
+      enddo
+      
+c     store initial values of position
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        
+      enddo
+      
+c     construct current bond vectors
+      
+      do k=1,nscons
+        
+c     indices of atoms in bond
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+        
+c     calculate current bond vector
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+      
+c     periodic boundary condition for bond vectors
+      
+      call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+      
+c     calculate mass terms for PMF units
+      
+      jj=0
+      do ipmf=1,2
+        
+        summas(ipmf)=0.d0
+        pmfnrm(ipmf)=0.d0
+        
+        do i=1,npmf(ipmf)
+          
+          jj=jj+1
+          ii=lstpmf(jj,1)
+          summas(ipmf)=summas(ipmf)+weight(ii)
+          pmfnrm(ipmf)=pmfnrm(ipmf)+pmfwght(jj)
+          
+        enddo
+        
+      enddo
+      
+c     calculate PMF bond constraints and store initial positions
+      
+      img=.true.
+      call pmf_vectors
+     x  (img,nspmf,imcon,cell,xxx,yyy,zzz,xxt,yyt,zzt,
+     x  xxa,yya,zza,dxp,dyp,dzp)
+      
+c     move atoms by leapfrog algorithm
+      
+      safe=(ntcons.eq.0)
+      safep=(ntpmf.eq.0)
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        
+c     update velocities
+        
+        uxx(i)=vxx(i)+tstep*rmass(i)*fxx(i)
+        uyy(i)=vyy(i)+tstep*rmass(i)*fyy(i)
+        uzz(i)=vzz(i)+tstep*rmass(i)*fzz(i)
+        
+c     update positions
+        
+        xxx(i)=xxo(j)+tstep*uxx(i)
+        yyy(i)=yyo(j)+tstep*uyy(i)
+        zzz(i)=zzo(j)+tstep*uzz(i)
+        
+      enddo
+      
+c     RDSHAKE procedure 
+      
+      if(ntcons.gt.0.or.ntpmf.gt.0) then
+        
+c     global exchange of configuration data
+        
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+c     apply constraint corrections - iteratively
+        
+        icyc=0
+        unsafe=.true.
+        
+        do while(unsafe.and.icyc.lt.mxshak)
+          
+          icyc=icyc+1
+          
+c     apply bond constraints
+          
+          viracc=0.d0
+          if(ntcons.gt.0)call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     apply pmf constraints
+          
+          viracc=0.d0
+          if(ntpmf.gt.0)call pmf_shake
+     x      (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,
+     x      viracc,xxt,yyt,zzt,strcon,summas,dxp,dyp,dzp,
+     x      xxa,yya,zza)
+          
+          virpmf=virpmf+viracc
+          do i=1,9
+            strpmf(i)=strpmf(i)+strcon(i)
+          enddo
+          
+          unsafe=(.not.(safe.and.safep.and.abs(viracc).lt.1.d-10))
+          
+        enddo
+        
+        safep=.not.unsafe
+        
+c     calculate velocity correction
+        
+        j=0
+        rstep=1.d0/tstep
+        do i=iatm0,iatm1
+          
+c     update corrected velocity
+          
+          j=j+1
+          uxx(i)=(xxx(i)-xxo(j))*rstep
+          uyy(i)=(yyy(i)-yyo(j))*rstep
+          uzz(i)=(zzz(i)-zzo(j))*rstep
+          
+c     calculate the corrected forces
+          
+          fxx(i)=(uxx(i)-vxx(i))*weight(i)*rstep
+          fyy(i)=(uyy(i)-vyy(i))*weight(i)*rstep
+          fzz(i)=(uzz(i)-vzz(i))*weight(i)*rstep
+          
+        enddo
+        
+      endif
+      
+c     calculate velocity at full time step
+      
+      do i=iatm0,iatm1
+        
+        vxx(i)=0.5d0*(vxx(i)+uxx(i))
+        vyy(i)=0.5d0*(vyy(i)+uyy(i))
+        vzz(i)=0.5d0*(vzz(i)+uzz(i))
+        
+      enddo
+      
+c     calculate kinetic energy
+      
+      engke=getkin(natms,idnode,mxnode)
+      
+c     kinetic contribution to stress tensor
+      
+      call kinstress(natms,idnode,mxnode,strkin)
+      
+c     total contributions to stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strpmf(i)+strcns(i)+strkin(i)
+      enddo
+      
+c     add pmf and constraint virials
+      
+      vircon=vircon+virpmf
+      
+c     restore half step velocity
+      
+      do i=iatm0,iatm1
+        
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+      
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate(dxx,dyy,dzz,xxt,yyt,zzt,stat=fail(1))
+      deallocate(uxx,uyy,uzz,dxp,dyp,dzp,stat=fail(2))
+      deallocate(txx,tyy,tzz,xxo,yyo,zzo,stat=fail(3))
+      deallocate(dxt,dyt,dzt,xxa,yya,zza,stat=fail(4))
+      
+      return
+      end subroutine pmflf
+      
+      subroutine pmflfq_1
+     x  (safe,safeq,lshmov,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,quattol,tolnce,tstep,vircom,
+     x  vircon,safep,nspmf,ntpmf,virpmf)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using implicit leapfrog quaternion algorithm
+c     plus bond constraints - PROVIDED rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     parallel replicated data version : block data
+c     
+c     tqx,tqy,tqz = torque in lab fixed frame
+c     omx,omy,omz = angular velocity in body fixed frame (principal axis)
+c     rotinx,y,z  = rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory 1993
+c     author      t.forester october 1993
+c     amended     t.forester dec 1994 : block data
+c     amended     w.smith sep 1999 : euler equation
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=14
+      real(8), parameter :: pt5=0.5d0
+      
+      logical safe,safeq,lshmov,newjob,safep,unsafe,img
+      integer imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer fail,i,igrp,igrp1,igrp2,idum,ifre1,ifre2,j,ifre
+      integer jg,ig,k,id,jr,nspmf,ntpmf,jj,ii,ipmf,icyc
+      real(8) engke,engrot,quattol,tolnce,tstep,vircom,vircon
+      real(8) strkin,rot,rstep,rtsq,engtrn,vaa,vbb,vcc,virpmf
+      real(8) trx,try,trz,delx,dely,delz,engfke,viracc
+      real(8) strgrp,tqx,tqy,tqz,fmx,fmy,fmz
+      real(8) strpmf,strcon,summas
+      
+      real(8), allocatable :: opx(:),opy(:),opz(:)
+      real(8), allocatable :: oqx(:),oqy(:),oqz(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xx1(:),yy1(:),zz1(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: gcxo(:),gcyo(:),gczo(:)
+      
+      
+      real(8), allocatable :: xxa(:,:),yya(:,:),zza(:,:)
+      real(8), allocatable :: dxp(:),dyp(:),dzp(:)
+      
+      dimension strkin(9),strgrp(9),rot(9),fail(nnn)
+      
+      dimension strpmf(9),strcon(9),summas(2)
+      
+      save igrp1,igrp2,ifre1,ifre2
+      
+      data newjob/.true./
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (opx(msgrp),opy(msgrp),opz(msgrp),stat=fail(1))
+      allocate (oqx(msgrp),oqy(msgrp),oqz(msgrp),stat=fail(2))
+      allocate (dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(3))
+      allocate (dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(5))
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(8))
+      allocate (xxo(msatms),yyo(msatms),zzo(msatms),stat=fail(9))
+      allocate (xx1(msatms),yy1(msatms),zz1(msatms),stat=fail(10))
+      allocate (vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(11))
+      allocate (gcxo(msgrp),gcyo(msgrp),gczo(msgrp),stat=fail(12))
+      
+      allocate(xxa(2,mspmf),yya(2,mspmf),zza(2,mspmf),stat=fail(13))
+      allocate(dxp(mspmf),dyp(mspmf),dzp(mspmf),stat=fail(14))
+      
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1500)
+      enddo
+      
+      if(newjob)then
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe) then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        newjob=.false.
+        
+      endif
+      
+      safe=.false.
+      
+c     constraint virials
+      
+      vircon=0.d0
+      virpmf=0.d0
+      
+c     temporary stress tensor accumulators
+      
+      do i=1,9
+        
+        strcns(i)=0.d0
+        strpmf(i)=0.d0
+        
+      enddo
+      
+c     store initial values of position and velocity
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        xxo(j)=xxx(i)
+        yyo(j)=yyy(i)
+        zzo(j)=zzz(i)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        gcxo(jg)=gcmx(ig)
+        gcyo(jg)=gcmy(ig)
+        gczo(jg)=gcmz(ig)
+        
+      enddo
+      
+c     construct current bond vectors
+      
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+      
+c     periodic boundary condition for bond vectors
+      
+      call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+      
+c     calculate mass terms for PMF units
+      
+      jj=0
+      do ipmf=1,2
+        
+        summas(ipmf)=0.d0
+        pmfnrm(ipmf)=0.d0
+        
+        do i=1,npmf(ipmf)
+          
+          jj=jj+1
+          ii=lstpmf(jj,1)
+          summas(ipmf)=summas(ipmf)+weight(ii)
+          pmfnrm(ipmf)=pmfnrm(ipmf)+pmfwght(jj)
+          
+        enddo
+        
+      enddo
+      
+c     calculate PMF bond constraints and store initial positions
+      
+      img=.true.
+      call pmf_vectors
+     x  (img,nspmf,imcon,cell,xxx,yyy,zzz,xxt,yyt,zzt,
+     x  xxa,yya,zza,dxp,dyp,dzp)
+      
+c     move atoms by leapfrog algorithm
+      
+      safe=(ntcons.eq.0)
+      safep=(ntpmf.eq.0)
+      
+c     calculate atom displacements from rigid body com
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcxo(jg)
+          dty(jr)=yyy(i)-gcyo(jg)
+          dtz(jr)=zzz(i)-gczo(jg)
+          
+        enddo
+        
+      enddo
+      
+c     minimum images
+      
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     integrate 'free' particles
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        
+c     advance velocity by leapfrog
+        
+        uxx(i)=vxo(j)+tstep*rmass(i)*fxx(i)
+        uyy(i)=vyo(j)+tstep*rmass(i)*fyy(i)
+        uzz(i)=vzo(j)+tstep*rmass(i)*fzz(i)
+        
+c     advance position by leapfrog
+        
+        xxx(i)=xxo(j)+tstep*uxx(i)
+        yyy(i)=yyo(j)+tstep*uyy(i)
+        zzz(i)=zzo(j)+tstep*uzz(i)
+        
+      enddo
+      
+      if(ntcons.gt.0.or.ntpmf.gt.0) then
+        
+c     store integrated positions
+        
+        j=0
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          j=j+1
+          xx1(j)=xxx(i)
+          yy1(j)=yyy(i)
+          zz1(j)=zzz(i)
+          
+        enddo
+        
+c     global exchange of configuration data
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        
+c     apply constraint corrections - iteratively
+        
+        icyc=0
+        unsafe=.true.
+        
+        do while(unsafe.and.icyc.lt.mxshak)
+          
+          icyc=icyc+1
+          
+c     apply bond constraints
+          
+          viracc=0.d0
+          if(ntcons.gt.0)call rdshake_1
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcon)
+          
+          vircon=vircon+viracc
+          do i=1,9
+            strcns(i)=strcns(i)+strcon(i)
+          enddo
+          
+c     apply pmf constraints
+          
+          viracc=0.d0
+          if(ntpmf.gt.0)call pmf_shake
+     x      (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,
+     x      viracc,xxt,yyt,zzt,strcon,summas,dxp,dyp,dzp,
+     x      xxa,yya,zza)
+          
+          virpmf=virpmf+viracc
+          do i=1,9
+            strpmf(i)=strpmf(i)+strcon(i)
+          enddo
+          
+          unsafe=(.not.(safe.and.safep.and.abs(viracc).lt.1.d-10))
+          
+        enddo
+        
+        safep=.not.unsafe
+        
+c     calculate force and velocity corrections
+        
+        j=0
+        rstep=1.d0/tstep
+        rtsq=1.d0/tstep**2
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          
+c     calculate force correction
+          
+          fxx(i)=fxx(i)+(xxx(i)-xx1(j))*weight(i)*rtsq
+          fyy(i)=fyy(i)+(yyy(i)-yy1(j))*weight(i)*rtsq
+          fzz(i)=fzz(i)+(zzz(i)-zz1(j))*weight(i)*rtsq
+          
+c     calculate velocity correction
+          
+          uxx(i)=uxx(i)+(xxx(i)-xx1(j))*rstep
+          uyy(i)=uyy(i)+(yyy(i)-yy1(j))*rstep
+          uzz(i)=uzz(i)+(zzz(i)-zz1(j))*rstep
+          
+        enddo
+        
+c     end of shake corrections
+        
+      endif
+      
+c     estimate full step velocity
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        
+        vxx(i)=0.5d0*(uxx(i)+vxo(j))
+        vyy(i)=0.5d0*(uyy(i)+vyo(j))
+        vzz(i)=0.5d0*(uzz(i)+vzo(j))
+        
+      enddo
+      
+c     calculate new kinetic energy at current timestep
+      
+      engfke=getkinf(ntfree,idnode,mxnode)
+      
+c     kinetic contribution to stress tensor
+      
+      call kinstressf(ntfree,idnode,mxnode,strkin)
+      
+c     restore free atom half step velocity
+      
+      do ifre=ifre1,ifre2
+        
+        i=lstfre(ifre)
+        vxx(i)=uxx(i)
+        vyy(i)=uyy(i)
+        vzz(i)=uzz(i)
+        
+      enddo
+      
+c     *************  Rigid body motion ****************************
+      
+c     translational rigid body motion
+      
+      jg=0
+      jr=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+c     calculate net force on rigid body
+        
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+          
+        enddo
+        
+c     advance velocity by leapfrog
+        
+        uxx(ig)=gvxx(ig)+fmx*tstep/gmass(id)
+        uyy(ig)=gvyy(ig)+fmy*tstep/gmass(id)
+        uzz(ig)=gvzz(ig)+fmz*tstep/gmass(id)
+        
+c     advance position by leapfrog
+        
+        gcmx(ig)=gcmx(ig)+tstep*uxx(ig)
+        gcmy(ig)=gcmy(ig)+tstep*uyy(ig)
+        gcmz(ig)=gcmz(ig)+tstep*uzz(ig)
+        
+c     estimate velocity at full time step
+        
+        gvxx(ig)=0.5d0*(gvxx(ig)+uxx(ig))
+        gvyy(ig)=0.5d0*(gvyy(ig)+uyy(ig))
+        gvzz(ig)=0.5d0*(gvzz(ig)+uzz(ig))
+        
+      enddo
+      
+c     calculate rigid body translational kinetic energy
+      
+      engtrn=getkint(ngrp,idnode,mxnode)
+      
+c     total translational kinetic energy
+      
+      engke=engtrn+engfke
+      
+c     calculate ridid body kinetic stress tensor
+      
+      call kinstressg(ngrp,idnode,mxnode,strgrp)
+      
+c     restore rigid body half timestep velocity
+      
+      do ig=igrp1,igrp2
+        
+        gvxx(ig)=uxx(ig)
+        gvyy(ig)=uyy(ig)
+        gvzz(ig)=uzz(ig)
+        
+      enddo
+      
+c     calculate rigid body contribution to stress tensor
+      
+      call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+      
+c     calculate torques in lab frame
+      
+      jr=0
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        id=lstgtp(ig)
+        
+        tqx=0.d0
+        tqy=0.d0
+        tqz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          tqx=tqx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          tqy=tqy+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          tqz=tqz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+        
+c     current rotational matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+c     store current angular velocity
+        
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+        
+c     iterate angular velocity for time step n (e. yezdimer)
+        
+        do i=1,5
+          
+          trx=(tqx*rot(1)+tqy*rot(4)+tqz*rot(7))*rotinx(id,2)
+     x      +(rotiny(id,1)-rotinz(id,1))*opy(jg)*opz(jg)*rotinx(id,2)
+          try=(tqx*rot(2)+tqy*rot(5)+tqz*rot(8))*rotiny(id,2)
+     x      +(rotinz(id,1)-rotinx(id,1))*opz(jg)*opx(jg)*rotiny(id,2)
+          trz=(tqx*rot(3)+tqy*rot(6)+tqz*rot(9))*rotinz(id,2)
+     x      +(rotinx(id,1)-rotiny(id,1))*opx(jg)*opy(jg)*rotinz(id,2)
+          
+          delx=tstep*trx
+          dely=tstep*try
+          delz=tstep*trz
+          
+c     improved angular velocity at time step n
+          
+          opx(jg)=omx(ig)+delx*pt5
+          opy(jg)=omy(ig)+dely*pt5
+          opz(jg)=omz(ig)+delz*pt5
+          
+        enddo
+        
+c     angular velocity at time step n+1/2
+        
+        uxx(ig)=omx(ig)+delx
+        uyy(ig)=omy(ig)+dely
+        uzz(ig)=omz(ig)+delz
+        
+c     angular velocity at time step n+1  (needed for quat algorithm)
+        
+        oqx(jg)=omx(ig)+delx*1.5d0
+        oqy(jg)=omy(ig)+dely*1.5d0
+        oqz(jg)=omz(ig)+delz*1.5d0
+        
+c     angular velocity at timestep n
+        
+        omx(ig)=omx(ig)+pt5*delx
+        omy(ig)=omy(ig)+pt5*dely
+        omz(ig)=omz(ig)+pt5*delz
+        
+      enddo
+      
+c     rotational kinetic energy
+      
+      engrot=getkinr(ngrp,idnode,mxnode)
+      
+c     restore half step angular velocity
+      
+      jg=0
+      do ig=igrp1,igrp2
+        
+        jg=jg+1
+        opx(jg)=omx(ig)
+        opy(jg)=omy(ig)
+        opz(jg)=omz(ig)
+        omx(ig)=uxx(ig)
+        omy(ig)=uyy(ig)
+        omz(ig)=uzz(ig)
+        
+      enddo
+      
+c     assign new quaternions
+      
+      call update_quaternions
+     x  (safeq,igrp1,igrp2,tstep,quattol,opx,opy,opz,oqx,oqy,oqz)
+      
+c     complete stress tensor
+      
+      do i=1,9
+        stress(i)=stress(i)+strkin(i)+strgrp(i)+strcns(i)+strbod(i)+
+     x    strpmf(i)
+      enddo
+      
+c     add pmf and constraint virials
+      
+      vircon=vircon+virpmf
+      
+c     minimum images of group positions and particle positions
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+      
+c     new atomic positions for atoms in rigid bodies - relative to c.o.m
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+c     new rotational matrix
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x      +gcmx(ig)
+          yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x      +gcmy(ig)
+          zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x      +gcmz(ig)
+          
+c     new atomic velocites in body frame
+          
+          vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+          
+c     new atomic velocites in lab frame
+          
+          vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+          vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+          vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+          
+        enddo
+        
+      enddo
+      
+      if(mxnode.gt.1) then
+        
+c     merge new group coordinates and velocities
+        
+        call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+      
+c     ensure all atoms are within cell boundaries
+      
+      call images(imcon,0,1,natms,cell,xxx,yyy,zzz)
+      
+c     deallocate work arrays
+      
+      deallocate(opx,opy,opz,xxt,yyt,zzt,stat=fail(1))
+      deallocate(oqx,oqy,oqz,dtx,dty,dtz,stat=fail(2))
+      deallocate(dxx,dyy,dzz,uxx,uyy,uzz,stat=fail(3))
+      deallocate(txx,tyy,tzz,dxt,dyt,dzt,stat=fail(4))
+      deallocate(xxo,yyo,zzo,xx1,yy1,zz1,stat=fail(5))
+      deallocate(vxo,vyo,vzo,gcxo,gcyo,gczo,stat=fail(6))
+      deallocate(dxp,dyp,dzp,xxa,yya,zza,stat=fail(7))
+      
+      return
+      end subroutine pmflfq_1
+      
+      subroutine pmf_shake
+     x  (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,
+     x  virpmf,xxt,yyt,zzt,strpmf,summas,dxp,dyp,dzp,
+     x  xxa,yya,zza)
+      
+c***********************************************************************
+c     
+c     dlpoly constraint subroutine for potential of mean force calc.
+c     accummulates constraint force to maintain reaction coordinate
+c     
+c     assume bond vectors dxp,dyp,dzp are input
+c     dxp=(sum) wght*xxx(i,1) - (sum) wght*xxx(j,2) etc
+c     
+c     copyright daresbury laboratory 1995
+c     author t.forester august 1995
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safep,img
+      integer idnode,mxnode,imcon,natms,nspmf,fail,icyc,k,jj
+      integer ii,i,ipmf
+      real(8) tstep,tolnce,virpmf,xxt,yyt,zzt,strpmf,summas
+      real(8) dxp,dyp,dzp,xxa,yya,zza,amt,strs1,strs2,strs3,strs5
+      real(8) strs6,strs9,tstep2,dis,omega2,eps,gamma,gammi
+      
+      dimension dxp(mspmf),dyp(mspmf),dzp(mspmf)
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension xxa(2,mspmf),yya(2,mspmf),zza(2,mspmf)
+      dimension amt(2),strpmf(9),summas(2)
+      
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:),dsq(:)
+      data fail/0/
+      
+c     allocate work arrays
+      
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),dsq(mspmf),
+     x  stat=fail)
+      if(fail.ne.0)call error(idnode,1230)
+      
+      if(mxcons.lt.nspmf) call error(idnode,492)
+      if(mspmf .lt.nspmf) call error(idnode,458)
+      
+c     timestep squared
+      
+      tstep2=tstep*tstep
+      
+c     accumulators for strpmf tensor
+      
+      virpmf=0.d0
+      strs1=0.d0
+      strs2=0.d0
+      strs3=0.d0
+      strs5=0.d0
+      strs6=0.d0
+      strs9=0.d0
+      
+c     application of constraint (shake) algorithm
+      
+      icyc=0
+      safep=.false.
+      
+      do while(.not.safep.and.icyc.lt.mxshak)
+        
+        icyc=icyc+1
+        
+c     calculate bond constraint length
+        
+        img=.true.
+        call pmf_vectors
+     x    (img,nspmf,imcon,cell,xxx,yyy,zzz,xxt,yyt,zzt,
+     x    xxa,yya,zza,dxt,dyt,dzt)
+        
+        amt(1)= tstep2/summas(1)
+        amt(2)=-tstep2/summas(2)
+        
+        eps=0.d0
+        dis=prmpmf
+        omega2=dis*dis
+        
+        do k=1,nspmf
+          
+          dsq(k)=dxt(k)**2+dyt(k)**2+dzt(k)**2
+          eps=max(eps,abs((omega2-dsq(k))/(2.0d0*dis)))
+          
+        enddo
+        
+c     check convergence condition
+        
+        safep=(eps.le.tolnce)
+        
+c     bypass calculations if converged
+        
+        if(.not.safep)then
+          
+          do k=1,nspmf
+            
+            gamma=(omega2-dsq(k))/(-2.d0*(amt(2)-amt(1))*
+     x        (dxp(k)*dxt(k)+dyp(k)*dyt(k)+dzp(k)*dzt(k)))
+            
+c     accumulate pmf virial
+            
+            virpmf=virpmf+gamma*(dxp(k)**2+dyp(k)**2+dzp(k)**2)
+            
+            strs1=strs1-gamma*dxp(k)*dxp(k)
+            strs2=strs2-gamma*dxp(k)*dyp(k)
+            strs3=strs3-gamma*dxp(k)*dzp(k)
+            strs5=strs5-gamma*dyp(k)*dyp(k)
+            strs6=strs6-gamma*dyp(k)*dzp(k)
+            strs9=strs9-gamma*dzp(k)*dzp(k)
+            
+c     improve approximate atomic positions
+            
+            jj=0
+            do ipmf=1,2
+              
+              gammi=-gamma*amt(ipmf)
+              
+              do ii=1,npmf(ipmf)
+                
+                jj=jj+1
+                i=lstpmf(jj,k)
+                
+                xxx(i)=xxx(i)+dxp(k)*gammi
+                yyy(i)=yyy(i)+dyp(k)*gammi
+                zzz(i)=zzz(i)+dzp(k)*gammi
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+        endif
+        
+      enddo
+      
+c     complete strpmf tensor
+      
+      strpmf(1)=strs1
+      strpmf(2)=strs2
+      strpmf(3)=strs3
+      strpmf(4)=strs2
+      strpmf(5)=strs5
+      strpmf(6)=strs6
+      strpmf(7)=strs3
+      strpmf(8)=strs6
+      strpmf(9)=strs9
+      
+c     splice coordinate arrays across nodes
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=virpmf
+        call gdsum(buffer(1),1,buffer(2))
+        virpmf=buffer(1)
+        call gdsum(strpmf,9,buffer)
+        call splice 
+     x    (idnode,natms,listpm,lstpmt,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate(dxt,dyt,dzt,dsq,stat=fail)
+      
+      return
+      end subroutine pmf_shake
+      
+      subroutine pmfvv
+     x  (safe,safep,lshmov,isw,idnode,mxnode,imcon,natms,nscons,
+     x  ntcons,nspmf,ntpmf,engke,tolnce,tstep,vircon,virpmf)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics. Velocity Verlet With PMF_RATTLE
+c     for potential of mean force calculations.
+c     
+c     copyright - daresbury laboratory
+c     adapted by w.smith october 2005
+c     original by t.forester aug 1995
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=7
+      
+      logical safe,lshmov,safep,unsafe,newjob,img
+      integer idnode,imcon,mxnode,natms,nscons,ntcons,nspmf,ntpmf
+      integer isw,mxtop
+      integer fail,iatm0,iatm1,i,j,k,jj,i1,ipmf,icyc
+      real(8) engke,tolnce,tstep,vircon,virpmf,strcon,summas
+      real(8) viracc,strpmf,strkin
+      
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxp(:),dyp(:),dzp(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxa(:,:),yya(:,:),zza(:,:)
+      
+      dimension strcon(9),strpmf(9),strkin(9),summas(2),fail(nnn)
+      save summas,newjob,strpmf
+      data newjob/.true./
+      
+c     set default safety flags
+      
+      safe=(ntcons.eq.0)
+      safep=(ntpmf.eq.0)
+      if(safe.and.safep)return
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      mxtop=max(mxcons,mspmf)
+      allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(1))
+      allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(2))
+      allocate(dxp(mspmf),dyp(mspmf),dzp(mspmf),stat=fail(3))
+      allocate(dxt(mxtop),dyt(mxtop),dzt(mxtop),stat=fail(4))
+      allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+      allocate(xxa(2,mspmf),yya(2,mspmf),zza(2,mspmf),stat=fail(6))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1220)
+      enddo
+      
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     calculate mass terms for PMF units
+      
+      if(newjob)then
+        
+        jj=0
+        do ipmf=1,2
+          
+          summas(ipmf)=0.d0
+          pmfnrm(ipmf)=0.d0
+          
+          do i=1,npmf(ipmf)
+            
+            jj=jj+1
+            i1=lstpmf(jj,1)
+            summas(ipmf)=summas(ipmf)+weight(i1)
+            pmfnrm(ipmf)=pmfnrm(ipmf)+pmfwght(jj)
+            
+          enddo
+          
+        enddo
+        
+        newjob=.false.
+        
+      endif
+      
+c     construct current bond vectors
+      
+      do k=1,nscons
+        
+c     indices of atoms in bond
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+        
+c     calculate current bond vector
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+      
+c     periodic boundary condition for bond vectors
+      
+      call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+      
+c     calculate PMF bond constraints and store initial positions
+      
+      img=.true.
+      call pmf_vectors
+     x  (img,nspmf,imcon,cell,xxx,yyy,zzz,xxt,yyt,zzt,xxa,yya,zza,
+     x  dxp,dyp,dzp)
+      
+c     update velocities
+      
+      do i=iatm0,iatm1
+        
+        vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+        
+      enddo
+      
+      if(mxnode.gt.1)
+     x  call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+      
+      if(isw.eq.1)then
+        
+c     constraint virials
+        
+        vircon=0.d0
+        virpmf=0.d0
+        
+c     temporary stress tensor accumulators
+        
+        do i=1,9
+          
+          strcns(i)=0.d0
+          strpmf(i)=0.d0
+          
+        enddo
+        
+c     update positions
+        
+        do i=iatm0,iatm1
+          
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+        
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     apply constraint corrections - iteratively
+      
+      icyc=0
+      unsafe=.true.
+      
+      do while(unsafe.and.icyc.lt.mxshak)
+        
+        icyc=icyc+1
+        
+        if(isw.eq.1)then
+          
+c     apply bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,viracc,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcon)
+            
+            vircon=vircon+viracc
+            do i=1,9
+              strcns(i)=strcns(i)+strcon(i)
+            enddo
+            
+          endif
+          
+c     apply pmf constraints
+          
+          if(ntpmf.gt.0)then
+            
+            safep=.false.
+            call pmf_rattle_r
+     x        (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,
+     x        viracc,summas,xxt,yyt,zzt,xxa,yya,zza,dxp,dyp,dzp,
+     x        dxt,dyt,dzt,strcon)
+            
+            virpmf=virpmf+viracc
+            do i=1,9
+              strpmf(i)=strpmf(i)+strcon(i)
+            enddo
+            
+          endif
+          
+          unsafe=(.not.(safe.and.safep.and.abs(viracc).le.1.d-10))
+          
+        endif
+        
+        if(isw.eq.2)then
+          
+c     apply rattle velocity constraints
+          
+          if(ntcons.gt.0)then
+            
+            safe=.false.
+            call rdrattle_v
+     x        (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x        dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+            
+          endif
+          
+c     apply pmf velocity constraints
+          
+          if(ntpmf.gt.0)then
+            
+            safep=.false.
+            call pmf_rattle_v
+     x        (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,
+     x        summas,dxp,dyp,dzp,xxt,yyt,zzt,xxa,yya,zza,dxt,dyt,dzt)
+            
+          endif
+          
+          unsafe=(.not.(safe.and.safep))
+          
+        endif
+        
+      enddo
+      
+      safep=(.not.unsafe)
+      
+c     periodic boundary condition
+      
+      if(isw.eq.1)call images
+     x  (imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+      
+      if(isw.eq.2)then
+        
+c     calculate kinetic energy
+        
+        engke=getkin(natms,idnode,mxnode)
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        
+c     total contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strpmf(i)+strcns(i)+strkin(i)
+        enddo
+        
+c     add pmf and constraint virials
+        
+        vircon=vircon+virpmf
+        
+      endif
+      
+c     global exchange of configuration data
+      
+      if(mxnode.gt.1)then
+        
+        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+        if(isw.eq.1)call merge
+     x    (idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        if(ntcons.gt.0)call merge
+     x    (idnode,mxnode,natms,mxbuff,fxx,fyy,fzz,buffer)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      deallocate(dxx,dyy,dzz,xxt,yyt,zzt,stat=fail(1))
+      deallocate(dxp,dyp,dzp,dxt,dyt,dzt,stat=fail(2))
+      deallocate(txx,tyy,tzz,xxa,yya,zza,stat=fail(3))
+      
+      return
+      end subroutine pmfvv
+      
+      subroutine pmf_rattle_r
+     x  (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,
+     x  virpmf,summas,xxt,yyt,zzt,xxa,yya,zza,dxp,dyp,dzp,
+     x  dxt,dyt,dzt,strpmf)
+      
+c***********************************************************************
+c     
+c     dlpoly constraint subroutine for potential of mean force calc.
+c     accumulates constraint force to maintain reaction coordinate.
+c     velocity verlet adaptation
+c     
+c     assume bond vectors dxp,dyp,dzp are input
+c     dxp=(sum) wght*xxx(i,1) - (sum) wght*xxx(j,2) etc
+c     
+c     copyright daresbury laboratory
+c     adapted by w.smith october 2005
+c     original t.forester august 1995
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safep,img
+      integer idnode,mxnode,imcon,natms,nspmf,icyc,k,jj
+      integer i1,i,ipmf
+      real(8) tstep,tolnce,virpmf,xxt,yyt,zzt,strpmf,summas,gamma
+      real(8) dxp,dyp,dzp,xxa,yya,zza,amt,tstep2,dis,omega2,eps,gammi
+      real(8) strs1,strs2,strs3,strs5,strs6,strs9,dxt,dyt,dzt,dsq
+      
+      dimension dxp(mspmf),dyp(mspmf),dzp(mspmf)
+      dimension dxt(mxcons),dyt(mxcons),dzt(mxcons)
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension xxa(2,mspmf),yya(2,mspmf),zza(2,mspmf)
+      dimension amt(2),strpmf(9),summas(2)
+      
+c     timestep squared
+      
+      tstep2=tstep*tstep
+      
+c     pmf virial
+      
+      virpmf=0.d0
+      
+c     accumulators for stress tensor
+      
+      strs1=0.d0
+      strs2=0.d0
+      strs3=0.d0
+      strs5=0.d0
+      strs6=0.d0
+      strs9=0.d0
+      
+c     array bound check
+      
+      if(mxcons.lt.nspmf) call error(idnode,492)
+      if(mspmf .lt.nspmf) call error(idnode,458)
+      
+c     application of constraint (shake) algorithm
+      
+      icyc=0
+      img=.true.
+      safep=.false.
+      dis=prmpmf
+      omega2=dis*dis
+      amt(1)= tstep2/summas(1)
+      amt(2)=-tstep2/summas(2)
+      
+      do while(.not.safep.and.icyc.lt.mxshak)
+        
+        icyc=icyc+1
+        
+        call pmf_vectors
+     x    (img,nspmf,imcon,cell,xxx,yyy,zzz,xxt,yyt,zzt,xxa,yya,zza,
+     x    dxt,dyt,dzt)
+        
+c     check convergence
+        
+        eps=0.d0
+        
+        do k=1,nspmf
+          
+          dsq=dxt(k)**2+dyt(k)**2+dzt(k)**2
+          eps=max(eps,abs((omega2-dsq)/dis))
+          
+        enddo
+        
+        eps=eps*0.5d0
+        
+c     verification of convergence
+        
+        safep=(eps.lt.tolnce)
+        
+c     bypass calculations if converged
+        
+        if(.not.safep)then
+          
+          do k=1,nspmf
+            
+            dsq=dxt(k)**2+dyt(k)**2+dzt(k)**2
+            gamma=(omega2-dsq)/(-(amt(2)-amt(1))*
+     x        (dxp(k)*dxt(k)+dyp(k)*dyt(k)+dzp(k)*dzt(k)))
+            
+c     accumulate pmf virial
+            
+            virpmf=virpmf+gamma*(dxp(k)**2+dyp(k)**2+dzp(k)**2)
+            
+            strs1=strs1-gamma*dxp(k)*dxp(k)
+            strs2=strs2-gamma*dxp(k)*dyp(k)
+            strs3=strs3-gamma*dxp(k)*dzp(k)
+            strs5=strs5-gamma*dyp(k)*dyp(k)
+            strs6=strs6-gamma*dyp(k)*dzp(k)
+            strs9=strs9-gamma*dzp(k)*dzp(k)
+            
+c     improve approximate atomic positions and velocities
+            
+            jj=0
+            do ipmf=1,2
+              
+              gammi=-0.5d0*gamma*amt(ipmf)
+              
+              do i1=1,npmf(ipmf)
+                
+                jj=jj+1
+                i=lstpmf(jj,k)
+                
+                xxx(i)=xxx(i)+dxp(k)*gammi
+                yyy(i)=yyy(i)+dyp(k)*gammi
+                zzz(i)=zzz(i)+dzp(k)*gammi
+                vxx(i)=vxx(i)+dxp(k)*gammi/tstep
+                vyy(i)=vyy(i)+dyp(k)*gammi/tstep
+                vzz(i)=vzz(i)+dzp(k)*gammi/tstep
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      strpmf(1)=strs1
+      strpmf(2)=strs2
+      strpmf(3)=strs3
+      strpmf(4)=strs2
+      strpmf(5)=strs5
+      strpmf(6)=strs6
+      strpmf(7)=strs3
+      strpmf(8)=strs6
+      strpmf(9)=strs9
+      
+c     splice coordinate and velocity arrays across nodes
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=virpmf
+        call gdsum(buffer(1),1,buffer(2))
+        virpmf=buffer(1)
+        call gdsum(strpmf,9,buffer)
+        call splice 
+     x    (idnode,natms,listpm,lstpmt,xxx,yyy,zzz,buffer)
+        call splice 
+     x    (idnode,natms,listpm,lstpmt,vxx,vyy,vzz,buffer)
+        
+      endif
+      
+      return
+      end subroutine pmf_rattle_r
+      
+      subroutine pmf_rattle_v
+     x  (safep,idnode,mxnode,imcon,natms,nspmf,tstep,tolnce,summas,
+     x  dxp,dyp,dzp,vxt,vyt,vzt,vxa,vya,vza,vxp,vyp,vzp)
+      
+c***********************************************************************
+c     
+c     dlpoly constraint subroutine for potential of mean force calc.
+c     accumulates velocity correction for second constraint condition
+c     velocity verlet adaptation
+c     
+c     assume bond vectors dxp,dyp,dzp are input
+c     dxp=(sum) wght*xxx(i,1) - (sum) wght*xxx(j,2) etc
+c     
+c     copyright daresbury laboratory
+c     author w.smith october 2005
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safep,img
+      integer idnode,mxnode,imcon,natms,nspmf,icyc,k,jj
+      integer i1,i,ipmf
+      real(8) tstep,tolnce,summas,gamma,vxt,vyt,vzt,vxa,vya,vza
+      real(8) vxp,vyp,vzp,dxp,dyp,dzp,amt,omega,eps,gammi,tolvel
+      
+      dimension dxp(mspmf),dyp(mspmf),dzp(mspmf)
+      dimension vxp(mspmf),vyp(mspmf),vzp(mspmf)
+      dimension vxt(mxatms),vyt(mxatms),vzt(mxatms)
+      dimension vxa(2,mspmf),vya(2,mspmf),vza(2,mspmf)
+      dimension amt(2),summas(2)
+      
+c     constraint convergence tolerance
+      
+      tolvel=tolnce/tstep
+      
+c     array bound check
+      
+      if(mxcons.lt.nspmf) call error(idnode,492)
+      if(mspmf .lt.nspmf) call error(idnode,458)
+      
+c     application of constraint (shake) algorithm
+      
+      icyc=0
+      img=.false.
+      safep=.false.
+      amt(1)= 0.5d0*tstep/summas(1)
+      amt(2)=-0.5d0*tstep/summas(2)
+      
+      do while(.not.safep.and.icyc.lt.mxshak)
+        
+        icyc=icyc+1
+        
+        call pmf_vectors
+     x    (img,nspmf,imcon,cell,vxx,vyy,vzz,vxt,vyt,vzt,vxa,vya,vza,
+     x    vxp,vyp,vzp)
+        
+c     check convergence
+        
+        eps=0.d0
+        do k=1,nspmf
+          
+          omega=dxp(k)*vxp(k)+dyp(k)*vyp(k)+dzp(k)*vzp(k)
+          eps=max(eps,abs(omega)/prmpmf)
+          
+        enddo
+        
+c     verification of convergence
+        
+        safep=(eps.lt.tolvel)
+        
+c     bypass calculations if converged
+        
+        if(.not.safep)then
+          
+          do k=1,nspmf
+            
+            omega=dxp(k)*vxp(k)+dyp(k)*vyp(k)+dzp(k)*vzp(k)
+            gamma=omega/((amt(2)-amt(1))*
+     x        (dxp(k)**2+dyp(k)**2+dzp(k)**2))
+            
+c     improve approximate atomic velocities
+            
+            jj=0
+            do ipmf=1,2
+              
+              gammi=-gamma*amt(ipmf)
+              
+              do i1=1,npmf(ipmf)
+                
+                jj=jj+1
+                i=lstpmf(jj,k)
+                
+                vxx(i)=vxx(i)+dxp(k)*gammi
+                vyy(i)=vyy(i)+dyp(k)*gammi
+                vzz(i)=vzz(i)+dzp(k)*gammi
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+        endif
+        
+      enddo
+      
+c     splice velocity arrays across nodes
+      
+      if(mxnode.gt.1)call splice 
+     x  (idnode,natms,listpm,lstpmt,vxx,vyy,vzz,buffer)
+      
+      return
+      end subroutine pmf_rattle_v
+      
+      end module pmf_module
diff -urN dl_class_1.9.orig/srcmod/property_module.f dl_class_1.9/srcmod/property_module.f
--- dl_class_1.9.orig/srcmod/property_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/property_module.f	2014-02-27 13:49:34.000000000 +0100
@@ -0,0 +1,1318 @@
+      module property_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining simulation property data
+c     copyright - daresbury laboratory
+c     author    - w. smith    nov 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use pair_module
+      use setup_module
+      use site_module
+      use tether_module
+      use utility_module
+      use vdw_module
+
+      implicit none
+
+      real(8), allocatable :: rdf(:,:),zdens(:,:)
+      real(8), allocatable :: stpval(:),sumval(:)
+      real(8), allocatable :: ssqval(:),zumval(:)
+      real(8), allocatable :: ravval(:),stkval(:,:)
+      real(8), allocatable :: xx0(:),yy0(:),zz0(:)
+      real(8), allocatable :: amsd(:)
+
+      save rdf,zdens,stpval,sumval,ssqval,xx0,yy0,zz0
+      save zumval,ravval,stkval
+
+      contains
+      
+      subroutine alloc_prp_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=6
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (zdens(mxzdn,mxatyp),stat=fail(1))
+      allocate (rdf(mxrdf,mxxtyp),amsd(mxatyp),stat=fail(2))
+      allocate (stpval(mxnstk),sumval(mxnstk),stat=fail(3))
+      allocate (ssqval(mxnstk),zumval(mxnstk),stat=fail(4))
+      allocate (ravval(mxnstk),stkval(mxstak,mxnstk),stat=fail(5))
+      allocate (xx0(mxatms),yy0(mxatms),zz0(mxatms),stat=fail(6))
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1740)
+      enddo
+
+      end subroutine alloc_prp_arrays
+
+      subroutine result
+     x  (ltad,lbpd,lgofr,lpgr,lzden,idnode,imcon,keyens,mxnode,natms,
+     x  levcfg,nzden,nstep,ntpatm,numacc,numrdf,keybpd,chip,chit,conint,
+     x  rcut,tstep,engcfg,volm,virtot,vircom,zlen,tboost,chit_shl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing simulation summary and
+c     saving the restart data
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith dec 1992.
+c     
+c***********************************************************************
+
+      implicit none
+
+      character*1 hms,dec
+      logical lgofr,lpgr,lzden,check,ltad,lbpd,goprint
+      
+      integer idnode,imcon,keyens,mxnode,natms,nzden,nstep,ntpatm
+      integer levcfg,numacc,numrdf,keybpd,i,iadd,io,j
+      real(8) chip,chit,conint,rcut,tstep,volm,timelp,avvol,zlen,dc
+      real(8) engcfg,virtot,vircom,prntim,simtim,tboost,chit_shl
+
+c     save restart data
+      
+      call revive
+     x  (lgofr,lzden,idnode,imcon,mxnode,natms,levcfg,nstep,nzden,
+     x  numacc,numrdf,chip,chit,conint,tstep,engcfg,virtot,vircom,
+     x  tboost,chit_shl)
+
+c     for TAD and BPD system averages not generally meaningful 
+c     useful only for BPD in configurational sampling mode
+      
+      goprint=.not.(ltad.or.(lbpd.and.keybpd.gt.1))
+      
+      if(goprint)then
+        
+c     calculate final fluctuations
+        
+        do i=1,mxnstk
+          ssqval(i)=sqrt(max(0.d0,ssqval(i)))
+        enddo
+        
+c     final averages and fluctuations
+        
+        call timchk(0,timelp)
+        
+        if(idnode.eq.0)then
+          
+          write(nrite,
+     x      "(/,/,1x,'run terminated after',i8,' steps.',
+     x      ' final averages calculated over',i8,' steps.',/,/)") 
+     x      nstep,numacc
+          write(nrite,"(1x,120('-'),
+     x      /,/,1x,'    step',5x,'eng_tot',4x,'temp_tot',5x,'eng_cfg',
+     x      5x,'eng_vdw',5x,'eng_cou',5x,'eng_bnd',5x,'eng_ang',5x,
+     x      'eng_dih',5x,'eng_tet',/,1x,'time    ',5x,' eng_pv',4x,
+     x      'temp_rot',5x,'vir_cfg',5x,'vir_vdw',5x,'vir_cou',5x,
+     x      'vir_bnd',5x,'vir_ang',5x,'vir_con',5x,'vir_tet',/,
+     x      1x,'cpu time',6x,'volume',4x,'temp_shl',5x,'eng_shl',
+     x      5x,'vir_shl',7x,'alpha',8x,'beta',7x,'gamma',5x,'vir_pmf',
+     x      7x,'press',/,/,
+     x      1x,120('-'))")          
+          
+          call get_prntime(hms,timelp,prntim)
+          call get_simtime(dec,nstep,tstep,simtim)
+          write(nrite,'(1x,i8,1p,9e12.4,/,1x,0p,f7.3,a1,1p,9e12.4,
+     x      /,1x,0p,f7.3,a1,1p,9e12.4)') 
+     x      nstep,(sumval(i),i=1,9),
+     x      simtim,dec,(sumval(i),i=10,18),
+     x      prntim,hms,(sumval(i),i=19,27)
+          write(nrite,"(/,1x,' r.m.s. ',1p,9e12.4,/,1x,'fluctn. ',
+     x      1p,9e12.4,/,9x,9e12.4)") (ssqval(i),i=1,27)
+          write(nrite,"(1x,120('-'))")
+          
+c     write out bias potential boost factor
+          
+          if(lbpd)write(nrite,"(/,/,1x,
+     x      'calculated bias potential boost factor',1p,e16.8)")tboost
+          
+          if(numacc.gt.0)then
+            iadd=27
+            
+c     write out estimated diffusion coefficients
+            
+            if(numacc.gt.0)then
+              
+              write(nrite,"(/,/,12x,'Approximate 3D Diffusion',
+     x          '  coefficients (10^-9 m^2 / s)',/,/,12x,'atom',7x,
+     x          ' D ')")
+              
+              do i=1,ntpatm
+                
+                iadd=iadd+1
+                dc=(ravval(iadd)-sumval(iadd))/
+     x            (3.d0*dble(numacc-min(mxnstk,numacc-1))*tstep)*10.d0
+                if(dc.lt.1d-10) dc=0.d0
+                if(lbpd)dc=dc/tboost
+                write(nrite,'(12x,a8,1p,e13.4)') unqatm(i),dc
+                
+              enddo
+              
+            endif
+            
+c     print out average pressure tensor
+            
+            write(nrite,"(/,/,16x,'Average pressure tensor',
+     x        39x,'r.m.s. fluctuations ',/)")
+            
+            do i=iadd,iadd+6,3
+              write(nrite,'(9x,1p,3e12.4,24x,3e12.4)')
+     x          (sumval(i+j),j=1,3),(ssqval(i+j),j=1,3)
+            enddo
+            iadd=iadd+9
+            
+            write(nrite,'(/,12x,a,1p,e12.4)') 'trace/3. ',
+     x        (sumval(iadd)+sumval(iadd-4)+sumval(iadd-8))/3.d0
+            
+c     write out mean cell vectors for npt 
+            
+            if(keyens.gt.3.and.(keyens.le.7))then
+              
+              write(nrite,"(/,/,17x,'Average cell vectors',
+     x          41x,'r.m.s. fluctuations ',/)")
+              
+              do i=iadd,iadd+6,3
+                write(nrite,'(3f20.10,9x,1p,3e12.4)')
+     x            (sumval(i+j),j=1,3),(ssqval(i+j),j=1,3)
+              enddo
+              iadd=iadd+9
+              
+            endif
+            
+c     write out remaining registers
+            
+            check=.false.
+            do i=iadd+1,mxnstk
+              
+              if((abs(sumval(i)).gt.1.d-10).or.
+     x          (abs(ssqval(i)).gt.1.d-10)) check=.true.
+              
+            enddo
+            
+            if(check)then
+              
+              write(nrite,"(/,/,12x,
+     x          'Remaining non-zero statistics registers ',/,/,12x,
+     x          'Register',7x,'Average value',8x,'r.m.s. fluc.')")
+              
+              do i=iadd+1,mxnstk
+                
+                if((abs(sumval(i)).gt.1.d-10).or.
+     x            (abs(ssqval(i)).gt.1.d-10))
+     x            write(nrite,'(10x,i10,2f20.10)') i,sumval(i),ssqval(i)
+                
+              enddo
+              
+            endif
+            
+          endif
+          
+c     print out sample of final configuration 
+          
+          write(nrite,"(/,/,1x,'sample of final configuration',/)")
+          write(nrite,"(6x,'i',7x,'x(i)',8x,'y(i)',8x,'z(i)',
+     x      7x,'vx(i)',7x,'vy(i)',7x,'vz(i)',7x,'fx(i)',7x,
+     x      'fy(i)',7x,'fz(i)',/,/)")
+          io=(natms+19)/20
+          
+          do i=1,natms,io
+            
+            write(nrite,"(1x,i6,1p,3e12.4,3e12.4,3e12.4)") 
+     x        i,xxx(i),yyy(i),zzz(i),vxx(i),vyy(i),vzz(i),
+     x        fxx(i),fyy(i),fzz(i)
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     bypass printing averages for certain tad and bpd options
+      
+      if(goprint)then
+        
+c     average volume
+        
+        avvol=sumval(19)
+        if(imcon.eq.0.or.imcon.eq.6)then
+          avvol=4.d0*pi/3.d0*rcut**3
+          volm=avvol
+        endif
+        
+c     calculate and print radial distribution functions
+        
+        if(lgofr.and.lpgr.and.(numrdf.gt.0))then 
+          
+c     scale densities for average volume
+          
+          do i=1,ntpatm
+            dens(i)=dens(i)*(volm/avvol)
+          enddo
+          
+          call rdf1
+     x      (lpgr,idnode,mxnode,ntpatm,numrdf,avvol,rcut)
+          
+        endif
+        
+        if(lzden.and.lpgr.and.(nzden.gt.0))then 
+          call zden1(lpgr,idnode,mxnode,ntpatm,nzden,avvol,zlen)
+        endif
+        
+        if(imcon.eq.0)volm=0.d0
+        
+      endif
+      
+c     print final time check
+        
+      call timchk(1,timelp)
+        
+      return
+      end subroutine result
+
+      subroutine diffsn0(idnode,natms,mxnode,tstep)
+
+c***********************************************************************
+c     
+c     DL_POLY routine for calculating displacements of sites from
+c     t=0 positions
+c     
+c     use diffsn1 for mean squared displacements
+c     
+c     parallel version - replicated data.
+c     
+c     copyright daresbury laboratory 1993
+c     
+c     author - t. forester      june 1993
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical newjob 
+      integer idnode,natms,mxnode,iatm1,iatm2,i
+      real(8) tstep
+
+      save newjob,iatm1,iatm2
+      data newjob/.true./
+
+      if(newjob)then
+
+        newjob=.false.
+        iatm1=(idnode*natms)/mxnode+1
+        iatm2=((idnode+1)*natms)/mxnode
+
+      endif
+
+      do i=iatm1,iatm2
+
+        xx0(i)=xx0(i)+vxx(i)*tstep
+        yy0(i)=yy0(i)+vyy(i)*tstep
+        zz0(i)=zz0(i)+vzz(i)*tstep
+        
+      enddo
+      
+      return
+      end subroutine diffsn0
+
+      subroutine diffsn1(idnode,natms,ntpatm,mxnode)
+      
+c***********************************************************************
+c     
+c     DL_POLY routine for calculating mean squared displacements
+c     
+c     displacements calculated in diffsn0
+c     
+c     parallel version - replicated data.
+c     
+c     copyright daresbury laboratory 1993
+c     
+c     author - t. forester      june 1993
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical newjob
+      integer idnode,natms,ntpatm,mxnode,iatm1,iatm2,k,i
+
+      save newjob,iatm1,iatm2
+
+      data newjob/.true./
+
+      if(newjob)then
+
+        newjob=.false.
+        iatm1=(idnode*natms)/mxnode+1
+        iatm2=((idnode+1)*natms)/mxnode
+
+      endif
+
+c     running sum of squared displacements
+      
+      do k=1,ntpatm
+        
+        amsd(k)=0.d0
+        
+      enddo
+      
+c     calculate square of displacements for each atom type
+
+      do i=iatm1,iatm2
+        
+        k=ltype(i)
+        amsd(k)=amsd(k)+xx0(i)**2+yy0(i)**2+zz0(i)**2
+        
+      enddo
+      
+c     global sum - replicated data strategy
+      
+      if(mxnode.gt.1)then
+        
+        do k=1,ntpatm
+          
+          buffer(k+ntpatm)=amsd(k)
+          
+        enddo
+        
+        call  gdsum(buffer(1+ntpatm),ntpatm,buffer(1))
+        
+        do k=1,ntpatm
+          
+          amsd(k)=buffer(k+ntpatm)
+          
+        enddo
+        
+      endif
+      
+c     mean squared displacement
+      
+      do k=1,ntpatm
+        
+        amsd(k)=amsd(k)/dble(max(numtyp(k),1))
+        
+      enddo
+      
+      return
+      end subroutine diffsn1
+
+      subroutine rdf0(iatm,ik,rcut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for accumulating statistic for radial
+c     distribution functions.
+c     double precision accumulators
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994    
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer iatm,ik,m,jatm,ll,k
+      real(8) rcut,rcsq,rdelr,ai,aj,rsq,rrr
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut*rcut
+
+c     grid interval for rdf tables
+
+      rdelr=dble(mxrdf)/rcut
+
+c     set up atom iatm type
+
+      ai=ltype(iatm) 
+
+c     start of primary loop for rdf accumulation
+
+      do m=1,ik
+
+c     atomic and potential function indices
+        
+        jatm=ilist(m)
+
+        aj=ltype(jatm)
+        if(ai.gt.aj)then
+          k=int(ai*(ai-1.d0)*0.5d0+aj+0.5d0)
+        else
+          k=int(aj*(aj-1.d0)*0.5d0+ai+0.5d0)
+        endif
+
+c     apply truncation of potential
+        
+        rsq=rsqdf(m)
+        
+        if(rcsq.gt.rsq)then
+
+          rrr=sqrt(rsq)
+          ll=Min(1+Int(rrr*rdelr),mxrdf)
+
+c     accumulate statistics
+
+          rdf(ll,k)=rdf(ll,k)+1.d0
+
+        endif
+        
+      enddo
+      
+      return
+      end subroutine rdf0
+
+      subroutine rdf1
+     x   (lpgr,idnode,mxnode,ntpatm,numrdf,volm,rcut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating radial distribution functions
+c     from accumulated data.
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994    
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,ntpatm,numrdf,ia,ib,k,j
+      real(8) volm,factor,sum,rrr,dvol,gofr,rcut,delrdf
+      
+      logical lpgr,zero
+
+      if(idnode.eq.0) write(nrite,
+     x   "(/,/,12X,'RADIAL DISTRIBUTION FUNCTIONS',/,/,
+     x   'calculated using ',i10,' configurations')") numrdf
+
+      if(lpgr)then
+        
+c     open RDF file and write headers
+        
+        if(idnode.eq.0)then
+          
+          open(nrdfdt,file='RDFDAT')
+          
+          write(nrdfdt,'(80a1)')cfgname
+          write(nrdfdt,'(2i10)')mxxtyp,mxrdf
+          
+        endif
+
+c     default bin width
+        
+        delrdf=rcut/dble(mxrdf)
+        
+c     construct rdf tables
+        
+        do ia=1,ntpatm
+          
+          do ib=ia,ntpatm
+            
+            k=(ib*(ib-1))/2+ia
+            
+            if(idnode.eq.0)then
+                
+              write(nrite,
+     x         "(/,'g(r)  :',2a8,/,/,8x,'r',6x,'g(r)',9x,'n(r)',/)") 
+     x           unqatm(ia),unqatm(ib)
+              write(nrdfdt,'(2a8)')unqatm(ia),unqatm(ib)
+              
+            endif
+              
+c     global sum of data on all nodes
+            
+            if(mxnode.gt.1) call gdsum(rdf(1,k),mxrdf,buffer)
+            
+c     normalisation factor 
+            
+            factor=volm*dens(ia)*dens(ib)*dble(numrdf)
+            if((ia.eq.ib).and.(volm*dens(ia).gt.1.d0)) 
+     x         factor=factor*0.5d0
+            
+c     running integration of rdf
+            
+            sum=0.d0
+              
+c     loop over distances
+              
+            zero=.true.
+            
+            do j=1,mxrdf
+              
+              if(zero.and.(j.lt.mxrdf-3)) 
+     x          zero=(rdf(j+2,k).le.0.d0)
+              
+              rrr=(dble(j)-0.5d0)*delrdf
+              dvol=4.d0*pi*(delrdf*rrr*rrr+(delrdf**3)/12.d0)
+              
+              gofr=rdf(j,k)/(factor*dvol)
+              sum=sum+gofr*dvol*dens(ib)
+              
+c     print out information
+                
+              if(idnode.eq.0)then
+                
+                write(nrdfdt,"(1p,2e14.6)")rrr,gofr
+                if(.not.zero)
+     x             write(nrite,"(f10.4,1p,2e14.6)")rrr,gofr,sum
+                
+              endif
+              
+            enddo
+              
+          enddo
+          
+        enddo
+        
+        if(idnode.eq.0)close (nrdfdt)
+        
+      endif
+      
+      return
+      end subroutine rdf1
+
+      subroutine static
+     x  (lbpd,lzeql,idnode,intsta,imcon,keyens,natms,nstack,
+     x  nstep,nsteql,ntpatm,numacc,mxnode,nblock,keybpd,numbpd,
+     x  consv,degfre,degrot,engang,engbnd,engcpe,engdih,enginv,
+     x  engke,engrot,engsrp,engunit,engcfg,stpeng,stpeth,stpprs,
+     x  stptmp,stpvir,stpvol,tstep,virbnd,engfbp,vircom,vircon,
+     x  vircpe,virsrp,engfld,virfld,engtbp,virtbp,virpmf,virshl,
+     x  engshl,engtet,virtet,degshl,shlke,virang,width,engmet,
+     x  virmet,engter,virter,boost,tboost)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for accumulating periodic data during the
+c     molecular dynamics simulation and computing the rolling averages
+c     
+c     copyright daresbury laboratory 1992
+c     
+c     author - w. smith       august 1992
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical lbpd,lzeql,newjob
+      integer idnode,intsta,imcon,keyens,natms,nstack,nstep,j
+      integer nsteql,ntpatm,numacc,mxnode,i,iadd,k,kstak
+      integer nblock,keybpd,numbpd
+      real(8) consv,degfre,degrot,engang,engbnd,engcpe,engdih
+      real(8) enginv,engke,engrot,engsrp,engunit,engcfg,stpeng
+      real(8) stpeth,stpprs,stptmp,stpvir,stpvol,tstep,virbnd
+      real(8) engfbp,vircom,vircon,vircpe,virsrp,engfld,virfld
+      real(8) engtbp,virtbp,virpmf,virshl,engshl,engtet,virtet
+      real(8) degshl,shlke,virang,width,sclnv1,sclnv2,stprot
+      real(8) stpcns,stpshl,zistk,engmet,virmet,engter,virter
+      real(8) tbold,aterm,bterm,cterm,boost,tboost
+
+      save newjob
+      
+      data newjob/.true./
+
+c     open statistics file for append
+      
+      if(newjob.and.idnode.eq.0.and.intsta.gt.0)then
+
+        open(nstats,file='STATIS',position='append')
+        newjob=.false.
+        
+      endif
+      
+      if(idnode.eq.0.and.nstep.eq.intsta.and.intsta.gt.0)then
+        
+        write(nstats,'(80a1)') cfgname
+        if(abs(engunit-9648.530821d0).le.1.d-10) write(nstats,
+     x    "(' ENERGY UNITS=electron Volts ')")
+        if(abs(engunit-9648530.821d0).le.1.d-10) write(nstats,
+     x    "(' ENERGY UNITS=kilo electron Volts ')")
+        if(abs(engunit-418.4d0).le.1.d-10)       write(nstats,
+     x    "(' ENERGY UNITS=kcal/mol ')")
+        if(abs(engunit-1.d2).le.1.d-10)          write(nstats,
+     x    "(' ENERGY UNITS=kjoule/mol ')")
+        if(abs(engunit-boltz).lt.1.d-10)         write(nstats,
+     x    "(' ENERGY UNITS=kelvin ')")
+        if(abs(engunit-1.d0).lt.1.d-10)          write(nstats,
+     x    "(' ENERGY UNITS=DL_POLY Internal Units ')")
+        
+      endif
+      
+c     calculate cell volume and minimum cell half-width
+      
+      if(imcon.eq.0)then
+        
+        width=0.d0
+        
+        stpvol=0.d0
+        do i=1,10
+           celprp(i)=0.d0
+        enddo
+        
+      else
+        
+        call dcell(cell,celprp)
+        stpvol=celprp(10)
+        width=min(celprp(7),celprp(8),celprp(9))/2.d0
+        
+        if(imcon.eq.4)then
+
+          stpvol=0.5d0*celprp(10)
+          width=sqrt(3.d0)*cell(1)/4.d0
+
+        elseif(imcon.eq.5)then
+        
+          stpvol=0.5d0*celprp(10)
+          width=cell(1)/2.d0
+
+        elseif(imcon.eq.6)then
+
+          width=min(celprp(7),celprp(8))/2.d0
+
+        elseif(imcon.eq.7)then
+        
+          stpvol=0.5d0*celprp(10)
+
+        endif
+        
+      endif
+
+c     energetic properties of system
+      
+      stpvir=virsrp+vircpe+virbnd+vircon+vircom+virtbp+virang
+     x  +virshl+virtet+virter+virmet+virfld
+      stpeng=engcfg+engke+engrot
+      stprot=2.d0*engrot/(boltz*max(1.d0,degrot))
+      stpshl=2.d0*shlke/(boltz*max(1.d0,degshl))
+      stptmp=2.d0*(engke+engrot)/(boltz*degfre)
+      stpprs=0.d0
+      if(imcon.gt.0)stpprs=(2.d0*engke-stpvir)/(3.d0*stpvol)
+      stpeth=stpeng+stpprs*stpvol
+      stpcns=stpeng+consv
+      
+c     convert pressure to units of katm
+      
+      stpprs=stpprs*prsunt
+      
+c     calculate mean squared displacements 
+c     atomic displacements from origin of production run
+      
+      if((.not.lzeql).or.(nstep.gt.nsteql))then
+
+        call diffsn0(idnode,natms,mxnode,tstep)
+        call diffsn1(idnode,natms,ntpatm,mxnode)
+        
+      endif
+
+c     zero statistics arrays
+      
+      if((nstep.le.0).or.(numacc.eq.0))then
+        
+        numacc=0
+        
+        do i=1,mxnstk
+          
+          stpval(i)=0.d0
+          sumval(i)=0.d0
+          ssqval(i)=0.d0
+          
+        enddo
+        
+        do i=1,mxatms
+          
+          xx0(i)=0.d0
+          yy0(i)=0.d0
+          zz0(i)=0.d0
+          
+        enddo
+        
+      endif
+      
+c     store current values in statistics array
+      
+      stpval(1) =stpcns/engunit
+      stpval(2) =stptmp
+      stpval(3) =engcfg/engunit
+      stpval(4) =(engsrp+engmet+engter)/engunit
+      stpval(5) =engcpe/engunit
+      stpval(6) =engbnd/engunit
+      stpval(7) =(engang+engtbp)/engunit
+      stpval(8) =(engdih+enginv+engfbp)/engunit
+      stpval(9) =engtet/engunit
+      stpval(10)=stpeth/engunit
+      stpval(11)=stprot
+      stpval(12)=stpvir/engunit
+      stpval(13)=(virsrp+virmet+virter)/engunit
+      stpval(14)=vircpe/engunit
+      stpval(15)=virbnd/engunit
+      stpval(16)=(virtbp+virang)/engunit
+      stpval(17)=vircon/engunit
+      stpval(18)=virtet/engunit
+      stpval(19)=stpvol
+      stpval(20)=stpshl
+      stpval(21)=engshl/engunit
+      stpval(22)=virshl/engunit
+      stpval(23)=acos(celprp(6))*180.d0/pi
+      stpval(24)=acos(celprp(5))*180.d0/pi
+      stpval(25)=acos(celprp(4))*180.d0/pi
+      stpval(26)=virpmf/engunit
+      stpval(27)=stpprs
+
+      iadd=27
+
+c     mean squared displacements 
+      
+      if((.not.lzeql).or.(nstep.gt.nsteql))then
+        
+        do k=1,ntpatm
+          
+          stpval(iadd+k)=amsd(k)
+          
+        enddo
+        
+      endif
+
+      iadd=iadd+ntpatm
+
+c     stress tensor
+
+      if(abs(stpvol).le.1.d-10) stpvol=1.d0
+      do i=1,9
+        stpval(iadd+i)=stress(i)*prsunt/(stpvol)
+      enddo
+      iadd=iadd+9
+
+c     cell vectors
+      
+      if(keyens.gt.3.and.(keyens.le.7))then
+        do i=1,9
+          stpval(iadd+i)=cell(i)
+        enddo
+        iadd=iadd+9
+      endif
+
+c     check on number of variables for stack - 
+      
+      if(iadd.gt.mxnstk) call error(idnode,170)
+
+c     accumulate totals over steps
+      
+      numacc=numacc+1
+      sclnv2=1.d0/dble(numacc)
+      sclnv1=dble(numacc-1)/dble(numacc)
+      
+      if(lbpd.and.keybpd.eq.1)then
+        
+c     calculate true thermodynamic averages in bias potential system
+c     note integers numacc and numbpd should be equal in this case
+        
+        tbold=tboost*dble(numbpd)/dble(numbpd-1)-boost/dble(numbpd-1)
+        cterm=0.d0
+        do i=1,mxnstk
+          
+          aterm=sumval(i)*tbold
+          bterm=ssqval(i)*tbold**2
+          if(tbold.gt.0.d0)cterm=(bterm+aterm**2)/tbold
+          ssqval(i)=(sclnv1*(sclnv1*bterm+boost*sclnv2*(cterm+
+     x      (tbold*stpval(i)-2.d0*aterm)*stpval(i))))/tboost**2
+          sumval(i)=(sclnv1*aterm+boost*sclnv2*stpval(i))/tboost
+          
+        enddo
+        
+      else
+        
+c     calculate true thermodynamic averages in normal system
+
+        do i=1,mxnstk
+          
+          ssqval(i)=sclnv1*(ssqval(i)+sclnv2*(stpval(i)-sumval(i))**2)
+          sumval(i)=sclnv1*sumval(i)+sclnv2*stpval(i)
+          
+        enddo
+        
+      endif
+      
+c     write statistics file
+      
+      if(idnode.eq.0.and.intsta.gt.0)then
+
+        if(mod(nstep,intsta).eq.0)then
+        
+          write(nstats,'(i10,1p,e14.6,0p,i10,/,(1p,5e14.6))')
+     x       nstep,nstep*tstep,iadd,(stpval(k),k=1,iadd)
+          call flush(nstats)
+c$$$c     write option for Excel spreadsheet
+c$$$          write(nstats,'(i10,1p,e14.6,0p,i10,300(1p,5e14.6))')
+c$$$     x      nstep,nstep*tstep,iadd,(stpval(k),k=1,iadd)
+
+        endif
+        
+      endif
+      
+c     zero rolling average accumulators
+      
+      if(nstep.le.0)then
+        
+        numacc=0
+        
+        do i=1,mxnstk
+          
+          zumval(i)=0.d0
+          
+          do j=1,mxstak
+            
+            stkval(j,i)=0.d0
+            
+          enddo
+          
+        enddo
+        
+      endif
+      
+c     store quantities in stack
+      
+      kstak=mod(nstep-1,nstack)+1
+      
+      if(nstep.gt.nstack)then
+        
+        do i=1,mxnstk
+          
+          zumval(i)=zumval(i)-stkval(kstak,i)
+          
+        enddo
+        
+      endif
+      
+      do i=1,mxnstk
+        
+        stkval(kstak,i)=stpval(i)
+        zumval(i)=zumval(i)+stpval(i)
+        
+      enddo
+      
+c     calculate rolling averages
+      
+      zistk=min(nstack,nstep)
+      
+      do i=1,mxnstk
+        
+        ravval(i)=zumval(i)/zistk
+        
+      enddo
+      
+c     zero accumulators during equilibration period
+      
+      if(lzeql.and.nstep.le.nsteql)then
+        
+        numacc=0
+        do i=1,mxnstk
+          
+          sumval(i)=0.d0
+          ssqval(i)=0.d0
+          
+        enddo
+        
+      endif
+
+c     close statistics file at regular intervals
+      
+      if(.not.newjob.and.mod(nstep,ndump).eq.0)then
+        
+        if(idnode.eq.0)close (nstats)
+        newjob=.true.
+        
+      endif
+      
+      return
+      end subroutine static
+
+      subroutine revive
+     x  (lgofr,lzden,idnode,imcon,mxnode,natms,levcfg,nstep,nzden,
+     x  numacc,numrdf,chip,chit,conint,tstep,engcfg,virtot,vircom,
+     x  tboost,chit_shl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing restart files at job termination
+c     or at selected intervals in simulation
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith dec 1992.
+c     
+c***********************************************************************
+     
+      implicit none
+      
+      logical lgofr,lzden
+      integer idnode,imcon,mxnode,natms,nstep,nzden,numacc,numrdf
+      integer levcfg,nsum,nbuff,i,j
+      real(8) chip,chit,conint,tstep,engcfg,rmxnode,virtot,vircom
+      real(8) tboost,chit_shl
+
+      if(mxnode.gt.1)then
+
+c     merge displacement data
+
+        call merge(idnode,mxnode,natms,mxbuff,xx0,yy0,zz0,buffer)
+
+c     globally sum rdf information before saving
+        
+        if(lgofr)then
+
+c     maximum rdfs that can be summed in each step
+          
+          nsum=mxbuff/mxrdf
+          if(nsum.eq.0) call error(idnode,200)
+          
+          nbuff=nsum*mxrdf
+          
+          do i=1,mxxtyp,nsum
+            
+            if((mxxtyp+1-i).lt.nsum) nbuff=(mxxtyp+1-i)*mxrdf
+            call  gdsum(rdf(1,i),nbuff,buffer)
+            
+          enddo
+          
+        endif
+
+c     globally sum zden information before saving
+        
+        if(lzden)then
+
+c     maximum zdfs that can be summed in each step
+          
+          nsum=mxbuff/mxzdn
+          if(nsum.eq.0) call error(idnode,200)
+          
+          nbuff=nsum*mxzdn
+          
+          do i =1,mxatyp,nsum
+            
+            if((mxatyp+1-i).lt.nsum) nbuff=(mxatyp+1-i)*mxzdn
+            call  gdsum(zdens(1,i),nbuff,buffer)
+            
+          enddo
+          
+        endif
+        
+      endif
+
+c     node 0 handles i/o
+
+      if(idnode.eq.0)then
+
+c     write configuration data to new configuration file
+
+        call config_write('REVCON',levcfg,imcon,natms,engcfg)
+
+c     write accumulator data to dump file
+        
+        open(nrest,file='REVIVE',form='unformatted')
+        
+        write(nrest) dble(nstep),dble(numacc),dble(numrdf),chit,
+     x    chip,conint,dble(nzden),tboost,chit_shl
+        write(nrest) virtot,vircom,eta,strcns,strbod
+        write(nrest) stpval
+        write(nrest) sumval
+        write(nrest) ssqval
+        write(nrest) zumval
+        write(nrest) ravval
+        write(nrest) stkval
+        write(nrest) xx0,yy0,zz0
+        write(nrest) xxs,yys,zzs
+        if(lgofr) write(nrest) rdf
+        if(lzden) write(nrest) zdens
+        
+        close (nrest)
+
+      endif
+
+c     divide rdf data between nodes
+      
+      rmxnode=1.d0/dble(mxnode)
+      
+      if(lgofr)then
+        
+        do i=1,mxxtyp
+          
+          do j=1,mxrdf
+            
+            rdf(j,i)=rdf(j,i)*rmxnode
+            
+          enddo
+          
+        enddo
+        
+      endif
+
+c     divide zdensity data between nodes
+
+      if(lzden)then
+        
+        do i=1,mxatyp
+          
+          do j=1,mxzdn
+            
+            zdens(j,i)=zdens(j,i)*rmxnode
+            
+          enddo
+          
+        enddo
+        
+      endif
+      
+      return
+      end subroutine revive
+
+      subroutine zden0(idnode,natms,mxnode,nzden,zlen)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for accumulating statistic for density profile
+c     zlen=length of cell in z direction
+c     
+c     double precision accumulators
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994    
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms,nzden,iatm,ll,k
+      real(8) zlen,zleno2,rzdn
+
+c     accumulator
+
+      nzden=nzden+1
+
+c     half of z length
+
+      zleno2=zlen*0.5d0
+
+c     grid interval for density profiles
+
+      rzdn=dble(mxzdn)/zlen
+
+c     set up atom iatm type
+
+      do iatm=idnode+1,natms,mxnode
+
+        k =ltype(iatm) 
+
+        ll=int((zzz(iatm)+zleno2)*rzdn+1.0d0)
+
+c     accumulate statistic
+
+        if(ll.gt.0.and.ll.le.mxzdn)zdens(ll,k)=zdens(ll,k)+1.d0
+
+      enddo
+      
+      return
+      end subroutine zden0
+
+      subroutine zden1
+     x  (lpgr,idnode,mxnode,ntpatm,nzden,volm,zlen)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating Z density profile
+c     from accumulated data.
+c     double precision version
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994    
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lpgr
+      integer idnode,mxnode,ntpatm,nzden,k,j
+      real(8) volm,zlen,delzdn,dvolz,factor,sum,rrr,rho
+
+      if(idnode.eq.0) write(nrite,
+     x  "(/,/,12X,'Z DENSITY PROFILES',/,/,
+     x  'calculated using ',i10,' configurations')") nzden
+      
+      if(lpgr)then
+
+c     open Z density file and write headers
+
+        if(idnode.eq.0)then
+
+          open(nzdndt,file='ZDNDAT')
+
+          write(nzdndt,'(80a1)')cfgname
+          write(nzdndt,'(2i10)')ntpatm,mxzdn
+
+        endif
+
+c     volume of z strip (arbitrary)
+
+        delzdn=zlen/dble(mxzdn)
+        dvolz=(volm/zlen)*delzdn
+        
+c     normalisation factor 
+        
+        nzden=max(nzden,1)
+        factor=1.d0/(dble(nzden)*dvolz)
+
+        do k=1,ntpatm
+          
+          if(idnode.eq.0)then
+
+             write(nrite,
+     x      "(/,'rho(r)  :',a8,/,/,8x,'r',6x,'rho',9x,'n(r)',/)")
+     x      unqatm(k)
+             write(nzdndt,'(a8)')unqatm(k)
+
+          endif
+
+c     global sum of data on all nodes
+          
+          if(mxnode.gt.1)call gdsum(zdens(1,k),mxzdn,buffer)
+
+c     running integration of z-density
+          
+          sum=0.d0
+
+c     loop over distances
+          
+          do j=1,mxzdn
+            
+            rrr=(dble(j)-0.5d0)*delzdn-zlen*0.5d0
+            rho=zdens(j,k)*factor
+            sum=sum+rho*dvolz
+
+c     print out information
+            
+            if(idnode.eq.0)then
+
+              write(nrite,"(f10.4,1p,2e14.6)") rrr,rho,sum
+              write(nzdndt,"(1p,2e14.6)") rrr,rho
+
+            endif
+            
+          enddo
+          
+        enddo
+        
+        if(idnode.eq.0)close (nzdndt)
+
+      endif
+      
+      return
+      end subroutine zden1
+
+      subroutine rdf0neu(ik,rcut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for accumulating statistic for radial
+c     distribution functions.
+c     neutral group implementation
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - t. forester    march 1994    
+c     amended     t. forester    april 1994
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer ik,m,iatm,jatm,ll,k
+      real(8) rcut,a0,a1,a2,a3,a4,a5,rcsq,rrcsq,sqlim,rdelr
+      real(8) ai,aj,rsq,rrr,sss
+      
+      data a0,a1,a2,a3,a4,a5/.0837557783d0,2.9399054d0,-7.8475201d0,
+     x  14.1328992d0,-12.6228528d0,4.32084948d0/
+      
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+      rrcsq=1.d0/rcsq
+      sqlim=0.01d0*rcsq
+      
+c     grid interval for rdf tables
+      
+      rdelr=dble(mxrdf)/rcut
+
+c     start of primary loop for rdf accumulation
+      
+      do m=1,ik
+        
+c     atomic and potential function indices
+        
+        iatm=ilist(m)
+        ai=ltype(iatm)
+        
+        jatm=jlist(m) 
+        aj=ltype(jatm)
+        
+        if(ai.gt.aj)then
+          ll=int(ai*(ai-1.d0)*0.5d0+aj+0.5d0)
+          k=lstvdw(ll)
+        else
+          ll=int(aj*(aj-1.d0)*0.5d0+ai+0.5d0)
+          k=lstvdw(ll)
+        endif
+        
+        rsq=rsqdf(m)
+        
+        if(rcsq.gt.rsq)then
+          
+c     determine interpolation panel for rdf table
+          
+          if(rsq.lt.sqlim)then
+            
+            rrr=sqrt(rsq)
+            
+          else
+
+c     interpolate square-root by polynomial plus newton-raphson
+            
+            sss=rsq*rrcsq
+            rrr=1.d0/
+     x        (a0 +sss*(a1+sss*(a2+sss*(a3+sss*(a4+sss*a5)))))
+            rrr=0.5d0*rrr*(3.d0-sss*rrr*rrr)
+            rrr=0.5d0*rrr*(3.d0-sss*rrr*rrr)
+            rrr=0.5d0*rrr*(3.d0-sss*rrr*rrr)*sss*rcut
+            
+          endif
+          
+          ll=int(rrr*rdelr+0.999999d0)
+
+c     accumulate statistics
+          
+          rdf(ll,k)=rdf(ll,k)+1.d0
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine rdf0neu
+      
+      end module property_module
diff -urN dl_class_1.9.orig/srcmod/rigid_body_module.f dl_class_1.9/srcmod/rigid_body_module.f
--- dl_class_1.9.orig/srcmod/rigid_body_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/rigid_body_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,243 @@
+      module rigid_body_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining rigid body arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    oct 2003
+c     
+c***********************************************************************
+      
+      use config_module
+      use error_module
+      use parse_module
+      use setup_module
+      use site_module
+      use solvation_module
+      
+      implicit none
+      
+      real(8), allocatable :: omx(:),omy(:),omz(:)
+      real(8), allocatable :: gcmx(:),gcmy(:),gcmz(:)
+      real(8), allocatable :: gvxx(:),gvyy(:),gvzz(:),gmass(:)
+      real(8), allocatable :: q0(:),q1(:),q2(:),q3(:)
+      real(8), allocatable :: gxx(:,:),gyy(:,:),gzz(:,:)
+      real(8), allocatable :: rotinx(:,:),rotiny(:,:),rotinz(:,:)
+      integer, allocatable :: lstrgd(:),numgsit(:),lstgtp(:)
+      integer, allocatable :: listyp(:),lstgst(:,:),lstfre(:)
+      integer, allocatable :: lstme(:),lstbod(:),lstcsit(:)
+      
+      save omx,omy,omz,gcmx,gcmy,gcmz,gvxx,gvyy,gvzz,gmass
+      save q0,q1,q2,q3,gxx,gyy,gzz,rotinx,rotiny,rotinz
+      save lstrgd,numgsit,lstgtp,listyp,lstgst,lstfre,lstme
+      save lstbod,lstcsit
+      
+      contains
+      
+      subroutine alloc_rgbdy_arrays(idnode)
+      
+      implicit none
+      
+      integer, parameter :: nnn=12
+      
+      integer i,fail,idnode
+      dimension fail(nnn)
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (omx(mxgrp),omy(mxgrp),omz(mxgrp),stat=fail(1))
+      allocate (gcmx(mxgrp),gcmy(mxgrp),gcmz(mxgrp),stat=fail(2))
+      allocate (gvxx(mxgrp),gvyy(mxgrp),gvzz(mxgrp),stat=fail(3))
+      allocate (q0(mxgrp),q1(mxgrp),q2(mxgrp),q3(mxgrp),stat=fail(4))
+      allocate (gxx(mxungp,mxngp),gyy(mxungp,mxngp),stat=fail(5))
+      allocate (gzz(mxungp,mxngp),gmass(mxungp),stat=fail(6))
+      allocate (rotinx(mxungp,2),rotiny(mxungp,2),stat=fail(7))
+      allocate (rotinz(mxungp,2),lstgtp(mxgrp),stat=fail(8))
+      allocate (lstrgd(mxgatm),numgsit(mxungp),stat=fail(9))
+      allocate (listyp(mxungp),lstgst(mxungp,mxngp),stat=fail(10))
+      allocate (lstfre(mxatms),lstme(mxatms),stat=fail(11))
+      allocate (lstbod(mxatms),lstcsit(2*mxcons),stat=fail(12))
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1013)
+      enddo
+      
+      end subroutine alloc_rgbdy_arrays
+      
+      subroutine define_rigid_body
+     x  (safe,lghost,idnode,itmols,ngrp,natmsr)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining rigid bodies
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     adapted   - p-a cazade  oct 2007,  solvation, excitation etc.
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lghost,site_test
+      integer idnode,itmols,ngrp,ntmp,idum,igrp
+      integer j,site,natmsr
+      
+      ngrp_ghost=0
+      ntmp=intstr(record,lenrec,idum)
+      numgrp(itmols)=numgrp(itmols)+ntmp
+      if(idnode.eq.0) then
+        write(nrite,"(/,1x,'number of rigid units    ',
+     x    6x,i10)") ntmp
+        write(nrite,"(/,' rigid body details:',/,/,21x,
+     x    6x,'unit',3x,'indices',/) ")
+      endif
+      
+      do igrp=1,numgrp(itmols)
+        
+        ngrp=ngrp+1
+        site_test=.true.
+        
+        if(ngrp.gt.mxungp) call error(idnode,301)
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        numgsit(ngrp)=intstr(record,lenrec,idum)
+        if(numgsit(ngrp).gt.mxngp) 
+     x    call error (idnode,302)
+        
+        listyp(ngrp)=ngrp
+        
+        do j=1,numgsit(ngrp)
+          
+          site=intstr(record,lenrec,idum)
+          
+          if(site.eq.0)then
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)return
+            site=intstr(record,lenrec,idum)
+            
+          endif
+          
+          lstgst(ngrp,j)=site
+          
+          if(lghost)then
+            
+            if(site_test)then
+              
+              if(site+natmsr.ge.ind_fre(3))then
+                
+                site_test=.false.
+                ngrp_ghost=ngrp_ghost+1
+                
+              endif
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+        if(idnode.eq.0) 
+     x    write(nrite,"(21x,10i10,100(/,21x,10i10))")
+     x    listyp(ngrp),(lstgst(ngrp,j),j=1,
+     x    numgsit(ngrp))
+        
+      enddo
+      
+      numgrp(itmols)=numgrp(itmols)-ngrp_ghost
+      ngrp=ngrp-ngrp_ghost
+        
+      return
+      end subroutine define_rigid_body
+      
+      subroutine bodystress
+     x  (idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to calculate rigid body contributions to the 
+c     stress tensor
+c     
+c     copyright daresbury laboratory
+c     author      w.smith   aug 2005
+c     
+c**********************************************************************
+      
+      implicit none
+      
+      integer i,j,ig,id,jr,igrp1,igrp2,idnode,mxnode,ngrp
+      real(8) vircom,strbod,dtx,dty,dtz
+      
+      dimension dtx(mxatms),dty(mxatms),dtz(mxatms),strbod(9)
+      
+c     group block indices
+      
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+      
+c     zero stress tensor accumulators
+      
+      vircom=0.d0
+      do i=1,9
+        strbod(i)=0.d0
+      enddo
+      
+c     convert atomic virial to molecular
+c     note convention: virial(atom-atom)=-sum(Ri.Fi)
+c     : virial(com-com)=-sum(Rcom.Fcom) so
+c     virial(com-com)=virial(atom-atom)+sum((Ri-Rcom).Fi)
+      
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          vircom=vircom+
+     x      (dtx(jr)*fxx(i)+dty(jr)*fyy(i)+dtz(jr)*fzz(i))
+          
+c     stress tensor : rigid body contributions
+          
+          strbod(1)=strbod(1)-dtx(jr)*fxx(i)
+          strbod(2)=strbod(2)-dtx(jr)*fyy(i)
+          strbod(3)=strbod(3)-dtx(jr)*fzz(i)
+          strbod(4)=strbod(4)-dty(jr)*fxx(i)
+          strbod(5)=strbod(5)-dty(jr)*fyy(i)
+          strbod(6)=strbod(6)-dty(jr)*fzz(i)
+          strbod(7)=strbod(7)-dtz(jr)*fxx(i)
+          strbod(8)=strbod(8)-dtz(jr)*fyy(i)
+          strbod(9)=strbod(9)-dtz(jr)*fzz(i)
+          
+        enddo
+        
+      enddo
+      
+      if(mxnode.gt.1)then
+        
+        call gdsum(strbod,9,buffer)
+        buffer(1)=vircom
+        call gdsum(buffer(1),1,buffer(2))
+        vircom=buffer(1)
+        
+      endif
+      
+c     symmetrise stress tensor
+      
+      strbod(2)=0.5d0*(strbod(2)+strbod(4))
+      strbod(4)=strbod(2)
+      strbod(3)=0.5d0*(strbod(3)+strbod(7))
+      strbod(7)=strbod(3)
+      strbod(6)=0.5d0*(strbod(6)+strbod(8))
+      strbod(8)=strbod(6)
+      
+      return
+      end subroutine bodystress
+      
+      end module rigid_body_module
diff -urN dl_class_1.9.orig/srcmod/serial.f dl_class_1.9/srcmod/serial.f
--- dl_class_1.9.orig/srcmod/serial.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/serial.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,529 @@
+      subroutine initcomms()
+
+c*********************************************************************
+c
+c     dummy initcomms routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      return
+      end
+
+      subroutine machine(idnode,mxnode)
+
+c*********************************************************************
+c
+c     dummy machine routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode
+
+      idnode=0
+      mxnode=1
+
+      return
+      end
+
+      integer function mynode()
+
+c*********************************************************************
+c
+c     dummy mynode routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      mynode=0
+
+      return
+      end
+
+      integer function nodedim()
+
+c*********************************************************************
+c
+c     dummy nodedim routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      nodedim=0
+
+      return
+      end
+
+      integer function numnodes()
+
+c*********************************************************************
+c
+c     dummy numnodes routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      numnodes=1
+
+      return
+      end
+
+      subroutine csend(msgtag,buf,length,pe,idum)
+
+c*********************************************************************
+c
+c     dummy csend routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c********************************************************************
+
+      implicit none
+
+      integer msgtag,length,pe,idum
+
+      real(8) buf(*)
+
+      return
+      end
+      
+      subroutine crecv(msgtag,buf,length)
+
+c*********************************************************************
+c
+c     dummy crecv routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer msgtag,length
+      real(8) buf(*)
+
+      return
+      end
+
+      subroutine gisum(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dummy isum for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c***********************************************************************
+      
+      implicit none
+
+      integer nnn
+      integer aaa(*),bbb(*)
+
+      return
+      end
+
+      subroutine gdsum(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c***********************************************************************
+
+      implicit none
+
+      integer nnn
+      real(8) aaa(*),bbb(*)
+
+      return
+      end
+
+      subroutine gimax(aaa,nnn,bbb)
+
+c***********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c***********************************************************************
+      
+      implicit none
+
+      integer nnn
+      integer aaa(*),bbb(*)
+
+      return
+      end
+
+      subroutine gstate(check)
+
+c***********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c***********************************************************************
+
+      implicit none
+
+      logical check
+
+      return
+      end
+
+      subroutine gsync()
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      return
+      end
+
+      subroutine exitcomms()
+
+c*********************************************************************
+c
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      stop
+      end
+
+      subroutine merge(idnode,mxnode,natms,nbuff,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+      implicit none
+
+      integer idnode,mxnode,natms,nbuff
+      real(8) xxx(*),yyy(*),zzz(*),buffer(*)
+
+      return
+      end
+
+      subroutine merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,natms
+      integer lstme(*)
+      real(8) xxx(*),yyy(*),zzz(*),buffer(*)
+
+      return
+      end
+
+      subroutine merge4(idnode,mxnode,ngrp,nbuff,q0,q1,q2,q3,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ngrp,nbuff
+      real(8) q0(*),q1(*),q2(*),q3(*),buffer(*)
+
+      return
+      end
+
+      subroutine shlmerge(idnode,mxnode,ntshl)
+      
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ntshl
+
+      return
+      end
+
+      subroutine shmove
+     x     (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x      txx,tyy,tzz,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode, mxnode, natms
+      integer lishap(*),lashap(*)
+      real(8) xxt(*),yyt(*),zzt(*),txx(*),tyy(*),tzz(*),buffer(*)
+
+      return
+      end
+
+      subroutine splice
+     x      (idnode,natms,listme,listot,xxx,yyy,zzz,buffer)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      implicit none
+
+      integer idnode,natms
+      integer listme(*),listot(*)
+      real(8) xxx(*),yyy(*),zzz(*),buffer(*)
+
+      return
+      end
+
+      subroutine passcon
+     x     (lshmov,idnode,mxnode,natms,nscons,lashap,lishap,listme,
+     x     listin,listot,listcon,lstfrz)
+      
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      use setup_module
+
+      implicit none
+
+      logical lshmov
+      integer idnode,mxnode,natms,nscons,i,j,k
+      integer lashap(mxproc),lishap(mxlshp),listme(mxatms)
+      integer listin(mxatms),listot(mxatms),listcon(mxcons,3)
+      integer lstfrz(mxatms)
+      
+      do i=1,natms
+         listme(i)=0
+      enddo
+      
+      do k=1,nscons
+         
+         i=listcon(k,2)
+         j=listcon(k,3)
+         listme(i)=listme(i)+1
+         listme(j)=listme(j)+1
+         
+      enddo
+
+c     keep record of all atoms subject to constraints
+      
+      do i=1,natms
+         
+         if(listme(i).gt.0)then
+            listot(i)=1
+         else
+            listot(i)=0
+         endif
+         
+      enddo
+      
+      return
+      end
+
+      subroutine passpmf
+     x  (idnode,mxnode,natms,nspmf,listpm,listin,lstpmt,lstpmf,npmf)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      use error_module
+      use setup_module
+
+      implicit none
+
+      integer idnode,mxnode,natms,nspmf,i,j,k
+      integer listpm(mxpmf),listin(mxatms),lstpmt(mxpmf)
+      integer lstpmf(mxspmf,mspmf),npmf(2)
+
+      if(mxpmf.lt.natms) call error(idnode,490)
+
+      do i=1,natms
+        listpm(i)=0
+      enddo
+      
+      do k=1,nspmf
+        
+        do j = 1,npmf(1)+npmf(2)
+
+          i=lstpmf(j,k)
+          listpm(i)= 1
+          
+        enddo
+
+      enddo
+
+c     keep record of all atoms subject to pmf constraints
+      
+      do i=1,natms
+        
+        if(listpm(i).gt.0)then
+          lstpmt(i)=1
+        else
+          lstpmt(i)=0
+        endif
+        
+      enddo
+      
+      return
+      end
+
+      subroutine passquat
+     x  (lcnb,idnode,mxnode,natms,ngrp,nscons,ntpmls,listin,
+     x  listcon,lstrgd,lstout,lstcsit,lstgtp,nummols,numgrp,numgsit)
+
+c*********************************************************************
+c     
+c     dummy routine for serial DL_POLY
+c     copyright daresbury laboratory
+c     author - w.smith
+c
+c*********************************************************************
+
+      use setup_module
+
+      implicit none
+
+      logical lcnb
+      integer idnode,mxnode,natms,ngrp,nscons,ntpmls,jj,id,igrp1,igrp2
+      integer i,j,k,jr,igrp,itmols,imols,ik,lgrp
+      integer listin(mxatms),listcon(mxcons,3),lstrgd(mxgatm)
+      integer lstout(mxatms),lstcsit(2*mxcons),numgsit(mxungp)
+      integer lstgtp(mxgrp),nummols(mxtmls),numgrp(mxtmls)
+      
+c     block indices for groups
+      
+      igrp1 = (idnode*ngrp)/mxnode + 1
+      igrp2 = ((idnode+1)*ngrp)/mxnode
+      
+c     locate site indices of atoms in constraints
+
+      do i = 1,natms
+        listin(i) = 0
+      enddo
+
+c     loop over molecule types
+
+      jr = 0 
+      igrp = 0
+      do itmols=1,ntpmls
+
+c     loop over molecules in system
+        
+        do imols=1,nummols(itmols)
+
+c     construct rigid body site list: each processor has a different copy
+          
+          do lgrp=1,numgrp(itmols)
+            
+            igrp=igrp+1
+            
+            if((igrp.ge.igrp1).and.(igrp.le.igrp2)) then
+                
+              id = lstgtp(igrp)
+              do jj = 1,numgsit(id)
+                  
+                jr = jr +1
+                i = lstrgd(jr)
+                listin(i) = jj
+
+              enddo
+            endif
+          enddo
+        enddo
+      enddo
+
+      lcnb = .true.
+      ik = 0
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+        if(listin(i).ne.0) then
+          ik = ik + 1
+          lstcsit(ik) = listin(i)
+          lcnb = .false.
+        endif
+
+        if(listin(j).ne.0) then
+          ik = ik + 1
+          lstcsit(ik) = listin(j)
+          lcnb = .false.
+        endif
+
+      enddo
+
+c     lcnb flags bodies connected by constraints
+
+      lcnb = (.not.lcnb)
+      
+      return
+      end
+
diff -urN dl_class_1.9.orig/srcmod/setup_module.f dl_class_1.9/srcmod/setup_module.f
--- dl_class_1.9.orig/srcmod/setup_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/setup_module.f	2011-07-11 17:09:10.000000000 +0200
@@ -0,0 +1,1664 @@
+      module setup_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining default array sizes
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c     note the following internal units apply everywhere
+c     
+c     unit of time      (to)    =          1 x 10**(-12) seconds
+c     unit of length    (lo)    =          1 x 10**(-10) metres
+c     unit of mass      (mo)    = 1.6605402  x 10**(-27) kilograms
+c     unit of charge    (qo)    = 1.60217733 x 10**(-19) coulombs
+c     unit of energy    (eo)    = 1.6605402  x 10**(-23) joules
+c     unit of pressure  (po)    = 1.6605402  x 10**(  7) pascals
+c     
+c*********************************************************************
+      
+      use parse_module
+      
+      implicit none
+      
+c     FIXED PARAMETERS
+      
+c     standard pi values
+      
+      real(8), parameter :: pi=3.141592653589793d0
+      real(8), parameter :: sqrpi=1.7724538509055159d0
+      
+c     conversion factor for coulombic terms in internal units
+c     i.e. (unit(charge)**2/(4 pi eps0 unit(length))/unit(energy)
+      
+      real(8), parameter :: r4pie0=138935.4835d0
+      
+c     boltzmann constant in internal units
+      
+      real(8), parameter :: boltz=8.31451115d-1
+      
+c     planck's constant in internal units
+      
+      real(8), parameter :: hbar=6.350780719d0
+      
+c     conversion factor for pressure from internal units to katm
+      
+      real(8), parameter :: prsunt=0.163882576d0
+      
+c     main input channel
+      
+      integer, parameter :: nread=5
+      
+c     main output channel
+      
+      integer, parameter :: nrite=6
+      
+c     force field input channel
+      
+      integer, parameter :: nfield=9
+      
+c     configuration file input channel
+      
+      integer, parameter :: nconf=10
+      
+c     statistical data file output channel
+      
+      integer, parameter :: nstats=20
+      
+c     trajectory history file channel
+      
+      integer, parameter :: nhist=21
+      
+c     acummulators restart dump file
+      
+      integer, parameter :: nrest=22
+      
+c     tabulated potential file channel
+      
+      integer, parameter :: ntable=23
+      
+c     rdf file channel number
+      
+      integer, parameter :: nrdfdt=24
+      
+c     z density file channel number
+      
+      integer, parameter :: nzdndt=25
+      
+c     hyperdynamics reference basin file
+      
+      integer, parameter :: nbsn=30
+      
+c     neb reaction path profile file
+      
+      integer, parameter :: npro=31
+      
+c     hyperdynamics events journal file
+      
+      integer, parameter :: nevnt=33
+      
+c     hyperdynamics tracking file
+      
+      integer, parameter :: ntrk=32
+      
+c     hyperdynamics restart file
+      
+      integer, parameter :: nhrs=35
+      
+c     free energy data file
+      
+      integer, parameter :: nfrnwr=41
+      
+c     solvation data file
+      
+      integer, parameter :: nsolwr=43
+      
+c     data dumping interval in event of system crash
+      
+      integer, parameter :: ndump=1000
+      
+c     maximum number of neb calculations
+      
+      integer, parameter :: maxneb=10
+      
+c     array allocation parameters (set by subroutine parset)
+      
+      integer kmaxa,kmaxb,kmaxc,minnode,msatms,msbad,msgrp
+      integer mspmf,msteth,mxangl,mxatms,mxbond,mxbuff,mxcell
+      integer mxcons,mxdihd,mxewld,mxexcl,mxfbp,mxfld,mxgatm,mxgrid
+      integer mxgrp,mxinv,mxlist,mxlshp,mxneut,mxngp,mxnstk,mxpang
+      integer mxpbnd,mxpdih,mxpfbp,mxpinv,mxpmf,mxproc,mxptbp,mxpvdw
+      integer mxrdf,mxzdn,mxshl,mxsite,mxspmf,mxstak,mxtang,mxtbnd
+      integer mxtbp,mxtcon,mxtdih,mxteth,mxtinv,mxtmls,mxtshl,mxungp
+      integer mxvdw,mxxdf,mx2tbp,mx3fbp,mxebuf,mxquat,mxshak,mxspl
+      integer kmaxd,kmaxe,kmaxf,mxspme,mxftab,mxhko,mxegrd,mxhke
+      integer mxmet,mxsmet,mxpmet,mxter,mxpter,mxatyp,mxxtyp
+      integer mxtmls_fre,mxewld_fre,mxebuf_fre,mxatms_fre,mxatyp_exc
+      integer mxtmls_exc,mxtmls_sol,mxebuf_sol,mxatms_sol
+      
+      save kmaxa,kmaxb,kmaxc,minnode,msatms,msbad,msgrp
+      save mspmf,msteth,mxangl,mxatms,mxbond,mxbuff,mxcell
+      save mxcons,mxdihd,mxewld,mxexcl,mxfbp,mxfld,mxgatm,mxgrid
+      save mxgrp,mxinv,mxlist,mxlshp,mxneut,mxngp,mxnstk,mxpang
+      save mxpbnd,mxpdih,mxpfbp,mxpinv,mxpmf,mxproc,mxptbp,mxpvdw
+      save mxrdf,mxzdn,mxshl,mxsite,mxspmf,mxstak,mxtang,mxtbnd
+      save mxtbp,mxtcon,mxtdih,mxteth,mxtinv,mxtmls,mxtshl,mxungp
+      save mxvdw,mxxdf,mx2tbp,mx3fbp,mxebuf,mxquat,mxshak,mxspl
+      save kmaxd,kmaxe,kmaxf,mxspme,mxftab,mxhko,mxegrd,mxhke
+      save mxmet,mxsmet,mxpmet,mxter,mxpter,mxatyp,mxxtyp
+      save mxtmls_fre,mxewld_fre,mxebuf_fre,mxatms_fre,mxatyp_exc
+      save mxtmls_exc,mxtmls_sol,mxebuf_sol,mxatms_sol
+      
+      contains
+      
+      subroutine parset(redirect,idnode,mxnode,buffer)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine to determine required array sizes for 
+c     allocation of memory manager
+c     
+c     copyright daresbury laboratory 1997
+c     author - w.smith june 1997
+c     
+c***********************************************************************
+      
+      logical loglnk,lewald,lspme,lhke,nolink,lcshft
+      logical lsolva,lfree,lfrmas,lghost,redirect
+      real(8) cell,celprp,rctbp,rcfbp,volm,xhi,yhi,zhi,rcut,rvdw
+      real(8) densvar,delr,cut,dens,ratio,drdf,dzdn,rcter,buffer
+      real(8) zlen
+      integer imcon,nhko,ilx,ily,ilz,ncells
+      integer idnode,mxnode,mxn1
+      
+      dimension cell(9),celprp(10),buffer(10)
+      
+      lhke=.false.
+      lspme=.false.
+      lewald=.false.
+      lcshft=.false.
+      nolink=.false.
+      redirect=.false.
+      mxtmls_sol=1
+      mxebuf_sol=1
+      mxatms_sol=1
+      mxtmls_fre=1
+      mxewld_fre=1
+      mxebuf_fre=1
+      mxatms_fre=1
+      mxatyp_exc=1
+      mxtmls_exc=1
+
+c     specify maximum and minimum nodes
+      
+      mxproc=mxnode
+      minnode=mxnode
+      
+c     scan the FIELD file data
+      
+      call fldscan(idnode,mxn1,rctbp,rcfbp,rcter)
+      
+c     scan CONFIG file data
+      
+      call cfgscan
+     x  (idnode,nconf,imcon,volm,xhi,yhi,zhi,cell,buffer)
+      
+c     scan CONTROL file data
+      
+      call conscan
+     x  (redirect,lewald,lspme,lhke,nolink,lcshft,lsolva,lfree,lfrmas,
+     x  lghost,idnode,imcon,nhko,rcut,rvdw,delr,densvar,drdf,dzdn,
+     x  zlen,cell)
+      
+c     set dimension of working coordinate arrays
+      
+      msatms=max(1,(mxatms+minnode-1)/minnode)
+      if(lsolva)mxatms_sol=mxatms
+      if(lfree.or.lghost)mxatms_fre=mxatms
+      
+c     maximum number of molecule types
+      
+      mxtmls=max(mxtmls,1)
+      if(lsolva)mxtmls_sol=mxtmls
+      if(lfree)mxtmls_fre=mxtmls
+      if(lghost)then
+        
+        mxtmls_exc=mxtmls
+        mxtmls_fre=mxtmls
+        
+      endif
+      
+c     maximum number of specified bondlength constraints
+      
+      mxtcon=max(mxtcon,1)
+      
+c     maximum number of chemical bond potentials
+      
+      mxtbnd=max(mxtbnd,1)
+      
+c     maximum number of different bond angle potentials
+      
+      mxtang=max(mxtang,1)
+      
+c     maximum number of different torsional potentials
+      
+      mxtdih=max(mxtdih,1)
+      
+c     maximum number of different inversion potentials
+      
+      mxtinv=max(mxtinv,1)
+      
+c     maximum number of unique rigid body units
+      
+      mxungp=max(mxungp,1)
+      
+c     maximum number of tethered atom potentials
+      
+      mxteth=max(mxteth,1)
+      
+c     maximum number of core-shell units
+      
+      mxshl=max(mxshl,1)
+      
+c     set maximum number of unique atom types
+      
+      mxatyp=max(1,mxatyp)
+      mxxtyp=(mxatyp*(mxatyp+1))/2
+      if(lghost)mxatyp_exc=mxatyp
+      
+c     maximum number of vdw potentials
+      
+      mxvdw=max(mxvdw,1)+1
+      
+c     maximum number of metal potentials
+      
+      mxmet=max(mxmet,1)+1
+      mxsmet=mxatyp
+      
+c     maximum number of tersoff potentials
+      
+      if(mxter.gt.0)then
+        
+        mxter=mxatyp
+        
+      endif
+      
+c     maximum number of three body potentials
+      
+      if(mxtbp.eq.0)then
+        
+        mx2tbp=0
+        
+      else
+        
+        mx2tbp=(mxatyp*(mxatyp+1))/2
+        mxtbp=mx2tbp*mxatyp
+        
+      endif
+      
+c     maximum number of four body potentials
+      
+      if(mxfbp.eq.0)then
+        
+        mx3fbp=0
+        
+      else
+        
+        mx3fbp=(mxatyp*(mxatyp+1)*(mxatyp+2))/6
+        mxfbp=mxatyp*mx3fbp
+        
+      endif
+      
+c     maximum number of angular potential parameters
+
+      mxpang=6
+
+c     maximum number of three body potential parameters
+      
+      mxptbp=mxpang+1
+      
+c     maximum number of four body potential parameters
+      
+      mxpfbp=3
+      
+c     maximum number of parameters for dihedrals
+      
+      mxpdih=5
+      
+c     maximum number of parameters for inversion potentials
+      
+      mxpinv=2
+      
+c     maximum number of parameters for bond potentials
+      
+      mxpbnd=4
+      
+c     maximum number of parameters for vdw potentials
+      
+      mxpvdw=6
+      
+c     maximum number of parameters for metal potentials
+      
+      mxpmet=7
+      
+c     maximum number of parameters for tersoff potential
+      
+      mxpter=11
+      
+c     maximum number of external field parameters
+      
+      mxfld=10
+      
+c     maximum number of excluded atoms per atom
+      
+      mxexcl=max(mxexcl,1)
+      
+c     maximum number of different sites in system
+      
+      mxsite=max(mxsite,1)
+      
+c     maximum number of chemical bonds per node
+      
+      mxbond=max(1,(mxbond+minnode-1)/minnode)
+      
+c     maximum number of bond angles per node
+      
+      mxangl=max(1,(mxangl+minnode-1)/minnode)
+      
+c     maximum number of torsion angles per node
+      
+      mxdihd=max(1,(mxdihd+minnode-1)/minnode)
+      
+c     maximum number of inversion potentials per node
+      
+      mxinv=max(1,(mxinv+minnode-1)/minnode)
+      
+c     maximum number of constraints per node
+      
+      mxcons=max(1,2*((mxcons+minnode-1)/minnode))
+      
+c     maximum number of tethered atoms per node
+      
+      msteth=max(1,(msteth+minnode-1)/minnode)
+      
+c     maximum size for working arrays for bonds, angles, dihedrals
+c     inversion potentials, tethers and core-shell units
+      
+      msbad=max(mxbond,mxangl,mxdihd,mxinv,msteth,mxshl)
+      
+c     maximum number of grid points in potentials arrays
+      
+      if(mxgrid.eq.0)then
+        
+        mxgrid=max(1000,int(rvdw/0.01d0+0.5d0)+4)
+        
+      endif
+      
+      mxegrd=0
+      if(lewald.or.lspme.or.lhke.or.lcshft)mxegrd=mxgrid
+      
+c     maximum dimension of rdf arrays
+      
+      mxrdf=max(128,int(rcut/drdf))
+      
+c     maximum dimension of zdensity arrays
+      
+      mxzdn=max(128,int(zlen/dzdn))
+      
+c     maximum number of rigid groups in system
+      
+      mxgrp=max(mxgrp,1)
+      
+c     maximum number of rigid groups per node
+      
+      msgrp=max(1,(mxgrp+minnode-1)/minnode)
+      
+c     maximum number of sites per rigid unit
+      
+      mxngp=max(mxngp,3)
+      
+c     maximum number of sites in rigid units
+      
+      mxgatm=max(1,mxgatm)
+      
+c     maximum number of timesteps in stack arrays
+      
+      mxstak=max(100,mxstak)
+      
+c     maximum number of variables in stack arrays
+      
+      mxnstk=45+mxatyp
+      
+c     dimension of shake shared atoms array
+      
+      mxlshp=max(mxcons*2,1)
+      
+c     set dimension of working arrays in ewald sum
+      
+      mxewld=1
+      mxebuf=1
+      if(lewald)then
+        
+        mxftab=1
+        mxewld=msatms
+        mxebuf=(2*kmaxa+1)*(2*kmaxb+1)*(2*kmaxc+1)-1
+        if(lfree.or.lghost)mxebuf=3*mxebuf
+        if(mxnode.le.16.and.mxebuf.le.5000)mxebuf=1
+        
+      endif
+      
+c     set dimension of working arrays in spme
+      
+      mxspme=1
+      if(lspme)then
+        
+        mxspme=mxatms
+        mxftab=2*(kmaxd+kmaxe+kmaxf)
+        
+      endif
+      
+c     set dimension of working arrays for HK ewald
+      
+      mxhko=1
+      mxhke=1
+      if(lhke)then
+        
+        mxhko=2
+        mxewld=msatms
+        mxhke=msatms
+        if(nhko.gt.0)mxhko=max(2,nhko)
+        mxebuf=(2*kmaxa+1)*(2*kmaxb+1)-1
+        if(mxnode.le.16.and.mxebuf.le.5000)mxebuf=1
+        
+      endif
+      
+      if(lsolva)mxebuf_sol=mxebuf
+      if(lfree.or.lghost)then
+        
+        mxebuf_fre=mxebuf
+        mxewld_fre=mxewld
+        
+      endif
+
+c     maximum dimension of principal transfer buffer
+      
+      mxbuff=max(6*mxatms,8*(mxcons+1),8*(mxgrp+1),mxnstk*mxstak,
+     x  mxebuf,mxgrid,2*kmaxa*kmaxb*kmaxc,2*kmaxd*kmaxe*kmaxf,
+     x  10000)
+      
+c     maximum size of verlet neighbour/link cell list for each atom
+c     decide if link-cells in use or not
+      
+      cut=rcut+delr
+      dens=dble(mxatms)/volm
+      ratio=1.5d0*dens*(4.d0*pi/3.d0)*cut**3
+      mxlist=min(nint(ratio),(mxatms+1)/2)
+      if(imcon.eq.0) then
+        
+        cell(1)=max(xhi+2.d0*cut,3.d0*cut)
+        cell(5)=max(yhi+2.d0*cut,3.d0*cut)
+        cell(9)=max(zhi+2.d0*cut,3.d0*cut)
+        
+      endif
+      if(imcon.eq.6)then
+        
+        cell(9)=max(zhi+2.d0*cut,3.d0*cut,cell(9))
+        
+      endif
+      
+      if(nolink)then
+        
+        loglnk=.false.
+        
+      else
+        
+        loglnk=.true.
+        call dcell(cell,celprp)
+        ilx=int(celprp(7)/cut)
+        ily=int(celprp(8)/cut)
+        ilz=int(celprp(9)/cut)
+        if(ilx.lt.3.or.ily.lt.3.or.ilz.lt.3)loglnk=.false.
+        ncells=ilx*ily*ilz
+        if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7)loglnk=.false.
+        if(mxneut.gt.0.and.ncells.le.36) loglnk=.false.
+        
+      endif
+      
+      mxcell=1
+      if(loglnk)then
+        
+        mxlist=14*nint(1.5d0*dens*celprp(10)/dble(ncells))
+        mxcell=(ilx+2)*(ily+2)*(ilz+2)
+        
+      endif
+      
+      if(mxneut.gt.0)mxlist=(mxneut+1)/2
+      mxlist=2*mxlist
+      if(mxtbp.gt.0.or.mxfbp.gt.0.or.mxter.gt.0)then
+        
+        if(mxtbp.gt.0)cut=min(cut,rctbp)
+        if(mxfbp.gt.0)cut=min(cut,rcfbp)
+        if(mxter.gt.0)cut=min(cut,rcter)
+        ilx=max(3,int(celprp(7)/cut))
+        ily=max(3,int(celprp(8)/cut))
+        ilz=max(3,int(celprp(9)/cut))
+        mxcell=max(mxcell,(ilx+2)*(ily+2)*(ilz+2))
+        
+      endif
+      mxcell=int(dble(mxcell)*densvar/100.d0)
+      mxlist=int(dble(mxlist)*densvar/100.d0)
+      mxlist=max(500,mxlist)
+      
+c     maximum size for coordinate difference arrays
+      
+      mxxdf=max(mxlist,mxatms,mxcons,mxn1*mxn1*(mxneut+1)/2)
+      
+c     maximum number of core-shell unit types
+      
+      mxtshl=max(mxtshl,1)
+      
+c     potential of mean force array parameter
+      
+      mxpmf=max(mxpmf,1)
+      
+c     number of pmf constraints on a processor
+      
+      mspmf=max(1,(mxpmf+minnode-1)/minnode)
+      
+c     maximum number of sites to define pmf units
+      
+      mxspmf=max(mxspmf,1)
+      
+c     maximum iterations in quaternion integration
+      
+      mxquat=100
+      
+c     maximum number of shake cycles
+      
+      mxshak=100
+      
+c     maximum b-spline interpolation order
+      
+      mxspl=12
+      
+c     increment mxneut
+      
+      if(mxneut.gt.0)mxneut=mxneut+1
+      
+      return
+      
+      end subroutine parset
+      
+      subroutine fldscan(idnode,mxn1,rctbp,rcfbp,rcter)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for scanning the field file to determine the
+c     required parameters
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith  november   1994
+c     
+c***********************************************************************
+      
+      integer, parameter :: mmk=1000
+      
+      character*8 name,keyword,chr(mmk)
+      logical check,ltable,lmetab,safe,lneut,loop1,loop2
+      real(8) rctbp,rcter,rcfbp,rct,ppp
+      integer mxn1,nxn1,idnode,nold
+      integer itmols,ksite,numsit,isite,nrept,ifrz,i,j
+      integer ishls,ibonds,numcon,numang,icon,iang,idih,numdih
+      integer numinv,iinv,numgrp,kgrp,numgsit,numteth,iteth
+      integer ipmf,jpmf,npmf,itpvdw,itptbp,itpfbp
+      integer itpter,k,nfld,nummols,idum,numshl,nneu
+      integer numbonds,itpmet,iii,ngrid
+      
+      mxtmls=0
+      mxatms=0
+      mxgrp=0
+      mxtcon=0
+      mxtbnd=0
+      mxtang=0
+      mxtdih=0
+      mxtinv=0
+      mxpmf=0
+      mxspmf=0
+      mxungp=0
+      mxngp=0
+      mxneut=0
+      mxmet=0
+      mxatyp=0
+      mxn1=0
+      nxn1=0
+      nold=-1
+      mxgatm=0
+      mxteth=0
+      msteth=0
+      mxvdw=0
+      mxtbp=0
+      mxter=0
+      mxexcl=0
+      mxsite=0
+      mxbond=0
+      mxcons=0
+      mxangl=0
+      mxdihd=0
+      mxinv=0
+      mxshl=0
+      mxtshl=0
+      mxfbp=0
+      mxgrid=0 
+      rctbp=0.d0
+      rcter=0.d0
+      rcfbp=0.d0
+      safe=.true.
+      loop1=.true.
+      loop2=.true.
+      lneut=.false.
+      ltable=.false.
+      lmetab=.false.
+      
+c     open force field data file
+      
+      if(idnode.eq.0)open (nfield,file='FIELD')
+      
+      call getrec(safe,idnode,nfield)
+      if(.not.safe)call abortscan(52,idnode)
+      
+c     read and process directives from field file
+      
+      do while(loop1)
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)call abortscan(52,idnode)
+        call lowcase(record,lenrec)
+        
+        if(findstring('neut',record,idum))then
+          
+          lneut=.true.
+          
+        elseif(findstring('molecu',record,idum))then
+          
+          mxtmls=intstr(record,lenrec,idum)
+          
+          do itmols=1,mxtmls
+            
+            loop2=.true.
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            
+            do while(loop2)
+              
+              call getrec(safe,idnode,nfield)
+              if(.not.safe)call abortscan(52,idnode)
+              call lowcase(record,lenrec)
+              
+              ksite=0
+              
+              if(findstring('nummol',record,idum))then
+                
+                nummols=intstr(record,lenrec,idum)
+                
+              elseif(findstring('atoms',record,idum))then
+                
+                numsit=intstr(record,lenrec,idum)
+                mxatms=mxatms+numsit*nummols
+                mxsite=mxsite+numsit
+                ksite=0
+                do isite=1,numsit
+                  
+                  if(ksite.lt.numsit)then
+                    
+                    call getrec(safe,idnode,nfield)
+                    if(.not.safe)call abortscan(52,idnode)
+                    
+                    call getword(name,record,8,lenrec)
+                    ppp=dblstr(record,lenrec,idum)
+                    ppp=dblstr(record,lenrec,idum)
+                    nrept=intstr(record,lenrec,idum)
+                    ifrz=intstr(record,lenrec,idum)
+                    nneu=intstr(record,lenrec,idum)
+                    if(nrept.eq.0)nrept=1
+                    if(lneut)then
+                      if(nneu.ne.nold) nxn1=0
+                      nxn1=nxn1+nrept
+                      mxn1=max(mxn1,nxn1)
+                      nold=nneu
+                    endif
+                    
+                    if(mxatyp.eq.0)then
+                      
+                      mxatyp=1
+                      chr(1)=name
+                      
+                    else
+                      
+                      check=.true.
+                      do j=1,mxatyp
+                        
+                        if(name.eq.chr(j))check=.false.
+                        
+                      enddo
+                      if(check)then
+                        
+                        mxatyp=mxatyp+1
+                        if(mxatyp.le.mmk)chr(mxatyp)=name
+                        
+                      endif
+                      
+                    endif
+                    if(nrept.eq.0)nrept=1
+                    ksite=ksite+nrept
+                    
+                  endif
+                  
+                enddo
+                
+                if(mmk.lt.mxatyp)call abortscan(34,idnode)
+                
+                if(lneut)mxneut=mxneut+nneu*nummols
+                
+              elseif(findstring('shell',record,idum))then
+                
+                numshl=intstr(record,40,idum)
+                mxtshl=mxtshl+numshl
+                mxshl=mxshl+nummols*numshl
+                
+                do ishls=1,numshl
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('bonds',record,idum))then
+                
+                numbonds=intstr(record,lenrec,idum)
+                mxtbnd=mxtbnd+numbonds
+                mxbond=mxbond+nummols*numbonds
+                
+                do ibonds=1,numbonds
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('constr',record,idum))then
+                
+                numcon=intstr(record,lenrec,idum)
+                mxtcon=mxtcon+numcon
+                mxcons=mxcons+nummols*numcon
+                
+                do icon=1,numcon
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('angles',record,idum))then
+                
+                numang=intstr(record,lenrec,idum)
+                mxtang=mxtang+numang
+                mxangl=mxangl+nummols*numang
+                
+                do iang=1,numang
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('dihedr',record,idum))then
+                
+                numdih=intstr(record,lenrec,idum)
+                mxtdih=mxtdih+numdih
+                mxdihd=mxdihd+nummols*numdih
+                
+                do idih=1,numdih
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('invers',record,idum))then
+                
+                numinv=intstr(record,lenrec,idum)
+                mxtinv=mxtinv+numinv
+                mxinv=mxinv+nummols*numinv
+                
+                do iinv=1,numinv
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('rigid',record,idum))then
+                
+                numgrp=intstr(record,lenrec,idum)
+                mxungp=mxungp+numgrp
+                mxgrp=mxgrp+numgrp*nummols
+                
+                do kgrp=1,numgrp
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                  numgsit=intstr(record,lenrec,idum)
+                  mxgatm=mxgatm+numgsit*nummols
+                  mxngp=max(mxngp,numgsit)
+                  do j=1,numgsit
+                    
+                    iii=intstr(record,lenrec,idum)
+                    if(iii.eq.0)then
+                      call getrec(safe,idnode,nfield)
+                      if(.not.safe)call abortscan(52,idnode)
+                      iii=intstr(record,lenrec,idum)
+                    endif
+                    
+                  enddo
+                  
+                enddo
+                
+              elseif(findstring('teth',record,idum))then
+                
+                numteth=intstr(record,lenrec,idum)
+                mxteth=mxteth+numteth
+                msteth=msteth+numteth*nummols
+                
+                do iteth=1,numteth
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  
+                enddo
+                
+              elseif(findstring('pmf',record,idum))then
+                
+                do ipmf=1,2
+                  
+                  call getrec(safe,idnode,nfield)
+                  if(.not.safe)call abortscan(52,idnode)
+                  call lowcase(record,lenrec)
+                  npmf=intstr(record,lenrec,idum)
+                  mxspmf=mxspmf+npmf
+                  
+                  do jpmf=1,npmf
+                    
+                    call getrec(safe,idnode,nfield)
+                    if(.not.safe)call abortscan(52,idnode)
+                    
+                  enddo
+                  
+                enddo
+                
+                mxpmf=mxpmf+nummols
+                
+              elseif(findstring('finish',record,idum))then
+                
+                loop2=.false.
+                
+              endif
+              
+            enddo
+            
+          enddo
+          
+        elseif(findstring('vdw',record,idum))then
+          
+          if(findstring('tab',record,idum))ltable=.true.
+          mxvdw=intstr(record,lenrec,idum)
+          do itpvdw=1,mxvdw
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            call lowcase(record,lenrec)
+            if(findstring('tab',record,idum))ltable=.true.
+            
+          enddo
+          mxvdw=max(mxvdw,(mxatyp*(mxatyp+1))/2)
+          
+          if(ltable)then
+            
+            if(idnode.eq.0)open(ntable,file='TABLE')
+            
+            call getrec(safe,idnode,ntable)
+            if(.not.safe)call abortscan(24,idnode)
+            call getrec(safe,idnode,ntable)
+            if(.not.safe)call abortscan(24,idnode)
+            ppp=dblstr(record,lenrec,idum)
+            ppp=dblstr(record,lenrec,idum)
+            mxgrid=max(mxgrid,intstr(record,lenrec,idum))
+            
+            close (ntable)
+            
+          endif
+          
+        elseif(findstring('metal',record,idum))then
+          
+          if(findstring('eam',record,idum))lmetab=.true.
+          mxmet=intstr(record,lenrec,idum)
+          do itpmet=1,mxmet
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            call lowcase(record,lenrec)
+            if(findstring('eam',record,idum))lmetab=.true.
+            
+          enddo
+          mxmet=max(mxmet,(mxatyp*(mxatyp+1))/2)
+          
+          if(lmetab)then
+            
+            if(idnode.eq.0)open(ntable,file='TABEAM')
+            
+            call getrec(safe,idnode,ntable)
+            if(.not.safe)call abortscan(24,idnode)
+            call getrec(safe,idnode,ntable)
+            if(.not.safe)call abortscan(24,idnode)
+            do i=1,intstr(record,lenrec,idum)
+              
+              call getrec(safe,idnode,ntable)
+              if(.not.safe)call abortscan(24,idnode)
+              ngrid=intstr(record,lenrec,idum)
+              mxgrid=max(mxgrid,ngrid+4)
+              do j=1,(ngrid+3)/4
+                
+                call getrec(safe,idnode,ntable)
+                if(.not.safe)call abortscan(24,idnode)
+                
+              enddo
+              
+            enddo
+            
+            close (ntable)
+            
+          endif
+          
+        elseif(findstring('tbp',record,idum))then
+          
+          mxtbp=intstr(record,lenrec,idum)
+          
+          do itptbp=1,mxtbp
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            call getword(name,record,8,lenrec)
+            call getword(name,record,8,lenrec)
+            call getword(name,record,8,lenrec)
+            call getword(keyword,record,4,lenrec)
+            ppp=dblstr(record,lenrec,idum)
+            ppp=dblstr(record,lenrec,idum)
+            ppp=dblstr(record,lenrec,idum)
+            ppp=dblstr(record,lenrec,idum)
+            rct=dblstr(record,lenrec,idum)
+            rctbp=max(rctbp,rct)
+            
+          enddo
+          
+        elseif(findstring('fbp',record,idum))then
+          
+          mxfbp=intstr(record,lenrec,idum)
+          do itpfbp=1,mxfbp
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            call getword(name,record,8,lenrec)
+            call getword(name,record,8,lenrec)
+            call getword(name,record,8,lenrec)
+            call getword(name,record,8,lenrec)
+            call getword(keyword,record,4,lenrec)
+            ppp=dblstr(record,lenrec,idum)
+            ppp=dblstr(record,lenrec,idum)
+            rct=dblstr(record,lenrec,idum)
+            rcfbp=max(rcfbp,rct)
+            
+          enddo
+          
+        elseif(findstring('tersof',record,idum))then
+          
+          mxter=intstr(record,lenrec,idum)
+          
+          do itpter=1,mxter
+            
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            call getrec(safe,idnode,nfield)
+            if(.not.safe)call abortscan(52,idnode)
+            rct=dblstr(record,lenrec,idum)
+            rcter=max(rcter,rct)
+            
+          enddo
+          
+        elseif(findstring('extern',record,idum))then
+          
+          call getrec(safe,idnode,nfield)
+          if(.not.safe)call abortscan(52,idnode)
+          nfld=intstr(record,lenrec,idum)
+          if(nfld.eq.0)nfld=5
+          call getrec(safe,idnode,nfield)
+          if(.not.safe)call abortscan(52,idnode)
+          
+          do k=1,nfld
+            
+            ppp=dblstr(record,lenrec,idum)
+            if(idum.gt.lenrec.and.k.lt.nfld)then
+              call getrec(safe,idnode,nfield)
+              if(.not.safe)call abortscan(52,idnode)
+            endif
+            
+          enddo
+          
+        elseif(findstring('close',record,idum))then
+          
+          loop1=.false.
+          
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)close (nfield)
+      
+      if(mxpmf.gt.0)mxpmf=mxatms
+      if(mxtcon.gt.0)mxexcl=max(mxexcl,6)
+      if(mxtbnd.gt.0)mxexcl=max(mxexcl,6)
+      if(mxtang.gt.0)mxexcl=max(mxexcl,16)
+      if(mxtdih.gt.0)mxexcl=max(mxexcl,50)
+      if(mxtinv.gt.0)mxexcl=max(mxexcl,50)
+      if(mxneut.gt.0)mxexcl=max(mxexcl,10*mxn1*mxn1)
+      if(mxgrp.gt.0)mxexcl=max(mxexcl,mxngp)
+      
+      return
+      
+      end subroutine fldscan
+      
+      subroutine cfgscan
+     x  (idnode,nconf,imcon,volm,xhi,yhi,zhi,cell,buffer)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for scanning the initial configuration
+c     file to determine the number of atoms present
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith  june       1997
+c     
+c     note: volm is volume containing all particles, not system volume
+c     
+c***********************************************************************
+      
+      character*80 header
+      character*8 name
+      logical lvolm
+      real(8) cell,celprp,buffer,extra,volm,xhi,yhi,zhi
+      real(8) xxx,yyy,zzz,uuu,vvv,www,coz
+      integer idnode,nconf,imcon,i,levcfg
+      dimension cell(9),celprp(10),buffer(10),extra(5)
+      
+      imcon=0
+      xhi=0.d0
+      yhi=0.d0
+      zhi=0.d0
+      volm=0.d0
+      do i=1,9
+        
+        cell(i)=0.d0
+        
+      enddo
+      if(idnode.eq.0)then
+        
+        open (nconf,file='CONFIG')
+        
+c     read the CONFIG file header
+        
+        read(nconf,'(a80)',end=100)header
+        read(nconf,'(2i10)',end=100)levcfg,imcon
+        lvolm=(imcon.eq.0.or.imcon.eq.6)
+        
+c     specify molecular dynamics simulation cell
+        
+        if(imcon.gt.0)then
+          
+          read(nconf,'(3f20.0)',end=100)cell(1),cell(2),cell(3)
+          read(nconf,'(3f20.0)',end=100)cell(4),cell(5),cell(6)
+          read(nconf,'(3f20.0)',end=100)cell(7),cell(8),cell(9)
+          call dcell(cell,celprp)
+          
+        endif
+        
+        if(.not.lvolm)then
+          
+          volm=celprp(10)
+          
+          if(imcon.eq.4)then
+            
+            volm=0.5d0*celprp(10)
+            
+          elseif(imcon.eq.5)then
+            
+            volm=0.5d0*celprp(10)
+            
+          elseif(imcon.eq.7)then
+            
+            volm=0.5d0*celprp(10)
+            
+          endif
+          
+        endif
+        
+        i=0
+        do while(.true.)
+          
+          i=i+1
+          if(levcfg.eq.0)then
+            
+            read(nconf,'(a8)',end=100) name
+            read(nconf,'(3f20.0)')xxx,yyy,zzz
+            
+          else if(levcfg.eq.1)then
+            
+            read(nconf,'(a8)',end=100) name
+            read(nconf,'(3f20.0)')xxx,yyy,zzz
+            read(nconf,'(3f20.0)')uuu,vvv,www
+            
+          else
+            
+            read(nconf,'(a8)',end=100) name
+            read(nconf,'(3f20.0)')xxx,yyy,zzz
+            read(nconf,'(3f20.0)')uuu,vvv,www
+            read(nconf,'(3f20.0)')uuu,vvv,www
+            
+          endif
+          
+          if(lvolm)then
+            
+            if(i.eq.1)then
+              
+              xhi=abs(xxx)
+              yhi=abs(yyy)
+              zhi=abs(zzz)
+              
+            else
+              
+              xhi=max(xhi,abs(xxx))
+              yhi=max(yhi,abs(yyy))
+              zhi=max(zhi,abs(zzz))
+              
+            endif
+            
+          endif
+          
+        enddo
+        
+  100   continue
+        
+        if(imcon.eq.0)then
+          
+          volm=8.d0*xhi*yhi*zhi
+          
+        else if(imcon.eq.6)then
+          
+          coz=(cell(1)*cell(4)+cell(2)*cell(5)+cell(3)*cell(6))/
+     x      (celprp(1)*celprp(2))
+          volm=2.d0*zhi*celprp(1)*celprp(2)*sqrt(1.d0-coz**2)
+          
+        endif
+        
+        close (nconf)
+        
+      endif
+      
+      extra(1)=dble(imcon)
+      extra(2)=xhi
+      extra(3)=yhi
+      extra(4)=zhi
+      extra(5)=volm
+      call gdsum(extra,5,buffer)
+      call gdsum(cell,9,buffer)
+      imcon=nint(extra(1))
+      xhi=extra(2)
+      yhi=extra(3)
+      zhi=extra(4)
+      volm=extra(5)
+      
+      return
+      
+      end subroutine cfgscan
+      
+      subroutine conscan
+     x  (redirect,lewald,lspme,lhke,nolink,lcshft,lsolva,lfree,lfrmas,
+     x  lghost,idnode,imcon,nhko,rcut,rvdw,delr,densvar,drdf,dzdn,
+     x  zlen,cell)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for scanning the contents of the control file
+c     
+c     copyright - daresbury laboratory 1997
+c     author    - w. smith  june       1997
+c     
+c***********************************************************************
+      
+      logical safe,lewald,lspme,lhke,peek,nolink,lcshft,lmetad
+      logical lsolva,lfree,lfrmas,lghost,redirect
+      real(8) cell,celprp,rcut,rvdw,delr,eps,alpha,fac,tol,tol1
+      real(8) densvar,drdf,dzdn,zlen
+      integer nhko,idnode,imcon,idum,jmp
+      integer nlatt,kmax1,kmax2,kmax3,kmaxpow2
+      dimension celprp(10),cell(9)
+      
+      nhko=0
+      mxstak=0
+      kmaxa=0
+      kmaxb=1
+      kmaxc=1
+      kmaxd=1
+      kmaxe=1
+      kmaxf=1
+      rcut=0.d0
+      rvdw=0.d0
+      delr=0.d0
+      drdf=0.05d0
+      dzdn=0.05d0
+      zlen=0.d0
+      densvar=1.d2
+      peek=.true.
+      lhke=.false.
+      lspme=.false.
+      lewald=.false.
+      lcshft=.false.
+      nolink=.false.
+      lghost=.false.
+      lfree=.false.
+      lfrmas=.false.
+      lsolva=.false.
+      lmetad=.false.
+      redirect=.false.
+      
+c     open the simulation input file
+      
+      if(idnode.eq.0)open (nread,file='CONTROL')
+      
+      call getrec(safe,idnode,nread)
+      if(.not.safe)call abortscan(17,idnode)
+      
+      do while(peek)
+        
+        call getrec(safe,idnode,nread)
+        if(.not.safe)call abortscan(17,idnode)
+        call lowcase(record,lenrec)
+        if(record(1).ne.'#')then
+          
+          if(findstring('stack',record,idum))then
+            
+            mxstak=intstr(record,lenrec,idum)
+            
+          elseif(findstring('no link',record,idum))then
+            
+            nolink=.true.
+            
+          elseif(findstring('metafreeze',record,idum))then
+            
+            lmetad=.true.
+            do while(lmetad)
+              call getrec(safe,idnode,nread)
+              if(.not.safe)call abortscan(17,idnode)
+              call lowcase(record,lenrec)
+              lmetad=.not.findstring('endmet',record,idum)
+            enddo
+            
+          elseif(findstring('redirect',record,idum))then
+            
+            redirect=.true.
+            
+          elseif(findstring('densvar',record,idum))then
+            
+            densvar=dblstr(record,lenrec,idum)
+            
+          elseif(findstring('shift',record,idum).or.
+     x        findstring('reaction',record,idum))then
+            
+            lcshft=.true.
+            
+          elseif(findstring('ewald',record,idum).or.
+     x        findstring('spme',record,idum).or.
+     x        findstring('hke',record,idum))then
+            
+c     read Ewald or HK-Ewald or SPM-Ewald sum parameters
+            
+            lhke=findstring('hke',record,idum)
+            lspme=findstring('spme',record,idum)
+            lewald=findstring('ewald',record,idum)
+            
+            if(findstring('precision',record,idum))then
+              
+              eps=dblstr(record,lenrec,idum)
+              if(lhke) then
+                
+                nhko=intstr(record,lenrec,idum)
+                nlatt=intstr(record,lenrec,idum)
+                nlatt=min(nlatt,2)
+                
+              endif
+              
+              if(rcut.lt.1.d-6)rcut=10.d0
+              
+c     compute alpha and the kmax
+              
+              if(lewald.or.lspme)then
+                
+                call dcell(cell,celprp)
+                eps=min(abs(eps),0.5d0)
+                tol=sqrt(abs(log(eps*rcut)))
+                alpha=sqrt(abs(log(eps*rcut*tol)))/rcut
+                tol1=sqrt(-log(eps*rcut*(2.d0*tol*alpha)**2))
+                fac=1.d0
+                if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7) 
+     x            fac=2.d0**(1.d0/3.d0)
+                kmax1=nint(0.25d0+fac*celprp(1)*alpha*tol1/pi)
+                kmax2=nint(0.25d0+fac*celprp(2)*alpha*tol1/pi)
+                kmax3=nint(0.25d0+fac*celprp(3)*alpha*tol1/pi)
+                
+              elseif(lhke)then
+                
+                if(nhko.eq.0)then
+                  if(eps.le.1.d-6)then
+                    alpha=3.46d0/rcut
+                  elseif(eps.le.1.d-5)then
+                    alpha=3.14d0/rcut
+                  else
+                    alpha=2.76d0/rcut
+                  endif
+                elseif(nhko.eq.1)then
+                  if(eps.le.1.d-6)then
+                    alpha=4.37d0/rcut
+                  elseif(eps.le.1.d-5)then
+                    alpha=4.08d0/rcut
+                  else
+                    alpha=3.75d0/rcut
+                  endif                
+                elseif(nhko.eq.2)then
+                  if(eps.le.1.d-6)then
+                    alpha=5.01d0/rcut
+                  elseif(eps.le.1.d-5)then
+                    alpha=4.74d0/rcut
+                  else
+                    alpha=4.44d0/rcut
+                  endif
+                elseif(nhko.eq.3)then
+                  if(eps.le.1.d-6)then
+                    alpha=5.55d0/rcut
+                  elseif(eps.le.1.d-5)then
+                    alpha=5.28d0/rcut
+                  else
+                    alpha=5.00d0/rcut
+                  endif
+                endif
+                alpha=alpha/dble(2*nlatt+1)
+                if(abs(cell(9)).lt.1.d-8)cell(9)=1.d0
+                call dcell(cell,celprp)
+                tol=2.d0*alpha*sqrt(abs(log(eps*alpha)))
+                tol1=2.d0*alpha*sqrt(abs(log(eps*alpha*tol)))
+                kmax1=nint(0.25d0+0.5d0*celprp(1)*tol1/pi)
+                kmax2=nint(0.25d0+0.5d0*celprp(2)*tol1/pi)
+                kmax3=1
+                
+              endif
+              
+            else
+              
+              alpha=dblstr(record,lenrec,idum)
+              kmax1=intstr(record,lenrec,idum)
+              kmax2=intstr(record,lenrec,idum)
+              
+              if(lhke)then
+                
+                kmax3=1
+                nhko=intstr(record,lenrec,idum)
+                
+              else
+                
+                kmax3=intstr(record,lenrec,idum)
+                
+              endif
+              
+            endif
+            
+c     for spme double kmax and set to next power of 2, with current
+c     upper limit of 512
+            
+            if(lspme)then
+              
+              kmaxpow2=1
+              do while (kmax1.gt.kmaxpow2.and.kmaxpow2.lt.256)
+                kmaxpow2=kmaxpow2 * 2
+              end do
+              kmaxd=2 * kmaxpow2
+              
+              kmaxpow2=1
+              do while (kmax2.gt.kmaxpow2.and.kmaxpow2.lt.256)
+                kmaxpow2=kmaxpow2 * 2
+              end do
+              kmaxe=2 * kmaxpow2
+              
+              kmaxpow2=1
+              do while (kmax3.gt.kmaxpow2.and.kmaxpow2.lt.256)
+                kmaxpow2=kmaxpow2 * 2
+              end do
+              kmaxf=2 * kmaxpow2
+              
+            elseif(lhke) then
+              
+              kmaxa=kmax1
+              kmaxb=kmax2
+              kmaxc=1
+              
+            else
+              
+              kmaxa=kmax1
+              kmaxb=kmax2
+              kmaxc=kmax3
+              
+            endif
+            
+          elseif(findstring('cut',record,idum))then
+            
+            rcut=dblstr(record,lenrec,idum)
+            
+          elseif(findstring('rvdw',record,idum))then
+            
+            rvdw=dblstr(record,lenrec,idum)
+            
+          elseif(findstring('delr',record,idum))then
+            
+            delr=dblstr(record,100,idum)
+            
+          else if(findstring('rdf',record,idum))then
+            
+            if(.not.findstring('print',record,idum))then
+              
+              jmp=intstr(record,lenrec,idum)
+              drdf=dblstr(record,lenrec,idum)
+              
+            endif
+            
+          else if(findstring('zden',record,idum))then
+            
+            jmp=intstr(record,lenrec,idum)
+            dzdn=dblstr(record,lenrec,idum)
+            zlen=dblstr(record,lenrec,idum)
+            if(dzdn.lt.1.d-8)then
+              
+              dzdn=0.1d0
+              zlen=0.1d0*dble(128)
+              
+            elseif(zlen.lt.1.d-8)then
+              
+              zlen=dzdn*dble(128)
+              
+            endif
+            
+          elseif(findstring('solva',record,idum))then
+            
+            lsolva=.true.
+            
+          elseif(findstring('decomp',record,idum))then
+            
+            lsolva=.true.
+            
+          elseif(findstring('free',record,idum))then
+            
+            lfree=.true.
+            
+          elseif(findstring('excit',record,idum))then
+            
+            lghost=.true.
+            lsolva=.true.
+            
+          elseif(findstring('reset_mass',record,idum))then
+            
+            lfrmas=.true.
+            
+          elseif(findstring('switch',record,idum))then
+            
+            lghost=.true.
+            lsolva=.true.
+            
+          elseif(findstring('finish',record,idum))then
+            
+            peek=.false.
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)close (nread)
+      if(abs(rvdw).le.1.d-10)rvdw=rcut
+      if(drdf.lt.1.d-8)drdf=0.05d0
+      if(dzdn.lt.1.d-8)dzdn=0.05d0
+      
+      return
+      
+      end subroutine conscan
+      
+      subroutine abortscan(key,idnode)
+      
+c*********************************************************************
+c     
+c     dl_poly subroutine for controlled exit of file scan
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c*********************************************************************
+      
+      integer key,idnode
+      
+      write(nrite,'(/,/,1x,a,i5)') 
+     x  'DL_POLY terminated due to error ', key
+      
+      if(key.eq.17)then
+        
+        write(nrite,'(/,/,1x,a)')
+     x    'error - strange exit from CONTROL file processing'
+        
+      else if(key.eq.52)then
+        
+        write(nrite,'(/,/,1x,a)')
+     x    'error - end of FIELD file encountered'
+        
+      else if(key.eq.24)then
+        
+        write(nrite,'(/,/,1x,a)')
+     x    'error - end of file encountered in TABLE file'
+        
+      else if(key.eq.34)then
+        
+        write(nrite,'(/,/,1x,a)')
+     x    'error - character array memory allocation failure'
+        
+      endif
+      
+      if(idnode.eq.0) then
+        close (nrite)
+        close (nhist)
+        close (nread)
+        close (nconf)
+        close (nstats)
+        close (nrest)
+        close (nfield)
+        close (ntable)
+      endif
+      
+      call gsync()
+      call exitcomms()
+      
+      return
+      end subroutine abortscan
+      
+      subroutine dcell(aaa,bbb)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine to calculate the dimensional properties of
+c     a simulation cell specified by the input matrix aaa.
+c     the results are returned in the array bbb, with :
+c     
+c     bbb(1 to 3) - lengths of cell vectors
+c     bbb(4 to 6) - cosines of cell angles
+c     bbb(7 to 9) - perpendicular cell widths
+c     bbb(10)     - cell volume
+c     
+c     copyright daresbury laboratory 1992
+c     author - w. smith         july 1992
+c     
+c***********************************************************************
+      
+      real(8) aaa,bbb,axb1,axb2,axb3,bxc1,bxc2,bxc3,cxa1,cxa2,cxa3
+      
+      dimension aaa(9),bbb(10)
+      
+c     calculate lengths of cell vectors
+      
+      bbb(1)=sqrt(aaa(1)*aaa(1)+aaa(2)*aaa(2)+aaa(3)*aaa(3))
+      bbb(2)=sqrt(aaa(4)*aaa(4)+aaa(5)*aaa(5)+aaa(6)*aaa(6))
+      bbb(3)=sqrt(aaa(7)*aaa(7)+aaa(8)*aaa(8)+aaa(9)*aaa(9))
+      
+c     calculate cosines of cell angles
+      
+      bbb(4)=(aaa(1)*aaa(4)+aaa(2)*aaa(5)+aaa(3)*aaa(6))/(bbb(1)*bbb(2))
+      bbb(5)=(aaa(1)*aaa(7)+aaa(2)*aaa(8)+aaa(3)*aaa(9))/(bbb(1)*bbb(3))
+      bbb(6)=(aaa(4)*aaa(7)+aaa(5)*aaa(8)+aaa(6)*aaa(9))/(bbb(2)*bbb(3))
+      
+c     calculate vector products of cell vectors
+      
+      axb1=aaa(2)*aaa(6)-aaa(3)*aaa(5)
+      axb2=aaa(3)*aaa(4)-aaa(1)*aaa(6)
+      axb3=aaa(1)*aaa(5)-aaa(2)*aaa(4)
+      bxc1=aaa(5)*aaa(9)-aaa(6)*aaa(8)
+      bxc2=aaa(6)*aaa(7)-aaa(4)*aaa(9)
+      bxc3=aaa(4)*aaa(8)-aaa(5)*aaa(7)
+      cxa1=aaa(8)*aaa(3)-aaa(2)*aaa(9)
+      cxa2=aaa(1)*aaa(9)-aaa(3)*aaa(7)
+      cxa3=aaa(2)*aaa(7)-aaa(1)*aaa(8)
+      
+c     calculate volume of cell
+      
+      bbb(10)=abs(aaa(1)*bxc1+aaa(2)*bxc2+aaa(3)*bxc3)
+      
+c     calculate cell perpendicular widths
+      
+      bbb(7)=bbb(10)/sqrt(bxc1*bxc1+bxc2*bxc2+bxc3*bxc3)
+      bbb(8)=bbb(10)/sqrt(cxa1*cxa1+cxa2*cxa2+cxa3*cxa3)
+      bbb(9)=bbb(10)/sqrt(axb1*axb1+axb2*axb2+axb3*axb3)
+      
+      return
+      end subroutine dcell
+      
+      end module setup_module
diff -urN dl_class_1.9.orig/srcmod/shake_module.f dl_class_1.9/srcmod/shake_module.f
--- dl_class_1.9.orig/srcmod/shake_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/shake_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,152 @@
+      module shake_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining bond shake arrays
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+      
+      use error_module
+      use parse_module
+      use setup_module
+      use site_module
+      use solvation_module
+      
+      implicit none
+      
+      real(8), allocatable :: prmcon(:)
+      integer, allocatable :: listcon(:,:),listot(:)
+      integer, allocatable :: numcon(:),lstcon(:,:)
+      integer, allocatable :: listme(:),lishap(:),lashap(:)
+      
+      save prmcon,listcon,listot,numcon,lstcon,listme,lishap,lashap
+      
+      contains
+      
+      subroutine alloc_shake_arrays(idnode)
+      
+      implicit none
+      
+      integer, parameter :: nnn=8
+      
+      integer i,fail,idnode
+      dimension fail(nnn)
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (prmcon(mxtcon),stat=fail(1))
+      allocate (numcon(mxtmls),stat=fail(2))
+      allocate (lstcon(mxtcon,2),stat=fail(3))
+      allocate (listcon(mxcons,3),stat=fail(4))
+      allocate (listme(mxatms),stat=fail(5))
+      allocate (lishap(mxlshp),stat=fail(6))
+      allocate (lashap(mxproc),stat=fail(7))
+      allocate (listot(mxatms),stat=fail(8))
+      
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1070)
+      enddo
+      
+      do i=1,mxtmls
+        numcon(i)=0
+      enddo
+      
+      end subroutine alloc_shake_arrays
+      
+      subroutine define_constraints
+     x  (safe,lghost,idnode,itmols,nconst,nsite,natmsr)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining constraints
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     adapted   - p-a cazade  oct 2007,  solvation, excitation etc.
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical safe,lghost
+      character*1 message(80)
+      integer idnode,itmols,nconst,nsite,ntmp,icnst
+      integer icnst1,iatm1,iatm2,isite1,isite2,idum,i
+      integer isol1,isol2,natmsr
+      
+      ntmp=intstr(record,lenrec,idum)
+      numcon(itmols)=numcon(itmols)+ntmp
+      if(idnode.eq.0) then
+        write(nrite,"(/,1x,'number of bond constraints',
+     x    5x,i10)") ntmp
+        write(nrite,"(/,/,1x,'constraint bond details:',
+     x    /,/,21x,5x,'index',5x,'index',2x,'bondlength',/)
+     x    ")
+      endif
+      
+      icnst1 = numcon(itmols)
+      do icnst=1,icnst1
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        
+        call copystring(record,message,80)
+        iatm1 = intstr(record,lenrec,idum)
+        iatm2 = intstr(record,lenrec,idum)
+        
+c     test for frozen atom pairs(:)
+        
+        isite1 = nsite - numsit(itmols) + iatm1
+        isite2 = nsite - numsit(itmols) + iatm2
+        if(lghost)then
+          
+          isol1=natmsr+iatm1
+          isol2=natmsr+iatm2
+          
+        endif
+        
+        if(lfzsit(isite1)*lfzsit(isite2).ne.0) then
+          
+          numcon(itmols) = numcon(itmols) -1
+          if(idnode.eq.0) write(nrite,'(14x,a16,40a1)')
+     x      '*** frozen *** ',(message(i),i=1,40)
+          
+        else
+          
+          nconst=nconst+1
+          
+          if(nconst.gt.mxtcon) call error(idnode,40)
+          
+          lstcon(nconst,1)= iatm1
+          lstcon(nconst,2)= iatm2
+          prmcon(nconst)=dblstr(record,lenrec,idum)
+          
+          if(lghost)then
+            
+            if((isol1.ge.ind_fre(3)).or.(isol2.ge.ind_fre(3)))then
+              
+              numcon(itmols)=numcon(itmols)-1
+              ntcons_ghost=ntcons_ghost+1
+              
+            endif
+            
+          endif
+          
+          if(idnode.eq.0) 
+     x      write(nrite,"(21x,2i10,f12.6)")
+     x      lstcon(nconst,1),lstcon(nconst,2),
+     x      prmcon(nconst)
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine define_constraints
+      
+      end module shake_module
diff -urN dl_class_1.9.orig/srcmod/site_module.f dl_class_1.9/srcmod/site_module.f
--- dl_class_1.9.orig/srcmod/site_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/site_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,233 @@
+      module site_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining atomic/site arrays
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use error_module
+      use parse_module
+      use setup_module
+
+      implicit none
+
+      character*1, allocatable :: molnam(:,:)
+      character*8, allocatable :: sitnam(:),unqatm(:)
+      real(8), allocatable :: dens(:),chgsit(:),wgtsit(:)
+      integer, allocatable :: nexsit(:),lfzsit(:),numsit(:),ltpsit(:)
+      integer, allocatable :: nugrp(:),lexsit(:,:),numgrp(:)
+      integer, allocatable :: numtyp(:),numfrz(:),nummols(:)
+
+      save numtyp,numfrz,dens,chgsit,wgtsit,sitnam,unqatm,nexsit
+      save lfzsit,numsit,ltpsit,nugrp,lexsit,numgrp,molnam,nummols
+
+      contains
+
+      subroutine alloc_site_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=16
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+         fail(i)=0
+      enddo
+      allocate (chgsit(mxsite),stat=fail(1))
+      allocate (wgtsit(mxsite),stat=fail(2))
+      allocate (nexsit(mxsite),stat=fail(3))
+      allocate (lfzsit(mxsite),stat=fail(4))
+      allocate (nugrp(mxsite) ,stat=fail(5))
+      allocate (ltpsit(mxsite),stat=fail(6))
+      allocate (numsit(mxtmls),stat=fail(7))
+      allocate (lexsit(mxsite,mxexcl),stat=fail(8))
+      allocate (sitnam(mxsite),stat=fail(9))
+      allocate (unqatm(mxsite),stat=fail(10))
+      allocate (numgrp(mxtmls),stat=fail(11))
+      allocate (numtyp(mxatyp),stat=fail(12))
+      allocate (numfrz(mxatyp),stat=fail(13))
+      allocate (dens(mxatyp),stat=fail(14))
+      allocate (nummols(mxtmls),stat=fail(15))
+      allocate (molnam(40,mxtmls),stat=fail(16))
+      do i=1,nnn
+         if(fail(i).ne.0)call error(idnode,1090)
+      enddo
+
+      do i=1,mxtmls
+         numsit(i)=0
+      enddo
+
+      end subroutine alloc_site_arrays
+
+      subroutine define_atoms
+     x  (safe,lneut,idnode,itmols,nsite,ksite,ntpatm)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for  defining atom types in system
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      character*8 atom1
+      character*1 message(80)
+      logical lneut,safe,atmchk
+      integer idnode,itmols,nsite,ksite,ntpatm,isite,nrept
+      integer ifrz,neugp,irept,jsite,idum
+      real(8) weight,charge
+
+      numsit(itmols)=intstr(record,lenrec,idum)
+      if(idnode.eq.0) then
+        write(nrite,"(/,1x,'number of atoms/sites',
+     x    10x,i10)") numsit(itmols)
+        if(.not.lneut)
+     x    write(nrite,"(/,/,1x,'atomic characteristics:',
+     x    /,/,21x,' site',5x,'name',10x,'mass',8x,
+     x    'charge',4x,'repeat',4x,'freeze'/)")
+        if(lneut)
+     x    write(nrite,"(/,/,1x,'atomic characteristics:',/
+     x    /,21x,' site',5x,'name',10x,'mass',8x,'charge',
+     x    4x,'repeat',4x,'freeze',3x,'chg grp')")
+        
+      endif
+      
+      do isite=1,numsit(itmols)
+        
+        if(ksite.lt.numsit(itmols))then
+
+c     read atom name, site number, mass, charge, freeze option
+          
+          call getrec(safe,idnode,nfield)
+          if(.not.safe)return
+
+          call copystring(record,message,80)
+          call getword(atom1,record,8,lenrec)
+          weight=dblstr(record,lenrec,idum)
+          charge=dblstr(record,lenrec,idum)
+          nrept=intstr(record,lenrec,idum)
+          ifrz =intstr(record,lenrec,idum)
+          neugp=intstr(record,lenrec,idum)
+          if(nrept.eq.0)nrept=1
+          ksite=ksite+nrept
+          
+          if(idnode.eq.0) then
+            
+            if(.not.lneut) then
+
+              write(nrite,
+     x          "(21x,i5,5x,a8,2f12.5,2i10)")
+     x          nsite+1,atom1,weight,charge,nrept,
+     x          ifrz
+
+            else
+
+              write(nrite,
+     x          "(21x,i5,5x,a8,2f12.5,3i10)")
+     x          nsite+1,atom1,weight,charge,nrept,
+     x          ifrz,neugp
+
+            endif
+
+          endif
+          
+          do irept=1,nrept
+            
+            nsite=nsite+1
+            if(nsite.gt.mxsite) call error(idnode,20)
+            
+            sitnam(nsite)=atom1
+            wgtsit(nsite)=weight
+            chgsit(nsite)=charge
+            lfzsit(nsite)=ifrz
+            nugrp(nsite)=neugp
+            
+          enddo
+          
+c     establish list of unique atom types
+          
+          atmchk=.true.
+          
+          do jsite=1,ntpatm
+            
+            if(atom1.eq.unqatm(jsite)) then
+              
+              atmchk=.false.
+              do irept=nsite,nsite-nrept+1,-1
+                
+                ltpsit(irept)=jsite
+                
+              enddo
+              
+            endif
+            
+          enddo
+          
+          if(atmchk)then
+            
+            ntpatm=ntpatm+1
+            if(ntpatm.gt.mxatyp)call error(idnode,14)
+            unqatm(ntpatm)=atom1
+            
+            do irept=nsite,nsite-nrept+1,-1
+              
+              ltpsit(irept)=ntpatm
+              
+            enddo
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine define_atoms
+
+      subroutine check_syschg(idnode,ntpmls,sumchg)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for checking the system charge
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,ntpmls,jsite,itmols,lsite
+      real(8) sumchg
+
+      jsite=0
+      do itmols=1,ntpmls
+        
+        do lsite=1,numsit(itmols)
+          
+          jsite=jsite+1
+          sumchg=sumchg+dble(nummols(itmols))*chgsit(jsite)
+          
+        enddo
+        
+      enddo
+      
+      if(abs(sumchg).gt.1.0d-6) then
+        
+        call warning(idnode,60,sumchg,0.d0,0.d0)
+        
+      endif
+      
+      return
+      end subroutine check_syschg
+      
+      end module site_module
diff -urN dl_class_1.9.orig/srcmod/solvation_module.f dl_class_1.9/srcmod/solvation_module.f
--- dl_class_1.9.orig/srcmod/solvation_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/solvation_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,996 @@
+      module solvation_module
+      
+c***********************************************************************
+c     
+c     dl_poly module for defining decomposition of energy arrays
+c     to calculate solvation energies
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      use setup_module
+      use error_module
+      use config_module
+      
+      implicit none
+      
+      logical lcomp(9)
+      
+      integer mxtmls_sol2,mxtmls_sol3,mxtmls_sol4
+      integer ntcons_ghost,ngrp_ghost,nswitch,niswitch
+      integer mxtmls_exc2,mxtmls_exc3,mxtmls_exc4
+      integer nfrn,ifrn,mfree,kfree,ind_fre(4)
+      
+      real(8) pfree,lambda1,lambda2,dlambda,eng_kin_fre
+      real(8) elrc2,virlrc2,engsic0,engsic2,elrc_sav,qfix_fre
+      real(8) virlrc_sav,volm_sav,elrc_fre,elrc_fre_sav,vlrc_fre
+      real(8) qchg0,qchg1,qchg2,ang_fre,bnd_fre,dih_fre
+      real(8) inv_fre,tbp_fre,fbp_fre,cou_fre,elrc2_sav
+      real(8) vdw_fre,eng_cfg_fre,shl_fre,virlrc2_sav,vlrc_fre_sav
+      real(8) qchg_sav,vir_cfg_fre,ang_vir,bnd_vir,dih_vir
+      real(8) inv_vir,tbp_vir,fbp_vir,cou_vir,vdw_vir,shl_vir
+      
+      integer, allocatable :: atm_fre(:)
+      integer, allocatable :: atmolt(:),rigid_sol(:),const_sol(:)
+      integer, allocatable :: lstgot_sol(:),natm_sol(:)
+      
+      real(8), allocatable :: elrc_sol(:),elrc_sol_sav(:),shl_sol(:)
+      real(8), allocatable :: cou_sol(:),vdw_sol(:),bnd_sol(:)
+      real(8), allocatable :: ckc_sol_sum(:),cks_sol_sum(:)
+      real(8), allocatable :: cou_sol_sic(:),ebuf_sol1(:),inv_sol(:)
+      real(8), allocatable :: ang_sol(:),dih_sol(:),en3_sol(:)
+      real(8), allocatable :: qfix_sol(:),ebuf_sol2(:),en4_sol(:)
+      real(8), allocatable :: vdw_sol_lng(:),cou_sol_lng(:)
+      real(8), allocatable :: degfre_sol(:),degrot_sol(:),temp_sol(:)
+      real(8), allocatable :: vxo_sol(:),vyo_sol(:),vzo_sol(:)
+      real(8), allocatable :: ckc1(:),cks1(:),ckc2(:),cks2(:)
+      real(8), allocatable :: ckc_fre_sum(:),cks_fre_sum(:)
+      real(8), allocatable :: ebuf_exc1(:),ebuf_exc2(:)
+      real(8), allocatable :: vxo_fre(:),vyo_fre(:),vzo_fre(:)
+      real(8), allocatable :: elrc_exc(:),elrc_exc_sav(:)
+      real(8), allocatable :: cou_exc(:),vdw_exc(:),bnd_exc(:)
+      real(8), allocatable :: ang_exc(:),dih_exc(:),en4_exc(:)
+      real(8), allocatable :: vdw_exc_lng(:),cou_exc_lng(:)
+      real(8), allocatable :: shl_exc(:),en3_exc(:),inv_exc(:)
+      real(8), allocatable :: qfix_exc(:),cou_exc_sic(:),weight_sav(:)
+      
+      save atmolt,rigid_sol,const_sol,lstgot_sol,natm_sol,elrc_sol
+      save elrc_sol_sav,cou_sol,vdw_sol,bnd_sol,ckc_sol_sum,cks_sol_sum
+      save cou_sol_sic,ebuf_sol1,en4_sol,ang_sol,dih_sol,en3_sol
+      save qfix_sol,ebuf_sol2,shl_sol,vdw_sol_lng,cou_sol_lng,degfre_sol
+      save degrot_sol,inv_sol,temp_sol,vxo_sol,vyo_sol,vzo_sol
+      save mxtmls_sol2,mxtmls_sol3,mxtmls_sol4,lcomp
+      
+      save nfrn,ifrn,mfree,kfree,pfree,lambda1,lambda2,dlambda
+      save eng_kin_fre,elrc2,virlrc2,engsic0,engsic2,cks_fre_sum
+      save virlrc_sav,volm_sav,elrc_fre,elrc_fre_sav,qchg1,qchg2
+      save ang_fre,bnd_fre,dih_fre,inv_fre,tbp_fre,fbp_fre,qchg0
+      save cou_fre,vdw_fre,eng_cfg_fre,elrc2_sav,elrc_sav,vlrc_fre
+      save ang_vir,bnd_vir,dih_vir,inv_vir,tbp_vir,fbp_vir,cou_vir
+      save vdw_vir,shl_vir,vir_cfg_fre,qfix_fre,virlrc2_sav
+      save ind_fre,atm_fre,ckc1,cks1,ckc2,cks2,ckc_fre_sum
+      save ebuf_exc1,ebuf_exc2,vxo_fre,vyo_fre,vzo_fre,vlrc_fre_sav
+      save weight_sav
+      
+      save ntcons_ghost,ngrp_ghost,qchg_sav,nswitch,niswitch
+      save mxtmls_exc2,mxtmls_exc3,mxtmls_exc4
+      save cou_exc,vdw_exc,bnd_exc,ang_exc,dih_exc,en4_exc,vdw_exc_lng
+      save cou_exc_lng,shl_exc,en3_exc,inv_exc,elrc_exc,elrc_exc_sav
+      save qfix_exc,cou_exc_sic
+      
+      contains
+      
+      subroutine alloc_sol_arrays(idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for allocating solvation module arrays
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=37
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+      
+      mxtmls_sol2=((mxtmls_sol+1)*mxtmls_sol)/2
+      mxtmls_sol3=(((mxtmls_sol+3)*mxtmls_sol+2)*mxtmls_sol)/6
+      mxtmls_sol4=((((mxtmls_sol+6)*mxtmls_sol+11)*mxtmls_sol+6)*
+     x  mxtmls_sol)/24
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (cou_sol(mxtmls_sol2),stat=fail(1))
+      allocate (vdw_sol(mxtmls_sol2),stat=fail(2))
+      allocate (shl_sol(mxtmls_sol),stat=fail(3))
+      allocate (ebuf_sol1(mxebuf_sol),stat=fail(4))
+      allocate (cou_sol_sic(mxtmls_sol2),stat=fail(5))
+      allocate (cks_sol_sum(mxtmls_sol),stat=fail(6))
+      allocate (ckc_sol_sum(mxtmls_sol),stat=fail(7))
+      allocate (bnd_sol(mxtmls_sol),stat=fail(8))
+      allocate (ang_sol(mxtmls_sol),stat=fail(9))
+      allocate (dih_sol(mxtmls_sol),stat=fail(10))
+      allocate (atmolt(mxatms_sol),stat=fail(11))
+      allocate (en3_sol(mxtmls_sol3),stat=fail(12))
+      allocate (en4_sol(mxtmls_sol4),stat=fail(13))
+      allocate (qfix_sol(mxtmls_sol),stat=fail(14))
+      allocate (elrc_sol(mxtmls_sol2),stat=fail(15))
+      allocate (elrc_sol_sav(mxtmls_sol2),stat=fail(16))
+      allocate (ebuf_sol2(mxebuf_sol),stat=fail(23))
+      allocate (rigid_sol(mxtmls_sol),stat=fail(24))
+      allocate (const_sol(mxtmls_sol),stat=fail(25))
+      allocate (degfre_sol(mxtmls_sol),stat=fail(26))
+      allocate (degrot_sol(mxtmls_sol),stat=fail(27))
+      allocate (natm_sol(mxtmls_sol),stat=fail(28))
+      allocate (lstgot_sol(mxatms_sol),stat=fail(29))
+      allocate (temp_sol(mxtmls_sol),stat=fail(30))
+      allocate (vxo_sol(mxatms_sol),stat=fail(31))
+      allocate (vyo_sol(mxatms_sol),stat=fail(32))
+      allocate (vzo_sol(mxatms_sol),stat=fail(33))
+      allocate (vdw_sol_lng(mxtmls_sol2),stat=fail(34))
+      allocate (cou_sol_lng(mxtmls_sol2),stat=fail(35))
+      allocate (inv_sol(mxtmls_sol),stat=fail(36))
+      allocate (weight_sav(mxatms_fre),stat=fail(37))
+      
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1030)
+      enddo
+      
+c     initialise accumulators
+      
+      lcomp(:)=.false.
+      elrc_sol(:)=0.d0
+      cou_sol(:)=0.d0
+      vdw_sol(:)=0.d0
+      en3_sol(:)=0.d0
+      en4_sol(:)=0.d0
+      bnd_sol(:)=0.d0
+      ang_sol(:)=0.d0
+      dih_sol(:)=0.d0
+      inv_sol(:)=0.d0
+      
+      return
+      end subroutine alloc_sol_arrays
+      
+      subroutine solva_temp(idnode,mxnode,natms,keyver)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for solvation module
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,ii,idnode,mxnode,natms,keyver
+      real(8) vvx,vvy,vvz
+      
+      temp_sol(:)=0.d0
+      
+      do i=idnode+1,natms,mxnode
+        
+        if(keyver.eq.0)then
+          
+          vvx=0.5d0*(vxx(i)+vxo_sol(i))
+          vvy=0.5d0*(vyy(i)+vyo_sol(i))
+          vvz=0.5d0*(vzz(i)+vzo_sol(i))
+          
+        else
+          
+          vvx=vxx(i)
+          vvy=vyy(i)
+          vvz=vzz(i)
+          
+        endif
+        
+        temp_sol(atmolt(i))=temp_sol(atmolt(i))+weight(i)*
+     x    (vvx*vvx+vvy*vvy+vvz*vvz)/(boltz*degfre_sol(atmolt(i)))
+        
+      enddo
+      
+c     global sum
+      
+      if(mxnode.gt.1)call gdsum(temp_sol,mxtmls_sol,buffer)
+        
+      return
+      end subroutine solva_temp
+      
+      subroutine alloc_free_arrays(idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly routine to allocate free energy arrays
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w.smith      aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer, parameter :: nnn=12
+      integer i,fail,idnode
+      dimension fail(nnn)
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (ebuf_exc1(mxebuf_fre),stat=fail(1))
+      allocate (ckc1(mxewld_fre),stat=fail(2))
+      allocate (cks1(mxewld_fre),stat=fail(3))
+      allocate (ckc2(mxewld_fre),stat=fail(4))
+      allocate (cks2(mxewld_fre),stat=fail(5))
+      allocate (cks_fre_sum(mxtmls_fre),stat=fail(6))
+      allocate (ckc_fre_sum(mxtmls_fre),stat=fail(7))
+      allocate (atm_fre(mxatms_fre),stat=fail(8))
+      allocate (ebuf_exc2(mxebuf_fre),stat=fail(9))
+      allocate (vxo_fre(mxatms_fre),stat=fail(10))
+      allocate (vyo_fre(mxatms_fre),stat=fail(11))
+      allocate (vzo_fre(mxatms_fre),stat=fail(12))
+      
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1030)
+      enddo
+      
+      return
+      
+      end subroutine alloc_free_arrays
+      
+      subroutine lrcorrect_fre(lfree,volm,elrc,virlrc)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for free energy module
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w.smith      aug 2008
+c     
+c***********************************************************************
+      
+      logical lfree
+      real(8) volm,elrc,virlrc
+      
+      elrc=elrc_sav*(volm_sav/volm)
+      elrc2=elrc2_sav*(volm_sav/volm)
+      virlrc=virlrc_sav*(volm_sav/volm)
+      virlrc2=virlrc2_sav*(volm_sav/volm)
+      if(lfree)then
+        elrc_fre=elrc_fre_sav*(volm_sav/volm)
+        vlrc_fre=vlrc_fre_sav*(volm_sav/volm)
+      endif
+      
+      end subroutine lrcorrect_fre
+      
+      subroutine free_kinetic(lfrmas,idnode,mxnode,keyver)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for free energy module
+c     calculate kinetic energy difference between states
+c     
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008: parallel version
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lfrmas
+      integer i,idnode,mxnode,keyver
+      real(8) fac
+      
+      fac=dlambda
+      eng_kin_fre=0.d0
+      
+      if(keyver.eq.0)then
+        
+        if(lfrmas)fac=dlambda/lambda1
+        do i=ind_fre(1)+idnode,ind_fre(2),mxnode
+          
+          eng_kin_fre=eng_kin_fre-
+     x      fac*weight(i)*((vxx(i)+vxo_fre(i))**2+
+     x      (vyy(i)+vyo_fre(i))**2+(vzz(i)+vzo_fre(i))**2)
+          
+        enddo
+        
+        if(lfrmas)fac=dlambda/lambda2
+        do i=ind_fre(3)+idnode,ind_fre(4),mxnode
+          
+          eng_kin_fre=eng_kin_fre+
+     x      fac*weight(i)*((vxx(i)+vxo_fre(i))**2+
+     x      (vyy(i)+vyo_fre(i))**2+(vzz(i)+vzo_fre(i))**2)
+          
+        enddo
+        
+        eng_kin_fre=eng_kin_fre/8.d0
+
+      else
+        
+        if(lfrmas)fac=dlambda/lambda1
+        do i=ind_fre(1)+idnode,ind_fre(2),mxnode
+          
+          eng_kin_fre=eng_kin_fre-fac*weight(i)*(vxx(i)**2+
+     x      vyy(i)**2+vzz(i)**2)
+          
+        enddo
+        
+        if(lfrmas)fac=dlambda/lambda2
+        do i=ind_fre(3)+idnode,ind_fre(4),mxnode
+          
+          eng_kin_fre=eng_kin_fre+fac*weight(i)*(vxx(i)**2+
+     x      vyy(i)**2+vzz(i)**2)
+          
+        enddo
+        
+        eng_kin_fre=eng_kin_fre/2.d0
+        
+      endif
+      
+c     global sum
+      
+      if(mxnode.gt.1)then
+        
+        buffer(1)=eng_kin_fre
+        call gdsum(buffer(1),1,buffer(2))
+        eng_kin_fre=buffer(1)
+        
+      endif
+      
+      return
+      end subroutine free_kinetic
+      
+      subroutine freegen()
+      
+c***********************************************************************
+c     
+c     dl_poly routine for free energy module: select mixing scheme
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w.smith      aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,j,fac1,fac2
+      real(8) sigma1,sigma2,acc,arg,gss,tt,pp,a1,a2,a3,a4,a5,err
+      
+      data a1,a2,a3/0.254829592d0,-0.284496736d0,1.421413741d0/
+      data a4,a5,pp/-1.453152027d0,1.061405429d0,0.3275911d0/
+
+      if(mfree.eq.1)then
+        
+c     linear mixing
+        
+        lambda1=(1.d0-pfree)
+        lambda2=pfree
+        dlambda=1.d0
+        
+      elseif(mfree.eq.2)then
+        
+c     nonlinear mixing
+        
+        lambda1=(1.d0-pfree)**kfree
+        lambda2=(1.d0-(1.d0-pfree)**kfree)
+        dlambda=dble(kfree)*(1.d0-pfree)**(kfree-1)
+        
+      elseif(mfree.eq.3)then
+        
+c     trigonmetric mixing
+        
+        lambda2=0.5d0*(1.d0+sin(pi*(pfree-0.5d0)))
+        lambda1=1.d0-lambda2
+        dlambda=0.5d0*pi*cos(pi*(pfree-0.5d0))
+        
+      elseif(mfree.eq.4)then
+        
+c     error function mixing
+        
+        acc=12.d0
+        arg=2.d0*sqrt(2.302585093*acc)
+        gss=exp(-(arg*(pfree-0.5d0))**2)
+        tt=1.d0/(1.d0+pp*arg*abs(pfree-0.5d0))
+        err=1.d0-tt*(a1+tt*(a2+tt*(a3+tt*(a4+tt*a5))))*gss
+        lambda2=0.5d0*(1.d0+sign(err,(pfree-0.5d0)))
+        lambda1=1.d0-lambda2
+        dlambda=gss*arg/sqrpi
+        
+      elseif(mfree.eq.5)then
+        
+c     polynomial mixing
+        
+        sigma1=0.d0
+        
+        do i=0,kfree-1
+          
+          fac1=1
+          fac2=1
+          
+          do j=0,i-1
+            
+            fac1=fac1*(kfree-1+i-j)
+            fac2=fac2*(i-j)
+            
+          enddo
+          
+          sigma1=sigma1+(dble(fac1/fac2))*pfree**i
+          
+        enddo
+        
+        lambda1=sigma1*(1.d0-pfree)**kfree
+        lambda2=1.d0-lambda1
+        dlambda=sigma1*kfree*(1.d0-pfree)**(kfree-1)
+        
+        sigma2=0.d0
+        
+        do i=1,kfree-1
+          
+          fac1=1
+          fac2=1
+          
+          do j=0,i-1
+            
+            fac1=fac1*(kfree-1+i-j)
+            fac2=fac2*(i-j)
+            
+          enddo
+          
+          sigma2=sigma2+(dble(fac1*i/fac2))*pfree**(i-1)
+          
+        enddo
+        
+        dlambda=dlambda-sigma2*(1.d0-pfree)**kfree
+        
+      else
+        
+c     spline kernel mixing
+        
+        arg=pfree-0.5d0
+        lambda2=2.d0*pfree-8.d0*arg**3*(1.d0-abs(arg))-0.5d0
+        lambda1=1.d0-lambda2
+        dlambda=2.d0+arg**2*(32.d0*abs(arg)-24.d0)
+        
+      endif
+      
+      return
+      end subroutine freegen
+      
+      subroutine free_energy_write(idnode,nstep,engunit)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing free energy file at selected
+c     intervals in simulation
+c     
+c     copyright - daresbury  laboratory
+c     author    - p.-a. cazade dec 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newjob
+      integer idnode,natms,nstep
+      real(8) engunit
+      
+      save newjob
+      data newjob/.true./
+      
+      if(idnode.eq.0)then
+          
+c     open the FREENG file if new job or file closed
+        
+        if(newjob)then
+          
+          newjob = .false.
+          open(nfrnwr,file='FREENG',position='append')
+          
+        endif
+        
+        if(nstep.eq.nfrn.or.nstep.eq.ifrn)then
+          
+          write(nfrnwr,'(80a1)')cfgname
+          
+          if(abs(engunit-9648.530821d0).le.1.d-10) write(nfrnwr,
+     x      "(' ENERGY UNITS=electron Volts ')")
+          if(abs(engunit-418.4d0).le.1.d-10)       write(nfrnwr,
+     x      "(' ENERGY UNITS=kcal/mol ')")
+          if(abs(engunit-1.d2).le.1.d-10)          write(nfrnwr,
+     x      "(' ENERGY UNITS=kjoule/mol ')")
+          if(abs(engunit-boltz).lt.1.d-10)         write(nfrnwr,
+     x      "(' ENERGY UNITS=kelvin ')")
+          if(abs(engunit-1.d0).lt.1.d-10)          write(nfrnwr,
+     x      "(' ENERGY UNITS=DL_POLY Internal UNITS ')")
+          
+          write(nfrnwr,'(1p,4e16.8)')pfree,lambda1,lambda2,dlambda
+          
+        endif
+        
+        if(mod(nstep-nfrn,ifrn).eq.0)then
+          
+          write(nfrnwr,"(i10,1p,2e16.8)")
+     x      nstep,eng_cfg_fre/engunit,vir_cfg_fre/engunit
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine free_energy_write
+      
+      subroutine alloc_exi_arrays(idnode)
+      
+c***********************************************************************
+c     
+c     dl_poly routine to allocate excited state arrays
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      integer, parameter :: nnn=15
+      integer i,fail,idnode
+      dimension fail(nnn)
+      
+      mxtmls_exc2=((mxtmls_exc+1)*mxtmls_exc)/2
+      mxtmls_exc3=(((mxtmls_exc+3)*mxtmls_exc+2)*mxtmls_exc)/6
+      mxtmls_exc4=((((mxtmls_exc+6)*mxtmls_exc+11)*mxtmls_exc+6)*
+     x  mxtmls_exc)/24
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      allocate (cou_exc(mxtmls_exc2),stat=fail(1))
+      allocate (vdw_exc(mxtmls_exc2),stat=fail(2))
+      allocate (bnd_exc(mxtmls_exc),stat=fail(3))
+      allocate (ang_exc(mxtmls_exc),stat=fail(4))
+      allocate (dih_exc(mxtmls_exc),stat=fail(5))
+      allocate (en3_exc(mxtmls_exc3),stat=fail(6))
+      allocate (en4_exc(mxtmls_exc4),stat=fail(7))
+      allocate (shl_exc(mxtmls_exc),stat=fail(8))
+      allocate (vdw_exc_lng(mxtmls_exc2),stat=fail(9))
+      allocate (cou_exc_lng(mxtmls_exc2),stat=fail(10))
+      allocate (inv_exc(mxtmls_exc),stat=fail(11))
+      allocate (elrc_exc(mxtmls_exc2),stat=fail(12))
+      allocate (elrc_exc_sav(mxtmls_exc2),stat=fail(13))
+      allocate (qfix_exc(mxtmls_exc),stat=fail(14))
+      allocate (cou_exc_sic(mxtmls_exc2),stat=fail(15))
+      
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1030)
+      enddo
+      
+c     initialise accumulators
+      
+      bnd_exc(:)=0.d0
+      ang_exc(:)=0.d0
+      dih_exc(:)=0.d0
+      inv_exc(:)=0.d0
+      en3_exc(:)=0.d0
+      en4_exc(:)=0.d0
+      elrc_exc(:)=0.d0
+      cou_exc(:)=0.d0
+      vdw_exc(:)=0.d0
+      
+      return
+      end subroutine alloc_exi_arrays
+      
+      subroutine update_ghost(idnode,mxnode)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for excited state module
+c     update the positions of ghost atoms
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,ii,idnode,mxnode
+      
+      if(ind_fre(1).lt.ind_fre(3))then
+        
+        ii=ind_fre(3)
+        
+        do i=ind_fre(1),ind_fre(2)
+          
+          xxx(ii)=xxx(i)
+          yyy(ii)=yyy(i)
+          zzz(ii)=zzz(i)
+          
+          ii=ii+1
+          
+        enddo
+        
+      else
+        
+        ii=ind_fre(1)
+        
+        do i=ind_fre(3),ind_fre(4)
+          
+          xxx(ii)=xxx(i)
+          yyy(ii)=yyy(i)
+          zzz(ii)=zzz(i)
+          
+          ii=ii+1
+          
+        enddo
+        
+      endif
+      
+      return
+      end subroutine update_ghost
+      
+      subroutine copy_force(idnode,mxnode)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for excited state module
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer i,ii,idnode,mxnode
+      
+      ii=ind_fre(3)
+      
+      do i=ind_fre(1),ind_fre(2)
+        
+        fxx(ii)=fxx(i)
+        fyy(ii)=fyy(i)
+        fzz(ii)=fzz(i)
+        
+        ii=ii+1
+        
+      enddo
+      
+      return
+      end subroutine copy_force
+      
+      subroutine switch(elrc,virlrc)
+c***********************************************************************
+c     
+c     dl_poly routine for switching system in excitation simulation
+c     copyright - daresbury laboratory
+c     author    - w. smith   sep 2008
+c     adapted from p.-a. cazade oct 2007
+c     
+c***********************************************************************
+      
+      real(8) :: swap,elrc,virlrc
+      real(8), allocatable :: cou_sic_swp(:),qfix_swp(:)
+      real(8), allocatable :: elrc_swp(:)
+      
+      allocate(cou_sic_swp(mxtmls_exc2),qfix_swp(mxtmls_exc))
+      allocate(elrc_swp(mxtmls_exc2))
+      
+      swap=elrc
+      elrc=elrc2
+      elrc2=swap
+      
+      swap=engsic0
+      engsic0=engsic2
+      engsic2=swap
+      
+      swap=virlrc
+      virlrc=virlrc2
+      virlrc2=swap
+      
+      swap=elrc_sav
+      elrc_sav=elrc2_sav
+      elrc2_sav=swap
+
+      swap=virlrc_sav
+      virlrc_sav=virlrc2_sav
+      virlrc2_sav=swap
+
+      swap=qchg0
+      qchg0=qchg2
+      qchg2=swap
+      
+      cou_sic_swp(:)=cou_sol_sic(:)
+      cou_sol_sic(:)=cou_exc_sic(:)
+      cou_exc_sic(:)=cou_sic_swp(:)
+      
+      qfix_swp(:)=qfix_sol(:)
+      qfix_sol(:)=qfix_exc(:)
+      qfix_exc(:)=qfix_swp(:)
+      
+      elrc_swp(:)=elrc_sol(:)
+      elrc_sol(:)=elrc_exc(:)
+      elrc_exc(:)=elrc_swp(:)
+      
+      elrc_swp(:)=elrc_sol_sav(:)
+      elrc_sol_sav(:)=elrc_exc_sav(:)
+      elrc_exc_sav(:)=elrc_swp(:)
+      
+      deallocate(elrc_swp,cou_sic_swp,qfix_swp)
+      
+      return
+      
+      end subroutine switch
+      
+      subroutine lrcorrect_sol(lghost,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for excited state module
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      logical :: lghost
+      real(8) :: volm 
+      
+      elrc_sol(:)=elrc_sol_sav(:)*(volm_sav/volm)
+      if(lghost)elrc_exc(:)=elrc_exc_sav(:)*(volm_sav/volm)
+      
+      return
+      end subroutine lrcorrect_sol
+      
+      subroutine switch_atm(lfrmas)
+      
+c***********************************************************************
+c     
+c     dl_poly routine for excitation module
+c     copyright - daresbury laboratory
+c     author    - p.-a. cazade oct 2007
+c     adapted   - w.smith      aug 2008
+c     
+c***********************************************************************
+      
+      logical lfrmas
+      integer i,at1_swap,at2_swap
+      
+      at1_swap=ind_fre(1)
+      at2_swap=ind_fre(2)
+      ind_fre(1)=ind_fre(3)
+      ind_fre(2)=ind_fre(4)
+      ind_fre(3)=at1_swap
+      ind_fre(4)=at2_swap
+      
+      if(lfrmas)then
+        
+        do i=ind_fre(1),ind_fre(2)
+          
+          atm_fre(i)=1
+          weight(i)=lambda1*weight_sav(i)
+          
+        enddo
+        
+        do i=ind_fre(3),ind_fre(4)
+          
+          atm_fre(i)=2
+          weight(i)=lambda2*weight_sav(i)
+          
+        enddo
+        
+      else
+        
+        do i=ind_fre(1),ind_fre(2)
+          atm_fre(i)=1
+        enddo
+        
+        do i=ind_fre(3),ind_fre(4)
+          atm_fre(i)=2
+        enddo
+        
+      endif
+      
+      return
+      end subroutine switch_atm
+      
+      subroutine solvation_write
+     x  (lexcite,lswitch,idnode,natms,nstep,nsolva,isolva,
+     x  tstep,engunit,elrc)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing solva file at selected
+c     intervals in simulation
+c     
+c     copyright - daresbury  laboratory
+c     author    - p.-a. cazade jun 2007
+c     adapted   - w. smith     aug 2008
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical newjob,lexcite,lswitch
+      integer idnode,natms,nstep,nsolva,isolva,i,j,k
+      integer mxtmls2,mxtmls3,mxtmls4
+      real(8) tstep,engunit,elrc
+      character*80 aa,bb,cc,dd
+      
+      save newjob
+      data newjob/.true./
+      
+      mxtmls2=((mxtmls+1)*mxtmls)/2
+      mxtmls3=(((mxtmls+3)*mxtmls+2)*mxtmls)/6
+      mxtmls4=((((mxtmls+6)*mxtmls+11)*mxtmls+6)*mxtmls)/24
+      
+      if(idnode.eq.0)then
+        
+c     open the SOLVAT file if new job or file closed
+        
+        if(newjob)then
+          
+          newjob=.false.
+          open(nsolwr,file='SOLVAT',position='append')
+          
+        endif
+        
+c     write file header block
+        
+        if(nstep.eq.nsolva.or.nstep.eq.isolva)then
+          
+          write(nsolwr,'(80a1)')cfgname
+          
+          if(abs(engunit-9648.530821d0).le.1.d-10)write(nsolwr,
+     x      "('ENERGY UNITS=electron Volts ')")
+          if(abs(engunit-418.4d0).le.1.d-10)      write(nsolwr,
+     x      "('ENERGY UNITS=kcal/mol ')")
+          if(abs(engunit-1.d2).le.1.d-10)         write(nsolwr,
+     x      "('ENERGY UNITS=kjoule/mol ')")
+          if(abs(engunit-boltz).lt.1.d-10)        write(nsolwr,
+     x      "('ENERGY UNITS=kelvin ')")
+          if(abs(engunit-1.d0).lt.1.d-10)         write(nsolwr,
+     x      "('ENERGY UNITS=DL_POLY Internal UNITS ')")
+          
+          write(nsolwr,'(2i10)')natms,mxtmls
+          write(nsolwr,'(1x,11a4)')' lex','lsw',' bnd',' ang',
+     x      ' dih',' inv',' shl',' cou',' vdw',' 3bd',' 4bd'
+          write(nsolwr,'(11l4)')lexcite,lswitch,lcomp
+          
+        endif
+        
+c     write out periodic data
+        
+        if(mod(nstep-nsolva,isolva).eq.0)then
+          
+c     mark start of time step data
+          
+          if(lexcite)then
+            write(nsolwr,'("timestep",i10,f12.5,1p,2e14.6)')
+     x        nstep,tstep,elrc/engunit,elrc2/engunit
+          else
+            write(nsolwr,'("timestep",i10,f12.5,1p,e14.6)')
+     x        nstep,tstep,elrc/engunit
+          endif
+          
+c     write intramolecular data
+          
+          write(nsolwr,'(1p,5e14.6)')temp_sol
+          if(lcomp(1))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')bnd_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')bnd_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')bnd_sol(:)/engunit
+            endif
+          endif
+          if(lcomp(2))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')ang_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')ang_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')ang_sol(:)/engunit
+            endif
+          endif
+          if(lcomp(3))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')dih_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')dih_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')dih_sol(:)/engunit
+            endif
+          endif
+          if(lcomp(4))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')inv_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')inv_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')inv_sol(:)/engunit
+            endif
+          endif
+          
+c     write core-shell data
+          
+          if(lcomp(5))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')shl_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')shl_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')shl_sol(:)/engunit
+            endif
+          endif
+          
+c     write coulombic data
+          
+          if(lcomp(6))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')cou_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')cou_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')cou_sol(:)/engunit
+            endif
+          endif
+          
+c     write vdw data
+          
+          if(lcomp(7))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')vdw_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')vdw_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')vdw_sol(:)/engunit
+            endif
+          endif
+          
+c     write 3-body data
+          
+          if(lcomp(8))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')en3_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')en3_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')en3_sol(:)/engunit
+            endif
+          endif
+          
+c     write 4-body data
+          
+          if(lcomp(9))then
+            if(lexcite)then
+              write(nsolwr,'(1p,5e14.6)')en4_sol(:)/engunit
+              write(nsolwr,'(1p,5e14.6)')en4_exc(:)/engunit
+            else
+              write(nsolwr,'(1p,5e14.6)')en4_sol(:)/engunit
+            endif
+          endif
+        
+        endif
+        
+c     close SOLVAT file at regular intervals
+        
+        if(.not.newjob.and.mod(nstep,ndump).eq.0)then
+          
+          close(nsolwr)
+          newjob=.true.
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine solvation_write
+      
+      end module solvation_module
diff -urN dl_class_1.9.orig/srcmod/spme_module.f dl_class_1.9/srcmod/spme_module.f
--- dl_class_1.9.orig/srcmod/spme_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/spme_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,1175 @@
+      module spme_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining spme arrays
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use setup_module
+      use utility_module
+
+      implicit none
+
+      real(8), allocatable :: csp(:),qqc(:,:,:),ffttable(:)
+      real(8), allocatable :: bspx(:,:), bspy(:,:), bspz(:,:)
+      real(8), allocatable :: bsdx(:,:), bsdy(:,:), bsdz(:,:)
+      integer, allocatable :: key1(:),key2(:),key3(:)
+      complex(8), allocatable :: ww1(:), ww2(:), ww3(:)
+      complex(8), allocatable :: qqq(:,:,:)
+      complex(8), allocatable :: bscx(:), bscy(:),bscz(:)
+CFFTW      pointer, save :: fplan, bplan
+
+      save csp,qqc,qqq,ww1,ww2,ww3,bscx,bscy,bscz,ffttable
+      save bspx,bspy,bspz,bsdx,bsdy,bsdz,key1,key2,key3
+
+      contains
+
+      subroutine alloc_spme_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=9
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate (csp(mxspl),ffttable(mxftab),stat=fail(1))
+      allocate (bspx(mxspme,mxspl),bspy(mxspme,mxspl),stat=fail(2))
+      allocate (bspz(mxspme,mxspl),bsdx(mxspme,mxspl),stat=fail(3))
+      allocate (bsdy(mxspme,mxspl),bsdz(mxspme,mxspl),stat=fail(4))
+      allocate (bscx(kmaxd),bscy(kmaxe),bscz(kmaxf),stat=fail(5))
+      allocate (key1(kmaxd),key2(kmaxe),key3(kmaxf),stat=fail(6))
+      allocate (ww1(kmaxd),ww2(kmaxe),ww3(kmaxf),stat=fail(7))
+      allocate (qqc(kmaxd,kmaxe,kmaxf),stat=fail(8))
+      allocate (qqq(kmaxd,kmaxe,kmaxf),stat=fail(9))
+      do i=1,nnn
+         if(fail(i).ne.0)call error(idnode,1750)
+      enddo
+
+      end subroutine alloc_spme_arrays
+
+      subroutine bspcoe(nospl,kmax1,kmax2,kmax3)
+
+c**********************************************************************
+c     
+c     dl_poly subroutine to calculate B-spline coefficients for 
+c     Euler exponential splines.
+c     
+c     copyright - daresbury laboratory 1998
+c     author    - w. smith july 1998
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer nospl,kmax1,kmax2,kmax3,k,i,j
+      complex(8) ccc
+
+c     calculate B-splines at knots
+
+        csp(1)=0.d0
+        csp(2)=1.d0
+        
+        do k=3,nospl
+          
+          csp(k)=0.d0
+          
+          do j=k,2,-1
+            
+            csp(j)=(dble(j-1)*csp(j)+dble(k-j+1)*csp(j-1))/dble(k-1)
+            
+          enddo
+          
+        enddo
+        
+c     calculate B-spline coefficients
+
+      do i=0,kmax1-1
+
+        ccc=(0.d0,0.d0)
+
+        do k=0,nospl-2
+
+          ccc=ccc+csp(k+2)*ww1(mod(i*k,kmax1)+1)
+
+        enddo
+
+        bscx(i+1)=ww1(mod(i*(nospl-1),kmax1)+1)/ccc
+
+      enddo
+
+      do i=0,kmax2-1
+
+        ccc=(0.d0,0.d0)
+
+        do k=0,nospl-2
+
+          ccc=ccc+csp(k+2)*ww2(mod(i*k,kmax2)+1)
+
+        enddo
+
+        bscy(i+1)=ww2(mod(i*(nospl-1),kmax2)+1)/ccc
+
+      enddo
+
+      do i=0,kmax3-1
+
+        ccc=(0.d0,0.d0)
+
+        do k=0,nospl-2
+
+          ccc=ccc+csp(k+2)*ww3(mod(i*k,kmax3)+1)
+
+        enddo
+
+        bscz(i+1)=ww3(mod(i*(nospl-1),kmax3)+1)/ccc
+
+      enddo
+
+      return
+      end subroutine bspcoe
+
+      subroutine bspgen(idnode,mxnode,natms,nospl,txx,tyy,tzz)
+
+c***********************************************************************
+c
+c     dl_poly subroutine to calculate B-splines for SPME method
+c
+c     copyright - daresbury laboratory 1998
+c     author    - w. smith july 1998
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer nospl,natms,idnode,mxnode,iatm0,iatm1,i,j,k
+      real(8) aaa,bbb,ccc,txx,tyy,tzz
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      
+c     set up atoms numbers for nodes
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     construct B-splines
+
+      do i=iatm0,iatm1
+
+        bsdx(i,1)=1.d0
+        bsdy(i,1)=1.d0
+        bsdz(i,1)=1.d0
+        bsdx(i,2)=-1.d0
+        bsdy(i,2)=-1.d0
+        bsdz(i,2)=-1.d0
+        bspx(i,1)=txx(i)-int(txx(i))
+        bspy(i,1)=tyy(i)-int(tyy(i))
+        bspz(i,1)=tzz(i)-int(tzz(i))
+        bspx(i,2)=1.d0-txx(i)+int(txx(i))
+        bspy(i,2)=1.d0-tyy(i)+int(tyy(i))
+        bspz(i,2)=1.d0-tzz(i)+int(tzz(i))
+
+      enddo
+      
+      do k=3,nospl
+        
+        do i=iatm0,iatm1
+
+          bspx(i,k)=0.d0
+          bspy(i,k)=0.d0
+          bspz(i,k)=0.d0
+
+        enddo
+        
+        do j=k,2,-1
+
+          if(k.eq.nospl)then
+            
+            do i=iatm0,iatm1
+              
+              bsdx(i,j)=bspx(i,j)-bspx(i,j-1)
+              bsdy(i,j)=bspy(i,j)-bspy(i,j-1)
+              bsdz(i,j)=bspz(i,j)-bspz(i,j-1)
+              
+            enddo
+            
+          endif
+          
+          do i=iatm0,iatm1
+            
+            aaa=txx(i)+dble(j-1)-int(txx(i))
+            bbb=tyy(i)+dble(j-1)-int(tyy(i))
+            ccc=tzz(i)+dble(j-1)-int(tzz(i))
+            bspx(i,j)=(aaa*bspx(i,j)+(dble(k)-aaa)*bspx(i,j-1))/
+     x        dble(k-1)
+            bspy(i,j)=(bbb*bspy(i,j)+(dble(k)-bbb)*bspy(i,j-1))/
+     x        dble(k-1)
+            bspz(i,j)=(ccc*bspz(i,j)+(dble(k)-ccc)*bspz(i,j-1))/
+     x        dble(k-1)
+
+          enddo
+          
+        enddo
+        
+        if(k.eq.nospl)then
+          
+          do i=iatm0,iatm1
+            
+            bsdx(i,1)=bspx(i,1)
+            bsdy(i,1)=bspy(i,1)
+            bsdz(i,1)=bspz(i,1)
+            
+          enddo
+          
+        endif
+        
+        do i=iatm0,iatm1
+
+          bspx(i,1)=(txx(i)-int(txx(i)))*bspx(i,1)/dble(k-1)
+          bspy(i,1)=(tyy(i)-int(tyy(i)))*bspy(i,1)/dble(k-1)
+          bspz(i,1)=(tzz(i)-int(tzz(i)))*bspz(i,1)/dble(k-1)
+
+        enddo
+        
+      enddo
+      
+      return
+      end subroutine bspgen
+
+      subroutine ewald_spme
+     x (idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3,nospl,
+     x  engcpe,vircpe,alpha,volm,epsq)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using the smoothed particle mesh ewald method
+c     due to Essmann et al J. Chem. Phys. 103 (1995) 8577.
+c     
+c     parallel replicated data version (part 1)
+c     
+c     copyright - daresbury laboratory 1998
+c     author    - w. smith july 1998
+c     additional FFT code - j. geronowicz sept 1999
+c     
+c     part 1 - reciprocal space terms (fourier part)
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical newjob,lconsw
+      
+      integer idnode,mxnode,natms,imcon,kmax1,kmax2,kmax3,nospl
+      integer npass,i,nnn,ipass,l,ll,k,kk,j,jj,fail,iatm0,iatm1
+      real(8) engcpe,vircpe,alpha,volm,epsq,omg,bb1,bb2,bb3,qchg
+      real(8) twopi,engsic,rvolm,ralph,shiftx,shifty,shiftz,det,qfix
+      real(8) tx,ty,tz,rcpcut,rcpct2,rkx1,rky1,rkz1,rkx2,rky2,rkz2
+      real(8) rkx3,rky3,rkz3,rksq,akv,eng1,den,scal1,tmp,rclprp
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+CESSL      integer inc2,inc3
+CSGIC      real(8) nauxfft(4)
+
+      dimension omg(9),rclprp(10)
+      complex(8) cpetot,vterm
+      save newjob,engsic,qchg,iatm0,iatm1
+      
+      data newjob/.true./,fail/0/
+CSGIC      data nauxfft/3,0,0,0/
+
+c     allocate temporary arrays
+
+      allocate (txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1760)
+
+      npass=1
+      lconsw=.true.
+      twopi=2.d0*pi
+      
+      if(newjob)then
+        
+        newjob=.false.
+        
+c     set up atoms numbers for nodes
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+        
+c     calculate self interaction correction and net system charge
+        
+        qchg=0.d0
+        engsic=0.d0
+        
+        do i=iatm0,iatm1
+          
+          qchg=qchg+chge(i)
+          engsic=engsic+chge(i)**2
+          
+        enddo
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=qchg
+          buffer(2)=engsic
+          call gdsum(buffer(1),2,buffer(3))
+          qchg  =buffer(1)
+          engsic=buffer(2)
+          
+        endif
+      
+        engsic=-r4pie0/epsq*alpha*engsic/sqrpi
+
+c     initialise the complex exponential arrays
+
+CCRAY        call spl_cexp(kmax1,kmax2,kmax3,ww1,ww2,ww3)
+CESSL        call spl_cexp(kmax1,kmax2,kmax3,ww1,ww2,ww3)
+CFFTW        call spl_cexp(kmax1,kmax2,kmax3,ww1,ww2,ww3)
+CSGIC        call spl_cexp(kmax1,kmax2,kmax3,ww1,ww2,ww3)
+
+c     initialise the default fft routine
+
+      call dlpfft3(1,1,kmax1,kmax2,kmax3,key1,key2,key3,
+     x  ww1,ww2,ww3,qqq)
+      
+c     calculate B-spline coefficients
+
+        call bspcoe(nospl,kmax1,kmax2,kmax3)
+        
+      endif
+      
+c     initialise coulombic potential energy
+      
+      engcpe=0.d0
+      vircpe=0.d0
+
+c     initalize stress tensor working arrays
+
+      do i = 1,9
+        omg(i) = 0.d0
+      enddo
+
+c     set working parameters
+
+      rvolm=twopi/volm
+      ralph=-0.25d0/alpha**2
+
+c     set switch for TO, RD and HP boundary conditions
+
+      if(imcon.eq.4.or.imcon.eq.5.or.imcon.eq.7) then
+
+        npass=2
+        lconsw=.false.
+        rvolm=0.5d0*rvolm
+        shiftx=0.5d0*dble(kmax1)
+        shifty=0.5d0*dble(kmax2)
+        shiftz=0.5d0*dble(kmax3)
+        if(imcon.eq.7)shiftz=0.d0
+
+      endif
+
+c     convert cell coordinates to fractional coordinates
+
+      call invert(cell,rcell,det)
+      if(abs(det).lt.1.d-6)call error(idnode,120)
+      
+      do i=iatm0,iatm1
+        
+        txx(i)=dble(kmax1)*(rcell(1)*xxx(i)+rcell(4)*yyy(i)+
+     x    rcell(7)*zzz(i)+0.5d0)
+        tyy(i)=dble(kmax2)*(rcell(2)*xxx(i)+rcell(5)*yyy(i)+
+     x    rcell(8)*zzz(i)+0.5d0)
+        tzz(i)=dble(kmax3)*(rcell(3)*xxx(i)+rcell(6)*yyy(i)+
+     x    rcell(9)*zzz(i)+0.5d0)
+
+      enddo
+      
+c     construct B-splines for atoms
+      
+      call bspgen(idnode,mxnode,natms,nospl,txx,tyy,tzz)
+      
+c     zero 3D charge array
+      
+      nnn=kmaxd*kmaxe*kmaxf
+      call set_block(nnn,0.d0,qqc)
+      
+c     construct 3D charge array
+      
+      do ipass=1,npass
+        
+        do i=iatm0,iatm1
+          
+          do l=1,nospl
+            
+            ll=int(tzz(i))-l+2
+            if(ll.gt.kmax3)ll=1
+            if(ll.lt.1)ll=ll+kmax3
+            do k=1,nospl
+              
+              kk=int(tyy(i))-k+2
+              if(kk.gt.kmax2)kk=1
+              if(kk.lt.1)kk=kk+kmax2
+              
+              do j=1,nospl
+                
+                jj=int(txx(i))-j+2
+                if(jj.gt.kmax1)jj=1
+                if(jj.lt.1)jj=jj+kmax1
+                
+                qqc(jj,kk,ll)=qqc(jj,kk,ll)+
+     x            chge(i)*bspx(i,j)*bspy(i,k)*bspz(i,l)
+                
+              enddo
+              
+            enddo
+            
+          enddo
+          
+        enddo
+        
+        if(.not.lconsw)then
+
+          do i=iatm0,iatm1
+
+            tx=txx(i)-shiftx
+            ty=tyy(i)-shifty
+            tz=tzz(i)-shiftz
+            txx(i)=txx(i)-sign(shiftx,tx)
+            tyy(i)=tyy(i)-sign(shifty,ty)
+            tzz(i)=tzz(i)-sign(shiftz,tz)
+
+          enddo
+
+        endif
+        
+      enddo
+
+c     global sum of charge array
+        
+      if(mxnode.gt.1) call gdsum(qqc,nnn,buffer)
+        
+c     load charge array into complex array for FFT
+
+      call cpy_rtc(nnn,qqc,qqq)
+
+c     calculate inverse 3D FFT of charge array (in place).
+      
+CFFTW      call fftwnd_f77_one(fplan,qqq,0)
+
+CESSL      inc2=kmaxd
+CESSL      inc3=kmaxd*kmaxe
+CESSL      call dcft3(qqq,inc2,inc3,qqq,inc2,inc3,kmax1,kmax2,kmax3,
+CESSL     x  -1,1.d0,buffer,mxbuff)
+
+CSGIC      call zzfft3d( -1,kmax1,kmax2,kmax3,1.d0,qqq,kmaxd,kmaxe,
+CSGIC     x              qqq,kmaxd,kmaxe,ffttable,buffer,nauxfft )
+
+CCRAY      call ccfft3d( -1,kmax1,kmax2,kmax3,1.d0,qqq,kmaxd,kmaxe,
+CCRAY     x              qqq,kmaxd,kmaxe,ffttable,buffer,nauxfft )
+      
+      call dlpfft3(0,1,kmax1,kmax2,kmax3,key1,key2,key3,
+     x  ww1,ww2,ww3,qqq)
+      
+c     set reciprocal space cutoff
+
+      call dcell(rcell,rclprp)
+
+      rcpcut=0.5d0*min(dble(kmax1)*rclprp(7),dble(kmax2)*rclprp(8),
+     x  dble(kmax3)*rclprp(9))
+      rcpcut=rcpcut*1.05d0*twopi
+      rcpct2=rcpcut**2
+      
+c     calculate convolution of charge array with gaussian function
+
+      do l=1,kmax3
+
+        ll=l-1
+        if(l.gt.kmax3/2)ll=l-kmax3-1
+        tmp=twopi*dble(ll)
+        rkx1=tmp*rcell(3)
+        rky1=tmp*rcell(6)
+        rkz1=tmp*rcell(9)
+        bb3=real(bscz(l)*conjg(bscz(l)))
+
+        do k=1,kmax2
+
+          kk=k-1
+          if(k.gt.kmax2/2)kk=k-kmax2-1
+          tmp=twopi*dble(kk)
+          rkx2=rkx1+tmp*rcell(2)
+          rky2=rky1+tmp*rcell(5)
+          rkz2=rkz1+tmp*rcell(8)
+          bb2=bb3*real(bscy(k)*conjg(bscy(k)))
+          
+          do j=1,kmax1
+
+            jj=j-1
+            if(j.gt.kmax1/2)jj=j-kmax1-1
+            tmp=twopi*dble(jj)
+            rkx3=rkx2+tmp*rcell(1)
+            rky3=rky2+tmp*rcell(4)
+            rkz3=rkz2+tmp*rcell(7)
+            bb1=bb2*real(bscx(j)*conjg(bscx(j)))
+                
+            rksq=rkx3*rkx3+rky3*rky3+rkz3*rkz3
+
+            if(rksq.gt.1.d-6.and.rksq.le.rcpct2)then
+
+              vterm=bb1*exp(ralph*rksq)/rksq*qqq(j,k,l)
+              akv=2.d0*(1.d0/rksq-ralph)*real(vterm*conjg(qqq(j,k,l)))
+              omg(1)=omg(1)-rkx3*rkx3*akv
+              omg(5)=omg(5)-rky3*rky3*akv
+              omg(9)=omg(9)-rkz3*rkz3*akv
+              omg(2)=omg(2)-rkx3*rky3*akv
+              omg(3)=omg(3)-rkx3*rkz3*akv
+              omg(6)=omg(6)-rky3*rkz3*akv
+              qqq(j,k,l)=vterm
+
+            else
+
+              qqq(j,k,l)=(0.d0,0.d0)
+
+            endif
+
+          enddo
+
+        enddo
+
+      enddo
+      
+CFFTW      call fftwnd_f77_one(bplan,qqq,0)
+CESSL      call dcft3(qqq,inc2,inc3,qqq,inc2,inc3,kmax1,kmax2,kmax3,
+CESSL     x  1,1.d0,buffer,mxbuff)
+
+CSGIC      call zzfft3d( 1,kmax1,kmax2,kmax3,1.d0,qqq,kmaxd,kmaxe,
+CSGIC     x              qqq,kmaxd,kmaxe,ffttable,buffer,nauxfft )
+
+CCRAY      call ccfft3d( 1,kmax1,kmax2,kmax3,1.d0,qqq,kmaxd,kmaxe,
+CCRAY     x              qqq,kmaxd,kmaxe,ffttable,buffer,nauxfft )
+
+      call dlpfft3(0,-1,kmax1,kmax2,kmax3,key1,key2,key3,
+     x  ww1,ww2,ww3,qqq)
+
+c     calculate atomic forces
+      
+      call spme_for
+     x  (idnode,mxnode,nospl,natms,kmax1,kmax2,kmax3,rvolm,
+     x  epsq,txx,tyy,tzz)
+
+c     complete product of charge array and its gaussian convolution
+
+      call ele_prd(nnn,qqq,qqc,qqq)
+      
+c     correction for charged systems
+
+      qfix=-(0.5d0*pi*r4pie0/epsq)*((qchg/alpha)**2/volm)/
+     x  dble(mxnode)
+      
+c     calculate total energy
+
+      call scl_csum(nnn,cpetot,qqq)
+
+      eng1=real(cpetot)
+      den=1.d0/dble(npass)
+      engcpe=engcpe+(den*rvolm*r4pie0*eng1/epsq+engsic)/
+     x   dble(mxnode)+qfix
+
+c     calculate stress tensor (symmetrical)
+
+      scal1=den*rvolm*r4pie0/(epsq*dble(mxnode))
+      stress(1) = stress(1)+scal1*(omg(1)+eng1)+qfix
+      stress(2) = stress(2)+scal1*omg(2)
+      stress(3) = stress(3)+scal1*omg(3)
+      stress(4) = stress(4)+scal1*omg(2)
+      stress(5) = stress(5)+scal1*(omg(5)+eng1)+qfix
+      stress(6) = stress(6)+scal1*omg(6)
+      stress(7) = stress(7)+scal1*omg(3)
+      stress(8) = stress(8)+scal1*omg(6)
+      stress(9) = stress(9)+scal1*(omg(9)+eng1)+qfix
+
+c     virial term
+
+      vircpe=vircpe-scal1*(omg(1)+omg(5)+omg(9)+3.d0*eng1)-3.d0*qfix
+      
+c     deallocate temporary arrays
+
+      deallocate (txx,tyy,tzz,stat=fail)
+      
+      return
+      end subroutine ewald_spme
+
+      subroutine spme_for
+     x  (idnode,mxnode,nospl,natms,kmax1,kmax2,kmax3,rvolm,
+     x  epsq,txx,tyy,tzz)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating coulombic forces in a
+c     periodic system using smoothed particle mesh ewald method
+c     
+c     parallel replicated data version (part 1)
+c     
+c     copyright - daresbury laboratory 1998
+c     author    - w. smith oct 1998
+c     
+c     part 1 - reciprocal space terms (fourier part)
+c
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,nospl,natms,kmax1,kmax2,kmax3,i,ll
+      integer iatm0,iatm1,kk,k,j,jj,l
+      real(8) rvolm,epsq,txx,tyy,tzz,fff,fac,bdx,bdy,bdz
+      real(8) det,qsum
+
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension fff(3)
+
+      fac=-2.d0*rvolm*r4pie0/epsq
+      call invert(cell,rcell,det)
+
+c     set up atom numbers for nodes
+
+      iatm0 = (idnode*natms)/mxnode + 1
+      iatm1 = ((idnode+1)*natms)/mxnode
+
+c     calculate forces
+
+      do i=iatm0,iatm1
+
+        fxx(i)=0.d0
+        fyy(i)=0.d0
+        fzz(i)=0.d0
+
+        do l=1,nospl
+          
+          ll=int(tzz(i))-l+2
+          if(ll.gt.kmax3)ll=1
+          if(ll.lt.1)ll=ll+kmax3
+          
+          do k=1,nospl
+            
+            kk=int(tyy(i))-k+2
+            if(kk.gt.kmax2)kk=1
+            if(kk.lt.1)kk=kk+kmax2
+            
+            do j=1,nospl
+              
+              jj=int(txx(i))-j+2
+              if(jj.gt.kmax1)jj=1
+              if(jj.lt.1)jj=jj+kmax1
+              
+              qsum=real(qqq(jj,kk,ll))
+              bdx=qsum*bsdx(i,j)*bspy(i,k)*bspz(i,l)*dble(kmax1)
+              bdy=qsum*bspx(i,j)*bsdy(i,k)*bspz(i,l)*dble(kmax2)
+              bdz=qsum*bspx(i,j)*bspy(i,k)*bsdz(i,l)*dble(kmax3)
+              
+              fxx(i)=fxx(i)+fac*chge(i)*(bdx*rcell(1)+bdy*rcell(2)+
+     x          bdz*rcell(3))
+              fyy(i)=fyy(i)+fac*chge(i)*(bdx*rcell(4)+bdy*rcell(5)+
+     x          bdz*rcell(6))
+              fzz(i)=fzz(i)+fac*chge(i)*(bdx*rcell(7)+bdy*rcell(8)+
+     x          bdz*rcell(9))
+              
+            enddo
+            
+          enddo
+          
+        enddo
+
+      enddo
+
+c     remove COM drift arising from SPME approximations
+
+      fff(1)=0.d0
+      fff(2)=0.d0
+      fff(3)=0.d0
+
+      do i=iatm0,iatm1
+
+        fff(1)=fff(1)+fxx(i)
+        fff(2)=fff(2)+fyy(i)
+        fff(3)=fff(3)+fzz(i)
+
+      enddo
+
+      if(mxnode.gt.1)call gdsum(fff,3,buffer)
+
+      fff(1)=fff(1)/dble(natms)
+      fff(2)=fff(2)/dble(natms)
+      fff(3)=fff(3)/dble(natms)
+
+      do i=iatm0,iatm1
+
+        fxx(i)=fxx(i)-fff(1)
+        fyy(i)=fyy(i)-fff(2)
+        fzz(i)=fzz(i)-fff(3)
+
+      enddo
+      
+      return
+      end subroutine spme_for
+
+      subroutine dlpfft3
+     x  (ind,isw,ndiv1,ndiv2,ndiv3,key1,key2,key3,ww1,ww2,ww3,aaa)
+
+c***********************************************************************
+c     
+c     dl-poly 3D fast fourier transform routine (in place)
+c     
+c     copyright daresbury laboratory 1998
+c     author w smith july 1998
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      logical lkx,lky,lkz
+      integer ind,isw,ndiv1,ndiv2,ndiv3,key1,key2,key3,i,idm,kkk
+      integer nu1,nu2,nu3,iii,jjj,j,jj2,num,l,kk1,k12,k
+      real(8) tpi,arg
+
+      dimension key1(ndiv1),key2(ndiv2),key3(ndiv3)
+      complex(8) ww1(ndiv1),ww2(ndiv2),ww3(ndiv3)
+      complex(8) ttt,aaa(ndiv1,ndiv2,ndiv3)
+      save nu1,nu2,nu3
+
+      data tpi/6.283185307179586d0/
+      
+      if(ind.gt.0)then
+
+c     check FFT array dimensions
+
+        idm=1
+        lkx=.true.
+        lky=.true.
+        lkz=.true.
+
+        do i=1,30
+          
+          idm=2*idm
+
+          if(idm.eq.ndiv1)then
+
+            lkx=.false.
+            nu1=i
+
+          endif
+          if(idm.eq.ndiv2)then
+
+            lky=.false.
+            nu2=i
+
+          endif
+          if(idm.eq.ndiv3)then
+
+            lkz=.false.
+            nu3=i
+
+          endif
+          
+        enddo
+        
+        if(lkx.or.lky.or.lkz)then
+          
+          write(*,*)'error - FFT array not 2**N'
+          stop
+          
+        endif
+        
+c     set reverse bit address arrays
+        
+        do kkk=1,ndiv1
+
+          iii=0
+          jjj=kkk-1
+
+          do j=1,nu1
+
+            jj2=jjj/2
+            iii=2*(iii-jj2)+jjj
+            jjj=jj2
+
+          enddo
+
+          key1(kkk)=iii+1
+
+        enddo
+        
+        do kkk=1,ndiv2
+
+          iii=0
+          jjj=kkk-1
+
+          do j=1,nu2
+
+            jj2=jjj/2
+            iii=2*(iii-jj2)+jjj
+            jjj=jj2
+
+          enddo
+
+          key2(kkk)=iii+1
+
+        enddo
+        
+        do kkk=1,ndiv3
+
+          iii=0
+          jjj=kkk-1
+
+          do j=1,nu3
+
+            jj2=jjj/2
+            iii=2*(iii-jj2)+jjj
+            jjj=jj2
+
+          enddo
+
+          key3(kkk)=iii+1
+
+        enddo
+        
+c     initialise complex exponential factors
+        
+        ww1(1)=(1.d0,0.d0)
+
+        do i=1,ndiv1/2
+
+          arg=(tpi/dble(ndiv1))*dble(i)
+          ww1(i+1)=cmplx(cos(arg),sin(arg),kind=8)
+          ww1(ndiv1+1-i)=conjg(ww1(i+1))
+
+        enddo
+        
+        ww2(1)=(1.d0,0.d0)
+
+        do i=1,ndiv2/2
+
+          arg=(tpi/dble(ndiv2))*dble(i)
+          ww2(i+1)=cmplx(cos(arg),sin(arg),kind=8)
+          ww2(ndiv2+1-i)=conjg(ww2(i+1))
+
+        enddo
+        
+        ww3(1)=(1.d0,0.d0)
+
+        do i=1,ndiv3/2
+
+          arg=(tpi/dble(ndiv3))*dble(i)
+          ww3(i+1)=cmplx(cos(arg),sin(arg),kind=8)
+          ww3(ndiv3+1-i)=conjg(ww3(i+1))
+
+        enddo
+        
+        return
+
+      endif
+
+c     take conjugate of exponentials if required
+      
+      if(isw.lt.0)then
+        
+        do i=1,ndiv1
+
+          ww1(i)=conjg(ww1(i))
+
+        enddo
+
+        do i=1,ndiv2
+
+          ww2(i)=conjg(ww2(i))
+
+        enddo
+
+        do i=1,ndiv3
+
+          ww3(i)=conjg(ww3(i))
+
+        enddo
+        
+      endif
+      
+c     perform fourier transform in X direction
+      
+      kkk=0
+      num=ndiv1/2
+      
+      do l=1,nu1
+
+        do while(kkk.lt.ndiv1)
+
+          do i=1,num
+            
+            iii=key1(kkk/num+1)
+            kk1=kkk+1
+            k12=kk1+num
+            
+            do j=1,ndiv2
+              
+              do k=1,ndiv3
+                
+                ttt=aaa(k12,j,k)*ww1(iii)
+                aaa(k12,j,k)=aaa(kk1,j,k)-ttt
+                aaa(kk1,j,k)=aaa(kk1,j,k)+ttt
+                
+              enddo
+              
+            enddo
+            
+            kkk=kkk+1
+            
+          enddo
+          
+          kkk=kkk+num
+          
+        enddo
+        
+        kkk=0
+        num=num/2
+
+      enddo
+      
+c     unscramble the fft using bit address array
+      
+      do kkk=1,ndiv1
+
+        iii=key1(kkk)
+
+        if(iii.gt.kkk)then
+
+          do j=1,ndiv2
+
+            do k=1,ndiv3
+
+              ttt=aaa(kkk,j,k)
+              aaa(kkk,j,k)=aaa(iii,j,k)
+              aaa(iii,j,k)=ttt
+
+            enddo
+
+          enddo
+
+        endif
+
+      enddo
+      
+c     perform fourier transform in Y direction
+      
+      kkk=0
+      num=ndiv2/2
+
+      do l=1,nu2
+
+        do while(kkk.lt.ndiv2)
+
+          do i=1,num
+            
+            iii=key2(kkk/num+1)
+            kk1=kkk+1
+            k12=kk1+num
+            
+            do j=1,ndiv1
+              
+              do k=1,ndiv3
+                
+                ttt=aaa(j,k12,k)*ww2(iii)
+                aaa(j,k12,k)=aaa(j,kk1,k)-ttt
+                aaa(j,kk1,k)=aaa(j,kk1,k)+ttt
+                
+              enddo
+              
+            enddo
+            
+            kkk=kkk+1
+            
+          enddo
+          
+          kkk=kkk+num
+          
+        enddo
+
+        kkk=0
+        num=num/2
+
+      enddo
+      
+c     unscramble the fft using bit address array
+      
+      do kkk=1,ndiv2
+
+        iii=key2(kkk)
+
+        if(iii.gt.kkk)then
+
+          do j=1,ndiv1
+
+            do k=1,ndiv3
+
+              ttt=aaa(j,kkk,k)
+              aaa(j,kkk,k)=aaa(j,iii,k)
+              aaa(j,iii,k)=ttt
+
+            enddo
+
+          enddo
+
+        endif
+
+      enddo
+      
+c     perform fourier transform in Z direction
+      
+      kkk=0
+      num=ndiv3/2
+
+      do l=1,nu3
+
+        do while(kkk.lt.ndiv3)
+
+          do i=1,num
+
+            iii=key3(kkk/num+1)
+            kk1=kkk+1
+            k12=kk1+num
+            
+            do j=1,ndiv1
+              
+              do k=1,ndiv2
+                
+                ttt=aaa(j,k,k12)*ww3(iii)
+                aaa(j,k,k12)=aaa(j,k,kk1)-ttt
+                aaa(j,k,kk1)=aaa(j,k,kk1)+ttt
+                
+              enddo
+              
+            enddo
+            
+            kkk=kkk+1
+            
+          enddo
+          
+          kkk=kkk+num
+          
+        enddo
+
+        kkk=0
+        num=num/2
+
+      enddo
+      
+c     unscramble the fft using bit address array
+      
+      do kkk=1,ndiv3
+
+        iii=key3(kkk)
+
+        if(iii.gt.kkk)then
+
+          do j=1,ndiv1
+
+            do k=1,ndiv2
+
+              ttt=aaa(j,k,kkk)
+              aaa(j,k,kkk)=aaa(j,k,iii)
+              aaa(j,k,iii)=ttt
+
+            enddo
+
+          enddo
+
+        endif
+
+      enddo
+      
+c     restore exponentials to unconjugated values if necessary
+      
+      if(isw.lt.0)then
+        
+        do i=1,ndiv1
+
+          ww1(i)=conjg(ww1(i))
+
+        enddo
+        
+        do i=1,ndiv2
+
+          ww2(i)=conjg(ww2(i))
+
+        enddo
+        
+        do i=1,ndiv3
+
+          ww3(i)=conjg(ww3(i))
+
+        enddo
+        
+      endif
+      
+      return
+      end subroutine dlpfft3
+
+      subroutine spl_cexp(ndiv1,ndiv2,ndiv3,ww1,ww2,ww3)
+
+c***********************************************************************
+c     
+c     dl-poly routine to create complex exponential arrays for
+c     b-splines
+c     
+c     copyright daresbury laboratory 1998
+c     author w smith oct 1998
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      integer ndiv1,ndiv2,ndiv3,i
+      real(8) tpi,arg
+      complex(8) ww1(ndiv1),ww2(ndiv2),ww3(ndiv3)
+
+      data tpi/6.283185307179586d0/
+
+c     initialise complex exponential factors
+      
+      ww1(1)=(1.d0,0.d0)
+
+      do i=1,ndiv1/2
+
+        arg=(tpi/dble(ndiv1))*dble(i)
+        ww1(i+1)=cmplx(cos(arg),sin(arg),kind=8)
+        ww1(ndiv1+1-i)=conjg(ww1(i+1))
+
+      enddo
+      
+      ww2(1)=(1.d0,0.d0)
+
+      do i=1,ndiv2/2
+
+        arg=(tpi/dble(ndiv2))*dble(i)
+        ww2(i+1)=cmplx(cos(arg),sin(arg),kind=8)
+        ww2(ndiv2+1-i)=conjg(ww2(i+1))
+
+      enddo
+      
+      ww3(1)=(1.d0,0.d0)
+
+      do i=1,ndiv3/2
+
+        arg=(tpi/dble(ndiv3))*dble(i)
+        ww3(i+1)=cmplx(cos(arg),sin(arg),kind=8)
+        ww3(ndiv3+1-i)=conjg(ww3(i+1))
+
+      enddo
+      
+      return
+      end subroutine spl_cexp
+      
+      end module spme_module
diff -urN dl_class_1.9.orig/srcmod/temp_scalers_module.f dl_class_1.9/srcmod/temp_scalers_module.f
--- dl_class_1.9.orig/srcmod/temp_scalers_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/temp_scalers_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,768 @@
+      module temp_scalers_module
+
+c***********************************************************************
+c     
+c     dl_poly module for temperature scaling routines
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      use config_module
+      use core_shell_module
+      use error_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use utility_module
+      
+      contains
+
+      subroutine quench(imcon,idnode,mxnode,natms,nscons,tolnce)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for quenching the bond energies in the 
+c     initial structure of a molecule defined by constraints
+c     
+c     copyright - daresbury laboratory 1992
+c     author w.smith november 1992
+c     
+c*********************************************************************
+
+      implicit none
+
+      logical safe
+      integer imcon,idnode,mxnode,natms,nscons,i,j,k,icyc
+      integer fail
+      real(8) tolnce,ddd,esig,vvv,ww1,ww2
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: uxx(:),uyy(:),uzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+
+      dimension fail(3)
+
+      data fail/0,0,0/
+
+c     allocate work arrays
+
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+      allocate (uxx(mxatms),uyy(mxatms),uzz(mxatms),stat=fail(2))
+      allocate (dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(3))
+
+      do i=1,3
+         if(fail(i).ne.0)call error(idnode,1770)
+      enddo
+
+c     calculate bond vectors
+
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+        
+        dxt(k)=xxx(i)-xxx(j)
+        dyt(k)=yyy(i)-yyy(j)
+        dzt(k)=zzz(i)-zzz(j)
+        
+      enddo
+      
+      call images(imcon,0,1,nscons,cell,dxt,dyt,dzt)
+      
+c     normalise bond vectors
+      
+      do k=1,nscons
+        
+        ddd=sqrt(dxt(k)**2+dyt(k)**2+dzt(k)**2)
+        
+        dxt(k)=dxt(k)/ddd
+        dyt(k)=dyt(k)/ddd
+        dzt(k)=dzt(k)/ddd
+        
+      enddo
+      
+c     start of quenching cycle
+      
+      icyc=0
+      safe=.false.
+      do while(.not.safe.and.icyc.lt.mxshak)
+        
+        icyc=icyc+1
+
+c     initialise velocity correction arrays
+        
+        do i=1,natms
+          
+          uxx(i)=0.d0
+          uyy(i)=0.d0
+          uzz(i)=0.d0
+          
+        enddo
+        
+c     calculate velocity corrections and error
+        
+        esig=0.d0
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          vvv=dxt(k)*(vxx(i)-vxx(j))+dyt(k)*(vyy(i)-vyy(j))+
+     x      dzt(k)*(vzz(i)-vzz(j))
+          
+          esig=max(esig,abs(vvv))
+          
+          ww1=weight(j)*vvv/(weight(i)+weight(j))
+          ww2=weight(i)*vvv/(weight(i)+weight(j))
+          uxx(i)=uxx(i)-ww1*dxt(k)
+          uyy(i)=uyy(i)-ww1*dyt(k)
+          uzz(i)=uzz(i)-ww1*dzt(k)
+          uxx(j)=uxx(j)+ww2*dxt(k)
+          uyy(j)=uyy(j)+ww2*dyt(k)
+          uzz(j)=uzz(j)+ww2*dzt(k)
+          
+        enddo
+
+        safe=(esig.lt.tolnce)
+        
+        if(mxnode.gt.1)call gstate(safe)
+        
+        if(.not.safe)then
+          
+c     transport velocity adjustments to other nodes
+          
+          if(mxnode.gt.1)then
+            
+            call shmove
+     x        (idnode,mxnode,natms,lashap,lishap,uxx,uyy,uzz,
+     x        xxt,yyt,zzt,buffer)
+            
+          endif
+          
+c     update velocities
+          
+          do k=1,nscons
+            
+            i=listcon(k,2)
+            j=listcon(k,3)
+            vxx(i)=vxx(i)+uxx(i)/dble(listme(i))
+            vyy(i)=vyy(i)+uyy(i)/dble(listme(i))
+            vzz(i)=vzz(i)+uzz(i)/dble(listme(i))
+            vxx(j)=vxx(j)+uxx(j)/dble(listme(j))
+            vyy(j)=vyy(j)+uyy(j)/dble(listme(j))
+            vzz(j)=vzz(j)+uzz(j)/dble(listme(j))
+            
+          enddo
+          
+        endif
+        
+      enddo
+      
+c     error exit if quenching fails
+      
+      if(.not.safe)call error(idnode,70)
+      
+c     splice velocity arrays across nodes
+      
+      if(mxnode.gt.1) call splice
+     x  (idnode,natms,listme,listot,vxx,vyy,vzz,buffer)
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,stat=fail(1))
+      deallocate (uxx,uyy,uzz,stat=fail(2))
+      deallocate (dxt,dyt,dzt,stat=fail(3))
+      
+      return
+      end subroutine quench
+
+      subroutine quatqnch(idnode,imcon,mxnode,natms,ngrp)
+
+c***********************************************************************
+c     
+c     dlpoly subroutine to convert atomic velocities to rigid body 
+c     c.o.m. and angular velocity
+c     
+c     parallel replicated data version : block data
+c     
+c     copyright daresbury laboratory 1993.
+c     author   - t.forester nov 1993.
+c     amended  - t.forester dec 1994 : block data.
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,imcon,mxnode,natms,ngrp,fail,ig,jr,id
+      integer igrp1,igrp2,i,j
+      real(8) rot,wxx,wyy,wzz
+
+      dimension rot(9)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+
+      data fail/0/
+      
+c     allocate work arrays 
+
+      allocate (xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail)
+      if(fail.ne.0)call error(idnode,1780)
+
+c     block indices for groups
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     translate atomic velocites to com velocity & angular velocity
+
+      jr=0
+      do ig=igrp1,igrp2
+
+        gvxx(ig)=0.d0
+        gvyy(ig)=0.d0
+        gvzz(ig)=0.d0
+        omx(ig)=0.d0
+        omy(ig)=0.d0
+        omz(ig)=0.d0
+
+        id=lstgtp(ig)
+
+        do j=1,numgsit(id)
+
+          jr =jr+1
+          i =lstrgd(jr)
+
+c     centre of mass momentum
+
+          gvxx(ig)=gvxx(ig)+weight(i)*vxx(i)
+          gvyy(ig)=gvyy(ig)+weight(i)*vyy(i)
+          gvzz(ig)=gvzz(ig)+weight(i)*vzz(i)
+
+c     distance to c.o.m of molecule
+
+          xxt(jr)=xxx(i)-gcmx(ig)
+          yyt(jr)=yyy(i)-gcmy(ig)
+          zzt(jr)=zzz(i)-gcmz(ig)
+
+        enddo
+
+c     centre of mass velocity
+
+        gvxx(ig)=gvxx(ig)/gmass(id)
+        gvyy(ig)=gvyy(ig)/gmass(id)
+        gvzz(ig)=gvzz(ig)/gmass(id)
+
+      enddo
+
+      call images(imcon,0,1,jr,cell,xxt,yyt,zzt)
+
+      jr=0
+      do ig=igrp1,igrp2
+
+c     rotational matrix
+
+        rot(1)=q0(ig)**2+q1(ig)**2-q2(ig)**2-q3(ig)**2
+        rot(2)=2.d0*(q1(ig)*q2(ig)-q0(ig)*q3(ig))
+        rot(3)=2.d0*(q1(ig)*q3(ig)+q0(ig)*q2(ig))
+        rot(4)=2.d0*(q1(ig)*q2(ig)+q0(ig)*q3(ig))
+        rot(5)=q0(ig)**2-q1(ig)**2+q2(ig)**2-q3(ig)**2
+        rot(6)=2.d0*(q2(ig)*q3(ig)-q0(ig)*q1(ig))
+        rot(7)=2.d0*(q1(ig)*q3(ig)-q0(ig)*q2(ig))
+        rot(8)=2.d0*(q2(ig)*q3(ig)+q0(ig)*q1(ig))
+        rot(9)=q0(ig)**2-q1(ig)**2-q2(ig)**2+q3(ig)**2
+        
+c     angular momentum accumulators
+
+        wxx=0.d0
+        wyy=0.d0
+        wzz=0.d0
+
+        id=lstgtp(ig)
+
+        do j=1,numgsit(id)
+
+          jr =jr+1
+          i =lstrgd(jr)
+
+          wxx=wxx+weight(i)*(yyt(jr)*vzz(i)-zzt(jr)*vyy(i))
+          wyy=wyy+weight(i)*(zzt(jr)*vxx(i)-xxt(jr)*vzz(i))
+          wzz=wzz+weight(i)*(xxt(jr)*vyy(i)-yyt(jr)*vxx(i))
+
+        enddo
+
+c     angular velocity in body fixed frame
+
+        omx(ig)=(rot(1)*wxx+rot(4)*wyy+rot(7)*wzz)*rotinx(id,2)
+        omy(ig)=(rot(2)*wxx+rot(5)*wyy+rot(8)*wzz)*rotiny(id,2)
+        omz(ig)=(rot(3)*wxx+rot(6)*wyy+rot(9)*wzz)*rotinz(id,2)
+        
+        jr=jr-numgsit(id)
+        do j=1,numgsit(id)
+          
+          jr=jr +1
+          i=lstrgd(jr)
+          
+c     site velocity in body frame 
+
+          wxx=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+          wyy=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+          wzz=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+
+          vxx(i)=rot(1)*wxx+rot(2)*wyy+rot(3)*wzz+gvxx(ig)
+          vyy(i)=rot(4)*wxx+rot(5)*wyy+rot(6)*wzz+gvyy(ig)
+          vzz(i)=rot(7)*wxx+rot(8)*wyy+rot(9)*wzz+gvzz(ig)
+
+        enddo
+
+      enddo
+
+      if(mxnode.gt.1)then
+
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,omx,omy,omz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+      endif
+
+c     deallocate work arrays
+
+      deallocate (xxt,yyt,zzt,stat=fail)
+      
+      return
+      end subroutine quatqnch
+
+      subroutine vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for scaling the velocity arrays to the
+c     desired temperature
+c     
+c     zeroes angular momentum in non-periodic system.
+c     
+c     parallel replicated data version : block data
+c     
+c     copyright daresbury laboratory 1992.
+c     author - w.smith july 1992
+c     amended - t.forester oct 1993
+c     amended - t.forester dec 1994 : block data
+c     
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,imcon,natms,ngrp,iatm1,iatm2,i
+      real(8) sigma,roti,rotinv,cmx,cmy,cmz,cmvx,cmvy,cmvz,sysmas
+      real(8) amx,amy,amz,det,scale,rsq,wxx,wyy,wzz,sumke
+
+      dimension roti(9),rotinv(9)
+
+c     block indices
+
+      iatm1=(idnode*natms)/mxnode+1
+      iatm2=((idnode+1)*natms)/mxnode
+
+c     calculate centre of mass position and motion of the system
+      
+      cmx=0.d0
+      cmy=0.d0
+      cmz=0.d0
+      cmvx=0.d0
+      cmvy=0.d0
+      cmvz=0.d0
+      sysmas=0.d0
+      
+      do i=iatm1,iatm2
+        
+        if(lstfrz(i).eq.0.and.weight(i).gt.1.d-6)then
+
+          cmx=cmx+weight(i)*xxx(i)
+          cmy=cmy+weight(i)*yyy(i)
+          cmz=cmz+weight(i)*zzz(i)
+          sysmas=sysmas+weight(i)
+          cmvx=cmvx+vxx(i)*weight(i)
+          cmvy=cmvy+vyy(i)*weight(i)
+          cmvz=cmvz+vzz(i)*weight(i)
+          
+        endif
+
+      enddo
+      
+      if(mxnode.gt.1)then
+        buffer(8)=sysmas
+        buffer(9)=cmx
+        buffer(10)=cmy
+        buffer(11)=cmz
+        buffer(12)=cmvx
+        buffer(13)=cmvy
+        buffer(14)=cmvz
+        call gdsum(buffer(8),7,buffer(1))
+        sysmas= buffer(8) 
+        cmx=buffer(9) 
+        cmy=buffer(10) 
+        cmz=buffer(11) 
+        cmvx=buffer(12) 
+        cmvy=buffer(13) 
+        cmvz=buffer(14) 
+      endif
+
+      cmx=cmx/sysmas
+      cmy=cmy/sysmas
+      cmz=cmz/sysmas
+      
+      cmvx=cmvx/sysmas
+      cmvy=cmvy/sysmas
+      cmvz=cmvz/sysmas
+      
+c     remove centre of mass motion  
+      
+      do i=1,natms
+        
+        if(lstfrz(i).eq.0.and.weight(i).gt.1.d-6)then
+
+          vxx(i)=vxx(i)-cmvx
+          vyy(i)=vyy(i)-cmvy
+          vzz(i)=vzz(i)-cmvz
+          
+        else
+
+          vxx(i)=0.d0
+          vyy(i)=0.d0
+          vzz(i)=0.d0
+
+        endif
+
+      enddo
+      
+c     zero angular momentum about centre of mass - non-periodic system
+      
+      if(imcon.eq.0)then
+
+c     move to centre of mass origin
+        
+        do i=1,natms
+          
+          xxx(i)=xxx(i)-cmx
+          yyy(i)=yyy(i)-cmy
+          zzz(i)=zzz(i)-cmz
+          
+        enddo
+        
+c     angular momentum accumulators
+        
+        amx=0.d0
+        amy=0.d0
+        amz=0.d0
+
+c     rotational inertia accumulators
+        
+        do i=1,9
+          roti(i)=0.d0
+        enddo
+        
+        do i=iatm1,iatm2
+          
+          amx=amx+weight(i)*(yyy(i)*vzz(i)-zzz(i)*vyy(i))
+          amy=amy+weight(i)*(zzz(i)*vxx(i)-xxx(i)*vzz(i))
+          amz=amz+weight(i)*(xxx(i)*vyy(i)-yyy(i)*vxx(i))
+          
+          rsq=xxx(i)**2+yyy(i)**2+zzz(i)**2
+          roti(1)=roti(1)+weight(i)*(xxx(i)*xxx(i)-rsq)
+          roti(2)=roti(2)+weight(i)* xxx(i)*yyy(i)
+          roti(3)=roti(3)+weight(i)* xxx(i)*zzz(i)
+          roti(5)=roti(5)+weight(i)*(yyy(i)*yyy(i)-rsq)
+          roti(6)=roti(6)+weight(i)* yyy(i)*zzz(i)
+          roti(9)=roti(9)+weight(i)*(zzz(i)*zzz(i)-rsq)
+          
+        enddo
+
+c     complete rotational inertia matrix
+        
+        roti(4)=roti(2)
+        roti(7)=roti(3)
+        roti(8)=roti(6)
+
+c     global sum
+
+        if(mxnode.gt.1)then
+          buffer(13)=amx
+          buffer(14)=amy
+          buffer(15)=amz
+          do i=1,9
+            buffer(15+i)=roti(i)
+          enddo
+          call gdsum(buffer(13),12,buffer(1))
+          amx=buffer(13) 
+          amy=buffer(14) 
+          amz=buffer(15) 
+          do i=1,9
+            roti(i)=buffer(15+i)
+          enddo
+        endif
+
+c     invert rotational inertia matrix
+        
+        call invert (roti,rotinv,det)
+
+c     correction to angular velocity
+        
+        wxx=rotinv(1)*amx+rotinv(2)*amy+rotinv(3)*amz
+        wyy=rotinv(4)*amx+rotinv(5)*amy+rotinv(6)*amz
+        wzz=rotinv(7)*amx+rotinv(8)*amy+rotinv(9)*amz
+
+c     correction to linear velocity
+        
+        do i=1,natms
+
+          if(lstfrz(i).eq.0.and.weight(i).gt.1.d-6)then
+
+            vxx(i)=vxx(i)+(wyy*zzz(i)-wzz*yyy(i))
+            vyy(i)=vyy(i)+(wzz*xxx(i)-wxx*zzz(i))
+            vzz(i)=vzz(i)+(wxx*yyy(i)-wyy*xxx(i))
+            
+          endif
+
+        enddo
+
+c     reset positions to original reference frame
+        
+        do i=1,natms
+          
+          xxx(i)=xxx(i)+cmx
+          yyy(i)=yyy(i)+cmy
+          zzz(i)=zzz(i)+cmz
+          
+        enddo
+        
+      endif
+
+c     calculate temperature 
+
+      sumke=0.d0
+      
+      do i=iatm1,iatm2
+
+        sumke=sumke+weight(i)*
+     x    (vxx(i)**2+vyy(i)**2+vzz(i)**2)
+
+      enddo
+
+      sumke=0.5d0*sumke
+      if(mxnode.gt.1)then
+        buffer(1)=sumke
+        call gdsum(buffer(1),1,buffer(2))
+        sumke=buffer(1)
+      endif
+
+c     apply temperature scaling
+      
+      scale=1.d0
+      if(sumke.gt.1.d-6)scale=sqrt(sigma/sumke)
+      
+      do i=1,natms
+        
+        vxx(i)=scale*vxx(i)
+        vyy(i)=scale*vyy(i)
+        vzz(i)=scale*vzz(i)
+        
+      enddo
+
+      if(ngrp.gt.0)then
+        call quatqnch(idnode,imcon,mxnode,natms,ngrp)
+
+      endif
+      
+      return
+      end subroutine vscaleg
+
+      subroutine shlqnch(idnode,mxnode,ntshl,temp)
+      
+c*********************************************************************
+c     
+c     dl_poly subroutine for quenching the internal bond energies
+c     in ions defined by shell model
+c     
+c     copyright - daresbury laboratory 1994
+c     author w.smith july  1994
+c     
+c*********************************************************************
+      
+      implicit none
+
+      integer idnode,mxnode,ntshl,ishl1,ishl2,i,j,k,m
+      real(8) temp,pke,rmu,dvx,dvy,dvz,tmx,tmy,tmz,scl
+
+c     permitted core-shell internal kinetic energy 
+      
+      pke=boltz*temp*1.d-4
+
+c     block indices
+
+      ishl1 = (idnode*ntshl)/mxnode+1
+      ishl2 = ((idnode+1)*ntshl)/mxnode
+
+c     calculate core and shell velocities from total momentum
+      
+      m=0
+      do k=ishl1,ishl2
+        
+        m=m+1
+        
+        i=listshl(m,2)
+        j=listshl(m,3)
+
+        rmu=(weight(i)*weight(j))/(weight(i)+weight(j))
+        
+        if(rmu.gt.0.d0)then
+          
+          dvx=vxx(j)-vxx(i)
+          dvy=vyy(j)-vyy(i)
+          dvz=vzz(j)-vzz(i)
+          
+          scl=sqrt(pke/(rmu*(dvx*dvx+dvy*dvy+dvz*dvz)))
+          
+          tmx=weight(i)*vxx(i)+weight(j)*vxx(j)
+          tmy=weight(i)*vyy(i)+weight(j)*vyy(j)
+          tmz=weight(i)*vzz(i)+weight(j)*vzz(j)
+          
+          vxx(i)=tmx/(weight(i)+weight(j))-scl*rmu*dvx/weight(i)
+          vxx(j)=tmx/(weight(i)+weight(j))+scl*rmu*dvx/weight(j)
+          vyy(i)=tmy/(weight(i)+weight(j))-scl*rmu*dvy/weight(i)
+          vyy(j)=tmy/(weight(i)+weight(j))+scl*rmu*dvy/weight(j)
+          vzz(i)=tmz/(weight(i)+weight(j))-scl*rmu*dvz/weight(i)
+          vzz(j)=tmz/(weight(i)+weight(j))+scl*rmu*dvz/weight(j)
+          
+        endif
+        
+      enddo
+
+      if(mxnode.gt.1) call shlmerge(idnode,mxnode,ntshl)
+      
+      return
+      end subroutine shlqnch
+      
+      subroutine regauss
+     x  (idnode,imcon,mxnode,natms,ngrp,nscons,ntcons,
+     x  ntshl,keyshl,sigma,temp,tolnce)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for resetting the system velocities
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    may 2007
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,imcon,mxnode,natms,ngrp,nscons
+      integer ntcons,ntshl,i,k,keyshl
+      real(8) temp,tolnce,sigma,rsq
+      
+c     set atomic velocities from gaussian distribution
+
+      call gauss(natms,vxx,vyy,vzz)
+      
+      do i=1,natms
+        
+        rsq=sqrt(rmass(i))
+        vxx(i)=vxx(i)*rsq
+        vyy(i)=vyy(i)*rsq
+        vzz(i)=vzz(i)*rsq
+        
+      enddo
+      
+      if(ntcons.gt.0)call quench
+     x  (imcon,idnode,mxnode,natms,nscons,tolnce)
+      
+      if(ngrp.gt.0)call quatqnch
+     x  (idnode,imcon,mxnode,natms,ngrp)
+      
+      if(keyshl.eq.1)then
+        
+        do k=1,4
+          
+          call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+          call shlqnch(idnode,mxnode,ntshl,temp)
+          
+        enddo
+        
+      else
+        
+        call vscaleg(idnode,mxnode,imcon,natms,ngrp,sigma)
+        
+      endif
+      
+      return
+      end subroutine regauss
+      
+      subroutine impact(khit,natms,idnode,mxnode,ehit,xhit,yhit,zhit)
+      
+c*********************************************************************
+c     
+c     DLPOLY routinue for impacting a selected atom with a specified
+c     recoil energy
+c     
+c     copyright daresbury laboratory
+c     author w.smith september 2007
+c     
+c*********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      
+      implicit none
+      
+      integer i,khit,natms,idnode,mxnode,iatm0,iatm1
+      real(8) ehit,vxo,vyo,vzo,xhit,yhit,zhit,fac,smass,vel
+      
+c     store original particle velocity
+      
+      vxo=vxx(khit)
+      vyo=vyy(khit)
+      vzo=vzz(khit)
+      
+c     determine recoil velocity
+      
+      vel=sqrt(2.d0*ehit/(weight(khit)*(xhit**2+yhit**2+zhit**2)))
+      
+c     reassign particle velocity
+      
+      vxx(khit)=vel*xhit
+      vyy(khit)=vel*yhit
+      vzz(khit)=vel*zhit
+      
+c     determine system mass
+      
+      smass=getmass(natms,idnode,mxnode)
+      
+c     calculate net system velocity
+      
+      vxo=(vxx(khit)-vxo)*weight(khit)/smass
+      vyo=(vyy(khit)-vyo)*weight(khit)/smass
+      vzo=(vzz(khit)-vzo)*weight(khit)/smass
+      
+c     reset system net velocity to zero
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      do i=iatm0,iatm1
+        
+        vxx(i)=vxx(i)-vxo
+        vyy(i)=vyy(i)-vyo
+        vzz(i)=vzz(i)-vzo
+        
+      enddo
+      
+      if(mxnode.gt.1)
+     x  call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+      
+      return
+      end subroutine impact
+      
+      end module temp_scalers_module
diff -urN dl_class_1.9.orig/srcmod/tersoff_module.f dl_class_1.9/srcmod/tersoff_module.f
--- dl_class_1.9.orig/srcmod/tersoff_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/tersoff_module.f	2011-04-16 16:13:06.000000000 +0200
@@ -0,0 +1,1011 @@
+      module tersoff_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining tersoff potential arrays
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    dec 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use parse_module
+      use setup_module
+      use site_module
+      use utility_module
+
+      implicit none
+
+      logical, allocatable :: filter(:)
+      integer, allocatable :: lstter(:),ltpter(:),lattsf(:)
+      real(8), allocatable :: prmter(:,:),prmter2(:,:)
+      real(8), allocatable :: vmbp(:,:,:),gmbp(:,:,:)
+      real(8), allocatable :: xtf(:),ytf(:),ztf(:),rtf(:)
+      real(8), allocatable :: ert(:),eat(:),grt(:),gat(:)
+      real(8), allocatable :: scr(:),gcr(:),gam(:),gvr(:)
+
+      save xtf,ytf,ztf,rtf,ert,eat,grt,gat,scr,gcr,gam,filter
+      save prmter,prmter2,lstter,ltpter,lattsf,vmbp,gmbp
+
+      contains
+      
+      subroutine alloc_ter_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=20
+
+      integer i,fail,idnode,npairs
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      npairs=(mxter*(mxter+1))/2
+      allocate (prmter(mxter,mxpter),stat=fail(1))
+      allocate (prmter2(2,npairs),stat=fail(2))
+      allocate (lstter(mxter),stat=fail(3))
+      allocate (ltpter(mxter),stat=fail(4))
+      allocate (lattsf(mxatms),stat=fail(5))
+      allocate (xtf(mxatms),stat=fail(6))
+      allocate (ytf(mxatms),stat=fail(7))
+      allocate (ztf(mxatms),stat=fail(8))
+      allocate (rtf(mxatms),stat=fail(9))
+      allocate (ert(mxatms),stat=fail(10))
+      allocate (eat(mxatms),stat=fail(11))
+      allocate (grt(mxatms),stat=fail(12))
+      allocate (gat(mxatms),stat=fail(13))
+      allocate (scr(mxatms),stat=fail(14))
+      allocate (gcr(mxatms),stat=fail(15))
+      allocate (gam(mxatms),stat=fail(16))
+      allocate (gvr(mxatms),stat=fail(17))
+      allocate (vmbp(mxgrid,npairs,3),stat=fail(18))
+      allocate (gmbp(mxgrid,npairs,3),stat=fail(19))
+      allocate (filter(mxsite),stat=fail(20))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1945)
+      enddo
+
+      end subroutine alloc_ter_arrays
+
+      subroutine define_tersoff
+     x  (safe,lunits,lmols,idnode,ntpter,ntpatm,rctter,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining tersoff potentials
+c
+c     based on potential form defined in:
+c     J. Tersoff, Phys. Rev. B 39 (1989) 5566.
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lunits,lmols
+      character*8 keyword
+      character*8 atom0,atom1
+      character*1 message(80)
+      integer fail,idnode,ntpter,ntpatm,i,idum,j,itpter
+      integer keypot,jtpatm,k,katm0,katm1,icross,npairs,ktyp
+      real(8) rctter,engunit
+      real(8), allocatable :: parpot(:)
+      data fail/0/
+
+      allocate (parpot(mxpter),stat=fail)
+      if(fail.ne.0)call error(idnode,1955)
+
+      ntpter=intstr(record,lenrec,idum)
+      
+      if(idnode.eq.0) then
+        
+        write(nrite,"(/,/,1x,'number of specified tersoff ',
+     x    'atom potentials',i10)") ntpter
+        write(nrite,"(/,/,16x,'atom    ',3x,' key',30x,
+     x    'parameters'/,/)")
+        
+      endif      
+      if(ntpter.gt.mxter) call error(idnode,88)
+      if(.not.lunits) call error(idnode,6)
+      if(.not.lmols) call error(idnode,13)
+      
+      rctter=0.d0
+
+      do i=1,mxter
+        lstter(i)=-1
+      enddo
+
+      do i=1,mxsite
+        filter(i)=.false.
+      enddo
+
+      k=0
+      do i=1,mxter
+        do j=1,i
+
+          k=k+1
+          prmter2(1,k)=0.d0
+          prmter2(2,k)=0.d0
+
+        enddo
+      enddo
+      
+      do itpter=1,ntpter
+        
+        do i=1,mxpter
+          parpot(i)=0.d0
+        enddo
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        call copystring(record,message,80)
+        call getword(atom0,record,8,lenrec)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+
+        if(keyword(1:4).eq.'ters') then
+
+          keypot=1
+
+        else
+
+          if(idnode.eq.0) write(nrite,*) message
+          call error(idnode,1972)
+
+        endif
+
+        parpot(1)=dblstr(record,lenrec,idum)  ! A_i
+        parpot(2)=dblstr(record,lenrec,idum)  ! a_i
+        parpot(3)=dblstr(record,lenrec,idum)  ! B_i
+        parpot(4)=dblstr(record,lenrec,idum)  ! b_i
+        parpot(5)=dblstr(record,lenrec,idum)  ! R_i
+
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        parpot(6)=dblstr(record,lenrec,idum)    ! S_i
+        parpot(7)=dblstr(record,lenrec,idum)    ! beta_i
+        parpot(8)=dblstr(record,lenrec,idum)    ! eta_i
+        parpot(9)=dblstr(record,lenrec,idum)    ! c_i
+        parpot(10)=dblstr(record,lenrec,idum)   ! d_i
+        parpot(11)=dblstr(record,lenrec,idum)   ! h_i
+        
+        if(idnode.eq.0) then
+
+          write(nrite,"(16x,a8,2x,a4,2x,1p,5e13.5)") 
+     x      atom0,keyword(1:4),(parpot(j),j=1,5)
+          write(nrite,"(32x,1p,5e13.5)")(parpot(j),j=6,mxpter)
+
+        endif
+        
+        katm0=0
+        
+        do jtpatm=1,ntpatm
+          if(atom0.eq.unqatm(jtpatm))katm0=jtpatm
+        enddo
+        
+        if(katm0.eq.0)call error(idnode,92)
+
+        filter(katm0)=.true.
+        
+c     convert parameters to internal units
+        
+        if(keypot.eq.1)then
+          
+          parpot(1)=parpot(1)*engunit
+          parpot(3)=parpot(3)*engunit
+
+        endif
+        if(lstter(katm0).gt.-1) call error(idnode,21)
+        lstter(katm0)=itpter
+        ltpter(itpter)=keypot
+
+c     calculate max tersoff cutoff
+        
+        rctter=max(rctter,parpot(6))
+        
+c     store tersoff single atom potential parameters
+        
+        do i=1,mxpter
+          prmter(itpter,i)=parpot(i)
+        enddo
+
+      enddo
+
+      if(rctter.lt.1.d-6)call error(idnode,1953)
+      
+c     start processing double atom potential parameters
+
+      npairs=(ntpter*(ntpter+1))/2
+
+      if(idnode.eq.0)then
+
+        write(nrite,"(/,/,1x,'number of tersoff ',
+     x    'cross terms',i10)") npairs
+        write(nrite,"(/,/,16x,'atom    ','atom    ',10x,
+     x    'parameters'/,/)")
+
+      endif
+
+      do icross=1,npairs
+
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        call getword(atom0,record,8,lenrec)
+        call getword(atom1,record,8,lenrec)
+
+        parpot(1)=dblstr(record,lenrec,idum)  ! chi_ij
+        parpot(2)=dblstr(record,lenrec,idum)  ! omega_ij
+
+        katm0=0
+        katm1=0
+        
+        do jtpatm=1,ntpatm
+          if(atom0.eq.unqatm(jtpatm))katm0=jtpatm
+          if(atom1.eq.unqatm(jtpatm))katm1=jtpatm
+        enddo
+        
+        if(katm0.eq.0.or.katm1.eq.0)call error(idnode,92)
+        
+        filter(katm0)=.true.
+        filter(katm1)=.true.
+        
+        ktyp=loc2(lstter(katm0),lstter(katm1))
+        prmter2(1,ktyp)=parpot(1)
+        prmter2(2,ktyp)=parpot(2)
+
+        if(idnode.eq.0)write(nrite,"(16x,a8,a8,1p,2e13.5)") 
+     x     atom0,atom1,(parpot(j),j=1,2)
+
+      enddo
+
+c     generate tersoff interpolation arrays
+
+      call tergen(ntpatm,rctter)
+
+      return
+      end subroutine define_tersoff
+
+      subroutine tergen(ntpatm,rctter)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for generating potential energy and 
+c     force arrays for tersoff forces only
+c
+c     based on potential form defined in:
+c     J. Tersoff, Phys. Rev. B 39 (1989) 5566.
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith dec 2003
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer ntpatm,katm0,katm1,ipt,jpt,kpt,i
+      real(8) dlrpot,rctter,baij,saij,bbij,sbij,rij,sij,att,arg
+      real(8) rrr,rep
+      
+c     define grid resolution for potential arrays
+      
+      dlrpot=rctter/dble(mxgrid-4)
+
+c     construct arrays for all types of short ranged  potential
+      
+      do katm0=1,ntpatm
+
+        if(filter(katm0))then
+          
+          ipt=lstter(katm0)
+          
+          do katm1=1,katm0
+            
+            if(filter(katm1))then
+              
+              jpt=lstter(katm1)
+              
+              if((ltpter(ipt).eq.1).and.(ltpter(jpt).eq.1))then
+                
+                kpt=loc2(ipt,jpt)
+                
+c     define tersoff parameters
+                
+                baij=sqrt(prmter(ipt,1)*prmter(jpt,1))
+                saij=0.5d0*(prmter(ipt,2)+prmter(jpt,2))
+                bbij=sqrt(prmter(ipt,3)*prmter(jpt,3))
+                sbij=0.5d0*(prmter(ipt,4)+prmter(jpt,4))
+                rij=sqrt(prmter(ipt,5)*prmter(jpt,5))
+                sij=sqrt(prmter(ipt,6)*prmter(jpt,6))
+                
+c     store potential cutoff
+                
+                vmbp(1,kpt,1)=sij
+                
+c     calculate screening function
+                
+                do i=2,mxgrid
+                  
+                  rrr=dble(i)*dlrpot
+                  
+                  if(rrr.le.rij)then
+                    
+                    vmbp(i,kpt,1)=1.d0
+                    gmbp(i,kpt,1)=0.d0
+                    
+                  else
+                    
+                    arg=pi*(rrr-rij)/(sij-rij)
+                    vmbp(i,kpt,1)=0.5d0*(1.d0+cos(arg))
+                    gmbp(i,kpt,1)=0.5d0*pi*rrr*sin(arg)/(sij-rij)
+                    
+                  endif
+                  
+                enddo
+                
+c     calculate screened repulsion function
+                
+                do i=2,mxgrid
+                  
+                  rrr=dble(i)*dlrpot
+                  
+                  rep=baij*exp(-saij*rrr)
+                  vmbp(i,kpt,2)=rep*vmbp(i,kpt,1)
+                  gmbp(i,kpt,2)=rep*(gmbp(i,kpt,1)+
+     x              saij*rrr*vmbp(i,kpt,1))
+                  
+                enddo
+                
+c     calculate screened attraction function
+                
+                do i=2,mxgrid
+                  
+                  rrr=dble(i)*dlrpot
+                  
+                  att=bbij*exp(-sbij*rrr)
+                  vmbp(i,kpt,3)=att*vmbp(i,kpt,1)
+                  gmbp(i,kpt,3)=att*(gmbp(i,kpt,1)+
+     x              sbij*rrr*vmbp(i,kpt,1))
+                  
+                enddo
+                
+              endif
+              
+            endif
+            
+          enddo
+          
+        endif
+        
+      enddo
+          
+      return
+      end subroutine tergen
+
+      subroutine tersoff
+     x  (idnode,mxnode,natms,imcon,rctter,engter,virter)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating potential and forces 
+c     due to a tersoff potential
+c
+c     Note: the subroutine converts coordinates to reduced units
+c     to avoid a call to images.f. The link cell algorithm used
+c     here necessitates a parallelepiped, cubic or orthorhombic
+c     cell geometry
+c
+c     based on potential form defined in:
+c     J. Tersoff, Phys. Rev. B 39 (1989) 5566.
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith dec 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe
+      integer idnode,mxnode,natms,imcon,nix,niy,niz,i,j,nbx
+      integer nby,nbz,ncells,l,ix,iy,iz,k,icell,kk,jx,jy,jz,jcell,iter
+      integer limit,ii,iatm
+      real(8) rctter,engter,virter,xm,ym,zm,det,cprp
+      real(8) xdc,ydc,zdc,sxx,syy,szz,strs
+
+      dimension nix(27),niy(27),niz(27),cprp(10),strs(6)
+
+      data nix/ 0,-1,-1,-1, 0, 0,-1, 1,-1, 0, 1,-1, 0, 1,
+     x  1, 1, 1, 0, 0, 1,-1, 1, 0,-1, 1, 0,-1/
+      data niy/ 0, 0,-1, 1, 1, 0, 0, 0,-1,-1,-1, 1, 1, 1,
+     x  0, 1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1/
+      data niz/ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+     x  0, 0, 0, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1/
+      
+c     flag for undefined potentials
+
+      safe=.true.
+
+c     initialise potential energy and virial
+
+      engter=0.d0
+      virter=0.d0
+
+c     create mock cell vectors for non-periodic system
+
+      if(imcon.eq.0) then
+
+        xm=0.d0
+        ym=0.d0
+        zm=0.d0
+
+        do i=1,natms
+
+          xm=max(xm,abs(xxx(i)))
+          ym=max(ym,abs(yyy(i)))
+          zm=max(zm,abs(zzz(i)))
+
+        enddo
+
+        cell(1)=2.d0*xm+rctter
+        cell(2)=0.d0
+        cell(3)=0.d0
+        cell(4)=0.d0
+        cell(5)=2.d0*ym+rctter
+        cell(6)=0.d0
+        cell(7)=0.d0
+        cell(8)=0.d0
+        cell(9)=2.d0*zm+rctter
+        
+      endif
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+
+c     check for appropriate boundary conditions
+      
+      if(imcon.gt.3)call error(idnode,1974)
+      call invert(cell,rcell,det)
+      call dcell(cell,cprp)
+
+c     calculate link cell numbers
+      
+      nbx=int(cprp(7)/(rctter+1.d-6))
+      nby=int(cprp(8)/(rctter+1.d-6))
+      nbz=int(cprp(9)/(rctter+1.d-6))
+      if(nbx.lt.3.or.nby.lt.3.or.nbz.lt.3)then
+        
+        if(idnode.eq.0)then
+          
+          write(nrite,'(a,3i5)')
+     x      'tersoff link cell decomposition is',nbx,nby,nbz
+          
+        endif
+        
+        call error(idnode,1977)
+        
+      endif
+      ncells=nbx*nby*nbz
+
+      if(ncells.gt.mxcell) then
+        
+        if(idnode.eq.0) then
+
+          write(nrite,'(a,i6)')
+     x      'number of required link cells in tersoff.f is ',ncells
+          write(nrite,'(a,i6)')
+     x      'number of  default link cells in tersoff.f is ',mxcell
+          call error(idnode,1976)
+
+        endif
+
+      endif
+
+c     transform atomic coordinates and construct link cells
+      
+      do l=1,ncells
+        
+        lct(l)=0
+        lst(l)=0
+        
+      enddo
+      
+      xdc=dble(nbx)
+      ydc=dble(nby)
+      zdc=dble(nbz)
+
+      do i=1,natms
+
+        if(filter(ltype(i)))then
+          
+          sxx=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          syy=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          szz=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+          xxx(i)=sxx
+          yyy(i)=syy
+          zzz(i)=szz
+          
+          ix=min(int(xdc*(sxx+0.5d0)),nbx-1)
+          iy=min(int(ydc*(syy+0.5d0)),nby-1)
+          iz=min(int(zdc*(szz+0.5d0)),nbz-1)
+          k=1+ix+nbx*(iy+nby*iz)
+          lst(k)=lst(k)+1
+          link(i)=lct(k)
+          lct(k)=i
+          
+        endif
+        
+      enddo
+
+c     loop over central atoms of angles
+      
+      ix=0
+      iy=1
+      iz=1
+      do icell=1,ncells
+
+        ix=ix+1
+        if(ix.gt.nbx)then
+          ix=1
+          iy=iy+1
+          if(iy.gt.nby)then
+            iy=1
+            iz=iz+1
+          endif
+        endif
+
+c     construct mini-list of neighbour cell contents
+
+        k=0
+        do kk=1,27
+
+          jx=ix+nix(kk)
+          jy=iy+niy(kk)
+          jz=iz+niz(kk)
+          
+          if(jx.gt.nbx)jx=1
+          if(jy.gt.nby)jy=1
+          if(jz.gt.nbz)jz=1
+          if(jx.lt.1)jx=jx+nbx
+          if(jy.lt.1)jy=jy+nby
+          if(jz.lt.1)jz=jz+nbz
+          
+          jcell=jx+nbx*(jy-1+nby*(jz-1))
+          j=lct(jcell)
+          
+          do ii=1,lst(jcell)
+
+            k=k+1
+            lattsf(k)=j
+            j=link(j)
+            
+          enddo
+          
+        enddo
+
+        limit=k
+        
+        do ii=1,lst(icell)
+          
+          iatm=lattsf(ii)
+          iter=lstter(ltype(iatm))
+
+          if(mod(iatm,mxnode).eq.idnode.and.iter.ge.0)then
+
+c     construct working arrays by interpolation
+
+            call terint(iatm,limit,rctter)
+
+c     calculate three body (attractive) terms
+
+            call tersoff3(ii,limit,engter,virter,strs)
+
+          endif
+          
+        enddo
+
+      enddo
+      
+c     calculate stress tensor
+              
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+c     check for undefined potentials
+
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe) call error(idnode,1978)
+
+c     global sum of three body potential and virial
+
+      if(mxnode.gt.1)then
+
+        buffer(1)=engter
+        buffer(2)=virter
+        call gdsum(buffer(1),2,buffer(3))
+        engter=buffer(1)
+        virter=buffer(2)
+
+      endif
+
+c    remove effect of double counting
+
+      engter=0.5d0*engter
+      virter=0.5d0*virter
+
+c     restore coordinate array to original representation
+
+      do i=1,natms
+
+        if(filter(ltype(i)))then
+          
+          sxx=xxx(i)
+          syy=yyy(i)
+          szz=zzz(i)
+          
+          xxx(i)=cell(1)*sxx+cell(4)*syy+cell(7)*szz
+          yyy(i)=cell(2)*sxx+cell(5)*syy+cell(8)*szz
+          zzz(i)=cell(3)*sxx+cell(6)*syy+cell(9)*szz
+          
+        endif
+        
+      enddo
+
+c     restore cell vector
+
+      if(imcon.eq.0) then
+        cell(1)=0.d0
+        cell(5)=0.d0
+        cell(9)=0.d0
+      endif
+      
+      return
+      end subroutine tersoff
+
+      subroutine terint(iatm,limit,rctter)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for constructing working arrays for
+c     a tersoff potential using interpolation
+c
+c     based on potential form defined in:
+c     J. Tersoff, Phys. Rev. B 39 (1989) 5566.
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith dec 2003
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer iatm,jatm,jj,limit,iter,jter,jjter,ll
+      real(8) rctter,sxij,syij,szij,ppp,t1,t2,rdr
+      real(8) vk0,vk1,vk2,gk0,gk1,gk2
+     
+      rdr=dble(mxgrid-4)/rctter
+      iter=lstter(ltype(iatm))
+
+c    initialise working arrays
+            
+      do jj=1,limit
+        
+        xtf(jj)=0.d0
+        ytf(jj)=0.d0
+        ztf(jj)=0.d0
+        rtf(jj)=0.d0
+        ert(jj)=0.d0
+        eat(jj)=0.d0
+        grt(jj)=0.d0
+        gat(jj)=0.d0
+        scr(jj)=0.d0
+        gcr(jj)=0.d0
+        
+      enddo
+
+c    construct working arrays
+      
+      do jj=1,limit
+        
+        jatm=lattsf(jj)
+        jter=lstter(ltype(jatm))
+        
+        if(jatm.ne.iatm.and.jter.ge.0)then
+          
+          sxij=xxx(jatm)-xxx(iatm)
+          sxij=sxij-nint(sxij)
+          syij=yyy(jatm)-yyy(iatm)
+          syij=syij-nint(syij)
+          szij=zzz(jatm)-zzz(iatm)
+          szij=szij-nint(szij)
+          
+          xtf(jj)=cell(1)*sxij+cell(4)*syij+cell(7)*szij
+          ytf(jj)=cell(2)*sxij+cell(5)*syij+cell(8)*szij
+          ztf(jj)=cell(3)*sxij+cell(6)*syij+cell(9)*szij
+          rtf(jj)=sqrt(xtf(jj)**2+ytf(jj)**2+ztf(jj)**2)
+          xtf(jj)=xtf(jj)/rtf(jj)
+          ytf(jj)=ytf(jj)/rtf(jj)
+          ztf(jj)=ztf(jj)/rtf(jj)
+            
+          jjter=loc2(iter,jter)
+          if(rtf(jj).le.vmbp(1,jjter,1))then
+            
+            ll=int(rdr*rtf(jj))
+            ppp=rtf(jj)*rdr-dble(ll)
+            
+c    interpolate screening function
+            
+            vk0=vmbp(ll,jjter,1)
+            vk1=vmbp(ll+1,jjter,1)
+            vk2=vmbp(ll+2,jjter,1)
+            t1=vk0+(vk1-vk0)*ppp
+            t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+            scr(jj)=t1+(t2-t1)*ppp*0.5d0
+            
+c    interpolate derivative of screening function
+            
+            gk0=gmbp(ll,jjter,1)
+            gk1=gmbp(ll+1,jjter,1)
+            gk2=gmbp(ll+2,jjter,1)
+            t1=gk0+(gk1-gk0)*ppp
+            t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+            gcr(jj)=-(t1+(t2-t1)*ppp*0.5d0)/rtf(jj)
+            
+c    interpolate repulsive component of energy
+            
+            vk0=vmbp(ll,jjter,2)
+            vk1=vmbp(ll+1,jjter,2)
+            vk2=vmbp(ll+2,jjter,2)
+            t1=vk0+(vk1-vk0)*ppp
+            t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+            ert(jj)=t1+(t2-t1)*ppp*0.5d0
+            
+c    interpolate derivative of repulsive function
+            
+            gk0=gmbp(ll,jjter,2)
+            gk1=gmbp(ll+1,jjter,2)
+            gk2=gmbp(ll+2,jjter,2)
+            t1=gk0+(gk1-gk0)*ppp
+            t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+            grt(jj)=-(t1+(t2-t1)*ppp*0.5d0)/rtf(jj)
+            
+c    interpolate attractive component of energy
+            
+            vk0=vmbp(ll,jjter,3)
+            vk1=vmbp(ll+1,jjter,3)
+            vk2=vmbp(ll+2,jjter,3)
+            t1=vk0+(vk1-vk0)*ppp
+            t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+            eat(jj)=t1+(t2-t1)*ppp*0.5d0
+            
+c    interpolate derivative of attractive function
+            
+            gk0=gmbp(ll,jjter,3)
+            gk1=gmbp(ll+1,jjter,3)
+            gk2=gmbp(ll+2,jjter,3)
+            t1=gk0+(gk1-gk0)*ppp
+            t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+            gat(jj)=-(t1+(t2-t1)*ppp*0.5d0)/rtf(jj)
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine terint
+
+      subroutine tersoff3(ii,limit,engter,virter,strs)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating three body contributions
+c     to a tersoff potential and tersoff potential, virial and
+c     atomic forces
+c
+c     based on potential form defined in:
+c     J. Tersoff, Phys. Rev. B 39 (1989) 5566.
+c     
+c     copyright - daresbury laboratory
+c     author    - w.smith dec 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical flag
+      integer iatm,jatm,katm,limit,ii,jj,kk
+      integer iter,jter,kter,jjter,kkter
+      real(8) cost,gtheta,ci,di,hi,gamma,gam_j,gam_k,eterm,gterm,strs
+      real(8) fxa,fya,fza,fxc,fyc,fzc,engter,virter,vterm,gam_ij,bi,ei
+
+      dimension strs(6)
+      
+      iatm=lattsf(ii)
+      iter=lstter(ltype(iatm))
+
+      bi=prmter(iter,7)
+      ei=prmter(iter,8)
+      ci=prmter(iter,9)
+      di=prmter(iter,10)
+      hi=prmter(iter,11)
+
+      do jj=1,limit
+        
+        jatm=lattsf(jj)
+        jter=lstter(ltype(jatm))
+        if(jter.ge.0.and.iatm.ne.jatm)then
+          
+          jjter=loc2(iter,jter)
+          if(rtf(jj).le.vmbp(1,jjter,1))then
+            
+            flag=.false.
+            
+c     potential energy and virial terms
+            
+            vterm=0.d0
+            eterm=0.d0
+            
+c     initialise work  arrays
+            
+            do kk=1,limit
+
+              gam(kk)=0.d0
+              gvr(kk)=0.d0
+              
+            enddo
+
+c     calculate bond factor
+
+            do kk=1,limit
+              
+              katm=lattsf(kk)
+              kter=lstter(ltype(katm))
+              if(kter.ge.0.and.iatm.ne.katm.and.jatm.ne.katm)then
+                
+                kkter=loc2(iter,kter)
+                
+                if(rtf(kk).le.vmbp(1,kkter,1))then
+                
+                  cost=(xtf(jj)*xtf(kk)+ytf(jj)*ytf(kk)+ztf(jj)*ztf(kk))
+                  gtheta=1.d0+(ci/di)**2-ci**2/(di**2+(hi-cost)**2)
+                  eterm=eterm+gtheta*prmter2(2,kkter)*scr(kk)
+                  vterm=vterm+gtheta*prmter2(2,kkter)*gcr(kk)*rtf(kk)
+                  gvr(kk)=2.d0*ci**2*(hi-cost)/(di**2+(hi-cost)**2)**2
+                  gam(kk)=gtheta
+                  flag=.true.
+
+                endif
+                
+              endif
+              
+            enddo
+            
+            if(flag)then
+              
+c     tersoff energy and virial
+
+              gam_ij=prmter2(1,jjter)*(1.d0+(bi*eterm)**ei)**(-0.5d0/ei)
+              gamma=0.5d0*prmter2(1,jjter)*bi*(bi*eterm)**(ei-1.d0)*
+     x          eat(jj)*(1.d0+(bi*eterm)**ei)**(-0.5d0/ei-1.d0)
+              engter=engter+ert(jj)-gam_ij*eat(jj)
+              virter=virter+gamma*vterm+(grt(jj)-gam_ij*gat(jj))*rtf(jj)
+
+c     calculate 3-body forces
+              
+              do kk=1,limit
+                
+                katm=lattsf(kk)
+                kter=lstter(ltype(katm))
+                if(kter.ge.0.and.iatm.ne.katm.and.jatm.ne.katm)then
+                  
+                  kkter=loc2(iter,kter)
+                  if(rtf(kk).le.vmbp(1,kkter,1))then
+                    
+                    gam_j=0.5d0*gamma*prmter2(2,kkter)*scr(kk)*gvr(kk)
+                    gam_k=0.5d0*gamma*prmter2(2,kkter)*gcr(kk)*gam(kk)
+                    
+c     calculate contribution to atomic forces
+                    
+                    cost=(xtf(jj)*xtf(kk)+ytf(jj)*ytf(kk)+
+     x                ztf(jj)*ztf(kk))
+                    
+                    fxa=gam_j*(xtf(kk)-xtf(jj)*cost)/rtf(jj)
+                    fya=gam_j*(ytf(kk)-ytf(jj)*cost)/rtf(jj)
+                    fza=gam_j*(ztf(kk)-ztf(jj)*cost)/rtf(jj)
+                    
+                    fxc=gam_j*(xtf(jj)-xtf(kk)*cost)/rtf(kk)-
+     x                gam_k*xtf(kk)
+                    fyc=gam_j*(ytf(jj)-ytf(kk)*cost)/rtf(kk)-
+     x                gam_k*ytf(kk)
+                    fzc=gam_j*(ztf(jj)-ztf(kk)*cost)/rtf(kk)-
+     x                gam_k*ztf(kk)
+                    
+                    fxx(jatm)=fxx(jatm)+fxa
+                    fyy(jatm)=fyy(jatm)+fya
+                    fzz(jatm)=fzz(jatm)+fza
+                    
+                    fxx(iatm)=fxx(iatm)-(fxa+fxc)
+                    fyy(iatm)=fyy(iatm)-(fya+fyc)
+                    fzz(iatm)=fzz(iatm)-(fza+fzc)
+                    
+                    fxx(katm)=fxx(katm)+fxc
+                    fyy(katm)=fyy(katm)+fyc
+                    fzz(katm)=fzz(katm)+fzc
+                    
+c     calculate contributions to stress tensor
+                    
+                    strs(1)=strs(1)+(fxa*xtf(jj)*rtf(jj)+
+     x                fxc*xtf(kk)*rtf(kk))
+                    strs(2)=strs(2)+(fxa*ytf(jj)*rtf(jj)+
+     x                fxc*ytf(kk)*rtf(kk))
+                    strs(3)=strs(3)+(fxa*ztf(jj)*rtf(jj)+
+     x                fxc*ztf(kk)*rtf(kk))
+                    strs(4)=strs(4)+(fya*ytf(jj)*rtf(jj)+
+     x                fyc*ytf(kk)*rtf(kk))
+                    strs(5)=strs(5)+(fya*ztf(jj)*rtf(jj)+
+     x                fyc*ztf(kk)*rtf(kk))
+                    strs(6)=strs(6)+(fza*ztf(jj)*rtf(jj)+
+     x                fzc*ztf(kk)*rtf(kk))
+
+                  endif
+                  
+                endif
+                
+              enddo
+            
+            else
+              
+              gam_ij=prmter2(1,jjter)
+              engter=engter+ert(jj)-gam_ij*eat(jj)
+              virter=virter+(grt(jj)-gam_ij*gat(jj))*rtf(jj)
+
+            endif
+
+c     calculate two body force terms
+            
+            gterm=0.5d0*(grt(jj)-gam_ij*gat(jj))
+            fxx(iatm)=fxx(iatm)+xtf(jj)*gterm
+            fyy(iatm)=fyy(iatm)+ytf(jj)*gterm
+            fzz(iatm)=fzz(iatm)+ztf(jj)*gterm
+            fxx(jatm)=fxx(jatm)-xtf(jj)*gterm
+            fyy(jatm)=fyy(jatm)-ytf(jj)*gterm
+            fzz(jatm)=fzz(jatm)-ztf(jj)*gterm
+            
+c     calculate contributions to stress tensor
+            
+            strs(1)=strs(1)-gterm*rtf(jj)*xtf(jj)*xtf(jj)
+            strs(2)=strs(2)-gterm*rtf(jj)*xtf(jj)*ytf(jj)
+            strs(3)=strs(3)-gterm*rtf(jj)*xtf(jj)*ztf(jj)
+            strs(4)=strs(4)-gterm*rtf(jj)*ytf(jj)*ytf(jj)
+            strs(5)=strs(5)-gterm*rtf(jj)*ytf(jj)*ztf(jj)
+            strs(6)=strs(6)-gterm*rtf(jj)*ztf(jj)*ztf(jj)
+
+          endif
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine tersoff3
+      
+      end module tersoff_module
diff -urN dl_class_1.9.orig/srcmod/tether_module.f dl_class_1.9/srcmod/tether_module.f
--- dl_class_1.9.orig/srcmod/tether_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/tether_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,447 @@
+      module tether_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining tether potential arrays
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    oct 2003
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use parse_module
+      use setup_module
+      use site_module
+      use utility_module
+
+      implicit none
+
+      real(8), allocatable :: prmtet(:,:)
+      integer, allocatable :: listtet(:,:)
+      integer, allocatable :: numteth(:),keytet(:),lsttet(:)
+      real(8), allocatable :: xxs(:),yys(:),zzs(:)
+
+      save prmtet,lsttet,listtet,numteth,keytet,xxs,yys,zzs
+
+      contains
+      
+      subroutine alloc_tet_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=8
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate (prmtet(mxteth,mxpbnd),stat=fail(1))
+      allocate (numteth(mxtmls),stat=fail(2))
+      allocate (keytet(mxteth),stat=fail(3))
+      allocate (lsttet(mxteth),stat=fail(4))
+      allocate (listtet(msteth,2),stat=fail(5))
+      allocate (xxs(mxatms),stat=fail(6))
+      allocate (yys(mxatms),stat=fail(7))
+      allocate (zzs(mxatms),stat=fail(8))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1260)
+      enddo
+
+      do i=1,mxtmls
+         numteth(i)=0
+      enddo
+
+      end subroutine alloc_tet_arrays
+
+      subroutine define_tethers
+     x  (safe,idnode,itmols,nteth,nsite,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining tether bonds
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe
+      character*8 keyword
+      character*1 message(80)
+      real(8) engunit
+      integer idnode,itmols,nteth,nsite,ntmp,iteth,iteth1,idum
+      integer iatm1,isite1,j,i
+
+      ntmp=intstr(record,lenrec,idum)
+      numteth(itmols)=numteth(itmols)+ntmp
+      if(idnode.eq.0)then
+        write(nrite,"(/,1x,'number of tethered atoms ',
+     x    6x,i10)")ntmp
+        write(nrite,"(/,' tethered atom details:',/,/,
+     x    21x,7x,'key',6x,'atom',19x,'parameters',/) ")
+      endif
+
+      iteth1=numteth(itmols)
+      do iteth=1,iteth1
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        call strip(record,lenrec)
+        call copystring(record,message,80)
+        call lowcase(record,4)
+        call getword(keyword,record,4,lenrec)
+
+        iatm1=intstr(record,lenrec,idum)
+
+c     test for frozen atom 
+
+        isite1=nsite-numsit(itmols)+iatm1
+        
+        if(lfzsit(isite1).ne.0)then
+
+          numteth(itmols)=numteth(itmols)-1
+          if(idnode.eq.0)write(nrite,'(14x,a16,40a1)')
+     x      '*** frozen *** ',(message(i),i=1,40)
+
+        else
+
+          nteth=nteth+1
+          if(nteth.gt.mxteth)call error(idnode,62)
+          
+          if(keyword(1:4).eq.'harm')then
+            keytet(nteth)=1
+          elseif(keyword(1:4).eq.'rhrm')then
+            keytet(nteth)=2
+          elseif(keyword(1:4).eq.'quar')then
+            keytet(nteth)=3
+          else
+            if(idnode.eq.0)write(nrite,*)message
+            call error(idnode,450)
+          endif
+
+          lsttet(nteth)=iatm1
+          prmtet(nteth,1)=dblstr(record,lenrec,idum)
+          prmtet(nteth,2)=dblstr(record,lenrec,idum)
+          prmtet(nteth,3)=dblstr(record,lenrec,idum)
+          
+          if(idnode.eq.0)
+     x      write(nrite,"(27x,a4,i10,1p,9e12.4)")
+     x      keyword(1:4),lsttet(nteth),
+     x      (prmtet(nteth,j),j=1,mxpbnd)
+
+c     convert energy units to internal units
+          
+          if(abs(keytet(nteth)).eq.1)then
+            prmtet(nteth,1)=prmtet(nteth,1)*engunit
+          elseif(abs(keytet(nteth)).eq.2)then
+            prmtet(nteth,1)=prmtet(nteth,1)*engunit
+          elseif(abs(keytet(nteth)).eq.3)then
+            prmtet(nteth,1)=prmtet(nteth,1)*engunit
+            prmtet(nteth,2)=prmtet(nteth,2)*engunit
+            prmtet(nteth,3)=prmtet(nteth,3)*engunit
+          endif
+
+        endif
+
+      enddo
+      
+      return
+      end subroutine define_tethers
+
+      subroutine tethfrc
+     x  (idnode,mxnode,imcon,natms,nstep,ntteth,engtet,virtet)
+
+c***********************************************************************
+c     
+c     dl_poly routine to tether atoms to initial positions
+c     includes stress tensor
+c     
+c     replicated data version : block data
+c     
+c     copyright daresbury laboratory 1994
+c     author     t.forester feb 1994
+c     amended    t.forester dec 1994 : block data
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe
+      integer idnode,mxnode,imcon,natms,nstep,ntteth,i,ii,ia,kk
+      integer itet1,itet2,fail
+
+      real(8) engtet,virtet,rab
+      real(8) rrab,omega,gamma
+
+      real(8), allocatable :: xdab(:),ydab(:),zdab(:)
+
+      data safe/.true./
+      
+      allocate (xdab(msbad),ydab(msbad),zdab(msbad),stat=fail)
+      if(fail.ne.0)call error(idnode,1270)
+
+c     set up reference positions at start of job
+
+      if(nstep.le.1)then
+
+        do i=1,natms
+
+          xxs(i)=xxx(i)
+          yys(i)=yyy(i)
+          zzs(i)=zzz(i)
+
+        enddo
+
+      endif
+
+c     check size of work arrays
+
+      if((ntteth-mxnode+1)/mxnode.gt.msbad) call error(idnode,420)
+
+c     block indices
+
+      itet1=(idnode*ntteth)/mxnode+1
+      itet2=((idnode+1)*ntteth)/mxnode
+      
+      ii=0
+      do i=itet1,itet2
+
+        ii=ii+1
+
+c     atomic index
+
+        ia= listtet(ii,2)
+
+c     tether vector
+
+        xdab(ii)=xxx(ia)-xxs(ia)
+        ydab(ii)=yyy(ia)-yys(ia)
+        zdab(ii)=zzz(ia)-zzs(ia)
+
+      enddo
+
+c     ignore  periodic boundary condition
+      
+      call images(imcon,0,1,ii,cell,xdab,ydab,zdab)
+
+c     zero tether energy and virial accumulators
+      
+      engtet=0.d0
+      virtet=0.d0
+
+c     loop over all specified tethered atoms
+
+      ii=0
+      do i=itet1,itet2
+        
+        ii=ii+1
+
+c     define components of bond vector
+        
+        rab=sqrt(xdab(ii)**2+ydab(ii)**2+zdab(ii)**2)
+
+c     check for possible zero length vector
+
+        if(rab.lt.1.d-10)then
+
+          rrab =0.d0
+
+        else
+
+          rrab=1.d0/rab
+
+        endif
+
+c     index of potential function parameters
+
+        kk=listtet(ii,1)
+
+c     calculate scalar constant terms
+
+        if(keytet(kk).eq.1)then
+
+c     harmonic function
+
+          omega=0.5d0*prmtet(kk,1)*rab**2
+          gamma=prmtet(kk,1)
+
+        elseif(keytet(kk).eq.2)then
+
+c     restrained harmonic: 
+
+          omega=0.5d0*prmtet(kk,1)*(min(rab,prmtet(kk,2)))**2
+     x      +prmtet(kk,1)*prmtet(kk,2)*
+     x      (sign(max(rab-prmtet(kk,2),0.d0),rab))
+          gamma=prmtet(kk,1)*(sign(min(rab,prmtet(kk,2)),rab))*rrab
+
+        elseif(keytet(kk).eq.3)then
+
+c     quartic potential
+
+          omega=0.5d0*prmtet(kk,1)*rab**2 +
+     x      1.d0/3.d0*prmtet(kk,2)*rab**3+
+     x      0.25d0*prmtet(kk,3)*rab**4
+          gamma=(prmtet(kk,1)*rab +
+     x      prmtet(kk,2)*rab**2 +
+     x      prmtet(kk,3)*rab**3)*rrab
+
+        else
+          safe=.false.
+          omega=0.d0
+          gamma=0.d0
+        endif
+        
+        gamma=-gamma
+
+c     calculate tether energy and virial
+
+        engtet=engtet+omega
+        virtet=virtet-gamma*rab*rab
+        
+c     index of atom
+        
+        ia=listtet(ii,2)
+
+c     calculate atomic forces
+        
+        fxx(ia)=fxx(ia)+gamma*xdab(ii)
+        fyy(ia)=fyy(ia)+gamma*ydab(ii)
+        fzz(ia)=fzz(ia)+gamma*zdab(ii)
+
+c     stress tensor 
+
+        stress(1)=stress(1)+xdab(ii)*gamma*xdab(ii)
+        stress(2)=stress(2)+xdab(ii)*gamma*ydab(ii)
+        stress(3)=stress(3)+xdab(ii)*gamma*zdab(ii)
+        stress(4)=stress(4)+ydab(ii)*gamma*xdab(ii)
+        stress(5)=stress(5)+ydab(ii)*gamma*ydab(ii)
+        stress(6)=stress(6)+ydab(ii)*gamma*zdab(ii)
+        stress(7)=stress(7)+zdab(ii)*gamma*xdab(ii)
+        stress(8)=stress(8)+zdab(ii)*gamma*ydab(ii)
+        stress(9)=stress(9)+zdab(ii)*gamma*zdab(ii)
+
+      enddo
+
+c     check for undefined potentials
+
+      if(mxnode.gt.1)call gstate(safe)
+      if(.not.safe)call error(idnode,450)
+
+c     sum contributions to potential and virial
+
+      if(mxnode.gt.1)then
+
+        buffer(3)=engtet
+        buffer(4)=virtet
+
+        call gdsum(buffer(3),2,buffer(1))
+
+        engtet=buffer(3)
+        virtet=buffer(4)
+
+      endif
+
+      deallocate (xdab,ydab,zdab,stat=fail)
+      
+      return
+      end subroutine tethfrc
+      
+      subroutine xscale(idnode,mxnode,natms,keyens,imcon,tstep)
+
+c***********************************************************************
+c     
+c     dl_poly routine to scale positions with change in box shape
+c     
+c     parallel replicated data version
+c     
+c     copyright daresbury laboratory 1995
+c     author t.forester      october 1995
+c     
+c***********************************************************************
+
+      implicit none
+      
+      integer idnode,mxnode,natms,keyens,imcon,iatm0,iatm1,i
+      real(8) tstep,xa,ya,za,totmas,xcmo,ycmo,zcmo
+      
+c     assign block of atoms to processor
+
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+      if((keyens.eq.4).or.(keyens.eq.6))then
+
+c     berendsen npt/nst
+
+        do i=iatm0,iatm1
+
+          xa=eta(1)*xxs(i)+eta(2)*yys(i)+eta(3)*zzs(i)
+          ya=eta(4)*xxs(i)+eta(5)*yys(i)+eta(6)*zzs(i)
+          za=eta(7)*xxs(i)+eta(8)*yys(i)+eta(9)*zzs(i)
+
+          xxs(i)=xa
+          yys(i)=ya
+          zzs(i)=za
+
+        enddo
+
+      elseif(keyens.eq.5.or.keyens.eq.7)then
+
+c     hoover npt/nst
+        
+        totmas=0.d0
+        do i=1,natms
+          if(rmass(i).gt.0.d0)totmas=totmas+weight(i)
+        enddo
+        
+        xcmo=0.d0
+        ycmo=0.d0
+        zcmo=0.d0
+
+        do i=1,natms
+
+          if(rmass(i).gt.0.d0)then
+
+            xcmo=xcmo+weight(i)*xxs(i)
+            ycmo=ycmo+weight(i)*yys(i)
+            zcmo=zcmo+weight(i)*zzs(i)
+
+          endif
+
+        enddo
+        xcmo=xcmo/totmas
+        ycmo=ycmo/totmas
+        zcmo=zcmo/totmas
+
+        do i=iatm0,iatm1
+
+          xa=xxs(i)-xcmo
+          ya=yys(i)-ycmo
+          za=zzs(i)-zcmo
+
+          xxs(i)=xxs(i)+tstep*(eta(1)*xa+eta(2)*ya+eta(3)*za)
+          yys(i)=yys(i)+tstep*(eta(2)*xa+eta(5)*ya+eta(6)*za)
+          zzs(i)=zzs(i)+tstep*(eta(3)*xa+eta(6)*ya+eta(9)*za)
+
+        enddo
+
+        call images(imcon,idnode,mxnode,natms,cell,xxs,yys,zzs)
+
+      endif
+
+      if(mxnode.gt.1)
+     x  call merge(idnode,mxnode,natms,mxbuff,xxs,yys,zzs,buffer)
+      
+      return 
+      end subroutine xscale
+      
+      end module tether_module
+
diff -urN dl_class_1.9.orig/srcmod/three_body_module.f dl_class_1.9/srcmod/three_body_module.f
--- dl_class_1.9.orig/srcmod/three_body_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/three_body_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,882 @@
+      module three_body_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining three-body potential arrays
+c     copyright - daresbury laboratory
+c     author  - w. smith  sep 2003
+c     adapted - w. smith  aug 2008 : solvation, free energy excitation
+c     adapted - w. smith  jan 2011 : metadynamics
+c     
+c***********************************************************************
+
+      use config_module     
+      use error_module     
+      use metafreeze_module
+      use parse_module
+      use setup_module
+      use site_module
+      use solvation_module
+      use utility_module
+
+      implicit none
+
+      logical, allocatable :: filter(:)
+      real(8), allocatable :: prmtbp(:,:),rcut3b(:)
+      integer, allocatable :: lsttbp(:),ltptbp(:),lattbp(:)
+
+      save prmtbp,rcut3b,lsttbp,ltptbp,lattbp,filter
+
+      contains
+      
+      subroutine alloc_tbp_arrays(idnode)
+
+      implicit none
+
+      integer i,fail,idnode
+      dimension fail(6)
+
+      do i=1,6
+        fail(i)=0
+      enddo
+
+      allocate (prmtbp(mxtbp,mxptbp),stat=fail(1))
+      allocate (rcut3b(mxtbp),stat=fail(2))
+      allocate (lsttbp(mxtbp),stat=fail(3))
+      allocate (ltptbp(mxtbp),stat=fail(4))
+      allocate (lattbp(mxatms),stat=fail(5))
+      allocate (filter(mxsite),stat=fail(6))
+
+      do i=1,6
+        if(fail(i).gt.0)call error(idnode,1170)
+      enddo
+
+      end subroutine alloc_tbp_arrays
+
+      subroutine define_three_body
+     x  (safe,lunits,lmols,idnode,ntptbp,ntpatm,rcuttb,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining three body potentials
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lunits,lmols
+      character*8 keyword
+      character*8 atom0,atom1,atom2
+      character*1 message(80)
+      integer idnode,ntptbp,ntpatm,fail,i,itbp,itptbp,keypot
+      integer idum,katm1,katm2,katm0,j,keytbp,ktbp,jtpatm
+      real(8) rcuttb,engunit
+      real(8), allocatable :: parpot(:)
+
+      data fail/0/
+
+      allocate (parpot(mxptbp),stat=fail)
+      if(fail.ne.0)call error(idnode,1180)
+
+      ntptbp=intstr(record,lenrec,idum)
+      
+      if(idnode.eq.0) then
+        
+        write(nrite,"(/,/,1x,'number of specified three ',
+     x    'body potentials',i10)") ntptbp
+        write(nrite,"(/,/,16x,'atom 1  ','atom 2  ','atom 3  ',
+     x    3x,' key',30x,'parameters'/,/)")
+        
+      endif      
+      if(ntptbp.gt.mxtbp) call error(idnode,83)
+      if(.not.lunits) call error(idnode,6)
+      if(.not.lmols) call error(idnode,13)
+      
+      do i=1,mxsite
+        filter(i)=.false.
+      enddo
+      
+      do itbp=1,mxtbp
+        lsttbp(itbp)=0
+      enddo
+      
+      do itbp=1,mxtbp,mx2tbp
+        lsttbp(itbp)=-1
+      enddo
+      
+      rcuttb=0.d0
+      
+      do itptbp=1,ntptbp
+        
+        do i=1,mxptbp
+          parpot(i)=0.d0
+        enddo
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+        
+c     Note the order!! atom0 is central 
+        
+        call copystring(record,message,80)
+        call getword(atom1,record,8,lenrec)
+        call getword(atom0,record,8,lenrec)
+        call getword(atom2,record,8,lenrec)
+        call lowcase(record,lenrec)
+        call getword(keyword,record,4,lenrec)
+        
+        if(keyword(1:4).eq.'harm') then
+          keypot=0
+        elseif(keyword(1:4).eq.'thrm') then
+          keypot=1
+        elseif(keyword(1:4).eq.'shrm') then
+          keypot=2
+        elseif(keyword(1:4).eq.'bvs1') then
+          keypot=3
+        elseif(keyword(1:4).eq.'bvs2') then
+          keypot=4
+        elseif(keyword(1:4).eq.'hbnd') then
+          keypot=5
+        else
+          if(idnode.eq.0) write(nrite,*) message
+          call error(idnode,442)
+        endif
+        
+        parpot(1)=dblstr(record,lenrec,idum)
+        parpot(2)=dblstr(record,lenrec,idum)
+        parpot(3)=dblstr(record,lenrec,idum)
+        parpot(4)=dblstr(record,lenrec,idum)
+        parpot(5)=dblstr(record,lenrec,idum)
+        
+        if(idnode.eq.0) 
+     x    write(nrite,"(16x,3a8,4x,a4,1x,1p,9e13.5)") 
+     x    atom1,atom0,atom2,keyword(1:4),(parpot(j),j=1,mxptbp)
+        
+        katm0=0
+        katm1=0
+        katm2=0
+        
+        do jtpatm=1,ntpatm
+          
+          if(atom0.eq.unqatm(jtpatm))katm0=jtpatm
+          if(atom1.eq.unqatm(jtpatm))katm1=jtpatm
+          if(atom2.eq.unqatm(jtpatm))katm2=jtpatm
+          
+        enddo
+        
+        if(katm0.eq.0.or.katm1.eq.0.or.katm2.eq.0) 
+     x    call error(idnode,84)
+        
+        filter(katm0)=.true.
+        filter(katm1)=.true.
+        filter(katm2)=.true.
+        
+        keytbp=(max(katm1,katm2)*(max(katm1,katm2)-1))/2+
+     x    min(katm1,katm2)+(katm0-1)*mx2tbp
+        
+        if(keytbp.gt.mxtbp) call error(idnode,86)
+
+c     convert parameters to internal units
+        
+        parpot(1)=parpot(1)*engunit
+        if(keypot.ne.5)parpot(2)=parpot(2)*(pi/180.d0)
+        
+        if(lsttbp(keytbp).gt.0) call error(idnode,18)
+        lsttbp(keytbp)=itptbp
+        ltptbp(itptbp)=keypot
+        ktbp=mx2tbp*((keytbp-1)/mx2tbp)+1
+        if(lsttbp(ktbp).lt.0)lsttbp(ktbp)=0
+
+c     calculate max three body cutoff
+        
+        rcuttb=max(rcuttb,parpot(5))
+        rcut3b(itptbp)=parpot(5)
+
+c     store three body potential parameters
+        
+        do i=1,4
+          prmtbp(itptbp,i)=parpot(i)
+        enddo
+        if(mxptbp.ge.6) then
+          do i=6,mxptbp
+            prmtbp(itptbp,i-1)=parpot(i-1)
+          enddo
+        endif
+      enddo
+
+      if(rcuttb.lt.1.d-6)call error(idnode,451)
+      
+      deallocate (parpot,stat=fail)
+
+      return
+      end subroutine define_three_body
+      
+      subroutine thbfrc
+     x  (lsolva,lfree,lexcite,idnode,mxnode,natms,imcon,rcuttb,
+     x  engtbp,virtbp)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating three body forces arising 
+c     from the included angle between three atoms
+c
+c     Note: the subroutine converts coordinates to reduced units
+c     to avoid a call to images.f. The link cell algorithm used
+c     here necessitates a parallelepiped cell geometry
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w.smith mar 1994 
+c     adapted   - w.smith aug 2008 solvation, free energy etc
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,lsolva,lfree,lexcite,lselect,lskip
+      logical idrive,jdrive,kdrive
+      integer idnode,mxnode,natms,imcon,nix,niy,niz
+      integer i,nbx,nby,nbz,ncells,l,ix,iy,iz,k,icell,kk,jx,jy,jz
+      integer j,jcell,ii,itbp,limit,last,ktbp,jtbp,jktbp,kktbp
+      integer ia,ib,ic,ktyp,jj,jk,kkk
+      real(8) rcuttb,engtbp,virtbp,tterm,uterm,xm,ym,zm,cprp,det
+      real(8) xdc,ydc,zdc,sxx,syy,szz,sxab,syab,szab,xab,yab,zab
+      real(8) rab,sxbc,sybc,szbc,xbc,ybc,zbc,rbc,xac,yac,zac,rac
+      real(8) rrab,rrbc,rrac,cost,sint,theta,pterm,gamma,vterm
+      real(8) gamsa,gamsb,gamsc,scrn,fxa,fya,fza,fxc,fyc,fzc,strs
+      real(8) strs_loc
+      
+      dimension nix(27),niy(27),niz(27),cprp(10),strs(6),strs_loc(9)
+      
+      data nix/ 0,-1,-1,-1, 0, 0,-1, 1,-1, 0, 1,-1, 0, 1,
+     x  1, 1, 1, 0, 0, 1,-1, 1, 0,-1, 1, 0,-1/
+      data niy/ 0, 0,-1, 1, 1, 0, 0, 0,-1,-1,-1, 1, 1, 1,
+     x  0, 1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1/
+      data niz/ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+     x  0, 0, 0, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1/
+      
+      lskip=(lfree.or.lexcite)
+      
+c     flag for undefined potentials
+      
+      safe=.true.
+      
+c     initialise accumulators
+      
+      engtbp=0.d0
+      virtbp=0.d0
+      tbp_fre=0.d0
+      tbp_vir=0.d0
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+      if(lsolva)then
+        
+        lcomp(8)=.true.
+        en3_sol(:)=0.d0
+        if(lexcite)en3_exc(:)=0.d0
+        
+      endif
+      
+c     create mock cell vectors for non-periodic system
+      
+      if(imcon.eq.0) then
+        
+        xm=0.d0
+        ym=0.d0
+        zm=0.d0
+        do i=1,natms
+          xm=max(xm,abs(xxx(i)))
+          ym=max(ym,abs(yyy(i)))
+          zm=max(zm,abs(zzz(i)))
+        enddo
+        
+        cell(1)=2.d0*xm+rcuttb
+        cell(2)=0.d0
+        cell(3)=0.d0
+        cell(4)=0.d0
+        cell(5)=2.d0*ym+rcuttb
+        cell(6)=0.d0
+        cell(7)=0.d0
+        cell(8)=0.d0
+        cell(9)=2.d0*zm+rcuttb
+        
+      endif
+      
+c     check for appropriate boundary conditions
+      
+      if(imcon.gt.3)call error(idnode,67)
+      call invert(cell,rcell,det)
+      call dcell(cell,cprp)
+      
+c     calculate link cell numbers
+      
+      nbx=int(cprp(7)/(rcuttb+1.d-6))
+      nby=int(cprp(8)/(rcuttb+1.d-6))
+      nbz=int(cprp(9)/(rcuttb+1.d-6))
+      ncells=nbx*nby*nbz
+      if(ncells.gt.mxcell) then
+        
+        if(idnode.eq.0) then
+          
+          write(nrite,'(a,i6)')
+     x      'number of required link cells in routine thbfrc is ',ncells
+          write(nrite,'(a,i6)')
+     x      'number of default link cells in routine thbfrc is ',mxcell
+          call error(idnode,69)
+          
+        endif
+        
+      endif
+      
+c     transform atomic coordinates and construct link cells
+      
+      do l=1,ncells
+        
+        lct(l)=0
+        lst(l)=0
+        
+      enddo
+      
+      xdc=dble(nbx)
+      ydc=dble(nby)
+      zdc=dble(nbz)
+      
+      do i=1,natms
+        
+        if(filter(ltype(i)))then
+          
+          sxx=rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i)
+          syy=rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i)
+          szz=rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i)
+          
+          xxx(i)=sxx
+          yyy(i)=syy
+          zzz(i)=szz
+          
+          ix=min(int(xdc*(sxx+0.5d0)),nbx-1)
+          iy=min(int(ydc*(syy+0.5d0)),nby-1)
+          iz=min(int(zdc*(szz+0.5d0)),nbz-1)
+          k=1+ix+nbx*(iy+nby*iz)
+          lst(k)=lst(k)+1
+          link(i)=lct(k)
+          lct(k)=i
+          
+        endif
+        
+      enddo
+      
+c     loop over central atoms of angles
+      
+      ix=0
+      iy=1
+      iz=1
+      do icell=1,ncells
+        
+        ix=ix+1
+        if(ix.gt.nbx)then
+          ix=1
+          iy=iy+1
+          if(iy.gt.nby)then
+            iy=1
+            iz=iz+1
+          endif
+        endif
+        
+c     construct mini-list of neighbour cell contents
+        
+        k=0
+        do kk=1,27
+          
+          jx=ix+nix(kk)
+          jy=iy+niy(kk)
+          jz=iz+niz(kk)
+          
+          if(jx.gt.nbx)jx=1
+          if(jy.gt.nby)jy=1
+          if(jz.gt.nbz)jz=1
+          if(jx.lt.1)jx=jx+nbx
+          if(jy.lt.1)jy=jy+nby
+          if(jz.lt.1)jz=jz+nbz
+          
+          jcell=jx+nbx*(jy-1+nby*(jz-1))
+          j=lct(jcell)
+          
+          do ii=1,lst(jcell)
+            
+            k=k+1
+            lattbp(k)=j
+            j=link(j)
+            
+          enddo
+          
+        enddo
+        
+        limit=k
+        
+        do ii=1,lst(icell)
+          
+          i=lattbp(ii)
+          itbp=mx2tbp*(ltype(i)-1)
+          if(mod(i,mxnode).eq.idnode.and.lsttbp(itbp+1).ge.0)then
+          
+          last=limit
+          
+          do kk=1,limit/2
+              
+          if(kk.gt.(limit-1)/2)last=limit/2
+          
+          do jj=1,last
+          
+          j=lattbp(jj)
+          jk=jj+kk
+          if(jk.gt.limit)jk=jk-limit
+          k=lattbp(jk)
+          if(i.ne.j.and.i.ne.k)then
+                  
+          jtbp=max(ltype(j),ltype(k))
+          ktbp=min(ltype(j),ltype(k))
+          jktbp=itbp+(jtbp*(jtbp-1))/2+ktbp
+          kktbp=lsttbp(jktbp)
+          if(kktbp.gt.0)then
+          
+c     make labels etc consistent with angfrc.f
+          
+          ia=j
+          ib=i
+          ic=k
+          
+          if(lmetadyn)then
+            
+            idrive=driven(ltype(ia))
+            jdrive=driven(ltype(ib))
+            kdrive=driven(ltype(ic))
+            
+          endif
+          
+          if(lskip)then
+            
+            if((atm_fre(ia).eq.1.or.atm_fre(ib).eq.1.or.
+     x        atm_fre(ic).eq.1).and.(atm_fre(ia).eq.2.or.
+     x        atm_fre(ib).eq.2.or.atm_fre(ic).eq.2))cycle
+            
+          endif
+          
+          sxab=xxx(ia)-xxx(ib)
+          sxab=sxab-nint(sxab)
+          syab=yyy(ia)-yyy(ib)
+          syab=syab-nint(syab)
+          szab=zzz(ia)-zzz(ib)
+          szab=szab-nint(szab)
+          
+          xab=cell(1)*sxab+cell(4)*syab+cell(7)*szab
+          if(abs(xab).lt.rcuttb)then
+          
+          yab=cell(2)*sxab+cell(5)*syab+cell(8)*szab
+          if(abs(yab).lt.rcuttb)then
+          
+          zab=cell(3)*sxab+cell(6)*syab+cell(9)*szab
+          if(abs(zab).lt.rcuttb)then
+                          
+          sxbc=xxx(ic)-xxx(ib)
+          sxbc=sxbc-nint(sxbc)
+          sybc=yyy(ic)-yyy(ib)
+          sybc=sybc-nint(sybc)
+          szbc=zzz(ic)-zzz(ib)
+          szbc=szbc-nint(szbc)
+          
+          xbc=cell(1)*sxbc+cell(4)*sybc+cell(7)*szbc
+          if(abs(xbc).lt.rcuttb)then
+                            
+          ybc=cell(2)*sxbc+cell(5)*sybc+cell(8)*szbc
+          if(abs(ybc).lt.rcuttb)then
+          
+          zbc=cell(3)*sxbc+cell(6)*sybc+cell(9)*szbc
+          if(abs(zbc).lt.rcuttb)then
+          
+          ktyp=ltptbp(kktbp)
+          rab=sqrt(xab*xab+yab*yab+zab*zab)
+          rbc=sqrt(xbc*xbc+ybc*ybc+zbc*zbc)
+          
+          if(rcut3b(kktbp).ge.max(rab,rbc))then
+          
+          xac=xab-xbc
+          yac=yab-ybc
+          zac=zab-zbc
+          rac=sqrt(xac*xac+yac*yac+zac*zac)
+          
+          rrab=1.d0/rab
+          rrbc=1.d0/rbc
+          rrac=1.d0/rac
+          
+c     normalise direction vectors
+          
+          xab=xab*rrab
+          yab=yab*rrab
+          zab=zab*rrab
+          
+          xbc=xbc*rrbc
+          ybc=ybc*rrbc
+          zbc=zbc*rrbc
+          
+          xac=xac*rrac
+          yac=yac*rrac
+          zac=zac*rrac
+          
+          cost=(xab*xbc+yab*ybc+zab*zbc)
+          if(abs(cost).gt.1.d0)cost=sign(1.d0,cost)
+          if(ktyp.ne.5)then
+            
+            sint=max(1.d-8,sqrt(1.d0-cost*cost))
+            theta=acos(cost)
+            
+          endif
+          
+          if(ktyp.eq.0)then
+            
+c     harmonic angle potential
+            
+            pterm=0.5d0*prmtbp(kktbp,1)*(theta-prmtbp(kktbp,2))**2
+            gamma=prmtbp(kktbp,1)*(theta-prmtbp(kktbp,2))/sint
+            
+            vterm=0.d0
+            gamsa=0.d0
+            gamsc=0.d0
+            gamsb=0.d0
+            
+          elseif(ktyp.eq.1)then
+            
+c     truncated harmonic valence angle potential
+            
+            scrn=exp(-(rab**8+rbc**8)/prmtbp(kktbp,3)**8)
+            pterm=scrn*0.5d0*prmtbp(kktbp,1)*(theta-prmtbp(kktbp,2))**2
+            vterm=-8.d0*pterm*(rab**8+rbc**8)/prmtbp(kktbp,3)**8
+            gamma=scrn*prmtbp(kktbp,1)*(theta-prmtbp(kktbp,2))/sint
+            gamsa=(8.d0*pterm/prmtbp(kktbp,3)**8)*rab**7
+            gamsc=(8.d0*pterm/prmtbp(kktbp,3)**8)*rbc**7
+            gamsb=0.d0
+            
+          elseif(ktyp.eq.2)then
+            
+c     screened harmonic valence angle potential
+            
+            scrn=exp(-(rab/prmtbp(kktbp,3)+rbc/prmtbp(kktbp,4)))
+            pterm=scrn*0.5d0*prmtbp(kktbp,1)*(theta-prmtbp(kktbp,2))**2
+            vterm=-pterm*(rab/prmtbp(kktbp,3)+rbc/prmtbp(kktbp,4))
+            gamma=scrn*prmtbp(kktbp,1)*(theta-prmtbp(kktbp,2))/sint
+            gamsa=(pterm/prmtbp(kktbp,3))
+            gamsc=(pterm/prmtbp(kktbp,4))
+            gamsb=0.d0
+            
+          elseif(ktyp.eq.3)then
+            
+c     screened vessal potential type 1
+            
+            scrn=exp(-(rab/prmtbp(kktbp,3)+rbc/prmtbp(kktbp,4)))
+            pterm=scrn*prmtbp(kktbp,1)/
+     x        (8.d0*(prmtbp(kktbp,2)-pi)**2)*
+     x        ((prmtbp(kktbp,2)-pi)**2-(theta-pi)**2)**2
+            vterm=-pterm*(rab/prmtbp(kktbp,3)+rbc/prmtbp(kktbp,4))
+            gamma=scrn*prmtbp(kktbp,1)/
+     x        (2.d0*(prmtbp(kktbp,2)-pi)**2)*
+     x        ((prmtbp(kktbp,2)-pi)**2-(theta-pi)**2)*(theta-pi)/sint
+            gamsa=(pterm/prmtbp(kktbp,3))
+            gamsc=(pterm/prmtbp(kktbp,4))
+            gamsb=0.d0
+            
+          elseif(ktyp.eq.4)then
+            
+c     truncated vessal potential type 2 - use with sw1
+            
+            scrn=exp(-(rab**8+rbc**8)/prmtbp(kktbp,4)**8)
+            pterm=scrn*prmtbp(kktbp,1)*(theta**prmtbp(kktbp,3)*
+     x        (theta-prmtbp(kktbp,2))**2*(theta+prmtbp(kktbp,2)-
+     x        2.d0*pi)**2-0.5d0*prmtbp(kktbp,3)*pi**(prmtbp(kktbp,3)
+     x        -1.d0)*(theta-prmtbp(kktbp,2))**2*(pi-
+     x        prmtbp(kktbp,2))**3)
+            vterm=-8.d0*pterm*(rab**8+rbc**8)/prmtbp(kktbp,4)**8
+            gamma=scrn*prmtbp(kktbp,1)*(theta**(prmtbp(kktbp,3)-1.d0)*
+     x        (theta-prmtbp(kktbp,2))*(theta+prmtbp(kktbp,2)-
+     x        2.d0*pi)*((prmtbp(kktbp,3)+4.d0)*theta**2-2.d0*pi*
+     x        (prmtbp(kktbp,3)+2.d0)*theta+prmtbp(kktbp,3)*
+     x        prmtbp(kktbp,2)*(2.d0*pi-prmtbp(kktbp,2)))-
+     x        prmtbp(kktbp,3)*pi**(prmtbp(kktbp,3)-1.d0)*
+     x        (theta-prmtbp(kktbp,2))*(pi-prmtbp(kktbp,2))**3)/sint
+            gamsa=(8.d0*pterm/prmtbp(kktbp,4)**8)*rab**7
+            gamsc=(8.d0*pterm/prmtbp(kktbp,4)**8)*rbc**7
+            gamsb=0.d0
+            
+          elseif(ktyp.eq.5)then
+            
+            if(min(rab,rbc).lt.1.5d0)then
+              
+              scrn=(5.d0*(prmtbp(kktbp,2)/rac)**2-6.d0)*
+     x          (prmtbp(kktbp,2)/rac)**10
+              tterm=prmtbp(kktbp,1)*cost**4
+              pterm=scrn*tterm
+              uterm=60.d0*((prmtbp(kktbp,2)/rac)**2-1.d0)*
+     x          (prmtbp(kktbp,2)/rac)**10
+              vterm=tterm*uterm
+              gamma=scrn*4.d0*prmtbp(kktbp,1)*cost**3
+              gamsb=tterm*uterm/rac
+              gamsa=0.d0
+              gamsc=0.d0
+              
+            endif
+            
+          else
+            
+            safe=.false.
+            pterm=0.d0
+            vterm=0.d0
+            gamma=0.d0
+            gamsa=0.d0
+            gamsb=0.d0
+            gamsc=0.d0
+            
+          endif
+          
+c     set selection control
+          
+          lselect=.true.
+          
+c     set triple index
+          
+          if(lsolva)kkk=loc3(atmolt(ia),atmolt(ib),atmolt(ic))
+          
+          if(lexcite)then
+            
+c     selected excitation option
+            
+            if((atm_fre(ia).ne.1).and.(atm_fre(ib).ne.1)
+     x        .and.(atm_fre(ic).ne.1))then
+              
+c     reset selection control
+              
+              lselect=(atm_fre(ia)+atm_fre(ib)+atm_fre(ic).eq.0)
+              
+              if(lsolva)en3_exc(kkk)=en3_exc(kkk)+pterm
+              
+            endif
+            
+          elseif(lfree)then
+            
+c     selected free energy option
+            
+            if((atm_fre(ia).eq.1).or.(atm_fre(ib).eq.1)
+     x        .or.(atm_fre(ic).eq.1))then
+              
+c     set hamiltonian mixing parameter
+              
+              tbp_fre=tbp_fre-pterm
+              tbp_vir=tbp_vir-vterm
+              pterm=lambda1*pterm
+              vterm=lambda1*vterm
+              gamma=lambda1*gamma
+              gamsa=lambda1*gamsa
+              gamsb=lambda1*gamsb
+              gamsc=lambda1*gamsc
+              
+            elseif((atm_fre(ia).eq.2).or.(atm_fre(ib).eq.2)
+     x          .or.(atm_fre(ic).eq.2))then
+              
+c     set hamiltonian mixing parameter
+              
+              tbp_fre=tbp_fre+pterm
+              tbp_vir=tbp_vir+vterm
+              pterm=lambda2*pterm
+              vterm=lambda2*vterm
+              gamma=lambda2*gamma
+              gamsa=lambda2*gamsa
+              gamsb=lambda2*gamsb
+              gamsc=lambda2*gamsc
+              
+            endif
+            
+          endif
+          
+          if(lselect)then
+            
+c     calculate potential and virial
+            
+            engtbp=engtbp+pterm
+            virtbp=virtbp+vterm
+            
+            if(lsolva)en3_sol(kkk)=en3_sol(kkk)+pterm
+            
+c     calculate atomic forces
+            
+            fxa=gamma*(xbc-xab*cost)*rrab+gamsa*xab+gamsb*xac
+            fya=gamma*(ybc-yab*cost)*rrab+gamsa*yab+gamsb*yac
+            fza=gamma*(zbc-zab*cost)*rrab+gamsa*zab+gamsb*zac
+            
+            fxc=gamma*(xab-xbc*cost)*rrbc+gamsc*xbc-gamsb*xac
+            fyc=gamma*(yab-ybc*cost)*rrbc+gamsc*ybc-gamsb*yac
+            fzc=gamma*(zab-zbc*cost)*rrbc+gamsc*zbc-gamsb*zac
+            
+            fxx(ia)=fxx(ia)+fxa
+            fyy(ia)=fyy(ia)+fya
+            fzz(ia)=fzz(ia)+fza
+            
+            fxx(ib)=fxx(ib)-fxa-fxc
+            fyy(ib)=fyy(ib)-fya-fyc
+            fzz(ib)=fzz(ib)-fza-fzc
+            
+            fxx(ic)=fxx(ic)+fxc
+            fyy(ic)=fyy(ic)+fyc
+            fzz(ic)=fzz(ic)+fzc
+            
+c     calculate stress tensor
+            
+            strs(1)=strs(1)+rab*xab*fxa+rbc*xbc*fxc
+            strs(2)=strs(2)+rab*xab*fya+rbc*xbc*fyc
+            strs(3)=strs(3)+rab*xab*fza+rbc*xbc*fzc
+            strs(4)=strs(4)+rab*yab*fya+rbc*ybc*fyc
+            strs(5)=strs(5)+rab*yab*fza+rbc*ybc*fzc
+            strs(6)=strs(6)+rab*zab*fza+rbc*zbc*fzc
+            
+          endif
+
+c     metadynamics local parameters
+        
+          if(lmetadyn)then
+            
+c     local energy and virial
+            
+            eng_loc=eng_loc+pterm
+            vir_loc=vir_loc+vterm
+            
+c     local forces
+            
+            fxx_loc(ia)=fxx_loc(ia)+fxa
+            fyy_loc(ia)=fyy_loc(ia)+fya
+            fzz_loc(ia)=fzz_loc(ia)+fza
+            
+            fxx_loc(ib)=fxx_loc(ib)-fxa-fxc
+            fyy_loc(ib)=fyy_loc(ib)-fya-fyc
+            fzz_loc(ib)=fzz_loc(ib)-fza-fzc
+            
+            fxx_loc(ic)=fxx_loc(ic)+fxc
+            fyy_loc(ic)=fyy_loc(ic)+fyc
+            fzz_loc(ic)=fzz_loc(ic)+fzc
+            
+c     local stress tensor
+            
+            strs_loc(1)=strs_loc(1)+rab*xab*fxa+rbc*xbc*fxc
+            strs_loc(2)=strs_loc(2)+rab*xab*fya+rbc*xbc*fyc
+            strs_loc(3)=strs_loc(3)+rab*xab*fza+rbc*xbc*fzc
+            strs_loc(4)=strs_loc(4)+rab*yab*fya+rbc*ybc*fyc
+            strs_loc(5)=strs_loc(5)+rab*yab*fza+rbc*ybc*fzc
+            strs_loc(6)=strs_loc(6)+rab*zab*fza+rbc*zbc*fzc
+            
+          endif
+
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          endif
+          
+          endif
+          
+          endif
+          
+          enddo
+          enddo
+          
+          endif
+
+        enddo
+
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+      
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+c     check for undefined potentials
+
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe) call error(idnode,442)
+
+c     global sum of three body potential and virial
+
+      if(mxnode.gt.1)then
+
+        buffer(1)=engtbp
+        buffer(2)=virtbp
+        buffer(3)=tbp_fre
+        buffer(4)=tbp_vir
+        call gdsum(buffer(1),4,buffer(5))
+        engtbp=buffer(1)
+        virtbp=buffer(2)
+        tbp_fre=buffer(3)
+        tbp_vir=buffer(4)
+
+c     sum up solvation energies
+        
+        if(lsolva)then
+
+          call gdsum(en3_sol,mxtmls_sol3,buffer(1))
+          if(lexcite)call gdsum(en3_exc,mxtmls_exc3,buffer(1))
+          
+        endif
+        
+      endif
+
+c     restore coordinate array to original representation
+
+      do i=1,natms
+
+        if(filter(ltype(i)))then
+          
+          sxx=xxx(i)
+          syy=yyy(i)
+          szz=zzz(i)
+          
+          xxx(i)=cell(1)*sxx+cell(4)*syy+cell(7)*szz
+          yyy(i)=cell(2)*sxx+cell(5)*syy+cell(8)*szz
+          zzz(i)=cell(3)*sxx+cell(6)*syy+cell(9)*szz
+          
+        endif
+        
+      enddo
+
+c     restore cell vector
+
+      if(imcon.eq.0) then
+        cell(1)=0.d0
+        cell(5)=0.d0
+        cell(9)=0.d0
+      endif
+      
+      return
+
+      end subroutine thbfrc
+      
+      end module three_body_module
diff -urN dl_class_1.9.orig/srcmod/utility_module.f dl_class_1.9/srcmod/utility_module.f
--- dl_class_1.9.orig/srcmod/utility_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/utility_module.f	2010-12-22 13:27:23.000000000 +0100
@@ -0,0 +1,1612 @@
+      module utility_module
+
+c***********************************************************************
+c     
+c     dl_poly module for utility subroutines and functions
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     
+c***********************************************************************
+      
+      implicit none
+
+      contains
+      
+      subroutine global_sum_forces(natms,mxnode,gxx,gyy,gzz)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine to perform global sum of atomic forces as
+c     requred by replicated data strategy
+c     
+c     copyright - daresbury laboratory 
+c     author    - w.smith december 2005
+c     
+c***********************************************************************
+      
+      use config_module
+      
+      implicit none
+      
+      integer natms,mxnode,i,j
+      real(8) gxx(*),gyy(*),gzz(*)
+
+      if(mxnode.gt.1) then
+        
+        j=0
+        do i=1,natms
+          
+          buffer(j+1)=gxx(i)
+          buffer(j+2)=gyy(i)
+          buffer(j+3)=gzz(i)
+          j=j+3
+          
+        enddo
+        call gdsum(buffer(1),3*natms,buffer(3*natms+1))
+        j=0
+        do i=1,natms
+          
+          gxx(i)=buffer(j+1)
+          gyy(i)=buffer(j+2)
+          gzz(i)=buffer(j+3)
+          j=j+3
+          
+        enddo
+        
+      endif
+      
+      return
+      end subroutine global_sum_forces
+      
+      subroutine images
+     x  (imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating the minimum image
+c     of atom pairs within a specified MD cell
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith march 1992.
+c     T3D optimised version. t.forester july 1994
+c     
+c     for
+c     imcon=0 no boundary conditions apply
+c     imcon=1 standard cubic boundaries apply
+c     imcon=2 orthorhombic boundaries apply
+c     imcon=3 parallelepiped boundaries apply
+c     imcon=4 truncated octahedron boundaries apply
+c     imcon=5 rhombic dodecahedron boundaries apply
+c     imcon=6 x-y parallelogram boundary conditions : no periodicity in z
+c     imcon=7 hexagonal prism boundaries apply
+c     
+c     note: in all cases the centre of the cell is at (0,0,0)
+c     warning - replicated data version: does not re-merge 
+c     coordinate arrays
+c     
+c***********************************************************************
+      
+      use error_module
+      
+      implicit none
+
+      integer imcon,idnode,mxnode,natms,iatm1,iatm2,i
+      real(8) cell,xxx,yyy,zzz,aaa,bbb,ccc,det,rt2,rt3,ssx
+      real(8) ssy,ssz,ddd,xss,yss,zss,rcell
+
+      dimension xxx(*),yyy(*),zzz(*)
+      dimension cell(9),rcell(9)
+
+      data rt2/1.41421356623d0/,rt3/1.7320508075d0/
+
+      if(imcon.gt.0) then
+
+c     block indices
+
+        iatm1 = (idnode*natms)/mxnode+1
+        iatm2 = ((idnode+1)*natms)/mxnode
+
+      endif
+      
+      if(imcon.eq.1)then
+
+c     standard cubic boundary conditions
+        
+        
+        aaa=1.d0/cell(1)
+
+        do i=iatm1,iatm2
+          xxx(i)=xxx(i)-cell(1)*nint(aaa*xxx(i))
+          yyy(i)=yyy(i)-cell(1)*nint(aaa*yyy(i))
+          zzz(i)=zzz(i)-cell(1)*nint(aaa*zzz(i))
+        enddo
+        
+      else if(imcon.eq.2)then
+
+c     rectangular (slab) boundary conditions
+        
+        aaa=1.d0/cell(1)
+        bbb=1.d0/cell(5)
+        ccc=1.d0/cell(9)
+        
+        do i=iatm1,iatm2
+          
+          xxx(i)=xxx(i)-cell(1)*nint(aaa*xxx(i))
+          yyy(i)=yyy(i)-cell(5)*nint(bbb*yyy(i))
+          zzz(i)=zzz(i)-cell(9)*nint(ccc*zzz(i))
+          
+        enddo
+        
+      else if(imcon.eq.3)then
+
+c     parallelepiped boundary conditions
+        
+        call invert(cell,rcell,det)
+        
+        do i=iatm1,iatm2
+          
+          ssx=(rcell(1)*xxx(i)+rcell(4)*yyy(i)+rcell(7)*zzz(i))
+          ssy=(rcell(2)*xxx(i)+rcell(5)*yyy(i)+rcell(8)*zzz(i))
+          ssz=(rcell(3)*xxx(i)+rcell(6)*yyy(i)+rcell(9)*zzz(i))
+          
+          xss=ssx-nint(ssx)
+          yss=ssy-nint(ssy)
+          zss=ssz-nint(ssz)
+          
+          xxx(i)=(cell(1)*xss+cell(4)*yss+cell(7)*zss)
+          yyy(i)=(cell(2)*xss+cell(5)*yss+cell(8)*zss)
+          zzz(i)=(cell(3)*xss+cell(6)*yss+cell(9)*zss)
+          
+        enddo
+        
+      else if(imcon.eq.4)then
+
+c     truncated octahedral boundary conditions
+        
+        if(.not.(abs(cell(1)-cell(5)).lt.1.d-6.and.
+     x    abs(cell(5)-cell(9)).lt.1.d-6)) call error(idnode,130)
+        
+        aaa=1.d0/cell(1)
+        
+        do i=iatm1,iatm2
+          
+          xxx(i)=xxx(i)-cell(1)*nint(aaa*xxx(i))
+          yyy(i)=yyy(i)-cell(1)*nint(aaa*yyy(i))
+          zzz(i)=zzz(i)-cell(1)*nint(aaa*zzz(i))
+          
+          if((abs(xxx(i))+abs(yyy(i))+abs(zzz(i))).ge.
+     x      (0.75d0*cell(1)))then
+            
+            xxx(i)=xxx(i)-0.5d0*sign(cell(1),xxx(i))
+            yyy(i)=yyy(i)-0.5d0*sign(cell(1),yyy(i))
+            zzz(i)=zzz(i)-0.5d0*sign(cell(1),zzz(i))
+            
+          endif
+          
+        enddo
+        
+      else if(imcon.eq.5)then
+
+c     rhombic dodecahedral boundary conditions
+        
+        if(.not.(abs(cell(1)-cell(5)).lt.1.d-6.and.
+     x    abs(cell(9)-cell(1)*rt2).lt.1.d-6)) 
+     x    call error(idnode,140)
+        
+        aaa=1.d0/cell(1)
+        bbb=1.d0/cell(9)
+        
+        do i=iatm1,iatm2
+          
+          xxx(i)=xxx(i)-cell(1)*nint(aaa*xxx(i))
+          yyy(i)=yyy(i)-cell(1)*nint(aaa*yyy(i))
+          zzz(i)=zzz(i)-cell(9)*nint(bbb*zzz(i))
+          
+          if((abs(xxx(i))+abs(yyy(i))+abs(rt2*zzz(i))).ge.
+     x      cell(1))then
+            
+            xxx(i)=xxx(i)-0.5d0*sign(cell(1),xxx(i))
+            yyy(i)=yyy(i)-0.5d0*sign(cell(1),yyy(i))
+            zzz(i)=zzz(i)-0.5d0*sign(cell(9),zzz(i))
+            
+          endif
+          
+        enddo
+        
+      else if(imcon.eq.6) then
+
+c     x-y boundary conditions 
+
+        det = cell(1)*cell(5) - cell(2)*cell(4)
+
+        if(abs(det).lt.1.d-6)call error(idnode,120)
+        
+        det = 1.d0/det
+
+        rcell(1) =  det*cell(5)
+        rcell(2) = -det*cell(2)
+        rcell(4) = -det*cell(4)
+        rcell(5) =  det*cell(1)
+        
+        do i=iatm1,iatm2
+
+          ssx = rcell(1)*xxx(i) + rcell(4)*yyy(i)
+          ssy = rcell(2)*xxx(i) + rcell(5)*yyy(i)
+
+          xss = ssx - nint(ssx)
+          yss = ssy - nint(ssy)
+
+          xxx(i)=cell(1)*xss + cell(4)*yss
+          yyy(i)=cell(2)*xss + cell(5)*yss
+
+        enddo
+
+      else if(imcon.eq.7) then
+
+c     hexagonal prism boundary conditions
+        
+        if(abs(cell(1)-rt3*cell(5)).ge.1.d-6)
+     x    call error(idnode,135)
+        
+        aaa=cell(1)/(rt3*2.d0)
+        bbb=cell(1)/rt3
+        ccc=rt3/cell(1)
+        ddd=1.d0/cell(9)
+        
+        do i=iatm1,iatm2
+          
+          yyy(i)=yyy(i)-bbb*nint(ccc*yyy(i))
+          zzz(i)=zzz(i)-cell(9)*nint(ddd*zzz(i))
+          
+          if((abs(yyy(i))+abs(rt3*xxx(i))).ge.bbb)then
+            
+            xxx(i)=xxx(i)-rt3*sign(aaa,xxx(i))
+            yyy(i)=yyy(i)-sign(aaa,yyy(i))
+            
+          endif
+          
+        enddo
+        
+      endif
+      
+      return
+      end subroutine images
+
+      subroutine config_write(fname,levcfg,imcon,natms,engcfg)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing CONFIG files
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith aug 2007
+c     
+c***********************************************************************
+      
+      use config_module
+      use setup_module
+      
+      implicit none
+      
+      character*6 fname
+      
+      integer i,natms,levcfg,imcon,nstep
+      real(8) engcfg
+
+      open(nconf,file=fname,form='formatted')
+      
+      write(nconf,'(80a1)') cfgname
+      write(nconf,'(3i10,1p,g20.12)') levcfg,imcon,natms,engcfg
+      if(imcon.gt.0) write(nconf,'(3f20.12)') cell
+      
+      do i=1,natms
+        
+        write(nconf,'(a8,i10)') atmnam(i),i
+        write(nconf,'(3g20.10)') xxx(i),yyy(i),zzz(i)
+        if(levcfg.gt.0)write(nconf,'(3g20.12)')
+     x    vxx(i),vyy(i),vzz(i)
+        if(levcfg.gt.1)write(nconf,'(3g20.12)') 
+     x    fxx(i),fyy(i),fzz(i)
+        
+      enddo
+      
+      close (nconf)
+      
+      return
+      end subroutine config_write
+      
+      subroutine bomb(idnode,nyr,nmn,ndy)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine to set an expiry date in a compiled program
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith    oct 2002
+c
+c***********************************************************************
+
+      use setup_module
+
+      implicit none
+
+      logical safe
+      integer info(8)
+      character*12 dat,tim,zon
+      integer idnode,nyr,nmn,ndy
+
+      safe=.true.
+
+      call date_and_time(dat,tim,zon,info)
+      
+      if(info(1).gt.nyr)then
+
+        safe=.false.
+
+      else if(info(1).eq.nyr)then
+
+        if(info(2).gt.nmn)then
+
+          safe=.false.
+
+        else if(info(2).eq.nmn)then
+
+          if(info(3).ge.ndy)safe=.false.
+
+        endif
+
+      endif
+
+      if(.not.safe)then
+
+        if(idnode.eq.0)write(nrite,'(a,/,a)')
+     x    'THE EXPIRY DATE OF THIS EXECUTABLE HAS PASSED.',
+     X    'PLEASE CONTACT W.SMITH@DL.AC.UK FOR A NEW LICENCE'
+
+        call exitcomms()
+
+      endif
+
+      return
+      end subroutine bomb
+
+      subroutine cpy_rtc(nnn,aaa,bbb)
+
+c**********************************************************************
+c
+c     dl_poly subroutine for copying a real array into a complex array
+c     of the same dimension
+c
+c     copyright daresbury laboratory 1998
+c     author w.smith oct 1998
+c
+c**********************************************************************
+
+      implicit none
+
+      integer i,nnn
+      real(8) aaa(*)
+      complex(8) bbb(*)
+
+      do i=1,nnn
+
+        bbb(i)=cmplx(aaa(i),0.d0,kind=8)
+
+      enddo
+
+      return
+      end subroutine cpy_rtc
+
+      function duni()
+
+c*********************************************************************
+c     
+c     dl_poly random number generator based on the universal
+c     random number generator of marsaglia, zaman and tsang
+c     (stats and prob. lett. 8 (1990) 35-39.) it must be
+c     called once to initialise parameters u,c,cd,cm
+c     
+c     copyright daresbury laboratory 1992
+c     author -  w.smith         july 1992
+c     
+c*********************************************************************
+
+      implicit none
+
+      logical new
+      integer ir,jr,i,j,k,l,m,ii,jj
+      real(4) s,t,u,c,cd,cm,uni
+      real(8) duni
+      dimension u(97)
+      save u,c,cd,cm,uni,ir,jr,new
+      data new/.true./
+
+      if(new)then
+
+c     initial values of i,j,k must be in range 1 to 178 (not all 1)
+c     initial value of l must be in range 0 to 168.
+
+        i=12
+        j=34
+        k=56
+        l=78
+c     
+        ir=97
+        jr=33
+        new=.false.
+
+        do 200 ii=1,97
+          s=0.0
+          t=0.5
+          do 100 jj=1,24
+            m=mod(mod(i*j,179)*k,179)
+            i=j
+            j=k
+            k=m
+            l=mod(53*l+1,169)
+            if(mod(l*m,64).ge.32)s=s+t
+            t=0.5*t
+  100     continue
+          u(ii)=s
+  200   continue
+        c =  362436.0/16777216.0
+        cd= 7654321.0/16777216.0
+        cm=16777213.0/16777216.0
+      else
+
+c     calculate random number
+        uni=u(ir)-u(jr)
+        if(uni.lt.0.0)uni=uni+1.0
+        u(ir)=uni
+        ir=ir-1
+        if(ir.eq.0)ir=97
+        jr=jr-1
+        if(jr.eq.0)jr=97
+        c=c-cd
+        if(c.lt.0.0)c=c+cm
+        uni=uni-c
+        if(uni.lt.0.0)uni=uni+1.0
+        duni=dble(uni)
+      endif
+      
+      return
+      end function duni
+
+      subroutine ele_prd(nnn,aaa,bbb,ccc)
+
+c**********************************************************************
+c
+c     dl_poly subroutine for element by element product of
+c     a real array (bbb) and a complex array (ccc)
+c
+c     copyright daresbury laboratory 1998
+c     author w.smith july 1998
+c
+c**********************************************************************
+
+      implicit none
+
+      integer i,nnn
+      real(8) bbb(*)
+      complex(8) aaa(*),ccc(*)
+
+      do i=1,nnn
+
+        aaa(i)=bbb(i)*ccc(i)
+
+      enddo
+
+      return
+      end subroutine ele_prd
+
+      subroutine gauss(natms,vxx,vyy,vzz)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for constructing velocity arrays
+c     with a gaussian distribution of unit variance.
+c     
+c     based on the Box-Muller method
+c     
+c     note - this version uses a universal random number 
+c     generator, which generates pseudo-random numbers between
+c     0 and 1. it is based on the algorithm of marsaglia, zaman
+c     and tsang in: stats and prob. lett. 8 (1990) 35-39.
+c     
+c     copyright daresbury laboratory 2007
+c     author - w. smith         nov  2007
+c     
+c*********************************************************************
+      
+      use setup_module
+      
+      implicit none
+
+      integer natms,i
+      real(8) vxx,vyy,vzz,rrr,rr1,rr2
+      
+      dimension vxx(natms),vyy(natms),vzz(natms)
+      
+c     initialise random number generator
+      
+      rrr=duni()
+      
+c     calculate gaussian random numbers
+      
+      do i=1,2*(natms/2),2
+        
+        rr1=sqrt(-2.d0*log(duni()))
+        rr2=2.d0*pi*duni()
+        vxx(i)=rr1*cos(rr2)
+        vxx(i+1)=rr1*sin(rr2)
+
+        rr1=sqrt(-2.d0*log(duni()))
+        rr2=2.d0*pi*duni()
+        vyy(i)=rr1*cos(rr2)
+        vyy(i+1)=rr1*sin(rr2)
+
+        rr1=sqrt(-2.d0*log(duni()))
+        rr2=2.d0*pi*duni()
+        vzz(i)=rr1*cos(rr2)
+        vzz(i+1)=rr1*sin(rr2)
+        
+      enddo
+      if(mod(natms,2).ne.0)then
+        
+        rr1=sqrt(-2.d0*log(duni()))
+        rr2=2.d0*pi*duni()
+        vxx(natms)=rr1*cos(rr2)
+        vyy(natms)=rr1*sin(rr2)
+        rr1=sqrt(-2.d0*log(duni()))
+        rr2=2.d0*pi*duni()
+        vzz(natms)=rr1*cos(rr2)
+        
+      endif
+      
+      return
+      end subroutine gauss
+
+      subroutine invert(a,b,d)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine to invert a 3 * 3 matrix using cofactors
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith       april 1992
+c     
+c***********************************************************************
+
+      implicit none
+
+      real(8) a,b,d,r
+
+      dimension a(9),b(9)
+
+c     calculate adjoint matrix
+      b(1)=a(5)*a(9)-a(6)*a(8)
+      b(2)=a(3)*a(8)-a(2)*a(9)
+      b(3)=a(2)*a(6)-a(3)*a(5)
+      b(4)=a(6)*a(7)-a(4)*a(9)
+      b(5)=a(1)*a(9)-a(3)*a(7)
+      b(6)=a(3)*a(4)-a(1)*a(6)
+      b(7)=a(4)*a(8)-a(5)*a(7)
+      b(8)=a(2)*a(7)-a(1)*a(8)
+      b(9)=a(1)*a(5)-a(2)*a(4)
+
+c     calculate determinant
+      d=a(1)*b(1)+a(4)*b(2)+a(7)*b(3)
+      r=0.d0
+      if(abs(d).gt.0.d0)r=1.d0/d
+
+c     complete inverse matrix
+      b(1)=r*b(1)
+      b(2)=r*b(2)
+      b(3)=r*b(3)
+      b(4)=r*b(4)
+      b(5)=r*b(5)
+      b(6)=r*b(6)
+      b(7)=r*b(7)
+      b(8)=r*b(8)
+      b(9)=r*b(9)
+
+      return
+      end subroutine invert
+
+      subroutine jacobi(a,v,n)
+
+c***********************************************************************
+c     
+c     diagonalisation of real symmetric matices by jacobi method
+c     
+c     input parameters:
+c     
+c     a(n,n) is the matrix to be diagonalised
+c     v(n,n) is the eigenvector matrix
+c     n   is the dimension of the matrices
+c     
+c     jacobi processes lower triangle only (upper triangle unchanged)
+c     
+c     variable rho sets absolute tolerance on convergence
+c     variable tes is a moving tolerance that diminishes
+c     on each pass until at true convergence tes<rho
+c     
+c     author w.smith 1993
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical pass
+      integer n,i,j,k
+      real(8) a,v,rho,tes,scl,v1,v2,v3,u,omg,s,c,tem
+
+      dimension a(n,n),v(n,n)
+
+      rho=1.0d-16
+      tes=0.0d0
+      scl=0.0d0
+
+c     initialize eigenvectors
+
+      do i=1,n
+        do j=1,n
+          v(i,j)=0.0d0
+        enddo
+        v(i,i)=1.0d0
+      enddo
+
+c     rescale matrix for optimal accuracy
+
+      do i=1,n
+        if(abs(a(i,i)).gt.scl)scl=abs(a(i,i))
+      enddo
+      do i=1,n
+        do j=1,i
+          a(i,j)=a(i,j)/scl
+        enddo
+      enddo
+
+c     set initial value of moving tolerance
+
+      do i=2,n
+        do j=1,i-1
+          tes=tes+2.0d0*a(i,j)*a(i,j)
+        enddo
+      enddo
+      tes=sqrt(tes)
+
+c     recycle until absolute tolerance satisfied
+
+      do while(tes.gt.rho)
+
+        tes=tes/dble(n)
+        if(tes.lt.rho)tes=rho
+        
+c     jacobi diagonalisation
+        
+        pass=.true.
+        
+c     recycle until moving tolerance satisfied
+        
+        do while(pass)
+          
+          pass=.false.
+          
+          do i=2,n
+            
+            do j=1,i-1
+              
+              if(abs(a(i,j)).ge.tes)then
+                pass=.true.
+                v1=a(j,j)
+                v2=a(i,j)
+                v3=a(i,i)
+                u=0.5d0*(v1-v3)
+                if(abs(u).lt.rho)then
+                  omg=-1.0d0
+                else
+                  omg=-v2/sqrt(v2*v2+u*u)
+                  if(u.lt.0.0d0)omg=-omg
+                endif
+                s=omg/sqrt(2.0d0*(1.0d0+sqrt(1.0d0-omg*omg)))
+                c=sqrt(1.0d0-s*s)
+                do k=1,n
+                  if(k.ge.i)then
+                    tem=a(k,j)*c-a(k,i)*s
+                    a(k,i)=a(k,j)*s+a(k,i)*c
+                    a(k,j)=tem
+                  else if(k.lt.j)then
+                    tem=a(j,k)*c-a(i,k)*s
+                    a(i,k)=a(j,k)*s+a(i,k)*c
+                    a(j,k)=tem
+                  else
+                    tem=a(k,j)*c-a(i,k)*s
+                    a(i,k)=a(k,j)*s+a(i,k)*c
+                    a(k,j)=tem
+                  endif
+                  tem=v(k,j)*c-v(k,i)*s
+                  v(k,i)=v(k,j)*s+v(k,i)*c
+                  v(k,j)=tem
+                enddo
+                a(j,j)=v1*c*c+v3*s*s-2.0d0*v2*s*c
+                a(i,i)=v1*s*s+v3*c*c+2.0d0*v2*s*c
+                a(i,j)=(v1-v3)*s*c+v2*(c*c-s*s)
+              endif
+              
+            enddo
+            
+          enddo
+          
+        enddo
+
+      enddo
+
+c     rescale matrix
+
+      do i=1,n
+        do j=1,i
+          a(i,j)=scl*a(i,j)
+        enddo
+      enddo
+
+      return
+      end subroutine jacobi
+
+      subroutine scl_csum(nnn,tot,aaa)
+
+c**********************************************************************
+c
+c     dl_poly subroutine to calculate the scalar sum of the elements
+c     of a complex array
+c
+c     copyright daresbury laboratory 1998
+c     author w.smith july 1998
+c
+c**********************************************************************
+
+      implicit none
+
+      integer i,nnn
+      complex(8) aaa(*),tot
+
+      tot=(0.d0,0.d0)
+
+      do i=1,nnn
+
+        tot=tot+aaa(i)
+
+      enddo
+
+      return
+      end subroutine scl_csum
+
+      subroutine set_block(nnn,ccc,aaa)
+
+c**********************************************************************
+c
+c     dl_poly subroutine to initialise an array to a single value
+c
+c     copyright daresbury laboratory 1998
+c     author w.smith july 1998
+c
+c**********************************************************************
+
+      implicit none
+
+      integer i,nnn
+      real(8) ccc,aaa(nnn)
+
+      do i=1,nnn,2
+
+        aaa(i)=ccc
+        aaa(i+1)=ccc
+
+      enddo
+      
+      return
+      end subroutine set_block
+
+      subroutine shellsort(n,list)
+
+c***********************************************************************
+c     
+c     dlpoly shell sort routine. 
+c     Sorts an array of integers into ascending order
+c     
+c     copyright daresbury laboratory 1993
+c     author - t.forester   november 1993
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer n,list,nn,nl,i,j,ix,imax
+
+      dimension list(*)
+
+c     set up sort
+
+      if(n.gt.1) then
+
+c     number of lists
+
+        nl = n/2
+
+c     iterate shell sort
+
+        do while(nl.gt.0)
+
+          do nn = 1,nl
+            
+c     begin insertion sort on nnth list
+            
+            do i = nn+nl,n,nl
+              
+              imax = list(i)
+              ix = i
+              
+c     find location for insertion
+              
+              j = i
+              do while(j.ge.nl+1)
+                
+                j = j-nl
+                if (list(j).gt.imax) then
+                  ix = j
+                else
+                  j =1
+                endif
+                
+              enddo
+              
+c     insert in index array
+              
+              do j = i,ix+nl,-nl
+                list(j) = list(j-nl)
+              enddo
+              
+              list(ix) = imax
+              
+            enddo
+            
+          enddo
+        
+          nl = nl/2
+
+        enddo
+        
+      endif
+
+      return
+      end subroutine shellsort
+
+      subroutine fcap(lfcap,natms,fmax,temp)
+      
+c*********************************************************************
+c     
+c     DLPOLY routinue for limiting the absolute magnitude of
+c     forces. Used in equilibration period only
+c     
+c     copyright daresbury laboratory 1993
+c     
+c     author -     t. forester march 1993
+c     amended-     t. forester  sept 1994
+c     
+c*********************************************************************
+
+      use config_module
+      
+      implicit none
+
+      logical lfcap
+      integer natms,i
+      real(8) fmax,temp,fmax1,fmax2,fxc,fyc,fzc,fmod,fscale
+      
+      if(lfcap) then
+
+c     maximum force permitted
+        
+        fmax1 = boltz*fmax*temp
+        fmax2 = fmax1*fmax1
+
+c     cap forces and conserve linear momentum
+        
+        fxc = 0.d0
+        fyc = 0.d0
+        fzc = 0.d0
+        
+        do i = 1,natms
+          
+          fmod = fxx(i)**2 + fyy(i)**2 + fzz(i)**2
+          
+          if(fmod.gt.fmax2) then
+            
+            fscale = sqrt(fmax2/fmod)
+            
+            fxx(i) = fxx(i)*fscale
+            fyy(i) = fyy(i)*fscale
+            fzz(i) = fzz(i)*fscale
+            
+          endif
+
+c     accummulate forces - to check on momentum conservation
+          
+          fxc = fxc + fxx(i)
+          fyc = fyc + fyy(i)
+          fzc = fzc + fzz(i)
+          
+        enddo
+
+c     ensure net forces sum to zero
+        
+        fxc = -fxc/dble(natms)
+        fyc = -fyc/dble(natms)
+        fzc = -fzc/dble(natms)
+
+c     conserve momentum
+        
+        do i = 1,natms
+          
+          fxx(i) = fxx(i) + fxc
+          fyy(i) = fyy(i) + fyc
+          fzz(i) = fzz(i) + fzc
+          
+        enddo
+        
+      endif
+      
+      return
+      end subroutine fcap
+
+      subroutine freeze(natms)
+
+c***********************************************************************
+c     
+c     dlpoly routine to quench forces and velocities on 'frozen' atoms
+c     replicated data version - blocked data
+c     
+c     copyright daresbury laboratory 1994
+c     author t.forester nov 1994
+c     
+c***********************************************************************
+
+      use config_module
+
+      implicit none
+
+      integer natms,i
+
+      do i = 1,natms
+        
+        if(lstfrz(i).ne.0) then
+          
+          vxx(i) = 0.d0
+          vyy(i) = 0.d0
+          vzz(i) = 0.d0
+          fxx(i) = 0.d0
+          fyy(i) = 0.d0
+          fzz(i) = 0.d0
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine freeze
+
+      subroutine mat_mul(aaa,bbb,ccc)
+
+c***********************************************************************
+c     
+c     dlpoly utility to multiply 3x3 matrices
+c
+c     copyright daresbury laboratory
+c     author      w.smith  oct  2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer i
+      real(8) aaa(9),bbb(9),ccc(9),tmp(9)
+
+      tmp(1)=aaa(1)*bbb(1)+aaa(4)*bbb(2)+aaa(7)*bbb(3)
+      tmp(2)=aaa(2)*bbb(1)+aaa(5)*bbb(2)+aaa(8)*bbb(3)
+      tmp(3)=aaa(3)*bbb(1)+aaa(6)*bbb(2)+aaa(9)*bbb(3)
+
+      tmp(4)=aaa(1)*bbb(4)+aaa(4)*bbb(5)+aaa(7)*bbb(6)
+      tmp(5)=aaa(2)*bbb(4)+aaa(5)*bbb(5)+aaa(8)*bbb(6)
+      tmp(6)=aaa(3)*bbb(4)+aaa(6)*bbb(5)+aaa(9)*bbb(6)
+
+      tmp(7)=aaa(1)*bbb(7)+aaa(4)*bbb(8)+aaa(7)*bbb(9)
+      tmp(8)=aaa(2)*bbb(7)+aaa(5)*bbb(8)+aaa(8)*bbb(9)
+      tmp(9)=aaa(3)*bbb(7)+aaa(6)*bbb(8)+aaa(9)*bbb(9)
+      
+      do i=1,9
+        ccc(i)=tmp(i)
+      enddo
+      
+      return
+      end subroutine mat_mul
+
+      subroutine getrotmat(q0,q1,q2,q3,rot)
+      
+c***********************************************************************
+c     
+c     dlpoly utility to  construct rotation matrix
+c     from quaternions using x convention for euler angles
+c
+c     copyright daresbury laboratory
+c     author      w.smith   mar 2005
+c     
+c**********************************************************************
+
+      implicit none
+      
+      real(8) q0,q1,q2,q3,rot(9)
+      
+      rot(1)=q0**2+q1**2-q2**2-q3**2
+      rot(2)=2.d0*(q1*q2-q0*q3)
+      rot(3)=2.d0*(q1*q3+q0*q2)
+      rot(4)=2.d0*(q1*q2+q0*q3)
+      rot(5)=q0**2-q1**2+q2**2-q3**2
+      rot(6)=2.d0*(q2*q3-q0*q1)
+      rot(7)=2.d0*(q1*q3-q0*q2)
+      rot(8)=2.d0*(q2*q3+q0*q1)
+      rot(9)=q0**2-q1**2-q2**2+q3**2
+      
+      return
+      end subroutine getrotmat
+
+      function sdot0(n,aaa,bbb)
+
+c***********************************************************************
+c     
+c     dlpoly utility to calculate scalar product of two arrays
+c
+c     copyright daresbury laboratory
+c     author      w.smith  july 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer n,i
+      real(8) sdot0,aaa,bbb
+
+      dimension aaa(*),bbb(*)
+
+      sdot0=0.d0
+
+      do i=1,n
+        sdot0=sdot0+aaa(i)*bbb(i)
+      enddo
+
+      return
+      end function sdot0
+
+      function sdot1(natms,idnode,mxnode,aaa,bbb)
+
+c***********************************************************************
+c     
+c     dlpoly utility to calculate scalar product of two arrays
+c     distributed version
+c     
+c     copyright daresbury laboratory
+c     author      w.smith  july 2005
+c     
+c**********************************************************************
+      
+      use config_module
+      
+      implicit none
+      
+      integer natms,idnode,mxnode,i,iatm0,iatm1
+      real(8) sdot1,aaa,bbb
+      
+      dimension aaa(*),bbb(*)
+      
+c     assign block of atoms to processor
+
+      iatm0=(idnode*natms)/mxnode + 1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+      sdot1=0.d0
+      
+      do i=iatm0,iatm1
+        sdot1=sdot1+aaa(i)*bbb(i)
+      enddo
+      
+      if(mxnode.gt.1)then
+        buffer(1)=sdot1
+        call gdsum(buffer(1),1,buffer(2))
+        sdot1=buffer(1)
+      endif
+      
+      return
+      end function sdot1
+
+      integer function loc2(i,j)
+
+c*********************************************************************
+c
+c     calculates double index array minimum reference
+c
+c     copyright daresbury laboratory
+c     author w.smith november 2005
+c
+c*********************************************************************
+      
+      integer i,j
+      
+      loc2=(max(i,j)*(max(i,j)-1))/2+min(i,j)
+      
+      return
+      end function loc2
+
+      integer function loc3(i,j,k)
+
+c*********************************************************************
+c
+c     calculates triple index array minimum reference
+c
+c     copyright daresbury laboratory
+c     author w.smith september 2008
+c
+c*********************************************************************
+      
+      integer i,j,k,a,b,c,u,v,w
+      
+      a=max(i,j)
+      b=min(a,k)
+      c=min(i,j)
+      u=max(a,k)
+      v=max(b,c)
+      w=min(b,c)
+      loc3=(u*(u*u-1))/6+(v*(v-1))/2+w
+      
+      return
+      end function loc3
+
+      integer function loc4(i,j,k,l)
+
+c*********************************************************************
+c
+c     calculates quaduple index array minimum reference
+c
+c     copyright daresbury laboratory
+c     author w.smith september 2008
+c
+c*********************************************************************
+      
+      integer i,j,k,l,a,b,c,d,e,f,t,u,v,w
+      
+      a=max(i,j)
+      b=max(k,l)
+      c=min(i,j)
+      d=min(k,l)
+      e=max(c,d)
+      f=min(a,b)
+      t=max(a,b)
+      u=max(e,f)
+      v=min(e,f)
+      w=min(c,d)
+      loc4=((((t+2)*t-1)*t-2)*t)/24+(u*(u*u-1))/6+(v*(v-1))/2+w
+      
+      return
+      end function loc4
+
+      character*3 function intstr3(nnn)
+
+c*********************************************************************
+c
+c     converts a 3 digit integer to a string "001" etc.
+c
+c     copyright daresbury laboratory
+c     author w.smith november 2005
+c
+c*********************************************************************
+
+      implicit none
+
+      integer nnn
+
+      write(intstr3,'(i3.3)')nnn
+
+      return
+      end function intstr3
+      
+      subroutine traject
+     x  (ltraj,idnode,imcon,istraj,keytrj,natms,nstraj,nstep,tstep)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing history file at selected
+c     intervals in simulation
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith dec 1992.
+c
+c***********************************************************************
+
+      use setup_module
+      use config_module
+
+      implicit none
+      
+      logical newjob,ltraj
+      integer idnode,imcon,istraj,keytrj,natms,nstraj,nstep,i
+      real(8) tstep
+
+      save newjob
+      data newjob/.true./
+      
+      if(ltraj.and.idnode.eq.0)then
+        
+c     open the history file if new job or file closed
+        
+        if(newjob)then
+          
+          newjob = .false.
+
+          open(nhist,file='HISTORY',position='append')
+
+        endif
+        
+        if(nstep.eq.nstraj.or.nstep.eq.istraj)then
+          
+          write(nhist,'(80a1)') cfgname
+          write(nhist,'(3i10)') keytrj,imcon,natms
+          
+        endif
+        
+        if(mod(nstep-nstraj,istraj).eq.0)then
+          
+          write(nhist,'(a8,4i10,f12.6)') 'timestep',
+     x         nstep,natms,keytrj,imcon,tstep
+
+          if(imcon.gt.0) write(nhist,'(3g12.4)') cell
+
+          do i = 1,natms
+
+            write(nhist,'(a8,i10,2f12.6)')
+     x        atmnam(i),i,weight(i),chge(i)
+            write(nhist,'(1p,3e12.4)') xxx(i),yyy(i),zzz(i)
+            if(keytrj.ge.1)then
+              write(nhist,'(1p,3e12.4)') vxx(i),vyy(i),vzz(i)
+            endif
+            if(keytrj.ge.2)then
+              write(nhist,'(1p,3e12.4)') fxx(i),fyy(i),fzz(i)
+            endif
+
+          enddo
+
+        endif
+
+c     close history file at regular intervals
+        
+        if(.not.newjob.and.mod(nstep,ndump).eq.0)then
+          
+          close (nhist)
+          newjob = .true.
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine traject
+      
+      subroutine traject_u
+     x     (ltraj,idnode,imcon,istraj,keytrj,natms,nstraj,nstep,tstep)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for writing history file at selected
+c     intervals in simulation
+c     
+c     Unformatted, double precision version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith dec 1992.
+c     
+c***********************************************************************
+      
+      use setup_module
+      use config_module
+      
+      implicit none
+      
+      logical newjob,ltraj
+      integer idnode,imcon,istraj,keytrj,natms,nstraj,nstep,i
+      real(8) tstep
+      
+      save newjob
+      data newjob/.true./
+      
+      if(ltraj.and.idnode.eq.0)then
+        
+c     open the history file if new job or file closed
+        
+        if(newjob)  then
+          
+          newjob = .false.
+          open(nhist,file='HISTORY',form='unformatted',
+     x      position='append')
+          
+        endif
+        if(nstep.eq.nstraj.or.nstep.eq.istraj)then
+          
+          write(nhist) cfgname
+          write(nhist) dble(natms)
+          write(nhist) (atmnam(i),i=1,natms)
+          write(nhist) (weight(i),i=1,natms)
+          write(nhist) (chge(i),i=1,natms)
+          
+        endif
+        
+        if(mod(nstep-nstraj,istraj).eq.0)then
+          
+          write(nhist)dble(nstep),dble(natms),dble(keytrj),
+     x      dble(imcon),tstep
+          
+          if(imcon.gt.0) write(nhist) cell
+          
+          write(nhist) (xxx(i),i = 1,natms)
+          write(nhist) (yyy(i),i = 1,natms)
+          write(nhist) (zzz(i),i = 1,natms)
+          
+          if(keytrj.ge.1)then
+            write(nhist) (vxx(i),i = 1,natms)
+            write(nhist) (vyy(i),i = 1,natms)
+            write(nhist) (vzz(i),i = 1,natms)
+          endif
+          if(keytrj.ge.2)then
+            write(nhist) (fxx(i),i = 1,natms)
+            write(nhist) (fyy(i),i = 1,natms)
+            write(nhist) (fzz(i),i = 1,natms)
+          endif
+          
+        endif
+        
+c     close history file at regular intervals
+        
+        if(.not.newjob.and.mod(nstep,ndump).eq.0)then
+          
+          close (nhist)
+          newjob=.true.
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine traject_u
+      
+      subroutine getcom_mol(ibeg,iend,imcon,idnode,mxnode,molmas,com)
+      
+c*********************************************************************
+c     
+c     dl_poly routine to calculate centre of mass of a molecule
+c     specified between two atomic indices of the configuration
+c     
+c     copyright daresbury laboratory
+c     author - w.smith june 2009
+c     
+c*********************************************************************
+      
+      use config_module
+      
+      implicit none
+      
+      integer ibeg,iend,imcon,i,idnode,mxnode,iatm0,iatm1,nmol
+      integer j,fail
+      real(8) molmas
+      real(8) com(3)
+      real(8), allocatable :: disx(:),disy(:),disz(:)
+      data fail/0/
+      
+      nmol=iend-ibeg+1
+      if(mxnode.eq.1.or.nmol.lt.mxnode)then
+        
+        iatm0=ibeg
+        iatm1=iend
+        
+      else
+        
+        iatm0=(idnode*nmol)/mxnode+ibeg
+        iatm1=((idnode+1)*nmol)/mxnode+ibeg-1
+        nmol=(iend-ibeg+1)/mxnode+1
+        
+      endif
+      
+      allocate (disx(nmol),disy(nmol),disz(nmol),stat=fail)
+      
+      com(1)=0.d0
+      com(2)=0.d0
+      com(3)=0.d0
+      molmas=0.d0
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        disx(j)=xxx(i)-xxx(ibeg)
+        disy(j)=yyy(i)-yyy(ibeg)
+        disz(j)=zzz(i)-zzz(ibeg)
+        
+      enddo
+      nmol=j
+      
+      call images(imcon,0,1,nmol,cell,disx,disy,disz)
+      
+      j=0
+      do i=iatm0,iatm1
+        
+        j=j+1
+        molmas=molmas+weight(i)
+        com(1)=com(1)+weight(i)*(disx(j)+xxx(ibeg))
+        com(2)=com(2)+weight(i)*(disy(j)+yyy(ibeg))
+        com(3)=com(3)+weight(i)*(disz(j)+zzz(ibeg))
+
+      enddo
+
+      nmol=iend-ibeg+1
+      if(mxnode.gt.1.and.nmol.ge.mxnode)then
+        
+        buffer(1)=com(1)
+        buffer(2)=com(2)
+        buffer(3)=com(3)
+        buffer(4)=molmas
+        call gdsum(buffer(1),4,buffer(5))
+        com(1)=buffer(1)
+        com(2)=buffer(2)
+        com(3)=buffer(3)
+        molmas=buffer(4)
+        
+      endif
+      
+      com(1)=com(1)/molmas
+      com(2)=com(2)/molmas
+      com(3)=com(3)/molmas
+
+      call images(imcon,0,1,1,cell,com(1),com(2),com(3))
+
+      deallocate(disx,disy,disz)
+      
+      return
+      end subroutine getcom_mol
+
+      subroutine timchk(ktim,time)
+      
+c***********************************************************************
+c     
+c     dlpoly timing routine for time elapsed in seconds
+c     
+c     copyright daresbury laboratory
+c     author w.smith nov 2003
+c
+c***********************************************************************
+
+      use setup_module
+
+      implicit none
+
+      logical init
+      character*12 dat,tim,zon
+      integer idnode,mynode,ktim,day
+      real(8) time,told,tsum,tnow
+      integer info(8)
+
+      save init,idnode,told,tsum,day
+
+      data init/.true./
+
+   10 format(/,' time elapsed since job start = ',f15.3,' seconds',/)
+
+      call date_and_time(dat,tim,zon,info)
+      
+      if(init)then
+
+         tsum=0.d0
+         time=0.d0
+         day=info(3)
+         idnode=mynode()
+         told=3600.d0*dble(info(5))+60.d0*dble(info(6))+
+     x         dble(info(7))+0.001d0*dble(info(8))
+         init=.false.
+
+      else
+
+         tnow=3600.d0*dble(info(5))+60.d0*dble(info(6))+
+     x         dble(info(7))+0.001d0*dble(info(8))
+         if(day.ne.info(3))then
+           told=told-86400.d0
+           day=info(3)
+         endif
+         tsum=tsum+tnow-told
+         told=tnow
+         time=tsum
+
+      endif
+
+      if(ktim.gt.0.and.idnode.eq.0) write(nrite,10)time
+
+      return
+      end subroutine timchk
+      
+      subroutine get_prntime(hms,timelp,prntim)
+      
+c***********************************************************************
+c     
+c     dlpoly routine for casting cpu elapsed time into days, hours, 
+c     minutes and seconds for printing (input timelp in seconds)
+c     copyright daresbury laboratory
+c     author w.smith may 2009
+c
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 hms
+      real(8) timelp,prntim
+      
+      if(timelp.ge.8.64d4)then
+        hms='d'
+        prntim=timelp/8.64d4
+      elseif(timelp.ge.3.6d3)then
+        hms='h'
+        prntim=timelp/3.6d3
+      elseif(timelp.ge.6.0d1)then
+        hms='m'
+        prntim=timelp/6.0d1
+      else
+        hms='s'
+        prntim=timelp
+      endif
+
+      return
+      end subroutine get_prntime
+      
+      subroutine get_simtime(dec,nstep,tstep,simtim)
+      
+c***********************************************************************
+c     
+c     dlpoly routine for casting simulation time into microseconds,
+c     nanoseconds, picoseconds and femtoseconds for printing (input
+c     tstep in picoseconds)
+c     copyright daresbury laboratory
+c     author w.smith may 2009
+c     
+c***********************************************************************
+      
+      implicit none
+      
+      character*1 dec
+      integer nstep
+      real(8) tmptim,simtim,tstep
+      
+      tmptim=tstep*dble(nstep)
+
+      if(tmptim.ge.1.0d6)then
+        dec='m'
+        simtim=tmptim*1.0d-6
+      elseif(tmptim.ge.1.0d3)then
+        dec='n'
+        simtim=tmptim*1.0d-3
+      elseif(tmptim.ge.1.0d0)then
+        dec='p'
+        simtim=tmptim
+      else
+        dec='f'
+        simtim=tmptim*1.0d3
+      endif
+
+      return
+      end subroutine get_simtime
+
+      end module utility_module
diff -urN dl_class_1.9.orig/srcmod/vdw_module.f dl_class_1.9/srcmod/vdw_module.f
--- dl_class_1.9.orig/srcmod/vdw_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/vdw_module.f	2011-02-21 10:56:11.000000000 +0100
@@ -0,0 +1,1743 @@
+      module vdw_module
+
+c***********************************************************************
+c     
+c     dl_poly module for defining van der waals potential arrays
+c     copyright - daresbury laboratory
+c     author    - w. smith    sep 2003
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     adapted   - d. quigley : metadynamics
+c     
+c***********************************************************************
+
+      use config_module
+      use error_module
+      use metafreeze_module
+      use pair_module
+      use parse_module
+      use setup_module
+      use site_module
+      use solvation_module
+      use utility_module
+
+      implicit none
+
+      integer, allocatable :: ltpvdw(:),lstvdw(:)
+      real(8), allocatable :: vvv(:,:),ggg(:,:),prmvdw(:,:)
+
+      save ltpvdw,lstvdw,prmvdw,vvv,ggg
+
+      contains
+      
+      subroutine alloc_vdw_arrays(idnode)
+
+      implicit none
+
+      integer, parameter :: nnn=5
+
+      integer i,fail,idnode
+      dimension fail(nnn)
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate (ltpvdw(mxvdw),stat=fail(1))
+      allocate (lstvdw(mxvdw),stat=fail(2))
+      allocate (prmvdw(mxvdw,mxpvdw),stat=fail(3))
+      allocate (vvv(mxgrid,mxvdw),stat=fail(4))
+      allocate (ggg(mxgrid,mxvdw),stat=fail(5))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,1014)
+      enddo
+
+      end subroutine alloc_vdw_arrays
+
+      subroutine define_van_der_waals
+     x  (safe,ltable,lunits,lmols,idnode,ntpvdw,
+     x  ntpatm,keyfce,dlrpot,rvdw,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for defining van der Waals potentials
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2003
+c     
+c***********************************************************************
+
+      implicit none
+
+      logical safe,ltable,lunits,lmols
+      character*1 message(80)
+      character*8 atom1,atom2,keyword
+
+      integer ntpvdw,ntpatm,keyfce,fail,idum,ivdw
+      integer itpvdw,keypot,numpar,katom1,katom2,jtpatm,keyvdw,i
+      integer ntab,idnode,j
+      real(8) dlrpot,rvdw,engunit
+      real(8), allocatable :: parpot(:)
+
+      allocate (parpot(mxpvdw),stat=fail)
+
+      ntpvdw=intstr(record,lenrec,idum)
+
+      ltable=findstring('table',record,idum)
+      
+      if(idnode.eq.0) then
+        
+        write(nrite,"(/,/,1x,'number of specified pair ',
+     x    'potentials',i10)") ntpvdw
+        write(nrite,"(/,/,16x,'atom 1  ','atom 2  ',3x,
+     x    ' key',30x,'parameters'/,/)")
+        
+      endif      
+
+      if(ntpvdw.gt.mxvdw) call error(idnode,80)
+      if(.not.lunits) call error(idnode,6)
+      if(.not.lmols) call error(idnode,13)
+      
+      do ivdw=1,mxvdw
+        
+        lstvdw(ivdw)=0
+        ltpvdw(ivdw)=-1
+        
+      enddo
+      
+      do itpvdw=1,ntpvdw
+        
+        do i=1,mxpvdw
+          parpot(i)=0.d0
+        enddo
+        
+        call getrec(safe,idnode,nfield)
+        if(.not.safe)return
+
+        call copystring(record,message,80)
+        call getword(atom1,record,8,lenrec)
+        call getword(atom2,record,8,lenrec)
+        call lowcase(record,lenrec-16)
+        call getword(keyword,record,4,lenrec)
+
+        if(keyword(1:4).eq.'12-6') then
+          keypot=1
+          numpar=2
+        elseif(keyword(1:4).eq.'lj  ') then
+          keypot=2
+          numpar=2
+        elseif(keyword(1:4).eq.'nm  ') then
+          keypot=3
+          numpar=4
+        elseif(keyword(1:4).eq.'buck') then
+          keypot=4
+          numpar=3
+        elseif(keyword(1:4).eq.'bhm ') then
+          keypot=5
+          numpar=5
+        elseif(keyword(1:4).eq.'hbnd') then
+          keypot=6
+          numpar=2
+        elseif(keyword(1:4).eq.'snm ') then
+          keypot=7
+          numpar=5
+        elseif(keyword(1:4).eq.'mors') then
+          keypot=8
+          numpar=3
+        elseif(keyword(1:4).eq.'wca ') then
+          keypot=9
+          numpar=3
+        elseif(keyword(1:4).eq.'gaus') then
+          keypot=10
+          numpar=6
+        elseif(keyword(1:4).eq.'tab ') then
+          keypot=0
+          numpar=0
+        else
+          if(idnode.eq.0) write(nrite,*) message
+          call error(idnode,452)
+        endif
+
+        parpot(1)=dblstr(record,lenrec,idum)
+        parpot(2)=dblstr(record,lenrec,idum)
+        parpot(3)=dblstr(record,lenrec,idum)
+        parpot(4)=dblstr(record,lenrec,idum)
+        parpot(5)=dblstr(record,lenrec,idum)
+        parpot(6)=dblstr(record,lenrec,idum)
+        
+        if(idnode.eq.0) 
+     x    write(nrite,"(16x,2a8,2x,a4,3x,1p,9e13.5)") 
+     x    atom1,atom2,keyword(1:4),(parpot(j),j=1,numpar)
+        
+        katom1=0
+        katom2=0
+        
+        do jtpatm=1,ntpatm
+
+          if(atom1.eq.unqatm(jtpatm))katom1=jtpatm
+          if(atom2.eq.unqatm(jtpatm))katom2=jtpatm
+          
+        enddo
+        
+        if(katom1.eq.0.or.katom2.eq.0) then
+          call  error(idnode,81)
+        endif
+        
+        keyvdw=loc2(katom1,katom2)
+
+c     convert energies to internal unit
+
+        if(keyvdw.gt.mxvdw) call error(idnode,82)
+        
+        parpot(1)=parpot(1)*engunit
+        
+        if(keypot.eq.1) then
+          
+          parpot(2)=parpot(2)*engunit
+          
+        else if(keypot.eq.4) then
+          
+          parpot(3)=parpot(3)*engunit
+          
+        else if(keypot.eq.5) then
+          
+          parpot(4)=parpot(4)*engunit
+          parpot(5)=parpot(5)*engunit
+          
+        else if(keypot.eq.6) then
+          
+          parpot(2)=parpot(2)*engunit
+          
+        else if(keypot.eq.10) then
+          
+          parpot(3)=parpot(3)*engunit
+          parpot(5)=parpot(5)*engunit
+          
+        endif
+
+        ltable=(ltable.or.(keypot.eq.0))
+
+        if(lstvdw(keyvdw).ne.0) call error(idnode,15)
+        lstvdw(keyvdw)=itpvdw
+        ltpvdw(itpvdw)=keypot
+        
+        do i=1,mxpvdw
+          
+          prmvdw(itpvdw,i)=parpot(i)
+          
+        enddo
+        
+      enddo
+
+c     generate nonbonded force arrays
+
+      if((ntpvdw.gt.0.and.mod(keyfce,2).eq.1).or.(keyfce.eq.2))
+     x  then
+        
+        call forgen(ltable,idnode,ntpvdw,dlrpot,rvdw)
+        
+        if(ltable)then
+          
+          call fortab
+     x      (idnode,ntpvdw,ntpatm,dlrpot,rvdw,engunit)
+          
+        endif
+        
+      endif
+
+c     check for unspecified atom-atom potentials
+      
+      ntab=(ntpatm*(ntpatm+1))/2
+      
+      if(ntpvdw.lt.ntab) then
+        
+        call warning(idnode,110,0.d0,0.d0,0.d0)
+
+        if(mxvdw.le.ntpvdw) call error(idnode,82)
+
+        do i=1,ntab
+          
+          if(lstvdw(i).eq.0)then
+            
+            lstvdw(i)=ntpvdw+1
+            
+          endif
+          
+        enddo
+
+c     define zero potential for undefined interactions
+        
+        do i=1,mxgrid
+          
+          ggg(i,ntpvdw+1)=0.d0
+          vvv(i,ntpvdw+1)=0.d0
+          
+        enddo
+        
+      endif
+
+      deallocate (parpot,stat=fail)
+
+      return
+      end subroutine define_van_der_waals
+
+      subroutine forgen(ltable,idnode,ntpvdw,dlrpot,rcut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for generating potential energy and 
+c     force arrays for van der waals forces only
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith may 1992.
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical ltable
+      integer i,ivdw,ntpvdw,idnode
+      real(8) dlrpot,rcut,rrr,ann,amm,gam,bet,eps,rr0,aaa,bbb
+      real(8) ccc,ddd,eee,sig,rho,rrc,aa1,aa2,aa3,ee1,ee2,ee3
+      real(8) rsq,ex1,ex2,ex3
+
+c     define grid resolution for potential arrays
+      
+      dlrpot=rcut/dble(mxgrid-4)
+
+c     construct arrays for all types of short ranged  potential
+      
+      do ivdw=1,ntpvdw
+        
+        if(ltpvdw(ivdw).eq.1)then
+          
+c       12 - 6 potential
+      
+          aaa=prmvdw(ivdw,1)
+          bbb=prmvdw(ivdw,2)
+          
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=(aaa/rrr**6-bbb)/rrr**6
+            ggg(i,ivdw)=6.d0*(2.d0*aaa/rrr**6-bbb)/rrr**6
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.2)then
+          
+c       lennard-jones potential
+      
+          eps=prmvdw(ivdw,1)
+          sig=prmvdw(ivdw,2)
+
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=4.d0*eps*(sig/rrr)**6*((sig/rrr)**6-1.d0)
+            ggg(i,ivdw)=24.d0*eps*(sig/rrr)**6*(2.d0*(sig/rrr)**6-1.d0)
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.3)then
+
+c       n - m potential
+      
+          eps=prmvdw(ivdw,1)
+          ann=max(prmvdw(ivdw,2),prmvdw(ivdw,3))
+          amm=min(prmvdw(ivdw,2),prmvdw(ivdw,3))
+          rr0=prmvdw(ivdw,4)
+
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=eps/(ann-amm)*(amm*(rr0/rrr)**ann-
+     x        ann*(rr0/rrr)**amm)
+            ggg(i,ivdw)=eps*amm*ann/(ann-amm)*((rr0/rrr)**ann-
+     x        (rr0/rrr)**amm)
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.4)then
+          
+c       buckingham exp - 6 potential
+      
+          aaa=prmvdw(ivdw,1)
+          rho=prmvdw(ivdw,2)
+          ccc=prmvdw(ivdw,3)
+
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=aaa*exp(-rrr/rho)-ccc/rrr**6
+            ggg(i,ivdw)=rrr*aaa*exp(-rrr/rho)/rho-6.d0*ccc/rrr**6
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.5)then
+          
+c       born-huggins-meyer exp - 6 - 8 potential
+      
+          aaa=prmvdw(ivdw,1)
+          bbb=prmvdw(ivdw,2)
+          ccc=prmvdw(ivdw,3)
+          ddd=prmvdw(ivdw,4)
+          eee=prmvdw(ivdw,5)
+
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=aaa*exp(bbb*(ccc-rrr))-ddd/rrr**6-eee/rrr**8
+            ggg(i,ivdw)=rrr*aaa*bbb*exp(bbb*(ccc-rrr))-6.d0*ddd/rrr**6
+     x        -8.d0*eee/rrr**8
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.6) then
+          
+c       Hydrogen-bond 12 - 10 potential
+      
+          aaa=prmvdw(ivdw,1)
+          bbb=prmvdw(ivdw,2)
+
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=aaa/rrr**12-bbb/rrr**10
+            ggg(i,ivdw)=12.0d0*aaa/rrr**12-10.d0*bbb/rrr**10
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.7) then
+          
+c       shifted and force corrected n - m potential (w. smith)
+      
+          eps=prmvdw(ivdw,1)
+          ann=prmvdw(ivdw,2)
+          amm=prmvdw(ivdw,3)
+          rr0=prmvdw(ivdw,4)
+          rrc=prmvdw(ivdw,5)
+          if(rrc.lt.1.d-6)rrc=rcut
+ 
+          if(ann.le.amm) call error(idnode,470)
+
+          gam=rrc/rr0
+          if(gam.lt.1.d0) call error(idnode,468)
+          bet=gam*((gam**(amm+1.d0)-1.d0)/(gam**(ann+1.d0)-1.d0))
+     x      **(1.d0/(ann-amm))
+          eps=-eps*(ann-amm)/(amm*(bet**ann)*(1.d0+(ann/gam-ann-1.d0)
+     x      /gam**ann)-ann*(bet**amm)*(1.d0+(amm/gam-amm-1.d0)
+     x      /gam**amm))
+
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            if(rrr.gt.rrc)then
+
+              vvv(i,ivdw)=0.d0
+              ggg(i,ivdw)=0.d0
+
+            else
+
+              vvv(i,ivdw)=eps/(ann-amm)*(amm*(bet**ann)*((rr0/rrr)**ann-
+     x          (1.d0/gam)**ann)-ann*(bet**amm)*((rr0/rrr)**amm-
+     x          (1.d0/gam)**amm)+ann*amm*((rrr/(gam*rr0)-1.d0)*
+     x          ((bet/gam)**ann-(bet/gam)**amm)))
+              ggg(i,ivdw)=eps*amm*ann/(ann-amm)*((bet**ann)*
+     x          (rr0/rrr)**ann-(bet**amm)*(rr0/rrr)**amm-rrr/
+     x          (gam*rr0)*((bet/gam)**ann-(bet/gam)**amm))
+
+            endif
+
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.8) then
+          
+c       morse potential
+          
+          eps=prmvdw(ivdw,1)
+          rr0=prmvdw(ivdw,2)
+          sig=prmvdw(ivdw,3)
+          
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            vvv(i,ivdw)=eps*((1.d0-exp(-sig*(rrr-rr0)))**2-1.d0)
+            ggg(i,ivdw)=-2.d0*rrr*eps*sig*(1.d0-exp(-sig*(rrr-rr0)))*
+     x        exp(-sig*(rrr-rr0))
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.9) then
+          
+c       weeks-chandler-anderson potential
+          
+          eps=prmvdw(ivdw,1)
+          sig=prmvdw(ivdw,2)
+          rr0=prmvdw(ivdw,3)
+          ddd=sig*2.d0**(1.d0/6.d0)
+          
+          do i=1,mxgrid
+            
+            rrr=dble(i)*dlrpot-rr0
+            if(rrr.gt.ddd)then
+              
+              vvv(i,ivdw)=0.d0
+              ggg(i,ivdw)=0.d0
+
+            else if(rrr.gt.0.d0)then
+              
+              vvv(i,ivdw)=4.d0*eps*(sig/rrr)**6*
+     x          ((sig/rrr)**6-1.d0)+eps
+              ggg(i,ivdw)=24.d0*eps*(1.d0+rr0/rrr)*(sig/rrr)**6*
+     x          (2.d0*(sig/rrr)**6-1.d0)
+            
+            endif
+              
+          enddo
+          
+        else if(ltpvdw(ivdw).eq.10)then
+          
+c       gaussian potential
+      
+          aa1=prmvdw(ivdw,1)
+          ee1=prmvdw(ivdw,2)
+          aa2=prmvdw(ivdw,3)
+          ee2=prmvdw(ivdw,4)
+          aa3=prmvdw(ivdw,5)
+          ee3=prmvdw(ivdw,6)
+
+          do i=1,mxgrid
+            
+            rsq=(dble(i)*dlrpot)**2
+            ex1=aa1*exp(-rsq*ee1)
+            ex2=aa2*exp(-rsq*ee2)
+            ex3=aa3*exp(-rsq*ee3)
+            vvv(i,ivdw)=ex1+ex2+ex3
+            ggg(i,ivdw)=2.d0*rsq*(ee1*ex1+ee2*ex2+ee3*ex3)
+            
+          enddo
+          
+        else if(ltpvdw(ivdw).lt.100) then
+          
+          if(.not.ltable)call error(idnode,150)
+          
+        endif
+        
+      enddo
+      
+      return
+      end subroutine forgen
+
+      subroutine fortab
+     x  (idnode,ntpvdw,ntpatm,dlrpot,rcut,engunit)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for reading potential energy and 
+c     force arrays for van der waals forces only
+c     
+c     copyright - daresbury laboratory 1994
+c     author    - w. smith march 1994
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical safe
+      character*8 atom1,atom2
+      integer idnode,ntpvdw,ntpatm,idum,ngrid
+      integer ivdw,katom1,katom2,jtpatm,l,i,j,k,keyvdw
+      real(8) dlrpot,rcut,engunit,delpot,cutpot,rdr,rrr,ppp
+      real(8) vk0,vk1,vk2,t1,t2
+
+      if(idnode.eq.0)open (ntable,file='TABLE')
+
+c     skip header record
+      
+      call getrec(safe,idnode,ntable)
+      if(.not.safe)call abort_table_read(idnode,ntable)
+
+c     read mesh resolution
+      
+      call getrec(safe,idnode,ntable)
+      if(.not.safe)call abort_table_read(idnode,ntable)
+      delpot=dblstr(record,lenrec,idum)
+      cutpot=dblstr(record,lenrec,idum)
+      ngrid=intstr(record,lenrec,idum)
+
+      dlrpot=rcut/dble(mxgrid-4)
+
+      if (abs(delpot-dlrpot) <= 1.0d-8) delpot=dlrpot
+      if ((delpot>dlrpot) .or. (ngrid-4 /= nint(cutpot/delpot))) then
+        
+         if (idnode == 0) write(nrite,"(                 
+     x    'expected radial increment : ',1p,e15.7,/,     
+     x    'TABLE    radial increment : ',1p,e15.7,/,/,   
+     x    'expected number of grid points : ',0p,i10,/,  
+     x    'grid points in TABLE           : ',i10)")     
+     x    dlrpot, delpot, mxgrid, ngrid
+         
+         call error(idnode,22)
+         
+      endif
+
+      if(cutpot.lt.rcut) call error(idnode,504)
+      if(abs(1.d0-(delpot/dlrpot)).gt.1.0d-8) then
+        if(idnode.eq.0) write(nrite,
+     x    "(/,' TABLE arrays resized for mxgrid=',i10)") mxgrid
+      endif
+
+c     read potential arrays for all pairs
+      
+      do ivdw=1,ntpvdw
+
+c     read potential arrays if potential not already defined
+        
+        if(ltpvdw(ivdw).eq.0)then
+          
+c     read pair potential labels and long range corrections
+          
+          call getrec(safe,idnode,ntable)
+          if(.not.safe)call abort_table_read(idnode,ntable)
+
+          call getword(atom1,record,8,lenrec)
+          call getword(atom2,record,8,lenrec)
+          prmvdw(ivdw,1)=dblstr(record,lenrec,idum)
+          prmvdw(ivdw,2)=dblstr(record,lenrec,idum)
+          
+          katom1=0
+          katom2=0
+          
+          do jtpatm=1,ntpatm
+            
+            if(atom1.eq.unqatm(jtpatm))katom1=jtpatm
+            if(atom2.eq.unqatm(jtpatm))katom2=jtpatm
+            
+          enddo
+          
+          if(katom1.eq.0.or.katom2.eq.0)then
+            if(idnode.eq.0) 
+     x        write(nrite,'(a)') '****',atom1,'***',atom2,'****'
+            call  error(idnode,81)
+          endif
+          
+          keyvdw=loc2(katom1,katom2)
+          
+          if(lstvdw(keyvdw).ne.ivdw) call error(idnode,23)
+          
+c     read potential arrays
+          
+          if(mxbuff.lt.ngrid)  then
+              
+            if(idnode.eq.0)
+     x         write(nrite,*) 'mxbuff must be >=',ngrid,' in fortab'
+            call error(idnode,48)
+              
+          endif
+
+c     read in potential arrays
+
+          do i=1,(ngrid+3)/4
+            
+             l=min(4,ngrid-(i-1)*4)
+             if (idnode == 0) then
+                read(unit=ntable, fmt=*, end=100)
+     x              (buffer((i-1)*4+j),j=1,l)
+             else
+                buffer((i-1)*4+1:(i-1)*4+l)=0.0d0
+             endif
+             
+          enddo
+          call gdsum(buffer(1:ngrid),ngrid,buffer(ngrid+1:2*ngrid))
+
+c     reconstruct arrays using 3pt interpolation
+
+          rdr=1.d0/delpot
+          vvv(1,ivdw)=1.d0
+          ggg(1,ivdw)=0.d0
+          do i=2,mxgrid
+            
+            rrr=dble(i)*dlrpot
+            l=int(rrr*rdr)
+            ppp=rrr*rdr-dble(l)
+            vk0=buffer(l)
+            vk1=buffer(l+1)
+            vk2=buffer(l+2)
+            
+            t1=vk0+(vk1-vk0)*ppp
+            t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+            vvv(i,ivdw)=t1+(t2-t1)*ppp*0.5d0
+
+          enddo
+
+c     read in force arrays
+
+          do i=1,(ngrid+3)/4
+            
+             l=min(4,ngrid-(i-1)*4)
+             if (idnode == 0) then
+                read(unit=ntable, fmt=*, end=100)
+     x              (buffer((i-1)*4+j),j=1,l)
+             else
+                buffer((i-1)*4+1:(i-1)*4+l)=0.0d0
+             endif
+             
+          enddo
+          call gdsum(buffer(1:ngrid),ngrid,buffer(ngrid+1:2*ngrid))
+
+c     reconstruct ggg arrays using 3pt interpolation
+
+          do i=2,mxgrid
+
+            rrr=dble(i)*dlrpot
+            l=int(rrr*rdr)
+            ppp=rrr*rdr-dble(l)
+            vk0=buffer(l)
+            vk1=buffer(l+1)
+            vk2=buffer(l+2)
+            
+            t1=vk0+(vk1-vk0)*ppp
+            t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+            
+            ggg(i,ivdw)=t1+(t2-t1)*ppp*0.5d0
+
+          enddo
+
+        endif
+        
+      enddo
+
+c     convert to internal units
+      
+      do k=1,ntpvdw
+        
+        if(ltpvdw(k).eq.0)then
+
+          do i=1,mxgrid
+            
+            vvv(i,k)=vvv(i,k)*engunit
+            ggg(i,k)=ggg(i,k)*engunit
+            
+          enddo
+          
+        endif
+        
+      enddo
+      
+      if(idnode.eq.0)close (ntable)
+      
+      if(idnode.eq.0)write(nrite,'(/,/,1x,a)')
+     x  'potential tables read from TABLE file'
+      
+      return
+      
+c     end of file error exit
+      
+  100 call abort_table_read(idnode,ntable)
+
+      end subroutine fortab
+
+      subroutine abort_table_read(idnode,ntable)
+
+c***********************************************************************
+c     
+c     dl_poly error exit subroutine for reading TABLE file
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith   sept 2005
+c     
+c***********************************************************************
+
+      implicit none
+      integer idnode,ntable
+
+      if(idnode.eq.0)close (ntable)
+      
+      call error(idnode,24)
+      
+      end subroutine abort_table_read
+
+      subroutine srfrce
+     x  (lsolva,lfree,lghost,iatm,ik,engsrp,virsrp,rcut,dlrpot)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating short range force and
+c     potential energy terms using verlet neighbour list
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith       march 1992
+c     
+c     version 3
+c     author    - t. forester    june  1993
+c     stress tensor added t.forester may 1994
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer iatm,ik,m,jatm,k,l,kkk
+      real(8) engsrp,virsrp,rcut,dlrpot
+      real(8) ab,rrr,rsq,ppp,t1,t2,vk0,vk1,vk2,gk0,gk1,gk2,gamma
+      real(8) fi,rcsq,rdr,ai,aj,fx,fy,fz,omega
+      real(8) strs(6),strs_loc(6)
+
+      dimension fi(3)
+
+CDIR$ CACHE_ALIGN fi
+      
+      lskip=(lfree.or.lghost)
+      if(lmetadyn)idrive=driven(ltype(iatm))
+      
+c     set cutoff condition for pair forces
+
+      rcsq=rcut**2
+
+c     interpolation spacing
+      
+      rdr=1.d0/dlrpot
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+
+c     initialise potential energy and virial
+      
+      engsrp=0.d0
+      virsrp=0.d0
+
+c     store forces for iatm 
+      
+      ai=dble(ltype(iatm))
+      fi(1)=fxx(iatm)
+      fi(2)=fyy(iatm)
+      fi(3)=fzz(iatm)
+
+c     start of primary loop for forces evaluation
+      
+      do m=1,ik
+        
+c     atomic and potential function indices
+        
+        jatm=ilist(m)
+        if(lmetadyn)jdrive=driven(ltype(jatm))
+        
+        if(lskip)then
+          if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+        endif
+        
+        aj=dble(ltype(jatm))
+        
+        if(ai.gt.aj) then
+          ab=ai*(ai-1.d0)*0.5d0+aj+0.5d0
+        else
+          ab=aj*(aj-1.d0)*0.5d0+ai+0.5d0
+        endif
+        
+        k=lstvdw(int(ab))
+        
+        if((ltpvdw(k).lt.100).and.(abs(vvv(1,k)).gt.1.d-10))then
+          
+c     apply truncation of potential
+          
+          rsq=rsqdf(m)
+          
+          if(rcsq.gt.rsq)then
+            
+            rrr=sqrt(rsq)               
+            l=int(rrr*rdr)
+            ppp=rrr*rdr-dble(l)
+            
+            if(l.eq.0)then
+              
+              omega=vvv(1,k)
+              gamma=ggg(1,k)
+              
+            else
+              
+c     calculate interaction energy using 3-point interpolation
+              
+              vk0=vvv(l,k)
+              vk1=vvv(l+1,k)
+              vk2=vvv(l+2,k)
+              t1=vk0+(vk1-vk0)*ppp
+              t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+              omega=t1+(t2-t1)*ppp*0.5d0
+              
+c     calculate forces using 3-point interpolation
+              
+              gk0=ggg(l,k)
+              gk1=ggg(l+1,k)
+              gk2=ggg(l+2,k)
+              t1=gk0+(gk1-gk0)*ppp
+              t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+              gamma=(t1+(t2-t1)*ppp*0.5d0)/rsq
+              
+            endif
+            
+c     set selection control
+            
+            lselect=.true.
+            
+c     set double index
+            
+            if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+            
+            if(lghost)then
+              
+c     selected excitation option
+              
+              if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                
+c     reset selection control
+                
+                lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                
+                if(lsolva)vdw_exc(kkk)=vdw_exc(kkk)+omega
+                
+              endif
+              
+            elseif(lfree)then
+              
+c     selected free energy option
+              
+              if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                
+c     set hamiltonian mixing parameter
+                
+                vdw_fre=vdw_fre-omega
+                vdw_vir=vdw_vir+gamma*rsq
+                omega=lambda1*omega
+                gamma=lambda1*gamma
+                
+              elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                
+c     set hamiltonian mixing parameter
+                
+                vdw_fre=vdw_fre+omega
+                vdw_vir=vdw_vir-gamma*rsq
+                omega=lambda2*omega
+                gamma=lambda2*gamma
+                
+              endif
+              
+            endif
+            
+            if(lselect)then
+              
+c     calculate potential and virial
+              
+              engsrp=engsrp+omega
+              virsrp=virsrp-gamma*rsq
+              
+              if(lsolva)vdw_sol(kkk)=vdw_sol(kkk)+omega
+              
+c     calculate forces
+              
+              fx=gamma*xdf(m)
+              fy=gamma*ydf(m)
+              fz=gamma*zdf(m)
+              
+              fi(1)=fi(1)+fx
+              fi(2)=fi(2)+fy
+              fi(3)=fi(3)+fz
+              
+              fxx(jatm)=fxx(jatm)-fx
+              fyy(jatm)=fyy(jatm)-fy
+              fzz(jatm)=fzz(jatm)-fz
+              
+c     calculate stress tensor
+              
+              strs(1)=strs(1)+xdf(m)*fx
+              strs(2)=strs(2)+xdf(m)*fy
+              strs(3)=strs(3)+xdf(m)*fz
+              strs(4)=strs(4)+ydf(m)*fy
+              strs(5)=strs(5)+ydf(m)*fz
+              strs(6)=strs(6)+zdf(m)*fz
+              
+            endif
+            
+            if(lmetadyn.and.(idrive.or.jdrive))then
+              
+              eng_loc=eng_loc+omega
+              vir_loc=vir_loc-gamma*rsq
+              
+              fxx_loc(iatm)=fxx_loc(iatm)+fx
+              fyy_loc(iatm)=fyy_loc(iatm)+fy
+              fzz_loc(iatm)=fzz_loc(iatm)+fz
+              
+              fxx_loc(jatm)=fxx_loc(jatm)-fx
+              fyy_loc(jatm)=fyy_loc(jatm)-fy
+              fzz_loc(jatm)=fzz_loc(jatm)-fz
+              
+              strs_loc(1)=strs_loc(1)+xdf(m)*fx
+              strs_loc(2)=strs_loc(2)+xdf(m)*fy
+              strs_loc(3)=strs_loc(3)+xdf(m)*fz
+              strs_loc(4)=strs_loc(4)+ydf(m)*fy
+              strs_loc(5)=strs_loc(5)+ydf(m)*fz
+              strs_loc(6)=strs_loc(6)+zdf(m)*fz
+              
+            endif
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+c     load temps back to fxx(iatm) etc
+      
+      fxx(iatm)=fi(1)
+      fyy(iatm)=fi(2)
+      fzz(iatm)=fi(3)
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+
+      return
+      end subroutine srfrce
+      
+      subroutine lrcorrect
+     x  (lsolva,lfree,lghost,idnode,imcon,keyfce,natms,
+     x  ntpatm,ntpvdw,elrc,engunit,virlrc,rcut,volm)
+      
+c*************************************************************************
+c     
+c     DL_POLY subroutine to evaluate long-range corrections to
+c     pressure and energy in a periodic system.
+c     
+c     copyright daresbury laboratory 1993
+c     author    - t. forester may 1993
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c***************************************************************************
+      
+      implicit none
+
+      integer, parameter :: nnn=10
+      logical lsolva,lfree,lghost
+      integer idnode,imcon,keyfce,natms,ntpatm,i,ka,ntpvdw
+      integer ivdw,j,k,it,jt,kt,fail
+      real(8) natyp,nbtyp,nctyp,ndtyp,nafrz,nbfrz,ncfrz,ndfrz
+      real(8) elrc,engunit,virlrc,rcut,volm,twopi,eadd,padd
+      real(8) denprd,aaa,bbb,ccc,ddd,eee,eps,sig,rr0,ann,amm
+      real(8) denprd1,denprd2,denprd3,denprdf
+      integer, allocatable :: numtyp_sol0(:,:),numfrz_sol0(:,:)
+      integer, allocatable :: numtyp_sol1(:,:),numfrz_sol1(:,:)
+      integer, allocatable :: numtyp_sol2(:,:),numfrz_sol2(:,:)
+      integer, allocatable :: numtyp_fre(:,:),numfrz_fre(:,:)
+      real(8), allocatable :: elrc_sol0(:),elrc_exc0(:)
+      
+      dimension fail(nnn)
+      
+      twopi=2.0d0*pi
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+      if(lfree.or.lghost)then
+        
+        allocate (numtyp_fre(mxatyp,0:2),stat=fail(1))
+        allocate (numfrz_fre(mxatyp,0:2),stat=fail(2))
+        allocate (elrc_exc0(mxtmls_exc2),stat=fail(3))
+        
+      endif
+      
+      if(lsolva)then
+        
+        allocate (elrc_sol0(mxtmls_sol2),stat=fail(4))
+        allocate (numtyp_sol0(mxatyp,mxtmls),stat=fail(5))
+        allocate (numfrz_sol0(mxatyp,mxtmls),stat=fail(6))
+        
+        if(lghost)then
+          
+          allocate (numtyp_sol1(mxatyp,mxtmls),stat=fail(7))
+          allocate (numfrz_sol1(mxatyp,mxtmls),stat=fail(8))
+          allocate (numtyp_sol2(mxatyp,mxtmls),stat=fail(9))
+          allocate (numfrz_sol2(mxatyp,mxtmls),stat=fail(10))
+          
+        endif
+        
+      endif
+      
+      do i=1,nnn
+        if(fail(i).ne.0)call error(idnode,1015)
+      enddo
+      
+c     initalise counter arrays
+      
+      do i=1,ntpatm
+        
+        numtyp(i)=0
+        numfrz(i)=0
+        
+      enddo
+      
+      if(lfree.or.lghost)then
+        
+        numtyp_fre(:,:)=0
+        numfrz_fre(:,:)=0
+        
+      endif
+      
+      if(lsolva)then
+        
+        numtyp_sol0(:,:)=0
+        numfrz_sol0(:,:)=0
+        
+        if(lghost)then
+          
+          numtyp_sol1(:,:)=0
+          numfrz_sol1(:,:)=0
+          numtyp_sol2(:,:)=0
+          numfrz_sol2(:,:)=0
+          
+        endif
+        
+      endif
+      
+c     evaluate number density in system
+      
+      do i=1,natms
+        
+        ka=ltype(i)
+        numtyp(ka)=numtyp(ka)+1
+        if(lstfrz(i).ne.0)numfrz(ka)=numfrz(ka)+1
+        
+      enddo
+      
+      if(lfree.or.lghost)then
+         
+        do i=1,natms
+          
+          ka=ltype(i)
+          numtyp_fre(ka,atm_fre(i))=numtyp_fre(ka,atm_fre(i))+1
+          if(lstfrz(i).ne.0)
+     x      numfrz_fre(ka,atm_fre(i))=numfrz_fre(ka,atm_fre(i))+1          
+          
+        enddo
+        
+      endif
+      
+      if(lsolva)then
+        
+        if(lghost)then
+          
+          do i=1,natms
+            
+            ka=ltype(i)
+            
+            if(atm_fre(i).eq.0)then
+              
+              numtyp_sol0(ka,atmolt(i))=numtyp_sol0(ka,atmolt(i))+1
+              if(lstfrz(i).ne.0)
+     x          numfrz_sol0(ka,atmolt(i))=numfrz_sol0(ka,atmolt(i))+1
+              
+            elseif(atm_fre(i).eq.1)then
+              
+              numtyp_sol1(ka,atmolt(i))=numtyp_sol1(ka,atmolt(i))+1
+              if(lstfrz(i).ne.0)
+     x          numfrz_sol1(ka,atmolt(i))=numfrz_sol1(ka,atmolt(i))+1
+              
+            elseif(atm_fre(i).eq.2)then
+              
+              numtyp_sol2(ka,atmolt(i))=numtyp_sol2(ka,atmolt(i))+1
+              if(lstfrz(i).ne.0)
+     x          numfrz_sol2(ka,atmolt(i))=numfrz_sol2(ka,atmolt(i))+1
+              
+            endif
+            
+          enddo
+          
+        else
+          
+          do i=1,natms
+            
+            ka=ltype(i)
+            numtyp_sol0(ka,atmolt(i))=numtyp_sol0(ka,atmolt(i))+1
+            if(lstfrz(i).ne.0)
+     x        numfrz_sol0(ka,atmolt(i))=numfrz_sol0(ka,atmolt(i))+1
+            
+          enddo
+          
+        endif
+        
+      endif
+      
+c     number densities
+      
+      do i=1,ntpatm
+        dens(i)=dble(numtyp(i))/volm
+      enddo
+      
+c     long range corrections to energy and pressure
+      
+      elrc=0.d0
+      elrc2=0.d0
+      virlrc=0.d0
+      virlrc2=0.d0
+      denprdf=0.d0
+      volm_sav=0.d0
+      elrc_fre=0.d0
+      vlrc_fre=0.d0
+      
+      if(imcon.ne.0.and.imcon.ne.6.and.ntpvdw.gt.0) then 
+         
+        if(mod(keyfce,2).eq.1) then
+          
+          ivdw=0
+          
+          do i=1,ntpatm
+            
+            do j=1,i
+               
+              eadd=0.d0
+              padd=0.d0
+              
+              ivdw=ivdw+1
+              k=lstvdw(ivdw)
+              
+              if(ltpvdw(k).eq.0) then
+                
+c     tabulated potential
+                
+                eadd=prmvdw(k,1)
+                padd=-prmvdw(k,2)
+                
+              else if(ltpvdw(k).eq.1) then
+                
+c     12-6 potential
+                
+                aaa=prmvdw(k,1)
+                bbb=prmvdw(k,2)
+                
+                eadd=aaa/(9.d0*rcut**9)-bbb/(3.d0*rcut**3)
+                padd=12.d0*aaa/(9.d0*rcut**9)-6.d0*bbb/(3.d0*rcut**3)
+                
+              else if(ltpvdw(k).eq.2) then
+                
+c     Lennard Jones potential
+      
+                eps=prmvdw(k,1)
+                sig=prmvdw(k,2)
+                
+                eadd=4.d0*eps*(sig**12/(9.d0*rcut**9)-
+     x            sig**6/(3.d0*rcut**3))
+                padd=4.d0*eps*(12.d0*sig**12/(9.d0*rcut**9)-
+     x            2.d0*sig**6/(rcut**3))
+                
+              else if(ltpvdw(k).eq.3) then
+                
+c     n - m potential
+                
+                eps=prmvdw(k,1)
+                ann=prmvdw(k,2)
+                amm=prmvdw(k,3)
+                rr0=prmvdw(k,4)
+                
+                eadd=eps/(ann-amm)*(amm*rr0**ann/((ann-3.d0)*
+     x            rcut**(ann-3.d0))-ann*rr0**amm/((amm-3.0d0)*
+     x            rcut**(amm-3.d0)))
+                padd=eps/(ann-amm)*ann*amm*(rr0**ann/((ann-3.d0)*
+     x            rcut**(ann-3.d0))-rr0**amm/((amm-3.0d0)*
+     x            rcut**(amm-3.d0)))
+                
+              else if(ltpvdw(k).eq.4) then
+                
+c     buckingham exp - 6 potential
+                
+                ccc=prmvdw(k,3)
+                
+                eadd=-ccc/(3.d0*rcut**3)
+                padd=-2.d0*ccc/(rcut**3)
+                
+              else if(ltpvdw(k).eq.5) then
+                
+c     born huggins meyer exp -6 - 8  potential
+                
+                ddd=prmvdw(k,4)
+                eee=prmvdw(k,5)
+                
+                eadd=-ddd/(3.d0*rcut**3)-eee/(5.d0*rcut**5)
+                padd=-2.d0*ddd/(rcut**3)-8.d0*eee/(5.d0*rcut**5)
+                
+              else if(ltpvdw(k).eq.6) then
+                
+c     hydrogen bond  12 - 10 potential
+                
+                aaa=prmvdw(k,1)
+                bbb=prmvdw(k,2)
+                
+                eadd=aaa/(9.d0*rcut**9)-bbb/(7.d0*rcut**7)
+                padd=12.d0*aaa/(9.d0*rcut**9)-1.d1*bbb/(7.d0*rcut**7)
+                
+              endif
+              
+              if(i.ne.j) then
+                
+                eadd=eadd*2.d0
+                padd=padd*2.d0
+                
+              endif
+              
+              if(.not.(lfree.or.lghost))then
+                
+                denprd=twopi*(dble(numtyp(i))*dble(numtyp(j))-
+     x            dble(numfrz(i))*dble(numfrz(j)))/volm**2
+                
+              else
+                 
+                nafrz=dble(numfrz_fre(i,0)+numfrz_fre(i,1))
+                natyp=dble(numtyp_fre(i,0)+numtyp_fre(i,1))
+                nbfrz=dble(numfrz_fre(j,0)+numfrz_fre(j,1))
+                nbtyp=dble(numtyp_fre(j,0)+numtyp_fre(j,1))
+                ncfrz=dble(numfrz_fre(i,0)+numfrz_fre(i,2))
+                nctyp=dble(numtyp_fre(i,0)+numtyp_fre(i,2))
+                ndfrz=dble(numfrz_fre(j,0)+numfrz_fre(j,2))
+                ndtyp=dble(numtyp_fre(j,0)+numtyp_fre(j,2))
+                
+                if(lghost)then
+                  
+                  denprd=twopi*(natyp*nbtyp-nafrz*nbfrz)/volm**2
+                  denprd3=twopi*(nctyp*ndtyp-ncfrz*ndfrz)/volm**2
+                  
+                elseif(lfree)then
+                  
+                  denprd1=twopi*(natyp*nbtyp-nafrz*nbfrz)/volm**2
+                  denprd2=twopi*(nctyp*ndtyp-ncfrz*ndfrz)/volm**2
+                  denprd=lambda1*denprd1+lambda2*denprd2
+                  denprd3=lambda2*denprd1+lambda1*denprd2
+                  denprdf=denprd2-denprd1
+                  
+                endif
+                
+              endif
+              
+              elrc=elrc+volm*denprd*eadd
+              virlrc=virlrc-denprd*padd*volm
+              
+              if(lfree.or.lghost)then
+                
+                elrc2=elrc2+volm*denprd3*eadd
+                virlrc2=virlrc2-denprd3*padd*volm
+                if(lfree)then
+                  elrc_fre=elrc_fre+volm*denprdf*eadd
+                  vlrc_fre=vlrc_fre-denprdf*padd*volm
+                endif
+                
+              endif
+              
+              if(lsolva)then
+                
+                elrc_sol0(:)=0.d0
+                if(lghost)elrc_exc0(:)=0.d0
+                
+                do it=1,mxtmls
+                  
+                  do jt=1,mxtmls
+                    
+                    kt=loc2(it,jt)
+                    
+                    if(lghost)then
+                       
+                      natyp=dble(numtyp_sol0(i,it)+numtyp_sol1(i,it))
+                      nbtyp=dble(numtyp_sol0(j,jt)+numtyp_sol1(j,jt))
+                      nafrz=dble(numfrz_sol0(i,it)+numfrz_sol1(i,it))
+                      nbfrz=dble(numfrz_sol0(j,jt)+numfrz_sol1(j,jt))
+                      
+                      elrc_sol0(kt)=elrc_sol0(kt)+twopi*(natyp*
+     x                nbtyp-nafrz*nbfrz)/volm**2
+                      
+                      nctyp=dble(numtyp_sol0(i,it)+numtyp_sol2(i,it))
+                      ndtyp=dble(numtyp_sol0(j,jt)+numtyp_sol2(j,jt))
+                      ncfrz=dble(numfrz_sol0(i,it)+numfrz_sol2(i,it))
+                      ndfrz=dble(numfrz_sol0(j,jt)+numfrz_sol2(j,jt))
+                      
+                      elrc_exc0(kt)=elrc_exc0(kt)+twopi*(nctyp*
+     x                ndtyp-ncfrz*ndfrz)/volm**2
+                      
+                    else
+                      
+                      natyp=dble(numtyp_sol0(i,it))
+                      nbtyp=dble(numtyp_sol0(j,jt))
+                      nafrz=dble(numfrz_sol0(i,it))
+                      nbfrz=dble(numfrz_sol0(j,jt))
+                      
+                      elrc_sol0(kt)=elrc_sol0(kt)+twopi*(natyp*
+     x                nbtyp-nafrz*nbfrz)/volm**2             
+                      
+                    endif
+                    
+                  enddo
+                  
+                enddo
+                
+                if(lghost)then
+                   
+                  elrc_sol(:)=elrc_sol(:)+volm*eadd*elrc_sol0(:)
+                  elrc_exc(:)=elrc_exc(:)+volm*eadd*elrc_exc0(:)
+                  
+                else
+                  
+                  elrc_sol(:)=elrc_sol(:)+volm*eadd*elrc_sol0(:)
+                  
+                endif
+                
+              endif
+              
+            enddo
+            
+          enddo
+          
+          if(lfree.or.lghost)then
+             
+            elrc_sav=elrc
+            elrc2_sav=elrc2
+            virlrc_sav=virlrc
+            virlrc2_sav=virlrc2
+            elrc_fre_sav=elrc_fre
+            vlrc_fre_sav=vlrc_fre
+            
+          endif
+          
+          volm_sav=volm
+          
+          if(lghost)then
+             
+            elrc_sol_sav(:)=elrc_sol(:)
+            elrc_exc_sav(:)=elrc_exc(:)
+            
+          elseif(lsolva)then
+            
+            elrc_sol_sav(:)=elrc_sol(:)
+            
+          endif
+          
+        endif
+        
+      endif
+      
+      if(idnode.eq.0)then
+        
+        write(nrite,
+     x    "(/,/,'long range correction for: vdw energy  ',e15.6,/,
+     x    25x,': vdw pressure',e15.6)")elrc/engunit,
+     x    prsunt*virlrc/(-3.d0*volm)
+      
+        if(lghost)
+     x    write(nrite,
+     x    "(/,/,'long range correction for: vdw energy  ',e15.6,/,
+     x    25x,': vdw pressure',e15.6)")elrc2/engunit,
+     x    prsunt*virlrc2/(-3.d0*volm)
+        
+      endif
+      
+c     deallocate work arrays
+      
+      if(lfree.or.lghost)
+     x  deallocate (elrc_exc0,numtyp_fre,numfrz_fre,stat=fail(1))
+      
+      if(lsolva)then
+        
+        deallocate (elrc_sol0,numtyp_sol0,numfrz_sol0,stat=fail(2))
+        
+        if(lghost)then
+          
+          deallocate (numtyp_sol1,numfrz_sol1,stat=fail(3))
+          deallocate (numtyp_sol2,numfrz_sol2,stat=fail(4))
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine lrcorrect
+
+
+      subroutine srfrceneu
+     x  (lsolva,lfree,lghost,ik,engsrp,virsrp,dlrpot,rcut)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for calculating short range force and
+c     potential energy terms using verlet neighbour list
+c     neutral group implementation
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 1992
+c     author    - w. smith       march 1992
+c     
+c     neutral groups
+c     author    - t. forester    march  1994
+c     
+c     adapted   - p.-a. cazade oct 2007: solvation, free energy etc
+c     
+c***********************************************************************
+      
+      implicit none
+
+      logical lsolva,lfree,lghost,lselect,lskip,idrive,jdrive
+      integer ik,m,iatm,jatm,l,k,kkk
+      real(8) engsrp,virsrp,dlrpot,rcut,rcsq,fx,fy,fz,omega,omega_exc
+      real(8) rrr,ppp,vk0,vk1,vk2,t1,t2,gk0,gk1,gk2,rdlpot,gamma
+      real(8) ai,aj,ak,rsq,strs(6),strs_loc(6)
+      
+      lskip=(lfree.or.lghost)
+
+c     set cutoff condition for pair forces
+      
+      rcsq=rcut**2
+
+c     reciprocal of interpolation spacing
+
+      rdlpot=1.d0/dlrpot
+
+c     initialise stress tensor accumulators
+
+      strs(:)=0.d0
+      strs_loc(:)=0.d0
+      
+c     initialise potential energy and virial
+      
+      engsrp=0.d0
+      virsrp=0.d0
+
+c     start of primary loop for forces evaluation
+      
+      do m=1,ik
+
+c     atomic and potential function indices
+        
+        iatm=ilist(m)
+        jatm=jlist(m)
+        
+c     metadynamics local definitions
+        
+        if(lmetadyn)then
+          
+          idrive=driven(ltype(iatm))
+          jdrive=driven(ltype(jatm))
+          
+        endif
+        
+        if(lskip)then
+          if(atm_fre(iatm)*atm_fre(jatm).eq.2)cycle
+        endif
+        
+        aj=ltype(jatm)
+        ai=ltype(iatm)
+
+        if(ai.gt.aj) then
+          ak=(ai*(ai-1.d0)*0.5d0+aj+0.5d0)
+        else
+          ak=(aj*(aj-1.d0)*0.5d0+ai+0.5d0)
+        endif
+        k=lstvdw(int(ak))
+
+        if(abs(vvv(1,k)).gt.1.d-10)then
+
+          rsq=rsqdf(m)
+
+          if(rsq.lt.rcsq) then
+              
+            rrr=sqrt(rsq)
+
+c     determine interpolation panel for force arrays
+            
+            l=int(rrr*rdlpot)
+            ppp=rrr*rdlpot-dble(l)
+
+c     calculate interaction energy using 3-point interpolation
+            
+            vk0=vvv(l,k)
+            vk1=vvv(l+1,k)
+            vk2=vvv(l+2,k)
+            t1=vk0+(vk1-vk0)*ppp
+            t2=vk1+(vk2-vk1)*(ppp-1.0d0)
+            omega=t1+(t2-t1)*ppp*0.5d0
+
+c     calculate forces using 3-point interpolation
+            
+            gk0=ggg(l,k)
+            gk1=ggg(l+1,k)
+            gk2=ggg(l+2,k)
+            t1=gk0+(gk1-gk0)*ppp
+            t2=gk1+(gk2-gk1)*(ppp-1.0d0)
+            gamma=(t1+(t2-t1)*ppp*0.5d0)/rsq
+
+c     set selection control
+              
+            lselect=.true.
+            
+c     set double index
+            
+            if(lsolva)kkk=loc2(atmolt(iatm),atmolt(jatm))
+            
+            if(lghost)then
+              
+c     selected excitation option
+              
+              if((atm_fre(iatm).ne.1).and.(atm_fre(jatm).ne.1))then
+                
+c     reset selection control
+                
+                lselect=(atm_fre(iatm)+atm_fre(jatm).eq.0)
+                
+                if(lsolva)vdw_exc(kkk)=vdw_exc(kkk)+omega
+                
+              endif
+              
+            elseif(lfree)then
+              
+c     selected free energy option
+              
+              if((atm_fre(iatm).eq.1).or.(atm_fre(jatm).eq.1))then
+                
+c     set hamiltonian mixing parameter
+                
+                omega=lambda1*omega
+                gamma=lambda1*gamma
+                
+              elseif((atm_fre(iatm).eq.2).or.(atm_fre(jatm).eq.2))then
+                
+c     set hamiltonian mixing parameter
+                
+                omega=lambda2*omega
+                gamma=lambda2*gamma
+                
+              endif
+              
+            endif
+            
+            if(lselect)then
+              
+c     calculate potential energy and virial
+            
+              engsrp=omega+engsrp
+              virsrp=virsrp-gamma*rsq
+              
+              if(lsolva)vdw_sol(kkk)=vdw_sol(kkk)+omega
+              
+              fx=gamma*xdf(m)
+              fy=gamma*ydf(m)
+              fz=gamma*zdf(m)
+              
+              fxx(iatm)=fxx(iatm)+fx
+              fyy(iatm)=fyy(iatm)+fy
+              fzz(iatm)=fzz(iatm)+fz
+              
+              fxx(jatm)=fxx(jatm)-fx
+              fyy(jatm)=fyy(jatm)-fy
+              fzz(jatm)=fzz(jatm)-fz
+              
+c     calculate stress tensor
+            
+              strs(1)=strs(1)+xdf(m)*fx
+              strs(2)=strs(2)+xdf(m)*fy
+              strs(3)=strs(3)+xdf(m)*fz
+              strs(4)=strs(4)+ydf(m)*fy
+              strs(5)=strs(5)+ydf(m)*fz
+              strs(6)=strs(6)+zdf(m)*fz
+              
+            endif
+
+c     metadynamics local parameters
+        
+            if(lmetadyn.and.(idrive.or.jdrive))then
+              
+c     local energy and virial
+          
+              eng_loc=eng_loc+omega
+              vir_loc=vir_loc-gamma*rsq
+              
+c     local forces
+          
+              fxx_loc(iatm)=fxx_loc(iatm)+fx
+              fyy_loc(iatm)=fyy_loc(iatm)+fy
+              fzz_loc(iatm)=fzz_loc(iatm)+fz
+              
+              fxx_loc(jatm)=fxx_loc(jatm)-fx
+              fyy_loc(jatm)=fyy_loc(jatm)-fy
+              fzz_loc(jatm)=fzz_loc(jatm)-fz
+              
+c     local stress tensor
+          
+              strs_loc(1)=strs_loc(1)+xdf(m)*fx
+              strs_loc(2)=strs_loc(2)+xdf(m)*fy
+              strs_loc(3)=strs_loc(3)+xdf(m)*fz
+              strs_loc(4)=strs_loc(4)+ydf(m)*fy
+              strs_loc(5)=strs_loc(5)+ydf(m)*fz
+              strs_loc(6)=strs_loc(6)+zdf(m)*fz
+              
+            endif
+            
+          endif
+          
+        endif
+        
+      enddo
+      
+c     complete stress tensor
+      
+      stress(1)=stress(1)+strs(1)
+      stress(2)=stress(2)+strs(2)
+      stress(3)=stress(3)+strs(3)
+      stress(4)=stress(4)+strs(2)
+      stress(5)=stress(5)+strs(4)
+      stress(6)=stress(6)+strs(5)
+      stress(7)=stress(7)+strs(3)
+      stress(8)=stress(8)+strs(5)
+      stress(9)=stress(9)+strs(6)
+
+      if(lmetadyn)then
+        
+        stress_loc(1)=stress_loc(1)+strs_loc(1)
+        stress_loc(2)=stress_loc(2)+strs_loc(2)
+        stress_loc(3)=stress_loc(3)+strs_loc(3)
+        stress_loc(4)=stress_loc(4)+strs_loc(2)
+        stress_loc(5)=stress_loc(5)+strs_loc(4)
+        stress_loc(6)=stress_loc(6)+strs_loc(5)
+        stress_loc(7)=stress_loc(7)+strs_loc(3)
+        stress_loc(8)=stress_loc(8)+strs_loc(5)
+        stress_loc(9)=stress_loc(9)+strs_loc(6)
+        
+      endif
+      
+      return
+      end subroutine srfrceneu
+
+      end module vdw_module
diff -urN dl_class_1.9.orig/srcmod/vv_motion_module.f dl_class_1.9/srcmod/vv_motion_module.f
--- dl_class_1.9.orig/srcmod/vv_motion_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/vv_motion_module.f	2011-02-22 12:46:30.000000000 +0100
@@ -0,0 +1,3031 @@
+      module vv_motion_module
+
+c***********************************************************************
+c     
+c     dl_poly module for velocity verlet integration schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use error_module
+      use metafreeze_module,only : lmetadyn
+      use property_module
+      use setup_module
+      use shake_module
+      use site_module
+      use utility_module
+      
+      contains
+      
+      subroutine rdrattle_r
+     x  (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x  tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x  txx,tyy,tzz,xxt,yyt,zzt,stresh)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for applying bond constraint corrections after
+c     atomic integration. rattle algorithm
+c     must be used in conjunction with integration algorithms
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith october 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical check,safe,lshmov
+      integer idnode,imcon,mxnode,natms,nscons,icyc,i,j,k
+      real(8) tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,esig
+      real(8) txx,tyy,tzz,xxt,yyt,zzt,stresh,dx,dy,dz,dis,omega2
+      real(8) strs1,strs2,strs3,strs5,strs6,strs9,amti,amtj,gamma
+      real(8) gammi,gammj,dli,dlj
+      
+      dimension stresh(9)
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension dxx(mxcons),dyy(mxcons),dzz(mxcons)
+      dimension dxt(mxcons),dyt(mxcons),dzt(mxcons)
+      
+c     constraint virial
+
+      vircon=0.d0
+
+c     accumulators for stress tensor
+
+      strs1=0.d0
+      strs2=0.d0
+      strs3=0.d0
+      strs5=0.d0
+      strs6=0.d0
+      strs9=0.d0
+
+c     test size of work arrays
+
+      check=.true.
+      if(mxxdf.lt.nscons)check=.false.
+      if(mxnode.gt.1)call gstate(check)
+      if(.not.check)call error(idnode,412)
+
+c     application of constraint (shake) algorithm
+      
+      icyc=0
+      safe=.false.
+
+      do while(.not.safe.and.icyc.lt.mxshak)
+
+        icyc=icyc+1
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+
+c     calculate temporary bond vector
+          
+          dxt(k)=xxx(i)-xxx(j)
+          dyt(k)=yyy(i)-yyy(j)
+          dzt(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+c     periodic boundary condition
+        
+        call images(imcon,0,1,nscons,cell,dxt,dyt,dzt)
+
+c     calculate maximum error in bondlength
+        
+        esig=0.d0
+        
+        do k=1,nscons
+
+c     set bond parameter
+          
+          dx=dxt(k)
+          dy=dyt(k)
+          dz=dzt(k)
+          dis=prmcon(listcon(k,1))
+          esig=max(esig,abs(dx*dx+dy*dy+dz*dz-dis*dis)/dis)
+          
+        enddo
+        
+        esig=esig*0.5d0
+
+c     global verification of convergence
+        
+        safe=(esig.lt.tolnce)
+        
+        if(mxnode.gt.1)call gstate(safe)
+
+c     bypass calculations if all tolerances satisfied 
+        
+        if(.not.safe)then
+          
+c     initialise increment arrays
+          
+          do i=1,natms
+            
+            xxt(i)=0.d0
+            yyt(i)=0.d0
+            zzt(i)=0.d0
+            
+          enddo
+          
+c     calculate constraint forces
+          
+          do k=1,nscons
+            
+            i=listcon(k,2)
+            j=listcon(k,3)
+            
+c     set constraint parameters
+            
+            dis=prmcon(listcon(k,1))
+            omega2= dis*dis
+            amti= tstep*rmass(i)
+            amtj=-tstep*rmass(j)
+            
+c     constraint force parameter
+            
+            dx=dxt(k)
+            dy=dyt(k)
+            dz=dzt(k)
+            
+            gamma=(omega2-(dx*dx+dy*dy+dz*dz))/
+     x        (-tstep*(amti-amtj)*(dxx(k)*dx+dyy(k)*dy+dzz(k)*dz))
+            
+c     accumulate bond virial
+            
+            vircon=vircon+gamma*(dxx(k)**2+dyy(k)**2+dzz(k)**2)
+            
+            strs1=strs1-gamma*dxx(k)*dxx(k)
+            strs2=strs2-gamma*dxx(k)*dyy(k)
+            strs3=strs3-gamma*dxx(k)*dzz(k)
+            strs5=strs5-gamma*dyy(k)*dyy(k)
+            strs6=strs6-gamma*dyy(k)*dzz(k)
+            strs9=strs9-gamma*dzz(k)*dzz(k)
+            
+c     improve approximate constraint force
+            
+            gammi=-0.5d0*gamma*amti
+            xxt(i)=xxt(i)+dxx(k)*gammi
+            yyt(i)=yyt(i)+dyy(k)*gammi
+            zzt(i)=zzt(i)+dzz(k)*gammi
+            
+            gammj=-0.5d0*gamma*amtj
+            xxt(j)=xxt(j)+dxx(k)*gammj
+            yyt(j)=yyt(j)+dyy(k)*gammj
+            zzt(j)=zzt(j)+dzz(k)*gammj
+            
+          enddo
+          
+c     sum up constraint forces across nodes
+          
+          if(mxnode.gt.1)then
+            
+            if(lshmov)call shmove
+     x        (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x        txx,tyy,tzz,buffer)
+            
+          endif
+          
+          do k=1,nscons
+            
+            i=listcon(k,2)
+            j=listcon(k,3)
+            
+            dli=1.0d0/dble(listme(i))
+            dlj=1.0d0/dble(listme(j))
+            
+            xxx(i)=xxx(i)+tstep*dli*xxt(i)
+            yyy(i)=yyy(i)+tstep*dli*yyt(i)
+            zzz(i)=zzz(i)+tstep*dli*zzt(i)
+            xxx(j)=xxx(j)+tstep*dlj*xxt(j)
+            yyy(j)=yyy(j)+tstep*dlj*yyt(j)
+            zzz(j)=zzz(j)+tstep*dlj*zzt(j)
+            
+            vxx(i)=vxx(i)+dli*xxt(i)
+            vzz(i)=vzz(i)+dli*zzt(i)
+            vyy(i)=vyy(i)+dli*yyt(i)
+            vxx(j)=vxx(j)+dlj*xxt(j)
+            vyy(j)=vyy(j)+dlj*yyt(j)
+            vzz(j)=vzz(j)+dlj*zzt(j)
+            
+          enddo
+          
+        endif
+        
+      enddo
+
+c     error exit for non-convergence
+
+      if(.not.safe)return
+      
+c     complete stress tensor
+      
+      stresh(1)=strs1
+      stresh(2)=strs2
+      stresh(3)=strs3
+      stresh(4)=strs2
+      stresh(5)=strs5
+      stresh(6)=strs6
+      stresh(7)=strs3
+      stresh(8)=strs6
+      stresh(9)=strs9
+      
+c     splice coordinate arrays across nodes
+
+      if(mxnode.gt.1)then
+
+        buffer(1)=vircon
+        call gdsum(buffer(1),1,buffer(2))
+        vircon=buffer(1)
+        call gdsum(stresh,9,buffer)
+        call splice 
+     x    (idnode,natms,listme,listot,xxx,yyy,zzz,buffer)
+        call splice 
+     x    (idnode,natms,listme,listot,vxx,vyy,vzz,buffer)
+
+      endif
+      
+      return
+      end subroutine rdrattle_r
+
+      subroutine rdrattle_v
+     x  (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x  dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+
+c*********************************************************************
+c     
+c     dl_poly subroutine for applying a bond constraints to 
+c     the velocities of the constrained atoms using the rattle
+c     procedure (replicated data version)
+c     
+c     copyright - daresbury laboratory
+c     author w.smith october 2002
+c     
+c*********************************************************************
+
+      implicit none
+
+      logical safe
+      integer idnode,mxnode,natms,nscons,icyc
+      integer i,j,k
+      real(8) tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt
+      real(8) esig,amti,amtj,gamma,gammi,gammj,dli,dlj,tolvel
+
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension dxx(mxcons),dyy(mxcons),dzz(mxcons)
+      
+c     constraint convergence tolerance
+
+      tolvel=tolnce/tstep
+
+c     start of rattle cycle
+      
+      icyc=0
+      safe=.false.
+
+      do while(.not.safe.and.icyc.lt.mxshak)
+
+        icyc=icyc+1
+
+c     initialise velocity correction arrays
+        
+        do i=1,natms
+          
+          xxt(i)=0.d0
+          yyt(i)=0.d0
+          zzt(i)=0.d0
+
+        enddo
+
+c     calculate velocity constraint corrections
+        
+        esig=0.d0
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          amti= 0.5d0*tstep*rmass(i)
+          amtj=-0.5d0*tstep*rmass(j)
+
+c     calculate constraint force parameter
+
+          gamma=(dxx(k)*(vxx(i)-vxx(j))+dyy(k)*(vyy(i)-vyy(j))+
+     x      dzz(k)*(vzz(i)-vzz(j)))/((amti-amtj)*
+     x      (dxx(k)**2+dyy(k)**2+dzz(k)**2))
+          esig=max(esig,abs(gamma))
+
+c     improve approximate constraint force
+
+          gammi=-gamma*amti
+          xxt(i)=xxt(i)+gammi*dxx(k)
+          yyt(i)=yyt(i)+gammi*dyy(k)
+          zzt(i)=zzt(i)+gammi*dzz(k)
+          gammj=-gamma*amtj
+          xxt(j)=xxt(j)+gammj*dxx(k)
+          yyt(j)=yyt(j)+gammj*dyy(k)
+          zzt(j)=zzt(j)+gammj*dzz(k)
+          
+        enddo
+
+c     global verification of convergence
+        
+        safe=(esig.lt.tolvel)
+        if(mxnode.gt.1)then
+          
+          call gstate(safe)
+          
+        endif
+
+c     terminate iteration if constraints satisfied
+        
+        if(.not.safe)then
+          
+c     transport velocity adjustments to other nodes
+          
+          if(mxnode.gt.1)then
+            
+            call shmove
+     x        (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x        txx,tyy,tzz,buffer)
+            
+          endif
+          
+c     update velocities
+          
+          do k=1,nscons
+            
+            i=listcon(k,2)
+            j=listcon(k,3)
+            
+            dli=1.d0/dble(listme(i))
+            vxx(i)=vxx(i)+dli*xxt(i)
+            vyy(i)=vyy(i)+dli*yyt(i)
+            vzz(i)=vzz(i)+dli*zzt(i)
+            dlj=1.d0/dble(listme(j))
+            vxx(j)=vxx(j)+dlj*xxt(j)
+            vyy(j)=vyy(j)+dlj*yyt(j)
+            vzz(j)=vzz(j)+dlj*zzt(j)
+            
+          enddo
+        
+        endif
+        
+      enddo
+
+c     error exit if rattle fails
+
+      if(.not.safe)return
+      
+c     splice velocity arrays across nodes
+      
+      if(mxnode.gt.1)then
+
+        call splice
+     x    (idnode,natms,listme,listot,vxx,vyy,vzz,buffer)
+
+      endif
+      
+      return
+      end subroutine rdrattle_v
+
+      subroutine nvevv_1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,ntcons,
+     x  tstep,engke,tolnce,vircon)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     nve ensemble
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith october 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     
+c***********************************************************************
+
+      implicit none
+      
+      integer, parameter :: nnn=4
+
+      logical safe,lshmov
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons,i,j,k
+      integer iatm0,iatm1
+      real(8) tstep,engke,tolnce,vircon
+      integer fail(nnn)
+      real(8) strkin(9)
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      
+      safe=.true.
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+        
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(3))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(4))
+        
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,1980)
+        enddo
+
+      endif
+
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     construct current bond vectors
+      
+      do k=1,nscons
+
+c     indices of atoms in bond
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+c     calculate current bond vector
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+
+c     periodic boundary condition for bond vectors
+      
+      if(ntcons.gt.0)
+     x  call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+c     update velocities for first and second stages
+      
+      do i=iatm0,iatm1
+        
+        vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+
+      enddo
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     update positions
+        
+        do i=iatm0,iatm1
+          
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge position data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     second stage of velocity verlet algorithm
+
+      else
+
+c     merge velocity data
+
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+
+        endif
+
+c     calculate kinetic energy
+        
+        engke=getkin(natms,idnode,mxnode)
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strcns(i)+strkin(i)
+        enddo
+
+      endif
+      
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+        deallocate(dxx,dyy,dzz,dxt,dyt,dzt,stat=fail(2))
+
+      endif
+      
+      return
+      end subroutine nvevv_1
+
+      subroutine nvtvv_b1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,ntcons,
+     x  tstep,taut,sigma,engke,tolnce,vircon)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     nvt ensemble - Berendsen thermostat (n.b. not symplectic)
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith october 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     
+c***********************************************************************
+
+      implicit none
+      
+      integer, parameter :: nnn=4
+
+      logical safe,lshmov
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons
+      integer i,j,k,iatm0,iatm1
+      real(8) tstep,taut,sigma,engke,tolnce,vircon,chit
+      integer fail(nnn)
+      real(8) strkin(9)
+      
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      
+      safe=.true.
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(3))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(4))
+        
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,1990)
+        enddo
+
+      endif
+
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     construct current bond vectors
+      
+      do k=1,nscons
+
+c     indices of atoms in bond
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+c     calculate current bond vector
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+
+c     periodic boundary condition for bond vectors
+      
+      if(ntcons.gt.0)
+     x  call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+c     update velocities
+      
+      do i=iatm0,iatm1
+        
+        vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+        
+      enddo
+
+c     first pass of velocity verlet algorithm
+      
+      if(isw.eq.1)then
+
+c     update positions
+        
+        do i=iatm0,iatm1
+          
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge position data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+        
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     second pass of velocity verlet algorithm
+        
+      else
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+        
+        if(ntcons.gt.0)then
+          
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+c     calculate kinetic energy
+        
+        engke=getkin(natms,idnode,mxnode)
+
+c     apply Berendsen thermostat - taut is the relaxation time
+        
+        chit=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=chit*vxx(i)
+          vyy(i)=chit*vyy(i)
+          vzz(i)=chit*vzz(i)
+          
+        enddo
+        
+        engke=engke*chit**2
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,
+     x    buffer)
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)+strcns(i)
+        enddo
+
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+        deallocate(dxx,dyy,dzz,dxt,dyt,dzt,stat=fail(2))
+
+      endif
+      
+      return
+      end subroutine nvtvv_b1
+
+      subroutine nvtvv_e1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,ntcons,
+     x  tstep,engke,tolnce,vircon)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     nvt ensemble - evans thermostat
+c     Comp. Phys. reports 1, 299, (1984)
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith october 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=4
+
+      logical safe,lshmov
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons
+      integer i,j,k,iatm0,iatm1
+      real(8) tstep,engke,tolnce,vircon,vdotf,scale,chit
+      integer fail(nnn)
+      real(8) strkin(9)
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      
+      safe=.true.
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(3))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(4))
+        
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,2000)
+        enddo
+
+      endif
+
+      if(ntcons.eq.0)safe=.true.
+
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+c     construct current bond vectors
+      
+      do k=1,nscons
+
+c     indices of atoms in bond
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+c     calculate current bond vector
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+
+c     periodic boundary condition for bond vectors
+      
+      if(ntcons.gt.0)
+     x  call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+c     first stage of velocity verlet algorithm
+      
+      if(isw.eq.1)then
+
+c     calculate kinetic energy and evans thermostat parameter
+        
+        engke=0.d0
+        vdotf=0.d0
+        do i=iatm0,iatm1
+          
+          engke=engke+weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+          vdotf=vdotf+vxx(i)*fxx(i)+vyy(i)*fyy(i)+vzz(i)*fzz(i)
+          
+        enddo
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=engke
+          buffer(2)=vdotf
+          call gdsum(buffer(1),2,buffer(3))
+          engke=buffer(1)
+          vdotf=buffer(2)
+          
+        endif
+        engke=0.5d0*engke
+        chit=0.5d0*vdotf/engke
+
+c     thermostat the velocities
+        
+        scale=(1.d0-0.5d0*tstep*chit)
+        do i=iatm0,iatm1
+          
+          vxx(i)=scale*vxx(i)
+          vyy(i)=scale*vyy(i)
+          vzz(i)=scale*vzz(i)
+          
+        enddo
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+          
+        enddo
+
+c     update positions
+        
+        do i=iatm0,iatm1
+          
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge position data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+        
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     second stage of velocity verlet algorithm
+        
+      else
+
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+          
+        enddo
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+        
+        if(ntcons.gt.0)then
+          
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+c     calculate kinetic energy and evans thermostat parameter
+        
+        engke=0.d0
+        vdotf=0.d0
+        do i=iatm0,iatm1
+          
+          engke=engke+weight(i)*(vxx(i)**2+vyy(i)**2+vzz(i)**2)
+          vdotf=vdotf+vxx(i)*fxx(i)+vyy(i)*fyy(i)+vzz(i)*fzz(i)
+          
+        enddo
+        
+        if(mxnode.gt.1)then
+          
+          buffer(1)=engke
+          buffer(2)=vdotf
+          call gdsum(buffer(1),2,buffer(3))
+          engke=buffer(1)
+          vdotf=buffer(2)
+          
+        endif
+        engke=0.5d0*engke
+        chit=0.5d0*vdotf/engke
+        scale=(1.d0-0.5d0*tstep*chit)
+
+c     scale velocities
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=scale*vxx(i)
+          vyy(i)=scale*vyy(i)
+          vzz(i)=scale*vzz(i)
+          
+        enddo
+        
+        engke=engke*scale**2
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)+strcns(i)
+        enddo
+
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+        deallocate(dxx,dyy,dzz,dxt,dyt,dzt,stat=fail(2))
+
+      endif
+      
+      return
+      end subroutine nvtvv_e1
+
+      subroutine nvtvv_h1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,ntcons,
+     x  ntshl,keyshl,tstep,taut,sigma,chit,consv,conint,engke,
+     x  tolnce,vircon,chit_shl,sigma_shl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     nvt ensemble - nose-hoover thermostat
+c     Molecular Physics 87 (1996) 1117
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith october 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=4
+      
+      logical safe,lshmov
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons
+      integer i,j,k,iatm0,iatm1
+      real(8) tstep,taut,sigma,chit,consv,conint,engke,tolnce,vircon
+      real(8) hstep,qmass
+      integer fail(nnn)
+      real(8) strkin(9)
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+      
+      safe=.true.
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(1))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(2))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(3))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(4))
+        
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,2010)
+        enddo
+
+      endif
+
+c     inertia parameter for Nose-Hoover thermostat
+      
+      hstep=0.5d0*tstep
+      qmass=2.d0*sigma*taut**2
+
+c     block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+
+c     construct current bond vectors
+      
+      do k=1,nscons
+
+c     indices of atoms in bond
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+c     calculate current bond vector
+        
+        dxx(k)=xxx(i)-xxx(j)
+        dyy(k)=yyy(i)-yyy(j)
+        dzz(k)=zzz(i)-zzz(j)
+        
+      enddo
+
+c     periodic boundary condition for bond vectors
+      
+      if(ntcons.gt.0)
+     x  call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+c     first stage of velocity verlet algorithm
+      
+      if(isw.eq.1)then
+
+c     integrate and apply nvt thermostat
+
+        call nvtscale
+     x    (idnode,mxnode,natms,engke,sigma,hstep,qmass,taut,
+     x    chit,conint)
+
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+        if(lmetadyn.and.keyshl.eq.1)then
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          call nvtscale_shl
+     x      (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x      taut,chit_shl,conint)      
+        endif
+        
+c     update velocities
+        
+        do i=iatm0,iatm1
+ 
+          vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+
+        enddo
+
+c     update positions
+        
+        do i=iatm0,iatm1
+          
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge position data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+        
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     second stage of velocity verlet algorithm
+        
+      else
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+ 
+          vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+          
+        enddo
+        
+        if(ntcons.gt.0)then
+
+c     merge velocity data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+          
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+c     integrate and apply nvt thermostat
+        
+        call nvtscale
+     x    (idnode,mxnode,natms,engke,sigma,hstep,qmass,taut,
+     x    chit,conint)
+        
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     metdynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+        if(lmetadyn.and.keyshl.eq.1)then
+          call nvtscale_shl
+     x      (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x      taut,chit_shl,conint)      
+        endif
+        
+c     conserved quantity less kinetic and potential energy terms
+        
+        consv=conint+0.5d0*qmass*chit**2
+
+c     metadynamics shell thermostat
+
+        if(lmetadyn.and.keyshl.eq.1)then
+           consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)+strcns(i)
+        enddo
+
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxt,yyt,zzt,txx,tyy,tzz,stat=fail(1))
+        deallocate(dxx,dyy,dzz,dxt,dyt,dzt,stat=fail(2))
+
+      endif
+      
+      return
+      end subroutine nvtvv_h1
+
+      subroutine nptvv_b1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x  ntcons,ntpatm,tstep,taut,taup,sigma,engke,press,elrc,
+     x  virlrc,tolnce,virtot,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     npt ensemble - Berendsen thermostat and barostat 
+c     (n.b. not symplectic)
+c     
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith december 2002
+c     amended   - w. smith  january 2005 : f90 conversion
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer, parameter :: nnn=7
+
+      logical newjob,safe,lshmov
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons,ntpatm
+      integer i,j,k,iatm0,iatm1,mxiter,iter,kk
+      real(8) tstep,taut,taup,sigma,engke,press,elrc,virlrc,tolnce
+      real(8) virtot,vircon,volm,volm0,elrc0,virlrc0,psyst
+      real(8) chit,chip,scale,beta
+
+      integer fail(nnn)
+      real(8) strkin(9),uni(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      
+      save newjob,volm0,elrc0,virlrc0,iatm0,iatm1,dens0
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./,beta/7.3728d-3/
+      
+      safe=.true.
+      
+      if(newjob)then
+
+c     block indices
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2020)
+
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+        newjob=.false.
+        
+      endif
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(3))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(4))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(5))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(6))
+        allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(7))
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,2030)
+        enddo
+
+      endif
+
+c     construct current bond vectors
+
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     first stage of velocity verlet algorithm
+      
+      if(isw.eq.1)then          
+
+c     calculate kinetic energy
+        
+        engke=getkin(natms,idnode,mxnode)
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+ 
+          vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+          
+        enddo
+          
+c     store current integration variables
+        
+        if(ntcons.gt.0)then
+
+          do i=iatm0,iatm1
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+            
+          enddo
+        
+        endif
+
+c     iteration required if ntcons > 0 and isw = 1
+
+        mxiter=1
+        if(isw.eq.1.and.ntcons.gt.0)mxiter=2
+        do iter=1,mxiter
+          
+          scale=1.d0
+          
+          if(iter.eq.mxiter)then
+
+c     calculate system pressure
+            
+            psyst=(2.d0*engke-virtot-vircon)/(3.d0*volm)
+
+c     apply Berendsen barostat taup is relaxation time
+            
+            chip=1.d0+beta*tstep*(psyst-press)/taup
+            scale=chip**(1.d0/3.d0)
+            volm=chip*volm
+            
+c     reset cell parameters for new volume
+          
+            do i=1,9
+              cell(i)=scale*cell(i)
+            enddo
+          
+          endif
+
+c     update positions
+          
+          do i=iatm0,iatm1
+            
+            xxx(i)=scale*xxx(i)+tstep*vxx(i)
+            yyy(i)=scale*yyy(i)+tstep*vyy(i)
+            zzz(i)=scale*zzz(i)+tstep*vzz(i)
+            
+          enddo
+          
+c     merge position data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)
+     x        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+            
+          endif
+          
+          if(iter.lt.mxiter)then
+            
+            do i=iatm0,iatm1
+
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+
+            enddo
+
+          endif
+
+        enddo
+
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        
+        do kk=1,ntpatm
+          dens(kk)=dens0(kk)*(volm0/volm)
+        enddo
+
+c     construct scaling tensor for tethered bonds
+
+        do i=1,9
+          eta(i)=scale*uni(i)
+        enddo
+
+c     second pass of velocity verlet algorithm
+        
+      else
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+ 
+          vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+          
+        enddo
+
+c     apply Berendsen thermostat taut is relaxation time
+        
+        engke=getkin(natms,idnode,mxnode)
+        chit=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=chit*vxx(i)
+          vyy(i)=chit*vyy(i)
+          vzz(i)=chit*vzz(i)
+          
+        enddo
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          
+c     correct constraint bond velocities using rattle
+        
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        engke=0.5d0*(strkin(1)+strkin(5)+strkin(9))
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)+strcns(i)
+        enddo
+
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxo,yyo,zzo,vxo,vyo,vzo,stat=fail(1))
+        deallocate(txx,tyy,tzz,dxx,dyy,dzz,stat=fail(2))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nptvv_b1
+
+      subroutine nptvv_h1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,ntcons,
+     x  ntpatm,ntshl,keyshl,tstep,taut,taup,sigma,temp,chip,chit,
+     x  consv,conint,engke,elrc,tolnce,vircon,virtot,virlrc,volm,
+     x  press,chit_shl,sigma_shl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     npt ensemble - Melchionna, Ciccotti and Holian
+c     Molecular Physics 78 (1993) 533
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith november 2002
+c     amended   - w. smith january 2005: f90 conversion
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=7
+      integer, parameter :: ncyc=5
+      
+      logical safe,lshmov,newjob
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons,ntpatm
+      integer i,j,k,iatm0,iatm1,mxiter,iter,kk,icyc
+      real(8) tstep,taup,taut,sigma,temp,chip,chit,consv,conint
+      real(8) engke,elrc,tolnce,vircon,virtot,virlrc,volm,press
+      real(8) volm0,elrc0,virlrc0,hstep,qstep,totmas,qmass,pmass
+      real(8) vzero,chit0,chip0,cons0,scale,fstep
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      integer fail(nnn)
+      real(8) cell0(9),com(3),vom(3),strkin(9),uni(9)
+
+      save newjob,totmas,volm0,elrc0,virlrc0,dens0
+      save cell0,iatm0,iatm1,hstep,qstep,fstep,pmass,qmass
+
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl 
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      
+      safe=.true.
+      
+      if(newjob)then
+
+c     block indices
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2040)
+
+c     store intitial parameters
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        hstep=0.5d0*tstep
+        fstep=0.5d0*tstep/dble(ncyc)
+        qstep=0.25d0*tstep/dble(ncyc)
+        
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+
+c     total system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+
+c     inertia parameter for Nose-Hoover thermostat and barostat
+        
+        qmass=2.d0*sigma*taut**2
+        pmass=2.d0*sigma*taup**2
+        
+        newjob=.false.
+        
+      endif
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(6))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,2050)
+        enddo
+        
+      endif
+      
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metdynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+        
+      endif
+      
+c     first stage of velocity verlet algorithm
+      
+      if(isw.eq.1)then
+        
+c     store current integration variables if ntcons > 0
+        
+        if(ntcons.gt.0)then
+          
+          vzero=volm
+          chit0=chit
+          chip0=chip
+          cons0=conint
+          do i=iatm0,iatm1
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+            
+          enddo
+          
+        endif
+        
+c     iteration necessary if ntcons > 0 and isw = 1
+        
+        mxiter=1
+        if(isw.eq.1.and.ntcons.gt.0)mxiter=2
+        do iter=1,mxiter
+          
+c     volume integration parameter
+          
+          do icyc=1,ncyc
+            
+c     integrate and apply npt thermostat
+            
+            call nptscale_t
+     x        (idnode,mxnode,natms,engke,temp,sigma,qstep,pmass,qmass,
+     x        taut,chip,chit,conint)
+            
+c     metdynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif           
+            
+c     integrate and apply npt barostat
+            
+            call nptscale_p
+     x        (idnode,mxnode,natms,engke,fstep,pmass,chip,chit,
+     x        volm,press,vircon,virtot)
+            
+c     integrate and apply npt thermostat
+            
+            call nptscale_t
+     x        (idnode,mxnode,natms,engke,temp,sigma,qstep,pmass,qmass,
+     x        taut,chip,chit,conint)
+            
+c     metdynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif   
+            
+          enddo
+          
+c     scale cell vectors - isotropic
+          
+          scale=(volm/volm0)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+          
+c     update velocities
+          
+          do i=iatm0,iatm1
+            
+            vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+            vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+            vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+            
+          enddo
+
+c     calculate system centre of mass
+          
+          call getcom(natms,idnode,mxnode,totmas,com)
+
+c     update positions
+          
+          scale=exp(tstep*chip)
+          do i=iatm0,iatm1
+            
+            xxx(i)=scale*(xxx(i)-com(1))+tstep*vxx(i)+com(1)
+            yyy(i)=scale*(yyy(i)-com(2))+tstep*vyy(i)+com(2)
+            zzz(i)=scale*(zzz(i)-com(3))+tstep*vzz(i)+com(3)
+            
+          enddo
+
+c     merge position data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)
+     x        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+
+          endif
+
+c     restore original integration parameters if iter < mxiter
+          
+          if(iter.lt.mxiter)then
+            
+            volm=vzero
+            chit=chit0
+            chip=chip0
+            conint=cons0
+
+            do i=iatm0,iatm1
+              
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+              
+            enddo
+            
+          endif
+          
+        enddo
+
+c     second stage of velocity verlet algorithm
+        
+      else
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+          
+        enddo
+        
+        if(ntcons.gt.0)then
+
+c     merge velocity data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+          
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+        do icyc=1,ncyc
+          
+c     integrate and apply npt thermostat
+          
+          call nptscale_t
+     x      (idnode,mxnode,natms,engke,temp,sigma,qstep,pmass,qmass,
+     x      taut,chip,chit,conint)
+          
+c     metdynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+          if(lmetadyn.and.keyshl.eq.1)then
+            if(mxnode.gt.1)call merge
+     x        (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            call nvtscale_shl
+     x        (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x        taut,chit_shl,conint)      
+          endif  
+          
+c     integrate and apply npt barostat
+          
+          call nptscale_p
+     x      (idnode,mxnode,natms,engke,fstep,pmass,chip,chit,
+     x      volm,press,vircon,virtot)
+          
+c     integrate and apply npt thermostat
+          
+          call nptscale_t
+     x      (idnode,mxnode,natms,engke,temp,sigma,qstep,pmass,qmass,
+     x      taut,chip,chit,conint)
+
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+          if(lmetadyn.and.keyshl.eq.1)then
+            if(mxnode.gt.1)call merge
+     x        (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            call nvtscale_shl
+     x        (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x        taut,chit_shl,conint)      
+          endif  
+          
+        enddo
+
+c     remove system centre of mass velocity
+        
+        call getvom(natms,idnode,mxnode,totmas,vom)
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=vxx(i)-vom(1)
+          vyy(i)=vyy(i)-vom(2)
+          vzz(i)=vzz(i)-vom(3)
+          
+        enddo
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     scale cell vectors - isotropic
+        
+        scale=(volm/volm0)**(1.d0/3.d0)
+        do i=1,9
+          cell(i)=cell0(i)*scale
+        enddo
+
+c     conserved quantity less kinetic and potential energy terms
+        
+        consv=conint+0.5d0*qmass*chit**2+
+     x    0.5d0*pmass*chip**2+press*volm
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        engke=0.5d0*(strkin(1)+strkin(5)+strkin(9))
+
+c     metadynamics shell thermostat
+
+        if(lmetadyn.and.keyshl.eq.1)then
+          consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)+strcns(i)
+        enddo
+
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      do kk=1,ntpatm
+        dens(kk)=dens0(kk)*(volm0/volm)
+      enddo
+
+c     construct scaling tensor (for tethered atoms)
+      
+      do i=1,9
+        eta(i)=chip*uni(i)
+      enddo
+
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxo,yyo,zzo,vxo,vyo,vzo,stat=fail(1))
+        deallocate(txx,tyy,tzz,dxx,dyy,dzz,stat=fail(2))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nptvv_h1
+
+      subroutine nstvv_b1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,
+     x  ntcons,ntpatm,mode,tstep,taut,taup,sigma,engke,press,elrc,
+     x  virlrc,tolnce,vircon,volm)
+      
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     anisotropic npt ensemble - Berendsen thermostat and barostat 
+c     (n.b. not symplectic)
+c     
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith december 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     
+c***********************************************************************
+      
+      implicit none
+
+      integer, parameter :: nnn=7
+
+      logical newjob,safe,lshmov
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons,ntpatm
+      integer i,j,k,iatm0,iatm1,mxiter,iter,kk,mode
+      real(8) tstep,taut,taup,sigma,engke,press,elrc,virlrc,tolnce,beta
+      real(8) vircon,volm,volm0,elrc0,virlrc0,chit
+      real(8) xtmp,ytmp,ztmp
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      integer fail(nnn)
+      real(8) uni(9),strkin(9),celp(10)
+
+      save newjob,volm0,elrc0,virlrc0,iatm0,iatm1,dens0
+      
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./,beta/7.3728d-3/
+      
+      safe=.true.
+      
+      if(newjob)then
+
+c     block indices
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2060)
+
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+        newjob=.false.
+        
+      endif
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(3))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(4))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(5))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(6))
+        allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(7))
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,2070)
+        enddo
+        
+      endif
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     first stage of velocity verlet algorithm
+      
+      if(isw.eq.1)then          
+
+c     extract previous constraint terms from stress tensor
+
+        do i=1,9
+          stress(i)=stress(i)-strcns(i)
+        enddo
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+          
+        enddo
+
+c     store current integration variables
+        
+        if(ntcons.gt.0)then
+          
+          do i=iatm0,iatm1
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+            
+          enddo
+          
+        endif
+        
+c     iteration required if ntcons > 0 and isw = 1
+
+        mxiter=1
+        if(isw.eq.1.and.ntcons.gt.0)mxiter=2
+        do iter=1,mxiter
+
+c     zero scaling matrix
+
+          do i=1,9
+            eta(i)=uni(i)
+          enddo
+
+          if(iter.eq.mxiter)then
+
+c     calculate Berendsen barostat - taup is relaxation time
+            
+            do i=1,9
+              eta(i)=tstep*beta*(stress(i)+strcns(i)-
+     x          press*volm*uni(i))/(taup*volm)+uni(i)
+            enddo
+            if(mode.gt.0)then
+              eta(3)=0.d0
+              eta(6)=0.d0
+              eta(7)=0.d0
+              eta(8)=0.d0
+              if(mode.lt.3)then
+                eta(2)=0.d0
+                eta(4)=0.d0
+                if(mode.eq.2)then
+                  eta(1)=0.5d0*(eta(1)+eta(5))
+                  eta(5)=eta(1)
+                endif
+              endif
+            endif
+
+c     reset cell parameters for new volume
+          
+            call mat_mul(eta,cell,cell)
+            
+c     calculate new volume
+            
+            call dcell(cell,celp)
+            volm=celp(10)
+            
+          endif
+
+c     update positions
+          
+          do i=iatm0,iatm1
+            
+            xtmp=eta(1)*xxx(i)+eta(4)*yyy(i)+eta(7)*zzz(i)
+            ytmp=eta(2)*xxx(i)+eta(5)*yyy(i)+eta(8)*zzz(i)
+            ztmp=eta(3)*xxx(i)+eta(6)*yyy(i)+eta(9)*zzz(i)
+            xxx(i)=tstep*vxx(i)+xtmp
+            yyy(i)=tstep*vyy(i)+ytmp
+            zzz(i)=tstep*vzz(i)+ztmp
+            
+          enddo
+
+c     merge position data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)
+     x        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+            
+          endif
+          
+          if(iter.lt.mxiter)then
+
+            do i=iatm0,iatm1
+
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+
+            enddo
+            
+          endif
+
+        enddo
+
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        
+        do kk=1,ntpatm
+          dens(kk)=dens0(kk)*(volm0/volm)
+        enddo
+        
+c     second pass of velocity verlet algorithm
+        
+      else
+        
+c     update velocities
+        
+        do i=iatm0,iatm1
+ 
+          vxx(i)=vxx(i)+0.5d0*tstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+0.5d0*tstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+0.5d0*tstep*rmass(i)*fzz(i)
+          
+        enddo
+        
+c     apply Berendsen thermostat taut is relaxation time
+        
+        engke=getkin(natms,idnode,mxnode)
+        chit=sqrt(1.d0+tstep/taut*(sigma/engke-1.d0))
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=chit*vxx(i)
+          vyy(i)=chit*vyy(i)
+          vzz(i)=chit*vzz(i)
+          
+        enddo
+        
+c     merge velocity data
+          
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          
+c     correct constraint bond velocities using rattle
+        
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        engke=0.5d0*(strkin(1)+strkin(5)+strkin(9))
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)+strcns(i)
+        enddo
+        
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxo,yyo,zzo,stat=fail(1))
+        deallocate(txx,tyy,tzz,dxx,dyy,dzz,stat=fail(2))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nstvv_b1
+
+      subroutine nstvv_h1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,nscons,ntcons,
+     x  ntpatm,mode,ntshl,keyshl,tstep,taut,taup,sigma,temp,chit,
+     x  consv,conint,engke,elrc,tolnce,vircon,virlrc,volm,press,
+     x  chit_shl,sigma_shl)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for integrating newtonian equations of
+c     motion in molecular dynamics - velocity verlet incorporating
+c     bond constraints via the shake/rattle algorithm
+c     
+c     anisotropic npt ensemble - Melchionna, Ciccotti and Holian
+c     Molecular Physics 78 (1993) 533
+c     
+c     parallel replicated data version
+c     
+c     copyright - daresbury laboratory 
+c     author    - w. smith november 2002
+c     amended   - w. smith january 2005 : f90 conversion
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=7
+      integer, parameter :: ncyc=5
+      
+      logical safe,lshmov,newjob
+      integer isw,idnode,mxnode,natms,imcon,nscons,ntcons,ntpatm
+      integer i,j,k,iatm0,iatm1,mxiter,iter,kk,icyc,mode
+      real(8) tstep,taup,taut,sigma,temp,chit,consv,conint,chit0
+      real(8) engke,elrc,tolnce,vircon,virlrc,volm,press,volm0
+      real(8) elrc0,virlrc0,hstep,qstep,totmas,qmass,pmass
+      real(8) cons0,cxx,cyy,czz,chip2,fstep
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+
+      integer fail(nnn)
+      real(8) com(3),vom(3),czero(9),strkin(9),eta0(9),celp(10)
+      
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metdynamics shell thermostat variables
+      
+      data newjob/.true./
+
+      save newjob,totmas,volm0,elrc0,virlrc0,dens0
+      save iatm0,iatm1,hstep,qstep,pmass,qmass,fstep
+      
+      safe=.true.
+
+      if(newjob)then
+
+c     block indices
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2080)
+
+c     store intitial parameters
+
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        hstep=0.5d0*tstep
+        fstep=0.5d0*tstep/dble(ncyc)
+        qstep=0.25d0*tstep/dble(ncyc)
+
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+
+c     system total mass
+
+        totmas=getmass(natms,idnode,mxnode)
+
+c     inertia parameter for Nose-Hoover thermostat and barostat
+        
+        qmass=2.d0*sigma*taut**2
+        pmass=2.d0*sigma*taup**2
+
+        newjob=.false.
+        
+      endif
+
+c     allocate working arrays
+
+      if(ntcons.gt.0)then
+
+        do i=1,nnn
+          fail(i)=0
+        enddo
+        
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(6))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+
+        do i=1,nnn
+          if(fail(i).gt.0)call error(idnode,2090)
+        enddo
+
+      endif
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metdynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+
+c     construct current bond vectors
+
+      if(ntcons.gt.0)then
+        
+        do k=1,nscons
+          
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+        
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     store current integration variables
+        
+        if(ntcons.gt.0)then
+          
+          chit0=chit
+          cons0=conint
+          do i=1,9
+
+            czero(i)=cell(i)
+            eta0(i)=eta(i)
+
+          enddo
+          do i=iatm0,iatm1
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+            
+          enddo
+          
+        endif
+
+c     subtract kinetic terms from stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+        do i=1,9
+          stress(i)=stress(i)-strkin(i)
+        enddo
+
+c     iteration necessary if ntcons > 0 and isw = 1
+
+        mxiter=1
+        if(isw.eq.1.and.ntcons.gt.0)mxiter=2
+        do iter=1,mxiter
+
+c     calculate current volume
+
+          call dcell(cell,celp)
+          volm=celp(10)
+
+          do icyc=1,ncyc
+            
+c     integrate and apply nst thermostat
+            
+            call nstscale_t
+     x        (idnode,mxnode,natms,mode,engke,temp,sigma,qstep,
+     x        pmass,qmass,taut,chit,conint)
+            
+c     metdynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply nst barostat
+            
+            call nstscale_p
+     x        (idnode,mxnode,natms,mode,fstep,pmass,chit,press,volm)
+            
+c     integrate and apply nst thermostat
+            
+            call nstscale_t
+     x        (idnode,mxnode,natms,mode,engke,temp,sigma,qstep,
+     x        pmass,qmass,taut,chit,conint)
+
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+
+c     update velocities
+          
+          do i=iatm0,iatm1
+   
+            vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+            vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+            vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+            
+          enddo
+
+c     calculate system centre of mass
+          
+          call getcom(natms,idnode,mxnode,totmas,com)
+
+c     update positions
+          
+          do i=iatm0,iatm1
+            
+            cxx=xxx(i)-com(1)
+            cyy=yyy(i)-com(2)
+            czz=zzz(i)-com(3)
+            
+            xxx(i)=xxx(i)+
+     x        tstep*(vxx(i)+eta(1)*cxx+eta(4)*cyy+eta(7)*czz)
+            yyy(i)=yyy(i)+
+     x        tstep*(vyy(i)+eta(2)*cxx+eta(5)*cyy+eta(8)*czz)
+            zzz(i)=zzz(i)+
+     x        tstep*(vzz(i)+eta(3)*cxx+eta(6)*cyy+eta(9)*czz)
+            
+          enddo
+
+c     merge position data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)
+     x        call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            
+c     subtract old constraint terms from stress tensor
+
+            do i=1,9
+              stress(i)=stress(i)-strcns(i)
+            enddo
+
+c     correct constraint bonds using rattle
+
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+            
+c     add new constraint terms to stress tensor
+
+            do i=1,9
+              stress(i)=stress(i)+strcns(i)
+            enddo
+
+          endif
+
+c     restore original integration parameters if iter < mxiter
+
+          if(iter.lt.mxiter)then
+
+            chit=chit0
+            conint=cons0
+            do i=1,9
+
+              cell(i)=czero(i)
+              eta(i)=eta0(i)
+
+            enddo
+            do i=iatm0,iatm1
+              
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+              
+            enddo
+
+          endif
+
+        enddo
+
+c     second stage of velocity verlet algorithm
+        
+      else
+
+c     update velocities
+        
+        do i=iatm0,iatm1
+ 
+          vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+          
+        enddo
+        
+        if(ntcons.gt.0)then
+
+c     merge velocity data
+          
+          if(mxnode.gt.1)
+     x      call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     add constraint terms to stress tensor
+
+            do i=1,9
+              stress(i)=stress(i)+strcns(i)
+            enddo
+
+c     correct constraint bond velocities using rattle
+          
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+          
+        endif
+
+        do icyc=1,ncyc
+          
+c     integrate and apply nst thermostat
+          
+          call nstscale_t
+     x      (idnode,mxnode,natms,mode,engke,temp,sigma,qstep,
+     x      pmass,qmass,taut,chit,conint)
+          
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+          if(lmetadyn.and.keyshl.eq.1)then
+            if(mxnode.gt.1)call merge
+     x        (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            call nvtscale_shl
+     x        (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x        taut,chit_shl,conint)      
+          endif  
+          
+c     integrate and apply nst barostat
+          
+          call nstscale_p
+     x      (idnode,mxnode,natms,mode,fstep,pmass,chit,press,volm)
+          
+c     integrate and apply nst thermostat
+          
+          call nstscale_t
+     x      (idnode,mxnode,natms,mode,engke,temp,sigma,qstep,
+     x      pmass,qmass,taut,chit,conint)
+          
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+          if(lmetadyn.and.keyshl.eq.1)then
+            if(mxnode.gt.1)call merge
+     x        (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+            call nvtscale_shl
+     x        (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x        taut,chit_shl,conint)      
+          endif  
+          
+        enddo
+        
+c     remove system centre of mass velocity
+        
+        call getvom(natms,idnode,mxnode,totmas,vom)
+        
+        do i=iatm0,iatm1
+          
+          vxx(i)=vxx(i)-vom(1)
+          vyy(i)=vyy(i)-vom(2)
+          vzz(i)=vzz(i)-vom(3)
+          
+        enddo
+
+c     merge velocity data
+        
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     conserved quantity less kinetic and potential energy terms
+        
+        chip2=sdot0(9,eta,eta)
+        if(mode.eq.2)chip2=chip2-eta(1)**2
+        consv=conint+0.5d0*qmass*chit**2+0.5d0*pmass*chip2+press*volm
+
+c     metadynamics shell thermostat
+
+        if(lmetadyn.and.keyshl.eq.1)then
+          consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstress(natms,idnode,mxnode,strkin)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strkin(i)
+        enddo
+
+      endif
+
+c     periodic boundary condition
+      
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        if(mxnode.gt.1)
+     x    call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+        
+      endif
+      
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        do kk=1,ntpatm
+          dens(kk)=dens0(kk)*(volm0/volm)
+        enddo
+
+c     deallocate working arrays
+
+      if(ntcons.gt.0)then
+
+        deallocate(xxo,yyo,zzo,vxo,vyo,vzo,stat=fail(1))
+        deallocate(txx,tyy,tzz,dxx,dyy,dzz,stat=fail(2))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nstvv_h1
+      
+      end module vv_motion_module
+
diff -urN dl_class_1.9.orig/srcmod/vv_rotation1_module.f dl_class_1.9/srcmod/vv_rotation1_module.f
--- dl_class_1.9.orig/srcmod/vv_rotation1_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/vv_rotation1_module.f	2011-02-22 12:46:30.000000000 +0100
@@ -0,0 +1,4701 @@
+      module vv_rotation1_module
+      
+c***********************************************************************
+c     
+c     dl_poly module 1 for velocity verlet rotational integration 
+c     schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use error_module
+      use metafreeze_module, only : lmetadyn
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use vv_motion_module
+      use utility_module
+      
+      contains
+      
+      subroutine rotate_omega
+     x  (idnode,mxnode,ngrp,tstep,p0,p1,p2,p3,dtx,dty,dtz)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for updating the angular velocity and momentum
+c     for rigid bodies
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith  sept 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer idnode,mxnode,ngrp,i,j,jr,jrs,ig,igrp1,igrp2,id
+      real(8) ftx,fty,ftz,fmx,fmy,fmz,tstep,tqx,tqy,tqz,tq0,tq1,tq2,tq3
+
+      real(8) p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp)
+      real(8) dtx(mxatms),dty(mxatms),dtz(mxatms),rot(9)
+
+c     group block indices
+        
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     fmx,fmy,fmz represent force on c.o.m.
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+          
+        enddo
+        
+c     current rotational matrix
+          
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+          
+        jr=jrs
+        ftx=0.d0
+        fty=0.d0
+        ftz=0.d0
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+          
+        enddo
+        tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+        tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+        tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+        tq0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+        tq1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+        tq2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+        tq3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+        
+c     update quaternion momentum by half timestep
+
+        p0(ig)=p0(ig)+tq0*tstep
+        p1(ig)=p1(ig)+tq1*tstep
+        p2(ig)=p2(ig)+tq2*tstep
+        p3(ig)=p3(ig)+tq3*tstep
+
+c     update centre of mass velocity by half timestep
+
+        gvxx(ig)=gvxx(ig)+fmx*tstep/gmass(id)
+        gvyy(ig)=gvyy(ig)+fmy*tstep/gmass(id)
+        gvzz(ig)=gvzz(ig)+fmz*tstep/gmass(id)
+        
+      enddo
+
+      return
+      end subroutine rotate_omega
+
+      subroutine nosquish(ig,tstep,qq0,qq1,qq2,qq3,pp0,pp1,pp2,pp3)
+
+c***********************************************************************
+c     
+c     dlpoly routine to implement the symplectic no_squish quaternion 
+c     algorithm of miller et al j.chem.phys 116 (2002) 8649
+c     
+c     copyright daresbury laboratory
+c     author      m. leslie jan 2004
+c     amended     w.smith   mar 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer m,ig,id
+      real(8) zetax,zetay,zetaz,tstep,cs,sn,trstep
+
+      integer, parameter :: mrot=10
+      real(8), parameter :: ov4=0.25d0
+      real(8), parameter :: ov8=0.125d0
+
+      real(8) qq0(*),qq1(*),qq2(*),qq3(*)
+      real(8) pp0(*),pp1(*),pp2(*),pp3(*)
+
+      real(8) qn1(0:3),pq2(0:3),qn2(0:3),pq3(0:3)
+      real(8) qn3(0:3),pq4(0:3)
+
+c     rotational time step
+
+      trstep=tstep/dble(mrot)
+
+c     rotation: iterate over mrot rotational time steps
+
+      id=lstgtp(ig)
+
+      do m=1,mrot
+        
+        zetaz=ov8*rotinz(id,2)*trstep*
+     x    (-pp0(ig)*qq3(ig)+pp1(ig)*qq2(ig)-
+     x    pp2(ig)*qq1(ig)+pp3(ig)*qq0(ig))
+        cs=cos(zetaz)
+        sn=sin(zetaz)
+        qn1(0)=cs*qq0(ig)-sn*qq3(ig)
+        qn1(1)=cs*qq1(ig)+sn*qq2(ig)
+        qn1(2)=cs*qq2(ig)-sn*qq1(ig)
+        qn1(3)=cs*qq3(ig)+sn*qq0(ig)
+        pq2(0)=cs*pp0(ig)-sn*pp3(ig)
+        pq2(1)=cs*pp1(ig)+sn*pp2(ig)
+        pq2(2)=cs*pp2(ig)-sn*pp1(ig)
+        pq2(3)=cs*pp3(ig)+sn*pp0(ig)
+        
+        zetay=ov8*rotiny(id,2)*trstep*
+     x    (-pq2(0)*qn1(2)-pq2(1)*qn1(3)+
+     x    pq2(2)*qn1(0)+pq2(3)*qn1(1))
+        cs=cos(zetay)
+        sn=sin(zetay)
+        qn2(0)=cs*qn1(0)-sn*qn1(2)
+        qn2(1)=cs*qn1(1)-sn*qn1(3)
+        qn2(2)=cs*qn1(2)+sn*qn1(0)
+        qn2(3)=cs*qn1(3)+sn*qn1(1)
+        pq3(0)=cs*pq2(0)-sn*pq2(2)
+        pq3(1)=cs*pq2(1)-sn*pq2(3)
+        pq3(2)=cs*pq2(2)+sn*pq2(0)
+        pq3(3)=cs*pq2(3)+sn*pq2(1)
+        
+        zetax=ov4*rotinx(id,2)*trstep*
+     x    (-pq3(0)*qn2(1)+pq3(1)*qn2(0)+
+     x    pq3(2)*qn2(3)-pq3(3)*qn2(2))
+        cs=cos(zetax)
+        sn=sin(zetax)
+        qn3(0)=cs*qn2(0)-sn*qn2(1)
+        qn3(1)=cs*qn2(1)+sn*qn2(0)
+        qn3(2)=cs*qn2(2)+sn*qn2(3)
+        qn3(3)=cs*qn2(3)-sn*qn2(2)
+        pq4(0)=cs*pq3(0)-sn*pq3(1)
+        pq4(1)=cs*pq3(1)+sn*pq3(0)
+        pq4(2)=cs*pq3(2)+sn*pq3(3)
+        pq4(3)=cs*pq3(3)-sn*pq3(2)
+        
+        zetay=ov8*rotiny(id,2)*trstep*
+     x    (-pq4(0)*qn3(2)-pq4(1)*qn3(3)+
+     x    pq4(2)*qn3(0)+pq4(3)*qn3(1))
+        cs=cos(zetay)
+        sn=sin(zetay)
+        qn2(0)=cs*qn3(0)-sn*qn3(2)
+        qn2(1)=cs*qn3(1)-sn*qn3(3)
+        qn2(2)=cs*qn3(2)+sn*qn3(0)
+        qn2(3)=cs*qn3(3)+sn*qn3(1)
+        pq3(0)=cs*pq4(0)-sn*pq4(2)
+        pq3(1)=cs*pq4(1)-sn*pq4(3)
+        pq3(2)=cs*pq4(2)+sn*pq4(0)
+        pq3(3)=cs*pq4(3)+sn*pq4(1)
+        
+        zetaz=ov8*rotinz(id,2)*trstep*
+     x    (-pq3(0)*qn2(3)+pq3(1)*qn2(2)-
+     x    pq3(2)*qn2(1)+pq3(3)*qn2(0))
+        cs=cos(zetaz)
+        sn=sin(zetaz)
+        qq0(ig)=cs*qn2(0)-sn*qn2(3)
+        qq1(ig)=cs*qn2(1)+sn*qn2(2)
+        qq2(ig)=cs*qn2(2)-sn*qn2(1)
+        qq3(ig)=cs*qn2(3)+sn*qn2(0)
+        pp0(ig)=cs*pq3(0)-sn*pq3(3)
+        pp1(ig)=cs*pq3(1)+sn*pq3(2)
+        pp2(ig)=cs*pq3(2)-sn*pq3(1)
+        pp3(ig)=cs*pq3(3)+sn*pq3(0)
+        
+      enddo
+
+      return
+      end subroutine nosquish
+
+      subroutine nveqvv_1
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,tolnce,tstep,vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      m. leslie jan 2004
+c     amended     w.smith   jan 2005: f90 conversion
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jr
+      integer id,ifre,jrs,idum,ig
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) tqx,tqy,tqz,ftx,fty,ftz
+      real(8) vaa,vbb,vcc,engtrn,fmx,fmy,fmz
+      real(8) qt0,qt1,qt2,qt3,opx,opy,opz,engfke
+
+      integer, parameter :: nnn=6
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      
+      save newjob,p0,p1,p2,p3
+      
+      data newjob/.true./
+      
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     group block indices
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     check work arrays are large enough
+
+      safe=(igrp2-igrp1+1.le.msgrp) 
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe)then 
+        igrp=igrp2-igrp1+1
+        call gimax(igrp,1,idum)
+        if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+        call  error(idnode,506)
+      endif
+      if(ntcons.gt.0)safe=.false.
+
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(2))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+
+      endif
+      if(newjob)then
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(6))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2100)
+      enddo
+
+      newjob=.false.
+      
+      if(ntcons.gt.0)then
+
+c     construct current bond vectors
+        
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     update free atom velocities 1/2 time step first and second stages
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+pt5*tstep*rmass(i)*fzz(i)
+        
+      enddo
+
+c     *************  Rigid body motion ****************************
+c     operations common to first and second stages
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     calculate com force arrays 
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+
+        enddo
+
+c     current rotation matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+
+        jr=jrs
+        ftx=0.d0
+        fty=0.d0
+        ftz=0.d0
+        do j=1,numgsit(id)
+          jr=jr+1
+          i=lstrgd(jr)
+          ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+        enddo
+
+        tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+        tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+        tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+        qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+        qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+        qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+        qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+
+c     update quaternion momenta by 1/2 time step
+        
+        p0(ig)=p0(ig)+qt0*pt5*tstep
+        p1(ig)=p1(ig)+qt1*pt5*tstep
+        p2(ig)=p2(ig)+qt2*pt5*tstep
+        p3(ig)=p3(ig)+qt3*pt5*tstep
+
+c     update centre of mass velocity by 1/2 time step
+
+        gvxx(ig)=gvxx(ig)+fmx*pt5*tstep/gmass(id)
+        gvyy(ig)=gvyy(ig)+fmy*pt5*tstep/gmass(id)
+        gvzz(ig)=gvzz(ig)+fmz*pt5*tstep/gmass(id)
+
+      enddo
+
+c     merge centre of mass velocities from all nodes
+
+      if(mxnode.gt.1)call merge
+     x  (idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     move centre of mass by full time step
+
+        do ig=igrp1,igrp2
+
+          gcmx(ig)=gcmx(ig)+tstep*gvxx(ig)
+          gcmy(ig)=gcmy(ig)+tstep*gvyy(ig)
+          gcmz(ig)=gcmz(ig)+tstep*gvzz(ig)
+
+        enddo
+
+c     merge centre of mass position from all nodes
+
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     rotate rigid groups: nosquish algorithm
+
+        jr=0
+        do ig=igrp1,igrp2
+          
+          call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+          
+        enddo
+
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+        
+        k=0
+        do ig=igrp1,igrp2
+
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          id=lstgtp(ig)
+
+          do j=1,numgsit(id)
+            
+            k=k+1
+            i=lstme(k)
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+
+          enddo
+          
+        enddo
+
+c     update positions of free particles
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge atom positions
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     end of first stage of velocity verlet algorithm
+
+      else
+
+c     second stage of velocity verlet algorithm
+
+        jr=0
+        do ig=igrp1,igrp2
+
+c     new angular momenta and velocities
+          
+          opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x      q3(ig)*p2(ig)-q2(ig)*p3(ig))
+          opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x      q0(ig)*p2(ig)+q1(ig)*p3(ig))
+          opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x      q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+          id=lstgtp(ig)
+
+          omx(ig)=opx*rotinx(id,2)
+          omy(ig)=opy*rotiny(id,2)
+          omz(ig)=opz*rotinz(id,2)
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+c     new atomic velocites in body frame
+
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+
+c     merge velocities from all nodes
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+
+        endif
+
+c     calculate rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     end of second stage of velocity verlet algorithm
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     calculate kinetic energy
+      
+      if(isw.eq.2)then
+
+        engfke=getkinf(ntfree,idnode,mxnode)
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engke=engfke+engtrn
+
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+        
+      endif
+
+c     deallocate working arrays
+
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(2))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nveqvv_1
+
+      subroutine nvtqvv_b1
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,taut,sigma,tolnce,tstep,
+     x  vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     nvt ensemble - Berendsen thermostat (n.b. not symplectic)
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith   mar 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jr
+      integer id,ifre,jrs,idum,ig,iatm0,iatm1
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) tqx,tqy,tqz,ftx,fty,ftz
+      real(8) vaa,vbb,vcc,engtrn,fmx,fmy,fmz
+      real(8) qt0,qt1,qt2,qt3,opx,opy,opz,taut,sigma,engtke
+      real(8) chit,engfke
+
+      integer, parameter :: nnn=6
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      
+      save newjob,p0,p1,p2,p3
+
+      data newjob/.true./
+      
+c     atom block indices
+      
+      iatm0=(idnode*natms)/mxnode+1
+      iatm1=((idnode+1)*natms)/mxnode
+      
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     group block indices
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     check work arrays are large enough
+
+      safe=(igrp2-igrp1+1.le.msgrp) 
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe)then 
+        igrp=igrp2-igrp1+1
+        call gimax(igrp,1,idum)
+        if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+        call  error(idnode,506)
+      endif
+      if(ntcons.gt.0)safe=.false.
+
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(2))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+
+      endif
+      if(newjob)then
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(6))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2120)
+      enddo
+
+      newjob=.false.
+
+      if(ntcons.gt.0)then
+
+c     construct current bond vectors
+        
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     update free atom velocities 1/2 time step first and second stages
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+pt5*tstep*rmass(i)*fzz(i)
+        
+      enddo
+
+c     *************  Rigid body motion ****************************
+c     operations common to first and second stages
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     calculate com force arrays 
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+
+        enddo
+
+c     current rotation matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+
+        jr=jrs
+        ftx=0.d0
+        fty=0.d0
+        ftz=0.d0
+        do j=1,numgsit(id)
+          jr=jr+1
+          i=lstrgd(jr)
+          ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+        enddo
+        tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+        tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+        tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+        qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+        qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+        qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+        qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+
+c     update quaternion momenta by 1/2 time step
+
+        p0(ig)=p0(ig)+qt0*pt5*tstep
+        p1(ig)=p1(ig)+qt1*pt5*tstep
+        p2(ig)=p2(ig)+qt2*pt5*tstep
+        p3(ig)=p3(ig)+qt3*pt5*tstep
+
+c     update centre of mass velocity by 1/2 time step
+
+        gvxx(ig)=gvxx(ig)+fmx*pt5*tstep/gmass(id)
+        gvyy(ig)=gvyy(ig)+fmy*pt5*tstep/gmass(id)
+        gvzz(ig)=gvzz(ig)+fmz*pt5*tstep/gmass(id)
+
+      enddo
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     move centre of mass by full time step
+
+        do ig=igrp1,igrp2
+
+          gcmx(ig)=gcmx(ig)+tstep*gvxx(ig)
+          gcmy(ig)=gcmy(ig)+tstep*gvyy(ig)
+          gcmz(ig)=gcmz(ig)+tstep*gvzz(ig)
+
+        enddo
+
+c     merge group coms from all nodes
+
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     rotate rigid groups: nosquish algoritm
+
+        jr=0
+        do ig=igrp1,igrp2
+          call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+        enddo
+
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+        
+        k=0
+        do ig=igrp1,igrp2
+
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          id=lstgtp(ig)
+
+          do j=1,numgsit(id)
+            
+            k=k+1
+            i=lstme(k)
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+
+          enddo
+          
+        enddo
+
+c     update positions of free particles
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge atom positions
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     end of first stage of velocity verlet algorithm
+
+      else
+
+c     second stage of velocity verlet algorithm
+
+        jr=0
+        do ig=igrp1,igrp2
+
+c     new angular momenta and velocities
+          
+          opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x      q3(ig)*p2(ig)-q2(ig)*p3(ig))
+          opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x      q0(ig)*p2(ig)+q1(ig)*p3(ig))
+          opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x      q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+          id=lstgtp(ig)
+
+          omx(ig)=opx*rotinx(id,2)
+          omy(ig)=opy*rotiny(id,2)
+          omz(ig)=opz*rotinz(id,2)
+          
+c     new rotation matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+c     new atomic velocites in body frame
+
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+
+c     merge velocities from all nodes
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+
+        endif
+
+c     calculate rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     end of second stage of velocity verlet algorithm
+        
+      endif
+
+c     calculate kinetic energy
+      
+      if(isw.eq.2)then
+
+        engfke=getkinf(ntfree,idnode,mxnode)
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engtke=engfke+engtrn+engrot
+        engke=engfke+engtrn
+
+c     apply Berendsen thermostat - taut is the relaxation time
+        
+        chit=sqrt(1.d0+tstep/taut*(sigma/engtke-1.d0))
+        
+        engke=engke*chit**2
+        engtrn=engtrn*chit**2
+        engrot=engrot*chit**2
+        
+c     thermostat velocities 
+        
+        do i=iatm0,iatm1
+          
+          if(lstfrz(i).eq.0)then
+
+            vxx(i)=chit*vxx(i)
+            vyy(i)=chit*vyy(i)
+            vzz(i)=chit*vzz(i)
+            
+          endif
+          
+        enddo
+
+c     merge velocities from all nodes
+
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     thermostat rigid body velocities
+
+        do ig=igrp1,igrp2
+          
+          omx(ig)=chit*omx(ig)
+          omy(ig)=chit*omy(ig)
+          omz(ig)=chit*omz(ig)
+          gvxx(ig)=chit*gvxx(ig)
+          gvyy(ig)=chit*gvyy(ig)
+          gvzz(ig)=chit*gvzz(ig)
+
+        enddo
+
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     exchange position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     merge group velocities from all processors
+
+      if(mxnode.gt.1)call merge
+     x  (idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+
+c     deallocate working arrays
+
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(2))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nvtqvv_b1
+
+      subroutine nvtqvv_h1
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntshl,keyshl,chit,consv,conint,engke,engrot,
+     x  taut,sigma,tolnce,tstep,vircom,vircon,chit_shl,sigma_shl)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     nvt ensemble - nose-hoover thermostat Molec Phys 87 (1996) 1117
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith april 2005
+c     adapted     d.quigley : metadynamics
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=6
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,lshmov,newjob
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ifre1,ifre2,igrp1,igrp2,igrp,i,j,k,jr
+      integer id,ig,ifre,jrs,idum
+      real(8) chit,consv,conint,engke,engrot,taut,sigma,tolnce,tstep
+      real(8) vircom,vircon,hstep,qmass,opx,opy,opz,fmx,fmy,fmz,engtrn
+      real(8) ftx,fty,ftz,tqx,tqy,tqz,qt0,qt1,qt2,qt3,vaa,vbb,vcc
+      real(8) engfke
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+
+      save newjob,p0,p1,p2,p3
+
+      data newjob/.true./
+      
+c     timestep parameters
+
+      hstep=pt5*tstep
+
+c     nose-hoover inertia parameter
+
+      qmass=2.d0*sigma*taut**2
+
+c     free atom block indices
+      
+      ifre1=(idnode*ntfree)/mxnode+1
+      ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     group block indices
+
+      igrp1=(idnode*ngrp)/mxnode+1
+      igrp2=((idnode+1)*ngrp)/mxnode
+
+c     check work arrays are large enough
+
+      safe=(igrp2-igrp1+1.le.msgrp) 
+      if(mxnode.gt.1) call gstate(safe)
+      if(.not.safe)then 
+        igrp=igrp2-igrp1+1
+        call gimax(igrp,1,idum)
+        if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+        call  error(idnode,506)
+      endif
+      if(ntcons.gt.0)safe=.false.
+
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(2))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+
+      endif
+      if(newjob)then
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(6))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2140)
+      enddo
+
+      newjob=.false.
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+
+      if(ntcons.gt.0)then
+
+c     construct current bond vectors
+        
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     apply thermostat for first stage
+
+      if(isw.eq.1)then
+        
+        call nvtqscl
+     x    (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,sigma,
+     x    hstep,qmass,taut,chit,conint)
+        
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+        if(lmetadyn.and.keyshl.eq.1)then
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          call nvtscale_shl
+     x      (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x      taut,chit_shl,conint)      
+        endif
+        
+      endif
+      
+c     calculate quaternion momenta at start of time step
+      
+      if(isw.eq.1)then
+        
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     update free atom velocities 1/2 time step first and second stages
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+        
+      enddo
+
+c     *************  Rigid body motion ****************************
+c     operations common to first and second stages
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     calculate com force arrays 
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+
+        enddo
+
+c     current rotation matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+
+        jr=jrs
+        ftx=0.d0
+        fty=0.d0
+        ftz=0.d0
+        do j=1,numgsit(id)
+          jr=jr+1
+          i=lstrgd(jr)
+          ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+        enddo
+        tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+        tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+        tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+        qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+        qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+        qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+        qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+
+c     update quaternion momenta by 1/2 time step
+
+        p0(ig)=p0(ig)+qt0*hstep
+        p1(ig)=p1(ig)+qt1*hstep
+        p2(ig)=p2(ig)+qt2*hstep
+        p3(ig)=p3(ig)+qt3*hstep
+
+c     update centre of mass velocity by 1/2 time step
+
+        gvxx(ig)=gvxx(ig)+fmx*hstep/gmass(id)
+        gvyy(ig)=gvyy(ig)+fmy*hstep/gmass(id)
+        gvzz(ig)=gvzz(ig)+fmz*hstep/gmass(id)
+
+      enddo
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     move centre of mass by full time step
+
+        do ig=igrp1,igrp2
+
+          gcmx(ig)=gcmx(ig)+tstep*gvxx(ig)
+          gcmy(ig)=gcmy(ig)+tstep*gvyy(ig)
+          gcmz(ig)=gcmz(ig)+tstep*gvzz(ig)
+
+        enddo
+
+c     merge group coms from all nodes
+
+        if(mxnode.gt.1)call merge
+     x    (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     rotate rigid groups: nosquish algoritm
+
+        jr=0
+        do ig=igrp1,igrp2
+          call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+        enddo
+
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+        
+        k=0
+        do ig=igrp1,igrp2
+
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+          id=lstgtp(ig)
+
+          do j=1,numgsit(id)
+            
+            k=k+1
+            i=lstme(k)
+            xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x        +gcmx(ig)
+            yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x        +gcmy(ig)
+            zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x        +gcmz(ig)
+
+          enddo
+          
+        enddo
+
+c     update positions of free particles
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          xxx(i)=xxx(i)+tstep*vxx(i)
+          yyy(i)=yyy(i)+tstep*vyy(i)
+          zzz(i)=zzz(i)+tstep*vzz(i)
+          
+        enddo
+
+c     merge atom positions
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+      
+c     apply shake corrections to bond constraints
+
+        if(ntcons.gt.0)then
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+          safe=.false.
+          call rdrattle_r
+     x      (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x      tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x      txx,tyy,tzz,xxt,yyt,zzt,strcns)
+          if(.not.safe)return
+
+        endif
+
+c     end of first stage of velocity verlet algorithm
+
+      else
+
+c     second stage of velocity verlet algorithm
+
+        jr=0
+        do ig=igrp1,igrp2
+
+c     new angular momenta and velocities
+          
+          opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x      q3(ig)*p2(ig)-q2(ig)*p3(ig))
+          opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x      q0(ig)*p2(ig)+q1(ig)*p3(ig))
+          opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x      q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+          id=lstgtp(ig)
+
+          omx(ig)=opx*rotinx(id,2)
+          omy(ig)=opy*rotiny(id,2)
+          omz(ig)=opz*rotinz(id,2)
+          
+c     new rotation matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+c     new atomic velocites in body frame
+
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+
+c     merge velocities from all nodes
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+
+        endif
+
+c     calculate rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     apply thermostat for second stage and calculate kinetic energy
+      
+        call nvtqscl
+     x    (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,sigma,
+     x    hstep,qmass,taut,chit,conint)
+
+        engke=engfke+engtrn
+
+c     merge velocities from all nodes
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+        if(lmetadyn.and.keyshl.eq.1)then
+          call nvtscale_shl
+     x      (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x      taut,chit_shl,conint)      
+        endif
+        
+c     conserved quantity less kinetic and potential energy terms
+        
+        consv=conint+0.5d0*qmass*chit**2
+
+c     metadynamics shell thermostat
+
+        if(lmetadyn.and.keyshl.eq.1)then
+          consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+        
+c     end of second stage of velocity verlet algorithm
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     merge group velocities from all processors
+
+      if(mxnode.gt.1)call merge
+     x  (idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+
+c     deallocate working arrays
+
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(2))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(3))
+
+      endif
+      
+      return
+      end subroutine nvtqvv_h1
+
+      subroutine nptqvv_b1
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,engke,engrot,press,taut,taup,sigma,
+     x  tolnce,tstep,vircom,vircon,elrc,virlrc,virtot,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     npt ensemble - Berendsen thermostat and barostat 
+c     (n.b. not symplectic)
+c     
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith april 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jr,kk
+      integer id,ifre,jrs,idum,ig,iatm0,iatm1,ntpatm,iter,mxiter
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) tqx,tqy,tqz,ftx,fty,ftz
+      real(8) vaa,vbb,vcc,engtrn,fmx,fmy,fmz
+      real(8) qt0,qt1,qt2,qt3,opx,opy,opz,taut,sigma,engtke
+      real(8) chit,chip,beta,volm,volm0,elrc,elrc0,virlrc,virlrc0
+      real(8) virtot,psyst,press,taup,scale,engfke
+
+      integer, parameter :: nnn=11
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),uni(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      
+      save newjob,volm0,elrc0,virlrc0,iatm0,iatm1,dens0
+      save p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./,beta/7.3728d-3/
+      
+      safe=.true.
+
+      if(newjob)then
+        
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2160)
+
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     atom block indices
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+      endif
+
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(2))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+
+        if(isw.eq.1)then
+
+          allocate(gxo(mxgrp),gyo(mxgrp),gzo(mxgrp),stat=fail(6))
+          allocate(b0(mxgrp),b1(mxgrp),b2(mxgrp),b3(mxgrp),stat=fail(7))
+          allocate(c0(mxgrp),c1(mxgrp),c2(mxgrp),c3(mxgrp),stat=fail(8))
+          allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+          allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(10))
+
+        endif
+
+      endif
+      if(newjob)then         
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(11))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2170)
+      enddo
+
+      newjob=.false.
+      if(ntcons.gt.0)safe=.false.
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+      if(isw.eq.1)then
+
+c     calculate kinetic energy
+
+        engfke=getkinf(ntfree,idnode,mxnode)
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engke=engfke+engtrn
+
+c     calculate quaternion momenta at start of time step
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     update free atom velocities 1/2 time step first and second stages
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+pt5*tstep*rmass(i)*fzz(i)
+        
+      enddo
+
+c     rigid body motion for first and second stages
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     calculate com force arrays 
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+
+        enddo
+
+c     current rotation matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+
+        jr=jrs
+        ftx=0.d0
+        fty=0.d0
+        ftz=0.d0
+        do j=1,numgsit(id)
+          jr=jr+1
+          i=lstrgd(jr)
+          ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+        enddo
+        tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+        tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+        tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+        qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+        qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+        qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+        qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+
+c     update quaternion momenta by 1/2 time step
+
+        p0(ig)=p0(ig)+qt0*pt5*tstep
+        p1(ig)=p1(ig)+qt1*pt5*tstep
+        p2(ig)=p2(ig)+qt2*pt5*tstep
+        p3(ig)=p3(ig)+qt3*pt5*tstep
+
+c     update centre of mass velocity by 1/2 time step
+
+        gvxx(ig)=gvxx(ig)+fmx*pt5*tstep/gmass(id)
+        gvyy(ig)=gvyy(ig)+fmy*pt5*tstep/gmass(id)
+        gvzz(ig)=gvzz(ig)+fmz*pt5*tstep/gmass(id)
+
+      enddo
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     store current integration variables
+        
+        if(ntcons.gt.0)then
+
+          do i=1,natms
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+
+          enddo
+          do ig=1,ngrp
+            
+            b0(ig)=q0(ig)
+            b1(ig)=q1(ig)
+            b2(ig)=q2(ig)
+            b3(ig)=q3(ig)
+            c0(ig)=p0(ig)
+            c1(ig)=p1(ig)
+            c2(ig)=p2(ig)
+            c3(ig)=p3(ig)
+            gxo(ig)=gcmx(ig)
+            gyo(ig)=gcmy(ig)
+            gzo(ig)=gcmz(ig)
+            
+          enddo
+
+        endif
+
+c     iteration required if ntcons > 0
+
+        mxiter=1
+        if(ntcons.gt.0)mxiter=2
+        do iter=1,mxiter
+
+          scale=1.d0
+
+          if(iter.eq.mxiter)then
+            
+c     calculate system pressure
+            
+            psyst=(2.d0*engke-virtot-vircon-vircom)/(3.d0*volm)
+            
+c     apply Berendsen barostat
+            
+            chip=1.d0+beta*tstep*(psyst-press)/taup
+            scale=chip**(1.d0/3.d0)
+            volm=chip*volm
+
+c     reset cell parameters for new volume
+            
+            do i=1,9
+              cell(i)=scale*cell(i)
+            enddo
+
+          endif
+
+c     update centre of mass position
+
+          do ig=igrp1,igrp2
+
+            gcmx(ig)=scale*gcmx(ig)+tstep*gvxx(ig)
+            gcmy(ig)=scale*gcmy(ig)+tstep*gvyy(ig)
+            gcmz(ig)=scale*gcmz(ig)+tstep*gvzz(ig)
+
+          enddo
+
+c     merge group coms from all nodes
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     rotate rigid groups: nosquish algorithm
+
+          jr=0
+          do ig=igrp1,igrp2
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+          enddo
+
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+          
+          k=0
+          do ig=igrp1,igrp2
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            id=lstgtp(ig)
+            
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=gcmx(ig)+
+     x          rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+              yyy(i)=gcmy(ig)+
+     x          rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+              zzz(i)=gcmz(ig)+
+     x          rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+              
+            enddo
+            
+          enddo
+          
+c     update positions of free particles
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            xxx(i)=scale*xxx(i)+tstep*vxx(i)
+            yyy(i)=scale*yyy(i)+tstep*vyy(i)
+            zzz(i)=scale*zzz(i)+tstep*vzz(i)
+            
+          enddo
+          
+c     merge position data
+
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+          
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+
+          endif
+
+          if(iter.lt.mxiter)then
+
+            do i=1,natms
+
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+
+            enddo
+            do ig=1,ngrp
+
+              q0(ig)=b0(ig)
+              q1(ig)=b1(ig)
+              q2(ig)=b2(ig)
+              q3(ig)=b3(ig)
+              p0(ig)=c0(ig)
+              p1(ig)=c1(ig)
+              p2(ig)=c2(ig)
+              p3(ig)=c3(ig)
+              gcmx(ig)=gxo(ig)
+              gcmy(ig)=gyo(ig)
+              gcmz(ig)=gzo(ig)
+
+            enddo
+
+          endif
+
+        enddo
+
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        
+        do kk=1,ntpatm
+          dens(kk)=dens0(kk)*(volm0/volm)
+        enddo
+
+c     construct scaling tensor for tethered bonds
+
+        do i=1,9
+          eta(i)=scale*uni(i)
+        enddo
+
+c     end of first stage of velocity verlet algorithm
+
+      else
+
+c     second stage of velocity verlet algorithm
+
+        jr=0
+        do ig=igrp1,igrp2
+
+c     new angular momenta and velocities
+          
+          opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x      q3(ig)*p2(ig)-q2(ig)*p3(ig))
+          opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x      q0(ig)*p2(ig)+q1(ig)*p3(ig))
+          opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x      q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+          id=lstgtp(ig)
+
+          omx(ig)=opx*rotinx(id,2)
+          omy(ig)=opy*rotiny(id,2)
+          omz(ig)=opz*rotinz(id,2)
+          
+c     new rotation matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+c     new atomic velocites in body frame
+
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+
+c     merge velocities and forces from all nodes
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+
+        endif
+
+c     calculate rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     calculate kinetic energy
+        
+        if(isw.eq.2)then
+
+          engfke=getkinf(ntfree,idnode,mxnode)
+          call getking(ngrp,idnode,mxnode,engtrn,engrot)
+          engtke=engfke+engtrn+engrot
+          engke=engfke+engtrn
+
+c     apply Berendsen thermostat - taut is the relaxation time
+          
+          chit=sqrt(1.d0+tstep/taut*(sigma/engtke-1.d0))
+          
+          engke=engke*chit**2
+          engtrn=engtrn*chit**2
+          engrot=engrot*chit**2
+          
+c     thermostat velocities 
+          
+          do i=iatm0,iatm1
+            
+            if(lstfrz(i).eq.0)then
+
+              vxx(i)=chit*vxx(i)
+              vyy(i)=chit*vyy(i)
+              vzz(i)=chit*vzz(i)
+              
+            endif
+            
+          enddo
+
+c     merge velocities from all nodes
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     thermostat rigid body velocities
+
+          do ig=igrp1,igrp2
+            
+            omx(ig)=chit*omx(ig)
+            omy(ig)=chit*omy(ig)
+            omz(ig)=chit*omz(ig)
+            gvxx(ig)=chit*gvxx(ig)
+            gvyy(ig)=chit*gvyy(ig)
+            gvzz(ig)=chit*gvzz(ig)
+
+          enddo
+
+c     merge group velocities from all processors
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+
+c     kinetic contribution to stress tensor
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)        
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+          
+c     add contributions to stress tensor
+          
+          do i=1,9
+            stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+          enddo
+          
+        endif
+        
+c     end of second stage of velocity verlet algorithm
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     deallocate working arrays
+
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(2))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(3))
+        
+        if(isw.eq.1)then
+          
+          deallocate(vxo,vyo,vzo,b0,b1,b2,b3,stat=fail(4))
+          deallocate(xxo,yyo,zzo,c0,c1,c2,c3,stat=fail(5))
+          deallocate(gxo,gyo,gzo,stat=fail(6))
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine nptqvv_b1
+
+      subroutine nptqvv_h1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x  ntcons,ntpatm,ntfree,ntshl,keyshl,tstep,taut,taup,sigma,
+     x  temp,chip,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x  vircon,virtot,virlrc,vircom,volm,press,chit_shl,sigma_shl)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     npt ensemble - nose-hoover thermostat Molec Phys 87 (1996) 1117
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith may 2005
+c     adapted     d.quigley : metadynamics
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=12
+      integer, parameter :: ncyc=5
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,lshmov,newjob
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ifre1,ifre2,igrp1,igrp2,igrp,i,j,k,jr
+      integer id,ig,ifre,jrs,idum,mxiter,iter,ntpatm,kk,icyc
+      real(8) chit,consv,conint,engke,engrot,taut,sigma,tolnce,tstep
+      real(8) vircom,vircon,hstep,qmass,opx,opy,opz,fmx,fmy,fmz,engtrn
+      real(8) ftx,fty,ftz,tqx,tqy,tqz,qt0,qt1,qt2,qt3,vaa,vbb,vcc
+      real(8) taup,temp,press,virtot,vzero,chit0,chip0,cons0
+      real(8) chip,volm,elrc,elrc0,virlrc,virlrc0,qstep,pmass,totmas
+      real(8) volm0,scale,cxx,cyy,czz,engfke,fstep
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),cell0(9),com(3),vom(3),uni(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: oxo(:),oyo(:),ozo(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+
+      save newjob,hstep,qstep,fstep,pmass,qmass
+      save p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2,volm0,elrc0,virlrc0
+      save totmas,dens0,cell0
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      
+      safe=.true.
+      
+      if(newjob)then
+
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2200)
+
+c     store intitial parameters
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        hstep=0.5d0*tstep
+        fstep=0.5d0*tstep/dble(ncyc)
+        qstep=0.25d0*tstep/dble(ncyc)
+        
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+
+c     total system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+
+c     nose-hoover thermostat and barostat inertia parameter
+        
+        qmass=2.d0*sigma*taut**2
+        pmass=2.d0*sigma*taup**2
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call error(idnode,506)
+        endif
+
+      endif
+
+      if(ntcons.gt.0)safe=.false.
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      
+      if(ntcons.gt.0)then
+        
+        allocate(gxo(mxgrp),gyo(mxgrp),gzo(mxgrp),stat=fail(2))
+        allocate(oxo(mxgrp),oyo(mxgrp),ozo(mxgrp),stat=fail(3))
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(4))
+        allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(5))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(6))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(8))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(9))
+        allocate(b0(mxgrp),b1(mxgrp),b2(mxgrp),b3(mxgrp),stat=fail(10))
+        allocate(gvxo(mxgrp),gvyo(mxgrp),gvzo(mxgrp),stat=fail(11))
+        
+      endif
+      if(newjob)then
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(12))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2210)
+      enddo
+
+      newjob=.false.
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+      
+      if(ntcons.gt.0)then
+
+c     construct current bond vectors
+        
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     remove system centre of mass velocity
+        
+        call getvom(natms,idnode,mxnode,totmas,vom)
+        
+        do i=1,natms
+          
+          vxx(i)=vxx(i)-vom(1)
+          vyy(i)=vyy(i)-vom(2)
+          vzz(i)=vzz(i)-vom(3)
+          
+        enddo
+        
+        do ig=1,ngrp
+          
+          gvxx(ig)=gvxx(ig)-vom(1)
+          gvyy(ig)=gvyy(ig)-vom(2)
+          gvzz(ig)=gvzz(ig)-vom(3)
+          
+        enddo
+
+c     store current integration variables if ntcons > 0
+        
+        if(ntcons.gt.0)then
+          
+          vzero=volm
+          chit0=chit
+          chip0=chip
+          cons0=conint
+          do i=1,natms
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+            
+          enddo
+          do ig=1,ngrp
+            
+            b0(ig)=q0(ig)
+            b1(ig)=q1(ig)
+            b2(ig)=q2(ig)
+            b3(ig)=q3(ig)
+            oxo(ig)=omx(ig)
+            oyo(ig)=omy(ig)
+            ozo(ig)=omz(ig)
+            gxo(ig)=gcmx(ig)
+            gyo(ig)=gcmy(ig)
+            gzo(ig)=gcmz(ig)
+            gvxo(ig)=gvxx(ig)
+            gvyo(ig)=gvyy(ig)
+            gvzo(ig)=gvzz(ig)
+            
+          enddo
+          
+        endif
+        
+      endif
+
+c     iteration necessary if ntcons > 0 and isw=1
+
+      mxiter=1
+      if(isw.eq.1.and.ntcons.gt.0)mxiter=3
+      do iter=1,mxiter
+        
+        if(isw.eq.1)then
+          
+          do icyc=1,ncyc
+            
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif           
+            
+c     integrate and apply npt barostat
+            
+            call nptqscl_p
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,fstep,pmass,
+     x        chip,chit,volm,press,vircon,virtot,vircom)
+            
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif           
+            
+          enddo
+          
+          engke=engfke+engtrn
+          
+c     scale cell vectors - isotropic
+          
+          scale=(volm/volm0)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+          
+c     calculate quaternion momenta
+          
+          do ig=igrp1,igrp2
+            
+            id=lstgtp(ig)
+            opx=omx(ig)*rotinx(id,1)
+            opy=omy(ig)*rotiny(id,1)
+            opz=omz(ig)*rotinz(id,1)
+            p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+            p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+            p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+            p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+            
+          enddo
+          
+        endif
+
+c     update free atom velocities 
+
+        do ifre=ifre1,ifre2
+
+          i=lstfre(ifre)
+          vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+          
+        enddo
+
+c     *************  Rigid body motion ****************************
+
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     calculate com force arrays 
+          
+          jrs=jr
+          fmx=0.d0
+          fmy=0.d0
+          fmz=0.d0
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            fmx=fmx+fxx(i)
+            fmy=fmy+fyy(i)
+            fmz=fmz+fzz(i)
+            
+          enddo
+          
+c     current rotation matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+          
+c     calculate torque in principal frame
+          
+          jr=jrs
+          ftx=0.d0
+          fty=0.d0
+          ftz=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+          tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+          tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+          
+c     calculate quaternion torques
+          
+          qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+          qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+          qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+          qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+          
+c     update quaternion momenta by 1/2 time step
+          
+          p0(ig)=p0(ig)+qt0*hstep
+          p1(ig)=p1(ig)+qt1*hstep
+          p2(ig)=p2(ig)+qt2*hstep
+          p3(ig)=p3(ig)+qt3*hstep
+          
+c     update centre of mass velocity by 1/2 time step
+          
+          gvxx(ig)=gvxx(ig)+fmx*hstep/gmass(id)
+          gvyy(ig)=gvyy(ig)+fmy*hstep/gmass(id)
+          gvzz(ig)=gvzz(ig)+fmz*hstep/gmass(id)
+          
+        enddo
+        
+        if(isw.eq.1)then
+          
+c     calculate system centre of mass
+          
+          call getcom(natms,idnode,mxnode,totmas,com)
+          
+c     move centre of mass by full time step
+          
+          do ig=igrp1,igrp2
+            
+            cxx=gcmx(ig)-com(1)
+            cyy=gcmy(ig)-com(2)
+            czz=gcmz(ig)-com(3)
+            gcmx(ig)=gcmx(ig)+tstep*(gvxx(ig)+chip*cxx)
+            gcmy(ig)=gcmy(ig)+tstep*(gvyy(ig)+chip*cyy)
+            gcmz(ig)=gcmz(ig)+tstep*(gvzz(ig)+chip*czz)
+            
+          enddo
+          
+c     merge group coms from all nodes
+          
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+c     rotate rigid groups: nosquish algorithm
+          
+          do ig=igrp1,igrp2
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+          enddo
+          
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+          
+          k=0
+          do ig=igrp1,igrp2
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            id=lstgtp(ig)
+            
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x          +gcmx(ig)
+              yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x          +gcmy(ig)
+              zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x          +gcmz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     update positions of free particles
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            cxx=xxx(i)-com(1)
+            cyy=yyy(i)-com(2)
+            czz=zzz(i)-com(3)
+            xxx(i)=xxx(i)+tstep*(vxx(i)+chip*cxx)
+            yyy(i)=yyy(i)+tstep*(vyy(i)+chip*cyy)
+            zzz(i)=zzz(i)+tstep*(vzz(i)+chip*czz)
+            
+          enddo
+          
+c     merge position data
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+          
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+            
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+            
+          endif
+          
+c     restore original integration parameters if iter < mxiter
+          
+          if(iter.lt.mxiter)then
+            
+            volm=vzero
+            chit=chit0
+            chip=chip0
+            conint=cons0
+            do i=1,natms
+              
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+              
+            enddo
+            do ig=1,ngrp
+              
+              q0(ig)=b0(ig)
+              q1(ig)=b1(ig)
+              q2(ig)=b2(ig)
+              q3(ig)=b3(ig)
+              omx(ig)=oxo(ig)
+              omy(ig)=oyo(ig)
+              omz(ig)=ozo(ig)
+              gcmx(ig)=gxo(ig)
+              gcmy(ig)=gyo(ig)
+              gcmz(ig)=gzo(ig)
+              gvxx(ig)=gvxo(ig)
+              gvyy(ig)=gvyo(ig)
+              gvzz(ig)=gvzo(ig)
+              
+            enddo
+            
+          endif
+          
+        endif
+
+c     operations for second stage only
+
+        if(isw.eq.2)then
+          
+          jr=0
+          do ig=igrp1,igrp2
+            
+c     new angular momenta and velocities
+            
+            opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x        q3(ig)*p2(ig)-q2(ig)*p3(ig))
+            opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x        q0(ig)*p2(ig)+q1(ig)*p3(ig))
+            opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x        q1(ig)*p2(ig)+q0(ig)*p3(ig))
+            
+            id=lstgtp(ig)
+            
+            omx(ig)=opx*rotinx(id,2)
+            omy(ig)=opy*rotiny(id,2)
+            omz(ig)=opz*rotinz(id,2)
+            
+c     new rotation matrix
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              
+c     new atomic velocites in body frame
+              
+              vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+              vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+              vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+              
+c     new atomic velocites in lab frame
+              
+              vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+              vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+              vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     merge velocities from all nodes
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+          
+c     correct constraint bond velocities using rattle
+          
+          if(ntcons.gt.0)then
+            
+            safe=.false.
+            call rdrattle_v
+     x        (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x        dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+            if(.not.safe)return
+            
+          endif
+          
+c     kinetic contribution to stress tensor
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)        
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+          
+c     calculate rigid body contribution to stress tensor
+
+          call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     add contributions to stress tensor
+          
+          do i=1,9
+            stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+          enddo
+          
+          do icyc=1,ncyc
+            
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif           
+            
+c     integrate and apply npt barostat
+            
+            call nptqscl_p
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,fstep,pmass,
+     x        chip,chit,volm,press,vircon,virtot,vircom)
+            
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif           
+            
+          enddo
+
+          engke=engfke+engtrn
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     scale cell vectors - isotropic
+          
+          scale=(volm/volm0)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+          
+c     calculate conserved variable
+
+          consv=conint+0.5d0*qmass*chit**2+press*volm
+     x      +0.5d0*pmass*chip**2
+          
+c     metadynamics shell thermostat
+          
+          if(lmetadyn.and.keyshl.eq.1)then
+            consv=consv+0.5d0*qmass_shl*chit_shl**2
+          endif
+          
+c     end of second stage of velocity verlet algorithm
+          
+        endif
+        
+c     end of iteration cycle
+
+      enddo
+          
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      do kk=1,ntpatm
+        dens(kk)=dens0(kk)*(volm0/volm)
+      enddo
+      
+c     construct scaling tensor (for tethered atoms)
+      
+      do i=1,9
+        eta(i)=chip*uni(i)
+      enddo
+      
+c     deallocate working arrays
+      
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(3))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(4))
+        deallocate(xxo,yyo,zzo,oxo,oyo,ozo,stat=fail(5))
+        deallocate(vxo,vyo,vzo,b0,b1,b2,b3,stat=fail(6))
+        deallocate(gxo,gyo,gzo,gvxo,gvyo,gvzo,stat=fail(7))
+
+      endif
+      
+      return
+      end subroutine nptqvv_h1
+
+      subroutine nstqvv_b1
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,mode,engke,engrot,press,taut,taup,sigma,
+     x  tolnce,tstep,vircom,vircon,elrc,virlrc,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     nst ensemble - Berendsen thermostat and barostat 
+c     (n.b. not symplectic)
+c     
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith may 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jr,kk,mode
+      integer id,ifre,jrs,idum,ig,iatm0,iatm1,ntpatm,iter,mxiter
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon,engfke
+      real(8) tqx,tqy,tqz,ftx,fty,ftz
+      real(8) vaa,vbb,vcc,engtrn,fmx,fmy,fmz
+      real(8) qt0,qt1,qt2,qt3,opx,opy,opz,taut,sigma,engtke
+      real(8) chit,beta,volm,volm0,elrc,elrc0,virlrc,virlrc0
+      real(8) press,taup,xtmp,ytmp,ztmp
+
+      integer, parameter :: nnn=11
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+      real(8) celp(10),uni(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      
+      save newjob,volm0,elrc0,virlrc0,iatm0,iatm1,dens0
+      save p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2
+
+      data newjob/.true./,beta/7.3728d-3/
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+      safe=.true.
+
+      if(newjob)then
+        
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2240)
+
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     atom block indices
+        
+        iatm0=(idnode*natms)/mxnode+1
+        iatm1=((idnode+1)*natms)/mxnode
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+      endif
+
+c     allocate working arrays
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(2))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(3))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(4))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(5))
+
+        if(isw.eq.1)then
+
+          allocate(gxo(mxgrp),gyo(mxgrp),gzo(mxgrp),stat=fail(6))
+          allocate(b0(mxgrp),b1(mxgrp),b2(mxgrp),b3(mxgrp),stat=fail(7))
+          allocate(c0(mxgrp),c1(mxgrp),c2(mxgrp),c3(mxgrp),stat=fail(8))
+          allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(9))
+          allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(10))
+
+        endif
+
+      endif
+      if(newjob)then         
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(11))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2250)
+      enddo
+
+      newjob=.false.
+      if(ntcons.gt.0)safe=.false.
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+      if(isw.eq.1)then
+
+c     calculate kinetic energy
+
+        engfke=getkinf(ntfree,idnode,mxnode)
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engke=engfke+engtrn
+
+c     calculate quaternion momenta at start of time step
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     update free atom velocities 1/2 time step first and second stages
+
+      do ifre=ifre1,ifre2
+
+        i=lstfre(ifre)
+        vxx(i)=vxx(i)+pt5*tstep*rmass(i)*fxx(i)
+        vyy(i)=vyy(i)+pt5*tstep*rmass(i)*fyy(i)
+        vzz(i)=vzz(i)+pt5*tstep*rmass(i)*fzz(i)
+        
+      enddo
+
+c     rigid body motion for first and second stages
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+c     calculate com force arrays 
+        
+        jrs=jr
+        fmx=0.d0
+        fmy=0.d0
+        fmz=0.d0
+        id=lstgtp(ig)
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          fmx=fmx+fxx(i)
+          fmy=fmy+fyy(i)
+          fmz=fmz+fzz(i)
+
+        enddo
+
+c     current rotation matrix 
+        
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+
+        jr=jrs
+        ftx=0.d0
+        fty=0.d0
+        ftz=0.d0
+        do j=1,numgsit(id)
+          jr=jr+1
+          i=lstrgd(jr)
+          ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+          fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+          ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+        enddo
+        tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+        tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+        tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+        qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+        qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+        qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+        qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+
+c     update quaternion momenta by 1/2 time step
+
+        p0(ig)=p0(ig)+qt0*pt5*tstep
+        p1(ig)=p1(ig)+qt1*pt5*tstep
+        p2(ig)=p2(ig)+qt2*pt5*tstep
+        p3(ig)=p3(ig)+qt3*pt5*tstep
+
+c     update centre of mass velocity by 1/2 time step
+
+        gvxx(ig)=gvxx(ig)+fmx*pt5*tstep/gmass(id)
+        gvyy(ig)=gvyy(ig)+fmy*pt5*tstep/gmass(id)
+        gvzz(ig)=gvzz(ig)+fmz*pt5*tstep/gmass(id)
+
+      enddo
+
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     store current integration variables
+        
+        if(ntcons.gt.0)then
+
+          do i=1,natms
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+
+          enddo
+          do ig=1,ngrp
+            
+            b0(ig)=q0(ig)
+            b1(ig)=q1(ig)
+            b2(ig)=q2(ig)
+            b3(ig)=q3(ig)
+            c0(ig)=p0(ig)
+            c1(ig)=p1(ig)
+            c2(ig)=p2(ig)
+            c3(ig)=p3(ig)
+            gxo(ig)=gcmx(ig)
+            gyo(ig)=gcmy(ig)
+            gzo(ig)=gcmz(ig)
+            
+          enddo
+
+        endif
+
+c     extract previous constraint terms from stress tensor
+
+      if(isw.eq.1)then          
+
+        do i=1,9
+          stress(i)=stress(i)-strcns(i)
+        enddo
+
+      endif
+
+c     iteration required if ntcons > 0
+
+        mxiter=1
+        if(ntcons.gt.0)mxiter=2
+        do iter=1,mxiter
+
+c     zero scaling matrix
+
+          do i=1,9
+            eta(i)=uni(i)
+          enddo
+
+          if(iter.eq.mxiter)then
+            
+c     calculate Berendsen barostat
+            
+            do i=1,9
+              eta(i)=tstep*beta*(stress(i)+strcns(i)-
+     x          press*volm*uni(i))/(taup*volm)+uni(i)
+            enddo
+            if(mode.gt.0)then
+              eta(3)=0.d0
+              eta(6)=0.d0
+              eta(7)=0.d0
+              eta(8)=0.d0
+              if(mode.lt.3)then
+                eta(2)=0.d0
+                eta(4)=0.d0
+                if(mode.eq.2)then
+                  eta(1)=0.5d0*(eta(1)+eta(5))
+                  eta(5)=eta(1)
+                endif
+              endif
+            endif
+
+c     reset cell parameters for new volume
+          
+            call mat_mul(eta,cell,cell)
+            
+c     calculate new volume
+            
+            call dcell(cell,celp)
+            volm=celp(10)
+
+          endif
+
+c     update centre of mass position
+
+          do ig=igrp1,igrp2
+
+            xtmp=eta(1)*gcmx(ig)+eta(4)*gcmy(ig)+eta(7)*gcmz(ig)
+            ytmp=eta(2)*gcmx(ig)+eta(5)*gcmy(ig)+eta(8)*gcmz(ig)
+            ztmp=eta(3)*gcmx(ig)+eta(6)*gcmy(ig)+eta(9)*gcmz(ig)
+            gcmx(ig)=tstep*gvxx(ig)+xtmp
+            gcmy(ig)=tstep*gvyy(ig)+ytmp
+            gcmz(ig)=tstep*gvzz(ig)+ztmp
+
+          enddo
+
+c     merge group coms from all nodes
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     rotate rigid groups: nosquish algorithm
+
+          jr=0
+          do ig=igrp1,igrp2
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+          enddo
+
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+          
+          k=0
+          do ig=igrp1,igrp2
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            id=lstgtp(ig)
+            
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=gcmx(ig)+
+     x          rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+              yyy(i)=gcmy(ig)+
+     x          rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+              zzz(i)=gcmz(ig)+
+     x          rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+              
+            enddo
+            
+          enddo
+          
+c     update positions of free particles
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            xxx(i)=tstep*vxx(i)+
+     x        eta(1)*xxx(i)+eta(4)*yyy(i)+eta(7)*zzz(i)
+            yyy(i)=tstep*vyy(i)+
+     x        eta(2)*xxx(i)+eta(5)*yyy(i)+eta(8)*zzz(i)
+            zzz(i)=tstep*vzz(i)+
+     x        eta(3)*xxx(i)+eta(6)*yyy(i)+eta(9)*zzz(i)
+            
+          enddo
+          
+c     merge position data
+
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+          
+c     apply shake corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+
+          endif
+
+          if(iter.lt.mxiter)then
+
+            do i=1,natms
+
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+
+            enddo
+            do ig=1,ngrp
+
+              q0(ig)=b0(ig)
+              q1(ig)=b1(ig)
+              q2(ig)=b2(ig)
+              q3(ig)=b3(ig)
+              p0(ig)=c0(ig)
+              p1(ig)=c1(ig)
+              p2(ig)=c2(ig)
+              p3(ig)=c3(ig)
+              gcmx(ig)=gxo(ig)
+              gcmy(ig)=gyo(ig)
+              gcmz(ig)=gzo(ig)
+
+            enddo
+
+          endif
+
+        enddo
+
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        
+        do kk=1,ntpatm
+          dens(kk)=dens0(kk)*(volm0/volm)
+        enddo
+
+c     end of first stage of velocity verlet algorithm
+
+      else
+
+c     second stage of velocity verlet algorithm
+
+        jr=0
+        do ig=igrp1,igrp2
+
+c     new angular momenta and velocities
+          
+          opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x      q3(ig)*p2(ig)-q2(ig)*p3(ig))
+          opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x      q0(ig)*p2(ig)+q1(ig)*p3(ig))
+          opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x      q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+          id=lstgtp(ig)
+
+          omx(ig)=opx*rotinx(id,2)
+          omy(ig)=opy*rotiny(id,2)
+          omz(ig)=opz*rotinz(id,2)
+          
+c     new rotation matrix
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            
+c     new atomic velocites in body frame
+
+            vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+            vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+            vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+
+c     new atomic velocites in lab frame
+            
+            vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+            vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+            vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+            
+          enddo
+          
+        enddo
+
+c     merge velocities and forces from all nodes
+
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     correct constraint bond velocities using rattle
+
+        if(ntcons.gt.0)then
+
+          safe=.false.
+          call rdrattle_v
+     x      (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x      dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+          if(.not.safe)return
+
+        endif
+
+c     calculate rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     calculate kinetic energy
+        
+        if(isw.eq.2)then
+
+          engfke=getkinf(ntfree,idnode,mxnode)
+          call getking(ngrp,idnode,mxnode,engtrn,engrot)
+          engtke=engfke+engtrn+engrot
+          engke=engfke+engtrn
+
+c     apply Berendsen thermostat - taut is the relaxation time
+          
+          chit=sqrt(1.d0+tstep/taut*(sigma/engtke-1.d0))
+          
+          engke=engke*chit**2
+          engtrn=engtrn*chit**2
+          engrot=engrot*chit**2
+          
+c     thermostat velocities 
+          
+          do i=iatm0,iatm1
+            
+            if(lstfrz(i).eq.0)then
+
+              vxx(i)=chit*vxx(i)
+              vyy(i)=chit*vyy(i)
+              vzz(i)=chit*vzz(i)
+              
+            endif
+            
+          enddo
+
+c     merge velocities from all nodes
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+
+c     thermostat rigid body velocities
+
+          do ig=igrp1,igrp2
+            
+            omx(ig)=chit*omx(ig)
+            omy(ig)=chit*omy(ig)
+            omz(ig)=chit*omz(ig)
+            gvxx(ig)=chit*gvxx(ig)
+            gvyy(ig)=chit*gvyy(ig)
+            gvzz(ig)=chit*gvzz(ig)
+
+          enddo
+
+c     merge group velocities from all processors
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+
+c     kinetic contribution to stress tensor
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)        
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+          
+c     add contributions to stress tensor
+          
+          do i=1,9
+            stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+          enddo
+          
+        endif
+
+c     end of second stage of velocity verlet algorithm
+        
+      endif
+      
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+
+c     deallocate working arrays
+
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(2))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(3))
+        
+        if(isw.eq.1)then
+          
+          deallocate(vxo,vyo,vzo,b0,b1,b2,b3,stat=fail(4))
+          deallocate(xxo,yyo,zzo,c0,c1,c2,c3,stat=fail(5))
+          deallocate(gxo,gyo,gzo,stat=fail(6))
+          
+        endif
+        
+      endif
+      
+      return
+      end subroutine nstqvv_b1
+
+      subroutine nstqvv_h1
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x  ntcons,ntpatm,ntfree,mode,ntshl,keyshl,tstep,taut,taup,
+     x  sigma,temp,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x  vircon,virlrc,vircom,volm,press,chit_shl,sigma_shl)
+      
+c***********************************************************************
+c     
+c     dlpoly routine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints - provided rigid body sites
+c     and constraint sites do not coincide.
+c     
+c     nst ensemble - nose-hoover thermostat Molec Phys 87 (1996) 1117
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith may 2005
+c     adapted     d.quigley : metadynamics
+c     
+c**********************************************************************
+
+      implicit none
+
+      integer, parameter :: nnn=12
+      integer, parameter :: ncyc=5
+      real(8), parameter :: pt5=0.5d0
+
+      logical safe,lshmov,newjob
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons,ntfree
+      integer ifre1,ifre2,igrp1,igrp2,igrp,i,j,k,jr,mode
+      integer id,ig,ifre,jrs,idum,mxiter,iter,ntpatm,kk,icyc
+      real(8) chit,consv,conint,engke,engrot,taut,sigma,tolnce,tstep
+      real(8) vircom,vircon,hstep,qmass,opx,opy,opz,fmx,fmy,fmz,engtrn
+      real(8) ftx,fty,ftz,tqx,tqy,tqz,qt0,qt1,qt2,qt3,vaa,vbb,vcc
+      real(8) taup,temp,press,vzero,chit0,cons0
+      real(8) chip2,volm,elrc,elrc0,virlrc,virlrc0,qstep,pmass,totmas
+      real(8) volm0,cxx,cyy,czz,engfke,fstep
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),com(3),vom(3)
+      real(8) czero(9),eta0(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: oxo(:),oyo(:),ozo(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+      
+      save newjob,hstep,qstep,fstep,pmass,qmass
+      save p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2,volm0,elrc0,virlrc0
+      save totmas,dens0
+
+      data newjob/.true./
+      
+      safe=.true.
+      if(newjob)then
+
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2280)
+
+c     store intitial parameters
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        hstep=0.5d0*tstep
+        fstep=0.5d0*tstep/dble(ncyc)
+        qstep=0.25d0*tstep/dble(ncyc)
+        
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     total system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+
+c     nose-hoover thermostat and barostat inertia parameter
+        
+        qmass=2.d0*sigma*taut**2
+        pmass=2.d0*sigma*taup**2
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call error(idnode,506)
+        endif
+
+      endif
+
+      if(ntcons.gt.0)safe=.false.
+      
+c     allocate working arrays
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(1))
+      if(ntcons.gt.0)then
+
+        allocate(gxo(mxgrp),gyo(mxgrp),gzo(mxgrp),stat=fail(2))
+        allocate(oxo(mxgrp),oyo(mxgrp),ozo(mxgrp),stat=fail(3))
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(4))
+        allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(5))
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(6))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(7))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(8))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(9))
+        allocate(b0(mxgrp),b1(mxgrp),b2(mxgrp),b3(mxgrp),stat=fail(10))
+        allocate(gvxo(mxgrp),gvyo(mxgrp),gvzo(mxgrp),stat=fail(11))
+
+      endif
+      if(newjob)then
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(12))
+      endif
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2290)
+      enddo
+
+      newjob=.false.
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+      
+      if(ntcons.gt.0)then
+
+c     construct current bond vectors
+        
+        do k=1,nscons
+
+c     indices of atoms in bond
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+c     calculate current bond vector
+          
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+        
+c     periodic boundary condition for bond vectors
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     first stage of velocity verlet algorithm
+
+      if(isw.eq.1)then
+
+c     remove system centre of mass velocity
+        
+        call getvom(natms,idnode,mxnode,totmas,vom)
+        
+        do i=1,natms
+          
+          vxx(i)=vxx(i)-vom(1)
+          vyy(i)=vyy(i)-vom(2)
+          vzz(i)=vzz(i)-vom(3)
+          
+        enddo
+        
+        do ig=1,ngrp
+          
+          gvxx(ig)=gvxx(ig)-vom(1)
+          gvyy(ig)=gvyy(ig)-vom(2)
+          gvzz(ig)=gvzz(ig)-vom(3)
+          
+        enddo
+
+c     store current integration variables if ntcons > 0
+        
+        if(ntcons.gt.0)then
+          
+          vzero=volm
+          chit0=chit
+          cons0=conint
+          do i=1,9
+
+            eta0(i)=eta(i)
+            czero(i)=cell(i)
+
+          enddo
+          do i=1,natms
+            
+            xxo(i)=xxx(i)
+            yyo(i)=yyy(i)
+            zzo(i)=zzz(i)
+            vxo(i)=vxx(i)
+            vyo(i)=vyy(i)
+            vzo(i)=vzz(i)
+            
+          enddo
+          do ig=1,ngrp
+            
+            b0(ig)=q0(ig)
+            b1(ig)=q1(ig)
+            b2(ig)=q2(ig)
+            b3(ig)=q3(ig)
+            oxo(ig)=omx(ig)
+            oyo(ig)=omy(ig)
+            ozo(ig)=omz(ig)
+            gxo(ig)=gcmx(ig)
+            gyo(ig)=gcmy(ig)
+            gzo(ig)=gcmz(ig)
+            gvxo(ig)=gvxx(ig)
+            gvyo(ig)=gvyy(ig)
+            gvzo(ig)=gvzz(ig)
+            
+          enddo
+          
+        endif
+        
+      endif
+
+c     iteration necessary if ntcons > 0 and isw=1
+
+      mxiter=1
+      if(isw.eq.1.and.ntcons.gt.0)mxiter=3
+      do iter=1,mxiter
+
+        if(isw.eq.1)then
+
+          do icyc=1,ncyc
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,
+     x        temp,sigma,qstep,pmass,qmass,taut,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply nst barostat
+            
+            call nstqscl_p
+     x        (idnode,mxnode,ntfree,ngrp,mode,fstep,pmass,chit,
+     x        press,volm)
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,
+     x        temp,sigma,qstep,pmass,qmass,taut,chit,conint)
+          
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+          
+          engke=engfke+engtrn
+          
+c     calculate quaternion momenta
+          
+          do ig=igrp1,igrp2
+            
+            id=lstgtp(ig)
+            opx=omx(ig)*rotinx(id,1)
+            opy=omy(ig)*rotiny(id,1)
+            opz=omz(ig)*rotinz(id,1)
+            p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+            p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+            p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+            p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+            
+          enddo
+          
+        endif
+
+c     update free atom velocities 
+
+        do ifre=ifre1,ifre2
+
+          i=lstfre(ifre)
+          vxx(i)=vxx(i)+hstep*rmass(i)*fxx(i)
+          vyy(i)=vyy(i)+hstep*rmass(i)*fyy(i)
+          vzz(i)=vzz(i)+hstep*rmass(i)*fzz(i)
+          
+        enddo
+
+c     *************  Rigid body motion ****************************
+
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     calculate com force arrays 
+          
+          jrs=jr
+          fmx=0.d0
+          fmy=0.d0
+          fmz=0.d0
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            fmx=fmx+fxx(i)
+            fmy=fmy+fyy(i)
+            fmz=fmz+fzz(i)
+
+          enddo
+
+c     current rotation matrix 
+          
+          call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     calculate torque in principal frame
+
+          jr=jrs
+          ftx=0.d0
+          fty=0.d0
+          ftz=0.d0
+          do j=1,numgsit(id)
+
+            jr=jr+1
+            i=lstrgd(jr)
+            ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+
+          enddo
+          tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+          tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+          tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+          qt0=2.0d0*(-q1(ig)*tqx-q2(ig)*tqy-q3(ig)*tqz)
+          qt1=2.0d0*( q0(ig)*tqx-q3(ig)*tqy+q2(ig)*tqz)
+          qt2=2.0d0*( q3(ig)*tqx+q0(ig)*tqy-q1(ig)*tqz)
+          qt3=2.0d0*(-q2(ig)*tqx+q1(ig)*tqy+q0(ig)*tqz)
+
+c     update quaternion momenta by 1/2 time step
+
+          p0(ig)=p0(ig)+qt0*hstep
+          p1(ig)=p1(ig)+qt1*hstep
+          p2(ig)=p2(ig)+qt2*hstep
+          p3(ig)=p3(ig)+qt3*hstep
+
+c     update centre of mass velocity by 1/2 time step
+
+          gvxx(ig)=gvxx(ig)+fmx*hstep/gmass(id)
+          gvyy(ig)=gvyy(ig)+fmy*hstep/gmass(id)
+          gvzz(ig)=gvzz(ig)+fmz*hstep/gmass(id)
+
+        enddo
+
+        if(isw.eq.1)then
+
+c     calculate system centre of mass
+          
+          call getcom(natms,idnode,mxnode,totmas,com)
+
+c     move centre of mass by full time step
+
+          do ig=igrp1,igrp2
+
+            cxx=gcmx(ig)-com(1)
+            cyy=gcmy(ig)-com(2)
+            czz=gcmz(ig)-com(3)
+            gcmx(ig)=gcmx(ig)+
+     x        tstep*(gvxx(ig)+eta(1)*cxx+eta(4)*cyy+eta(7)*czz)
+            gcmy(ig)=gcmy(ig)+
+     x        tstep*(gvyy(ig)+eta(2)*cxx+eta(5)*cyy+eta(8)*czz)
+            gcmz(ig)=gcmz(ig)+
+     x        tstep*(gvzz(ig)+eta(3)*cxx+eta(6)*cyy+eta(9)*czz)
+
+          enddo
+
+c     merge group coms from all nodes
+
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     rotate rigid groups: nosquish algorithm
+
+          do ig=igrp1,igrp2
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+          enddo
+
+c     new atomic positions for atoms in rigid bodies-relative to c.o.m
+          
+          k=0
+          do ig=igrp1,igrp2
+
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            id=lstgtp(ig)
+
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+rot(3)*gzz(id,j)
+     x          +gcmx(ig)
+              yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+rot(6)*gzz(id,j)
+     x          +gcmy(ig)
+              zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+rot(9)*gzz(id,j)
+     x          +gcmz(ig)
+
+            enddo
+            
+          enddo
+
+c     update positions of free particles
+          
+          do ifre=ifre1,ifre2
+            
+            k=k+1
+            i=lstfre(ifre)
+            cxx=xxx(i)-com(1)
+            cyy=yyy(i)-com(2)
+            czz=zzz(i)-com(3)
+            xxx(i)=xxx(i)+
+     x        tstep*(vxx(i)+eta(1)*cxx+eta(4)*cyy+eta(7)*czz)
+            yyy(i)=yyy(i)+
+     x        tstep*(vyy(i)+eta(2)*cxx+eta(5)*cyy+eta(8)*czz)
+            zzz(i)=zzz(i)+
+     x        tstep*(vzz(i)+eta(3)*cxx+eta(6)*cyy+eta(9)*czz)
+            
+          enddo
+          
+c     merge position data
+
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply shake corrections to bond constraints
+
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     subtract old constraint terms from stress tensor
+            
+            do i=1,9
+              stress(i)=stress(i)-strcns(i)
+            enddo
+            
+c     correct constraint bonds using rattle
+
+            safe=.false.
+            call rdrattle_r
+     x        (safe,lshmov,idnode,imcon,mxnode,natms,nscons,
+     x        tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,
+     x        txx,tyy,tzz,xxt,yyt,zzt,strcns)
+            if(.not.safe)return
+
+c     add new constraint terms to stress tensor
+
+            do i=1,9
+              stress(i)=stress(i)+strcns(i)
+            enddo
+
+          endif
+
+c     restore original integration parameters if iter < mxiter
+
+          if(iter.lt.mxiter)then
+            
+            volm=vzero
+            chit=chit0
+            conint=cons0
+            do i=1,9
+              
+              eta(i)=eta0(i)
+              cell(i)=czero(i)
+              
+            enddo
+            do i=1,natms
+              
+              xxx(i)=xxo(i)
+              yyy(i)=yyo(i)
+              zzz(i)=zzo(i)
+              vxx(i)=vxo(i)
+              vyy(i)=vyo(i)
+              vzz(i)=vzo(i)
+              
+            enddo
+            do ig=1,ngrp
+              
+              q0(ig)=b0(ig)
+              q1(ig)=b1(ig)
+              q2(ig)=b2(ig)
+              q3(ig)=b3(ig)
+              omx(ig)=oxo(ig)
+              omy(ig)=oyo(ig)
+              omz(ig)=ozo(ig)
+              gcmx(ig)=gxo(ig)
+              gcmy(ig)=gyo(ig)
+              gcmz(ig)=gzo(ig)
+              gvxx(ig)=gvxo(ig)
+              gvyy(ig)=gvyo(ig)
+              gvzz(ig)=gvzo(ig)
+              
+            enddo
+
+          endif
+
+        endif
+
+c     operations for second stage only
+
+        if(isw.eq.2)then
+          
+          jr=0
+          do ig=igrp1,igrp2
+            
+c     new angular momenta and velocities
+            
+            opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x        q3(ig)*p2(ig)-q2(ig)*p3(ig))
+            opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x        q0(ig)*p2(ig)+q1(ig)*p3(ig))
+            opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x        q1(ig)*p2(ig)+q0(ig)*p3(ig))
+            
+            id=lstgtp(ig)
+            
+            omx(ig)=opx*rotinx(id,2)
+            omy(ig)=opy*rotiny(id,2)
+            omz(ig)=opz*rotinz(id,2)
+            
+c     new rotation matrix
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              
+c     new atomic velocites in body frame
+              
+              vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+              vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+              vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+              
+c     new atomic velocites in lab frame
+              
+              vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+              vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+              vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     merge velocities from all nodes
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+          
+c     correct constraint bond velocities using rattle
+          
+          if(ntcons.gt.0)then
+            
+            safe=.false.
+            call rdrattle_v
+     x        (safe,idnode,mxnode,natms,nscons,tolnce,tstep,
+     x        dxx,dyy,dzz,txx,tyy,tzz,xxt,yyt,zzt)
+            if(.not.safe)return
+            
+c     add constraint terms to stress tensor
+
+            do i=1,9
+              stress(i)=stress(i)+strcns(i)
+            enddo
+
+          endif
+          
+c     kinetic terms for stress tensor
+        
+          call kinstressf(ntfree,idnode,mxnode,strkin)        
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     calculate rigid body contribution to stress tensor
+
+          call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     add contributions to stress tensor
+          
+          do i=1,9
+            stress(i)=stress(i)+strkin(i)+strgrp(i)+strbod(i)
+          enddo
+          
+          do icyc=1,ncyc
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,
+     x        temp,sigma,qstep,pmass,qmass,taut,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply nst barostat
+            
+            call nstqscl_p
+     x        (idnode,mxnode,ntfree,ngrp,mode,fstep,pmass,chit,
+     x        press,volm)
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,
+     x        temp,sigma,qstep,pmass,qmass,taut,chit,conint)
+          
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+          
+          engke=engfke+engtrn
+          
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+c     conserved quantity less kinetic and potential energy terms
+
+          chip2=sdot0(9,eta,eta)
+          if(mode.eq.2)chip2=chip2-eta(1)**2
+          consv=conint+0.5d0*qmass*chit**2+0.5d0*pmass*chip2+press*volm
+          
+c     metadynamics shell thermostat
+
+          if(lmetadyn.and.keyshl.eq.1)then
+            consv=consv+0.5d0*qmass_shl*chit_shl**2
+          endif
+          
+c     end of second stage of velocity verlet algorithm
+          
+        endif
+        
+c     end of iteration cycle
+
+      enddo
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      do kk=1,ntpatm
+        dens(kk)=dens0(kk)*(volm0/volm)
+      enddo
+      
+c     deallocate working arrays
+      
+      deallocate(dtx,dty,dtz,stat=fail(1))
+      
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(3))
+        deallocate(xxt,yyt,zzt,dxt,dyt,dzt,stat=fail(4))
+        deallocate(xxo,yyo,zzo,oxo,oyo,ozo,stat=fail(5))
+        deallocate(vxo,vyo,vzo,b0,b1,b2,b3,stat=fail(6))
+        deallocate(gxo,gyo,gzo,gvxo,gvyo,gvzo,stat=fail(7))
+
+      endif
+      
+      return
+      end subroutine nstqvv_h1
+      
+      end module vv_rotation1_module
+
diff -urN dl_class_1.9.orig/srcmod/vv_rotation2_module.f dl_class_1.9/srcmod/vv_rotation2_module.f
--- dl_class_1.9.orig/srcmod/vv_rotation2_module.f	1970-01-01 01:00:00.000000000 +0100
+++ dl_class_1.9/srcmod/vv_rotation2_module.f	2011-02-22 12:46:30.000000000 +0100
@@ -0,0 +1,5924 @@
+      module vv_rotation2_module
+      
+c***********************************************************************
+c     
+c     dl_poly module 2 for velocity verlet rotational integration 
+c     schemes
+c     copyright - daresbury laboratory
+c     author    - w. smith    aug 2006
+c     adapted   - d. quigley - metadynamics
+c     
+c***********************************************************************
+      
+      use config_module
+      use ensemble_tools_module
+      use error_module
+      use metafreeze_module, only : lmetadyn
+      use property_module
+      use rigid_body_module
+      use setup_module
+      use shake_module
+      use site_module
+      use vv_rotation1_module
+      use utility_module
+      
+      contains
+      
+      subroutine qrattle_r
+     x  (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x  nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x  dzt,txx,tyy,tzz,xxt,yyt,zzt,stresh)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for applying bond constraint corrections after
+c     atomic integration in the velocity verlet scheme. assumes rigid
+c     bodies connected by constraints.  must be used in conjunction with
+c     velocity verlet integration algorithm. note the iteration is
+c     handled by the calling routine.
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith february 2005
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical safe,lshmov,newstep,newjob
+      integer fail,idnode,imcon,mxnode,natms,nscons,i,j,k,ik
+      real(8) tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,dzt,txx,tyy
+      real(8) tzz,xxt,yyt,zzt,stresh,strs1,strs2,strs3,strs5,strs6
+      real(8) strs9,tstep2,esig,dis2,tqa,tqb,gamma,dli,dlj
+
+      real(8), allocatable :: esig1(:),ggx(:),ggy(:),ggz(:)
+
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension dxx(mxcons),dyy(mxcons),dzz(mxcons)
+      dimension dxt(mxcons),dyt(mxcons),dzt(mxcons)
+      dimension stresh(9),tqa(3),tqb(3)
+
+      save newjob,esig1,ggx,ggy,ggz
+
+      data newjob/.true./,fail/0/
+      
+      if(newjob)then
+        
+        allocate (esig1(mxcons),ggx(mxcons),ggy(mxcons),ggz(mxcons),
+     x    stat=fail)
+        if(fail.ne.0)call error(idnode,1615)
+        newjob=.false.
+
+      endif
+
+c     accumulators for stress tensor
+
+      strs1=0.d0
+      strs2=0.d0
+      strs3=0.d0
+      strs5=0.d0
+      strs6=0.d0
+      strs9=0.d0
+
+c     timestep squared
+      
+      tstep2=tstep*tstep
+
+c     constraint bond vectors are dxx,dyy,dzz (input)
+      
+
+      do k=1,nscons
+        
+        i=listcon(k,2)
+        j=listcon(k,3)
+
+c     calculate temporary bond vector
+        
+        dxt(k)=xxx(i)-xxx(j)
+        dyt(k)=yyy(i)-yyy(j)
+        dzt(k)=zzz(i)-zzz(j)
+        
+      enddo
+      
+c     periodic boundary condition
+      
+      call images(imcon,0,1,nscons,cell,dxt,dyt,dzt)
+
+c     calculate maximum error in bondlength
+      
+      esig=0.d0
+      do k=1,nscons
+
+        dis2=prmcon(listcon(k,1))**2
+        esig1(k)=(dis2-(dxt(k)**2+dyt(k)**2+dzt(k)**2))/dis2
+        esig=max(esig,abs(esig1(k)))
+
+      enddo
+      
+c     global verification of convergence
+
+      safe=(esig.lt.tolnce)
+      
+      if(mxnode.gt.1)call gstate(safe)
+
+c     continue if any tolerances unsatisfied 
+      
+      if(.not.safe)then
+
+c     initialise force increment arrays
+        
+        do i=1,natms
+          
+          xxt(i)=0.d0
+          yyt(i)=0.d0
+          zzt(i)=0.d0
+          
+        enddo
+
+c     calculate constraint forces
+        
+        ik=0
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dis2=prmcon(listcon(k,1))**2
+
+          if(newstep)then
+
+            call pivot(1,i,k,ik,tqa,dxx,dyy,dzz)
+            call pivot(1,j,k,ik,tqb,dxx,dyy,dzz)
+
+            ggx(k)=tstep2*(tqa(1)+tqb(1))/dis2
+            ggy(k)=tstep2*(tqa(2)+tqb(2))/dis2
+            ggz(k)=tstep2*(tqa(3)+tqb(3))/dis2
+
+          endif
+
+c     constraint force parameter 
+          
+          gamma=esig1(k)/(dxt(k)*ggx(k)+dyt(k)*ggy(k)+dzt(k)*ggz(k))
+          
+c     accumulate bond virial
+          
+          vircon=vircon-gamma*(dxx(k)**2+dyy(k)**2+dzz(k)**2)
+
+          strs1=strs1+gamma*dxx(k)*dxx(k)
+          strs2=strs2+gamma*dxx(k)*dyy(k)
+          strs3=strs3+gamma*dxx(k)*dzz(k)
+          strs5=strs5+gamma*dyy(k)*dyy(k)
+          strs6=strs6+gamma*dyy(k)*dzz(k)
+          strs9=strs9+gamma*dzz(k)*dzz(k)
+
+c     improved atomic force
+          
+          xxt(i)=xxt(i)+dxx(k)*gamma
+          yyt(i)=yyt(i)+dyy(k)*gamma
+          zzt(i)=zzt(i)+dzz(k)*gamma
+          xxt(j)=xxt(j)-dxx(k)*gamma
+          yyt(j)=yyt(j)-dyy(k)*gamma
+          zzt(j)=zzt(j)-dzz(k)*gamma
+          
+        enddo
+        
+c     transport temporary positions to other nodes
+        
+        if(mxnode.gt.1)then
+          
+          if(lshmov) call shmove
+     x      (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x      txx,tyy,tzz,buffer)
+          
+        endif
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dli=1.d0/dble(listme(i))
+          dlj=1.d0/dble(listme(j))
+
+          fxx(i)=fxx(i)+xxt(i)*dli
+          fyy(i)=fyy(i)+yyt(i)*dli
+          fzz(i)=fzz(i)+zzt(i)*dli
+          fxx(j)=fxx(j)+xxt(j)*dlj
+          fyy(j)=fyy(j)+yyt(j)*dlj
+          fzz(j)=fzz(j)+zzt(j)*dlj
+          
+        enddo
+
+c     complete stress tensor
+        
+        stresh(1)=stresh(1)+strs1
+        stresh(2)=stresh(2)+strs2
+        stresh(3)=stresh(3)+strs3
+        stresh(4)=stresh(4)+strs2
+        stresh(5)=stresh(5)+strs5
+        stresh(6)=stresh(6)+strs6
+        stresh(7)=stresh(7)+strs3
+        stresh(8)=stresh(8)+strs6
+        stresh(9)=stresh(9)+strs9
+        
+c     splice force arrays across nodes
+
+        if(mxnode.gt.1)then
+
+          call splice 
+     x      (idnode,natms,listme,listot,fxx,fyy,fzz,buffer)
+          
+        endif
+        
+
+      endif
+      
+      return
+      end subroutine qrattle_r
+
+      subroutine qrattle_v
+     x  (newstep,safe,lshmov,idnode,mxnode,natms,
+     x  nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x  xxt,yyt,zzt)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for applying bond constraint corrections after
+c     atomic integration in the velocity verlet scheme. assumes rigid
+c     bodies connected by constraints.  must be used in conjunction with
+c     velocity verlet integration algorithm. note the iteration is
+c     handled by the calling routine.
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith february 2005
+c     
+c***********************************************************************
+
+      implicit none
+      
+      logical safe,lshmov,newstep,newjob
+      integer fail,idnode,mxnode,natms,nscons,i,j,k,ik
+      real(8) tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,tqa,tqb
+      real(8) xxt,yyt,zzt,tstep2,esig,gamma,dli,dlj
+      real(8) tolvel
+
+      real(8), allocatable :: esig2(:),hhx(:),hhy(:),hhz(:)
+
+      dimension xxt(mxatms),yyt(mxatms),zzt(mxatms)
+      dimension txx(mxatms),tyy(mxatms),tzz(mxatms)
+      dimension dxx(mxcons),dyy(mxcons),dzz(mxcons)
+      dimension tqa(3),tqb(3)
+
+      save newjob,esig2,hhx,hhy,hhz
+
+      data newjob/.true./,fail/0/
+      
+      if(newjob)then
+        
+        allocate (esig2(mxcons),hhx(mxcons),hhy(mxcons),hhz(mxcons),
+     x    stat=fail)
+        if(fail.ne.0)call error(idnode,1625)
+        newjob=.false.
+
+      endif
+
+c     constraint bond vectors are dxx,dyy,dzz (input)
+      
+c     half timestep
+      
+      tstep2=tstep/2.d0
+
+c     tolerance for velocity convergence
+
+      tolvel=tolnce/tstep
+
+c     calculate maximum error in constraint
+      
+      esig=0.d0
+      do k=1,nscons
+
+        i=listcon(k,2)
+        j=listcon(k,3)
+        esig2(k)=(dxx(k)*(vxx(i)-vxx(j))+dyy(k)*(vyy(i)-vyy(j))+
+     x    dzz(k)*(vzz(i)-vzz(j)))
+        esig=max(esig,abs(esig2(k)))
+
+      enddo
+      
+c     global verification of convergence
+
+      safe=(esig.lt.tolvel)
+      
+      if(mxnode.gt.1)then
+        call gstate(safe)
+      endif
+
+c     continue if all tolerances satisfied else return to calling routine 
+      
+      if(.not.safe)then
+
+c     initialise velocity correction arrays
+        
+        do i=1,natms
+          
+          xxt(i)=0.d0
+          yyt(i)=0.d0
+          zzt(i)=0.d0
+          
+        enddo
+
+c     calculate constraint correction
+        
+        ik=0
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+
+          if(newstep)then
+
+            call pivot(2,i,k,ik,tqa,dxx,dyy,dzz)
+            call pivot(2,j,k,ik,tqb,dxx,dyy,dzz)
+
+            hhx(k)=tstep2*(tqa(1)+tqb(1))
+            hhy(k)=tstep2*(tqa(2)+tqb(2))
+            hhz(k)=tstep2*(tqa(3)+tqb(3))
+
+          endif
+
+c     constraint force parameter 
+          
+          gamma=esig2(k)/(dxx(k)*hhx(k)+dyy(k)*hhy(k)+dzz(k)*hhz(k))
+
+c     improved atomic force
+          
+          xxt(i)=xxt(i)-dxx(k)*gamma
+          yyt(i)=yyt(i)-dyy(k)*gamma
+          zzt(i)=zzt(i)-dzz(k)*gamma
+          xxt(j)=xxt(j)+dxx(k)*gamma
+          yyt(j)=yyt(j)+dyy(k)*gamma
+          zzt(j)=zzt(j)+dzz(k)*gamma
+          
+        enddo
+        
+c     transport temporary positions to other nodes
+        
+        if(mxnode.gt.1)then
+          
+          if(lshmov) call shmove
+     x      (idnode,mxnode,natms,lashap,lishap,xxt,yyt,zzt,
+     x      txx,tyy,tzz,buffer)
+          
+        endif
+        
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          
+          dli=1.d0/dble(listme(i))
+          dlj=1.d0/dble(listme(j))
+
+          fxx(i)=fxx(i)+dli*xxt(i)
+          fyy(i)=fyy(i)+dli*yyt(i)
+          fzz(i)=fzz(i)+dli*zzt(i)
+          fxx(j)=fxx(j)+dlj*xxt(j)
+          fyy(j)=fyy(j)+dlj*yyt(j)
+          fzz(j)=fzz(j)+dlj*zzt(j)
+          
+        enddo
+
+c     splice force arrays across nodes
+        
+        if(mxnode.gt.1)then
+
+          call splice 
+     x      (idnode,natms,listme,listot,fxx,fyy,fzz,buffer)
+          
+        endif
+
+      endif
+      
+      return
+      end subroutine qrattle_v
+
+      subroutine pivot(k,i,kk,ik,tqq,dxx,dyy,dzz)
+
+c***********************************************************************
+c     
+c     dl_poly subroutine for computing pivot vector for velocity
+c     corrections to bonds between rigid bodies
+c     must be used in conjunction with qrattle routines:
+c     if k=1 - use with qrattle_r
+c     if k=2 - use with qrattle_v
+c     
+c     copyright - daresbury laboratory
+c     author    - w. smith february 2005
+c     
+c***********************************************************************
+
+      implicit none
+
+      integer k,i,kk,ik,ig,id,jj
+      real(8) xxa,yya,zza,tax,tay,taz,trx,try,trz,vix,viy,viz
+      real(8) rot(9),tqq(3),dxx(mxcons),dyy(mxcons),dzz(mxcons)
+
+      ig=lstbod(i)
+
+      if(ig.eq.0)then
+
+c     atoms in constraint bonds
+        
+        tqq(1)=dxx(kk)*rmass(i)
+        tqq(2)=dyy(kk)*rmass(i)
+        tqq(3)=dzz(kk)*rmass(i)
+        
+      else
+
+c     terms for rigid body atoms
+
+        ik=ik+1
+        id=lstgtp(ig)
+
+        tqq(1)=dxx(kk)/gmass(id)
+        tqq(2)=dyy(kk)/gmass(id)
+        tqq(3)=dzz(kk)/gmass(id)
+
+        call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+        
+        jj=lstcsit(ik)
+
+c     com-site vector in lab frame
+
+        xxa=(gxx(id,jj)*rot(1)+gyy(id,jj)*rot(2)+gzz(id,jj)*rot(3))
+        yya=(gxx(id,jj)*rot(4)+gyy(id,jj)*rot(5)+gzz(id,jj)*rot(6))
+        zza=(gxx(id,jj)*rot(7)+gyy(id,jj)*rot(8)+gzz(id,jj)*rot(9))
+
+c     cross product of com-site vector and interatomic vector
+        
+        tax=yya*dzz(kk)-zza*dyy(kk)
+        tay=zza*dxx(kk)-xxa*dzz(kk)
+        taz=xxa*dyy(kk)-yya*dxx(kk)
+
+c     transform to body fixed frame
+        
+        trx=(tax*rot(1)+tay*rot(4)+taz*rot(7))*rotinx(id,2)
+        try=(tax*rot(2)+tay*rot(5)+taz*rot(8))*rotiny(id,2)
+        trz=(tax*rot(3)+tay*rot(6)+taz*rot(9))*rotinz(id,2)
+
+        if(k.eq.1)then
+
+c     direction of induced velocites in body frame
+          
+          vix=try*gzz(id,jj)-trz*gyy(id,jj)
+          viy=trz*gxx(id,jj)-trx*gzz(id,jj)
+          viz=trx*gyy(id,jj)-try*gxx(id,jj)
+          
+c     transform to lab frame
+          
+          tqq(1)=tqq(1)+vix*rot(1)+viy*rot(2)+viz*rot(3)
+          tqq(2)=tqq(2)+vix*rot(4)+viy*rot(5)+viz*rot(6)
+          tqq(3)=tqq(3)+vix*rot(7)+viy*rot(8)+viz*rot(9)
+
+        elseif(k.eq.2)then
+
+c     transform to lab frame
+
+          tqq(1)=tqq(1)+trx*rot(1)+try*rot(2)+trz*rot(3)
+          tqq(2)=tqq(2)+trx*rot(4)+try*rot(5)+trz*rot(6)
+          tqq(3)=tqq(3)+trx*rot(7)+try*rot(8)+trz*rot(9)
+          
+        endif
+
+      endif
+
+      return
+      end subroutine pivot
+
+      subroutine nveqvv_2
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,tolnce,tstep,vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith   jan 2005
+c     amended     w.smith   feb 2005: qrattle added
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jg,jr
+      integer id,ifre,jrs,icyc,mxshk,idum,ig
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) engtrn
+      real(8) vaa,vbb,vcc,opx,opy,opz,ftx,fty,ftz
+      real(8) fmx,fmy,fmz,tqx,tqy,tqz,tq0,tq1,tq2,tq3
+
+      integer, parameter :: nnn=13
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+
+      save newstep,newjob,p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2
+
+      data newjob/.true./
+      
+c     set array allocation error flags
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+c     assign initial parameters
+
+      if(newjob)then
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+        newjob=.false.
+
+      endif
+
+c     allocate working arrays
+
+      allocate(gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(2))
+      allocate(vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(3))
+      allocate(b0(msgrp),b1(msgrp),b2(msgrp),b3(msgrp),
+     x  stat=fail(4))
+      allocate(c0(msgrp),c1(msgrp),c2(msgrp),c3(msgrp),
+     x  stat=fail(5))
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(6))
+        allocate(gxo(msgrp),gyo(msgrp),gzo(msgrp),stat=fail(7))
+
+      endif
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(8))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(9))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(10))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(11))
+
+      endif
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(12))
+      if(isw.eq.2)then
+        allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(13))
+      endif
+
+c     check array allocation error flags
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2110)
+      enddo
+
+c     initialise constraint virial
+
+      if(isw.eq.1)then
+
+        vircon=0.d0
+
+        do i=1,9
+          strcns(i)=0.d0
+        enddo
+
+      endif
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     store key config data at start of time step
+
+      if(isw.eq.1)then
+
+c     atom positions
+
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+
+        enddo
+
+c     rigid body positions
+
+        j=0
+        do i=igrp1,igrp2
+          
+          j=j+1
+          gxo(j)=gcmx(i)
+          gyo(j)=gcmy(i)
+          gzo(j)=gcmz(i)
+
+        enddo
+
+      endif
+
+c     store free atom velocities
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+      
+c     store rigid body quaternions, momenta and cartesian velocities
+
+      j=0
+      do i=igrp1,igrp2
+
+        j=j+1
+        b0(j)=q0(i)
+        b1(j)=q1(i)
+        b2(j)=q2(i)
+        b3(j)=q3(i)
+        c0(j)=p0(i)
+        c1(j)=p1(i)
+        c2(j)=p2(i)
+        c3(j)=p3(i)
+        gvxo(j)=gvxx(i)
+        gvyo(j)=gvyy(i)
+        gvzo(j)=gvzz(i)
+
+      enddo
+
+c     store forces if isw = 2
+      
+      if(isw.eq.2)then
+
+        do i=1,natms
+
+          fxo(i)=fxx(i)
+          fyo(i)=fyy(i)
+          fzo(i)=fzz(i)
+
+        enddo
+      
+      endif
+
+c     -------------- start of shake iteration cycle -------------------
+      
+      icyc=0
+      mxshk=1
+      safe=.false.
+      newstep=.true.
+      if(ntcons.gt.0)mxshk=mxshak
+      do while(.not.safe.and.icyc.lt.mxshk)
+        
+        icyc=icyc+1
+
+c     update velocities of free atoms 1/2 timestep
+
+        j=0
+        do ifre=ifre1,ifre2
+          
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=vxo(j)+(pt5*tstep*rmass(i))*fxx(i)
+          vyy(i)=vyo(j)+(pt5*tstep*rmass(i))*fyy(i)
+          vzz(i)=vzo(j)+(pt5*tstep*rmass(i))*fzz(i)
+          
+        enddo
+        
+c     *************  rigid body motion ****************************
+
+c     operations common to first and second stages
+
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     fmx,fmy,fmz represent force on c.o.m.
+          
+          jrs=jr
+          fmx=0.d0
+          fmy=0.d0
+          fmz=0.d0
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            fmx=fmx+fxx(i)
+            fmy=fmy+fyy(i)
+            fmz=fmz+fzz(i)
+            
+          enddo
+
+c     current rotational matrix
+          
+          jg=jg+1
+          call getrotmat(b0(jg),b1(jg),b2(jg),b3(jg),rot)
+
+c     calculate torque in principal frame
+
+          jr=jrs
+          ftx=0.d0
+          fty=0.d0
+          ftz=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+          tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+          tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+          tq0=2.0d0*(-b1(jg)*tqx-b2(jg)*tqy-b3(jg)*tqz)
+          tq1=2.0d0*( b0(jg)*tqx-b3(jg)*tqy+b2(jg)*tqz)
+          tq2=2.0d0*( b3(jg)*tqx+b0(jg)*tqy-b1(jg)*tqz)
+          tq3=2.0d0*(-b2(jg)*tqx+b1(jg)*tqy+b0(jg)*tqz)
+
+c     update quaternion momentum by half timestep
+
+          p0(ig)=c0(jg)+tq0*pt5*tstep
+          p1(ig)=c1(jg)+tq1*pt5*tstep
+          p2(ig)=c2(jg)+tq2*pt5*tstep
+          p3(ig)=c3(jg)+tq3*pt5*tstep
+
+c     update centre of mass velocity by half timestep
+
+          gvxx(ig)=gvxo(jg)+fmx*pt5*tstep/gmass(id)
+          gvyy(ig)=gvyo(jg)+fmy*pt5*tstep/gmass(id)
+          gvzz(ig)=gvzo(jg)+fmz*pt5*tstep/gmass(id)
+          
+        enddo
+
+c     first stage of velocity verlet algorithm
+
+        if(isw.eq.1)then
+
+          jg=0
+          do ig=igrp1,igrp2
+
+            jg=jg+1
+
+c     update centre of mass position by full time step
+            
+            gcmx(ig)=gxo(jg)+tstep*gvxx(ig)
+            gcmy(ig)=gyo(jg)+tstep*gvyy(ig)
+            gcmz(ig)=gzo(jg)+tstep*gvzz(ig)
+            
+c     calculate rotation of rigid groups: nosquish algorithm
+            
+            q0(ig)=b0(jg)
+            q1(ig)=b1(jg)
+            q2(ig)=b2(jg)
+            q3(ig)=b3(jg)
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+            
+          enddo
+
+c     new atomic positions for atoms in rigid bodies - relative to com
+          
+          k=0
+          do ig=igrp1,igrp2
+            
+c     new rotational matrix
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+            
+            id=lstgtp(ig)
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x          rot(3)*gzz(id,j)+gcmx(ig)
+              yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x          rot(6)*gzz(id,j)+gcmy(ig)
+              zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x          rot(9)*gzz(id,j)+gcmz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     update positions of free particles to full time step
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            xxx(i)=xxo(i)+tstep*vxx(i)
+            yyy(i)=yyo(i)+tstep*vyy(i)
+            zzz(i)=zzo(i)+tstep*vzz(i)
+            
+          enddo
+
+c     merge free atom positions
+
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply rattle corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+            call qrattle_r
+     x        (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x        nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x        dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+
+          endif
+          
+c     end of first stage 
+
+        endif
+
+        if(isw.eq.2)then
+          
+c     second stage of velocity verlet algorithm
+          
+          jr=0
+          do ig=igrp1,igrp2
+            
+c     new angular momenta and velocities
+
+            opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x        q3(ig)*p2(ig)-q2(ig)*p3(ig))
+            opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x        q0(ig)*p2(ig)+q1(ig)*p3(ig))
+            opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x        q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+            id=lstgtp(ig)
+
+            omx(ig)=opx*rotinx(id,2)
+            omy(ig)=opy*rotiny(id,2)
+            omz(ig)=opz*rotinz(id,2)
+
+c     new rotational matrix
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     new atomic velocites
+            
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              
+c     new atomic velocites in body frame
+
+              vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+              vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+              vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+              
+c     new atomic velocites in lab frame
+              
+              vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+              vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+              vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     merge velocities and forces from all nodes
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)then
+
+              call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+              call merge1
+     x          (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+              
+            endif
+
+c     correct constraint bond velocities using rattle
+
+            call qrattle_v
+     x        (newstep,safe,lshmov,idnode,mxnode,natms,
+     x        nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x        xxt,yyt,zzt)
+
+          endif
+          
+c     end of second stage
+          
+        endif
+        
+        newstep=.false.
+        
+      enddo
+
+c     check shake convergence
+
+      if(.not.safe)call error(idnode,105)
+
+c     sum constraint virial and stress across processors
+      
+      if(mxnode.gt.1.and.isw.eq.1)then
+        
+        buffer(1)=vircon
+        call gdsum(buffer(1),1,buffer(2))
+        vircon=buffer(1)
+        call gdsum(strcns,9,buffer)
+        
+      endif
+
+c     -------------- end of shake iteration cycle -------------------
+      
+c     calculate kinetic energy
+      
+      if(isw.eq.2)then
+
+        engke=getkinf(ntfree,idnode,mxnode)      
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+
+        engke=engke+engtrn
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+
+      endif
+      
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     restore forces if isw = 2
+
+      if(isw.eq.2)then
+
+        do i=1,natms
+
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+
+        enddo
+      
+      endif
+
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(dtx,dty,dtz,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      if(isw.eq.2)then
+        deallocate(fxo,fyo,fzo,stat=fail(7))
+      endif
+      
+      return
+      end subroutine nveqvv_2
+
+      subroutine nvtqvv_b2
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,engke,engrot,taut,sigma,tolnce,tstep,
+     x  vircom,vircon)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     nvt ensemble - Berendsen thermostat (n.b. not symplectic)
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith   mar 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jg,jr
+      integer id,ifre,jrs,icyc,mxshk,idum,ig
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon,engtke
+      real(8) engtrn
+      real(8) vaa,vbb,vcc,opx,opy,opz,ftx,fty,ftz
+      real(8) fmx,fmy,fmz,tqx,tqy,tqz,tq0,tq1,tq2,tq3,taut,sigma,chit
+
+      integer, parameter :: nnn=13
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+
+      save newstep,newjob,p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2
+
+      data newjob/.true./
+      
+c     set array alocation error flags
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+c     assign initial parameters
+
+      if(newjob)then
+
+c     free atom block indices
+      
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+      
+c     group block indices
+
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+
+c     check work arrays are large enough
+
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+        newjob=.false.
+
+      endif
+
+c     allocate working arrays
+
+      allocate(gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(2))
+      allocate(vxo(msatms),vyo(msatms),vzo(mxatms),stat=fail(3))
+      allocate(b0(msgrp),b1(msgrp),b2(msgrp),b3(msgrp),
+     x  stat=fail(4))
+      allocate(c0(msgrp),c1(msgrp),c2(msgrp),c3(msgrp),
+     x  stat=fail(5))
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(6))
+        allocate(gxo(msgrp),gyo(msgrp),gzo(msgrp),stat=fail(7))
+
+      endif
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(8))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(9))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(10))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(11))
+
+      endif
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(12))
+      if(isw.eq.2)then
+        allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(13))
+      endif
+
+c     check array allocation error flags
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2130)
+      enddo
+
+c     initialise constraint virial
+
+      if(isw.eq.1)then
+
+        vircon=0.d0
+
+        do i=1,9
+          strcns(i)=0.d0
+        enddo
+
+      endif
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     store key config data at start of time step
+
+      if(isw.eq.1)then
+
+c     atom positions
+
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+          
+        enddo
+
+c     rigid body positions
+
+        j=0
+        do i=igrp1,igrp2
+          
+          j=j+1
+          gxo(j)=gcmx(i)
+          gyo(j)=gcmy(i)
+          gzo(j)=gcmz(i)
+
+        enddo
+
+      endif
+
+c     store free atom atom velocities
+
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+
+c     store rigid body quaternions, momenta and cartesian velocities
+
+      j=0
+      do i=igrp1,igrp2
+
+        j=j+1
+        b0(j)=q0(i)
+        b1(j)=q1(i)
+        b2(j)=q2(i)
+        b3(j)=q3(i)
+        c0(j)=p0(i)
+        c1(j)=p1(i)
+        c2(j)=p2(i)
+        c3(j)=p3(i)
+        gvxo(j)=gvxx(i)
+        gvyo(j)=gvyy(i)
+        gvzo(j)=gvzz(i)
+
+      enddo
+
+c     store forces if isw = 2
+
+      if(isw.eq.2)then
+
+        do i=1,natms
+
+          fxo(i)=fxx(i)
+          fyo(i)=fyy(i)
+          fzo(i)=fzz(i)
+
+        enddo
+      
+      endif
+
+c     -------------- start of shake iteration cycle -------------------
+      
+      icyc=0
+      mxshk=1
+      safe=.false.
+      newstep=.true.
+      if(ntcons.gt.0)mxshk=mxshak
+      do while(.not.safe.and.icyc.lt.mxshk)
+        
+        icyc=icyc+1
+        
+c     update velocities of free atoms 1/2 timestep
+
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=vxo(j)+(pt5*tstep*rmass(i))*fxx(i)
+          vyy(i)=vyo(j)+(pt5*tstep*rmass(i))*fyy(i)
+          vzz(i)=vzo(j)+(pt5*tstep*rmass(i))*fzz(i)
+          
+        enddo
+
+c     *************  rigid body motion ****************************
+
+c     operations common to first and second stages
+
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     fmx,fmy,fmz represent force on c.o.m.
+          
+          jrs=jr
+          fmx=0.d0
+          fmy=0.d0
+          fmz=0.d0
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            fmx=fmx+fxx(i)
+            fmy=fmy+fyy(i)
+            fmz=fmz+fzz(i)
+            
+          enddo
+
+c     current rotational matrix
+          
+          jg=jg+1
+          call getrotmat(b0(jg),b1(jg),b2(jg),b3(jg),rot)
+
+c     calculate torque in principal frame
+
+          jr=jrs
+          ftx=0.d0
+          fty=0.d0
+          ftz=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+          tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+          tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+          tq0=2.0d0*(-b1(jg)*tqx-b2(jg)*tqy-b3(jg)*tqz)
+          tq1=2.0d0*( b0(jg)*tqx-b3(jg)*tqy+b2(jg)*tqz)
+          tq2=2.0d0*( b3(jg)*tqx+b0(jg)*tqy-b1(jg)*tqz)
+          tq3=2.0d0*(-b2(jg)*tqx+b1(jg)*tqy+b0(jg)*tqz)
+
+c     update quaternion momentum by half timestep
+
+          p0(ig)=c0(jg)+tq0*pt5*tstep
+          p1(ig)=c1(jg)+tq1*pt5*tstep
+          p2(ig)=c2(jg)+tq2*pt5*tstep
+          p3(ig)=c3(jg)+tq3*pt5*tstep
+
+c     update centre of mass velocity by half timestep
+
+          gvxx(ig)=gvxo(jg)+fmx*pt5*tstep/gmass(id)
+          gvyy(ig)=gvyo(jg)+fmy*pt5*tstep/gmass(id)
+          gvzz(ig)=gvzo(jg)+fmz*pt5*tstep/gmass(id)
+          
+        enddo
+
+c     first stage of velocity verlet algorithm
+
+        if(isw.eq.1)then
+
+          jg=0
+          do ig=igrp1,igrp2
+
+            jg=jg+1
+
+c     update centre of mass position by full time step
+            
+            gcmx(ig)=gxo(jg)+tstep*gvxx(ig)
+            gcmy(ig)=gyo(jg)+tstep*gvyy(ig)
+            gcmz(ig)=gzo(jg)+tstep*gvzz(ig)
+            
+c     calculate rotation of rigid groups: nosquish algorithm
+            
+            q0(ig)=b0(jg)
+            q1(ig)=b1(jg)
+            q2(ig)=b2(jg)
+            q3(ig)=b3(jg)
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+            
+          enddo
+
+c     new atomic positions for atoms in rigid bodies - relative to com
+          
+          k=0
+          do ig=igrp1,igrp2
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+            id=lstgtp(ig)
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x          rot(3)*gzz(id,j)+gcmx(ig)
+              yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x          rot(6)*gzz(id,j)+gcmy(ig)
+              zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x          rot(9)*gzz(id,j)+gcmz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     update positions of free particles to full time step
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            xxx(i)=xxo(i)+tstep*vxx(i)
+            yyy(i)=yyo(i)+tstep*vyy(i)
+            zzz(i)=zzo(i)+tstep*vzz(i)
+            
+          enddo
+          
+c     merge atom positions
+
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply rattle corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+            call qrattle_r
+     x        (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x        nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x        dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+
+          endif
+          
+c     end of first stage 
+
+        else
+          
+c     second stage of velocity verlet algorithm
+          
+          jr=0
+          do ig=igrp1,igrp2
+            
+c     new angular momenta and velocities
+
+            opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x        q3(ig)*p2(ig)-q2(ig)*p3(ig))
+            opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x        q0(ig)*p2(ig)+q1(ig)*p3(ig))
+            opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x        q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+            id=lstgtp(ig)
+
+            omx(ig)=opx*rotinx(id,2)
+            omy(ig)=opy*rotiny(id,2)
+            omz(ig)=opz*rotinz(id,2)
+
+c     new rotational matrix
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     new atomic velocites
+            
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              
+c     new atomic velocites in body frame
+
+              vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+              vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+              vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+              
+c     new atomic velocites in lab frame
+              
+              vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+              vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+              vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     merge velocities and forces from all nodes
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)then
+
+              call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+              call merge1
+     x          (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+              
+            endif
+
+c     correct constraint bond velocities using rattle
+
+            call qrattle_v
+     x        (newstep,safe,lshmov,idnode,mxnode,natms,
+     x        nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x        xxt,yyt,zzt)
+
+          endif
+          
+c     end of second stage
+          
+        endif
+        
+        newstep=.false.
+        
+      enddo
+
+c     check shake convergence
+
+      if(.not.safe)call error(idnode,105)
+
+c     sum constraint virial and stress across processors
+      
+      if(mxnode.gt.1.and.isw.eq.1)then
+        
+        buffer(1)=vircon
+        call gdsum(buffer(1),1,buffer(2))
+        vircon=buffer(1)
+        call gdsum(strcns,9,buffer)
+        
+      endif
+
+c     -------------- end of shake iteration cycle -------------------
+      
+c     calculate kinetic energy
+      
+      if(isw.eq.2)then
+
+        engke=getkinf(ntfree,idnode,mxnode)      
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engtke=engke+engtrn+engrot
+        engke=engke+engtrn
+        
+c     apply Berendsen thermostat - taut is the relaxation time
+        
+        chit=sqrt(1.d0+tstep/taut*(sigma/engtke-1.d0))
+
+        engke=engke*chit**2
+        engtrn=engtrn*chit**2
+        engrot=engrot*chit**2
+
+c     thermostat velocities of free particles
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          if(lstfrz(i).ne.0)then
+            
+            vxx(i)=chit*vxx(i)
+            vyy(i)=chit*vyy(i)
+            vzz(i)=chit*vzz(i)
+            
+          endif
+
+        enddo
+
+c     thermostat rigid body velocities
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          omx(ig)=chit*omx(ig)
+          omy(ig)=chit*omy(ig)
+          omz(ig)=chit*omz(ig)
+          gvxx(ig)=chit*gvxx(ig)
+          gvyy(ig)=chit*gvyy(ig)
+          gvzz(ig)=chit*gvzz(ig)
+
+        enddo
+
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+
+      endif
+      
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     restore forces if isw = 2
+
+      if(isw.eq.2)then
+
+        do i=1,natms
+
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+
+        enddo
+      
+      endif
+
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(dtx,dty,dtz,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      if(isw.eq.2)then
+        deallocate(fxo,fyo,fzo,stat=fail(7))
+      endif
+      
+      return
+      end subroutine nvtqvv_b2
+
+      subroutine nvtqvv_h2
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntshl,keyshl,chit,consv,conint,engke,engrot,
+     x  taut,sigma,tolnce,tstep,vircom,vircon,chit_shl,sigma_shl)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     nvt ensemble - nose-hoover thermostat Molec Phys 87 (1996) 1117
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith april 2005
+c     adapted     d.quigley : metadynamics
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jg,jr
+      integer id,ifre,jrs,icyc,mxshk,idum,ig
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) engtrn,vaa,vbb,vcc,opx,opy,opz,ftx,fty,ftz
+      real(8) fmx,fmy,fmz,tqx,tqy,tqz,tq0,tq1,tq2,tq3,engfke
+      real(8) taut,sigma,chit,hstep,qmass,conint,consv
+
+      integer, parameter :: nnn=13
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9)
+
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+      
+      save newstep,newjob,p0,p1,p2,p3,hstep,qmass,ifre1,ifre2
+      save igrp1,igrp2
+
+      data newjob/.true./
+      
+c     set array allocation error flags
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+c     assign initial parameters
+
+      if(newjob)then
+        
+c     timestep parameters
+        
+        hstep=pt5*tstep
+        
+c     nose-hoover inertia parameter
+        
+        qmass=2.d0*sigma*taut**2
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+        newjob=.false.
+
+      endif
+
+c     allocate working arrays
+
+      allocate(gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(2))
+      allocate(vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(3))
+      allocate(b0(msgrp),b1(msgrp),b2(msgrp),b3(msgrp),
+     x  stat=fail(4))
+      allocate(c0(msgrp),c1(msgrp),c2(msgrp),c3(msgrp),
+     x  stat=fail(5))
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(6))
+        allocate(gxo(msgrp),gyo(msgrp),gzo(msgrp),stat=fail(7))
+
+      endif
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(8))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(9))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(10))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(11))
+
+      endif
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(12))
+      if(isw.eq.2)then
+        allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(13))
+      endif
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2150)
+      enddo
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+      
+c     initialise constraint virial
+
+      if(isw.eq.1)then
+
+        vircon=0.d0
+
+        do i=1,9
+          strcns(i)=0.d0
+        enddo
+
+      endif
+
+c     apply thermostat for first stage
+
+      if(isw.eq.1)then
+        
+        call nvtqscl
+     x    (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,sigma,
+     x    hstep,qmass,taut,chit,conint)
+        
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+        if(lmetadyn.and.keyshl.eq.1)then
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          call nvtscale_shl
+     x      (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x      taut,chit_shl,conint)      
+        endif
+        
+      endif
+
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+
+c     store key config data at start of time step
+
+      if(isw.eq.1)then
+
+c     atom positions
+
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+          
+        enddo
+
+c     rigid body positions
+
+        j=0
+        do i=igrp1,igrp2
+          
+          j=j+1
+          gxo(j)=gcmx(i)
+          gyo(j)=gcmy(i)
+          gzo(j)=gcmz(i)
+
+        enddo
+
+      endif
+
+c     store free atom atom velocities
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+
+c     store rigid body quaternions, momenta and cartesian velocities
+
+      j=0
+      do i=igrp1,igrp2
+
+        j=j+1
+        b0(j)=q0(i)
+        b1(j)=q1(i)
+        b2(j)=q2(i)
+        b3(j)=q3(i)
+        c0(j)=p0(i)
+        c1(j)=p1(i)
+        c2(j)=p2(i)
+        c3(j)=p3(i)
+        gvxo(j)=gvxx(i)
+        gvyo(j)=gvyy(i)
+        gvzo(j)=gvzz(i)
+
+      enddo
+
+c     store forces if isw = 2
+
+      if(isw.eq.2)then
+
+        do i=1,natms
+
+          fxo(i)=fxx(i)
+          fyo(i)=fyy(i)
+          fzo(i)=fzz(i)
+
+        enddo
+      
+      endif
+
+c     -------------- start of shake iteration cycle -------------------
+      
+      icyc=0
+      mxshk=1
+      safe=.false.
+      newstep=.true.
+      if(ntcons.gt.0)mxshk=mxshak
+
+      do while(.not.safe.and.icyc.lt.mxshk)
+        
+        icyc=icyc+1
+        
+c     update velocities of free atoms 1/2 timestep
+
+        j=0
+        do ifre=ifre1,ifre2
+
+          j=j+1
+          i=lstfre(ifre)
+          vxx(i)=vxo(j)+(pt5*tstep*rmass(i))*fxx(i)
+          vyy(i)=vyo(j)+(pt5*tstep*rmass(i))*fyy(i)
+          vzz(i)=vzo(j)+(pt5*tstep*rmass(i))*fzz(i)
+          
+        enddo
+
+c     *************  rigid body motion ****************************
+
+c     operations common to first and second stages
+
+        jg=0
+        jr=0
+        do ig=igrp1,igrp2
+          
+c     fmx,fmy,fmz represent force on c.o.m.
+          
+          jrs=jr
+          fmx=0.d0
+          fmy=0.d0
+          fmz=0.d0
+          id=lstgtp(ig)
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+            fmx=fmx+fxx(i)
+            fmy=fmy+fyy(i)
+            fmz=fmz+fzz(i)
+            
+          enddo
+
+c     current rotational matrix
+          
+          jg=jg+1
+          call getrotmat(b0(jg),b1(jg),b2(jg),b3(jg),rot)
+
+c     calculate torque in principal frame
+
+          jr=jrs
+          ftx=0.d0
+          fty=0.d0
+          ftz=0.d0
+          do j=1,numgsit(id)
+            
+            jr=jr+1
+            i=lstrgd(jr)
+
+            ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+            fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+            ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+            
+          enddo
+          tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+          tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+          tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+
+c     calculate quaternion torques
+
+          tq0=2.0d0*(-b1(jg)*tqx-b2(jg)*tqy-b3(jg)*tqz)
+          tq1=2.0d0*( b0(jg)*tqx-b3(jg)*tqy+b2(jg)*tqz)
+          tq2=2.0d0*( b3(jg)*tqx+b0(jg)*tqy-b1(jg)*tqz)
+          tq3=2.0d0*(-b2(jg)*tqx+b1(jg)*tqy+b0(jg)*tqz)
+
+c     update quaternion momentum by half timestep
+
+          p0(ig)=c0(jg)+tq0*pt5*tstep
+          p1(ig)=c1(jg)+tq1*pt5*tstep
+          p2(ig)=c2(jg)+tq2*pt5*tstep
+          p3(ig)=c3(jg)+tq3*pt5*tstep
+
+c     update centre of mass velocity by half timestep
+
+          gvxx(ig)=gvxo(jg)+fmx*pt5*tstep/gmass(id)
+          gvyy(ig)=gvyo(jg)+fmy*pt5*tstep/gmass(id)
+          gvzz(ig)=gvzo(jg)+fmz*pt5*tstep/gmass(id)
+          
+        enddo
+
+c     first stage of velocity verlet algorithm
+
+        if(isw.eq.1)then
+
+          jg=0
+          do ig=igrp1,igrp2
+
+            jg=jg+1
+
+c     update centre of mass position by full time step
+            
+            gcmx(ig)=gxo(jg)+tstep*gvxx(ig)
+            gcmy(ig)=gyo(jg)+tstep*gvyy(ig)
+            gcmz(ig)=gzo(jg)+tstep*gvzz(ig)
+            
+c     calculate rotation of rigid groups: nosquish algorithm
+            
+            q0(ig)=b0(jg)
+            q1(ig)=b1(jg)
+            q2(ig)=b2(jg)
+            q3(ig)=b3(jg)
+            call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+            
+          enddo
+
+c     new atomic positions for atoms in rigid bodies - relative to com
+          
+          k=0
+          do ig=igrp1,igrp2
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+            id=lstgtp(ig)
+            do j=1,numgsit(id)
+              
+              k=k+1
+              i=lstme(k)
+              xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x          rot(3)*gzz(id,j)+gcmx(ig)
+              yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x          rot(6)*gzz(id,j)+gcmy(ig)
+              zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x          rot(9)*gzz(id,j)+gcmz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     update positions of free particles to full time step
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            xxx(i)=xxo(i)+tstep*vxx(i)
+            yyy(i)=yyo(i)+tstep*vyy(i)
+            zzz(i)=zzo(i)+tstep*vzz(i)
+            
+          enddo
+
+c     merge atom positions
+
+          if(mxnode.gt.1)call merge1
+     x      (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply rattle corrections to bond constraints
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+            call qrattle_r
+     x        (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x        nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x        dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+
+          endif
+          
+c     end of first stage 
+
+        else
+          
+c     second stage of velocity verlet algorithm
+          
+          jr=0
+          do ig=igrp1,igrp2
+            
+c     new angular momenta and velocities
+
+            opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x        q3(ig)*p2(ig)-q2(ig)*p3(ig))
+            opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x        q0(ig)*p2(ig)+q1(ig)*p3(ig))
+            opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x        q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+            id=lstgtp(ig)
+
+            omx(ig)=opx*rotinx(id,2)
+            omy(ig)=opy*rotiny(id,2)
+            omz(ig)=opz*rotinz(id,2)
+
+c     new rotational matrix
+            
+            call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     new atomic velocites
+            
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              
+c     new atomic velocites in body frame
+
+              vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+              vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+              vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+              
+c     new atomic velocites in lab frame
+              
+              vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+              vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+              vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+              
+            enddo
+            
+          enddo
+          
+c     merge velocities and forces from all nodes
+          
+          if(ntcons.gt.0)then
+            
+            if(mxnode.gt.1)then
+
+              call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+              call merge1
+     x          (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+              
+            endif
+
+c     correct constraint bond velocities using rattle
+
+            call qrattle_v
+     x        (newstep,safe,lshmov,idnode,mxnode,natms,
+     x        nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x        xxt,yyt,zzt)
+
+          endif
+          
+c     end of second stage
+          
+        endif
+        
+        newstep=.false.
+        
+      enddo
+
+c     check shake convergence
+      
+      if(.not.safe)call error(idnode,105)
+
+c     sum constraint virial and stress across processors
+      
+      if(mxnode.gt.1.and.isw.eq.1)then
+        
+        buffer(1)=vircon
+        call gdsum(buffer(1),1,buffer(2))
+        vircon=buffer(1)
+        call gdsum(strcns,9,buffer)
+        
+      endif
+
+c     -------------- end of shake iteration cycle -------------------
+      
+c     apply thermostat for second stage and calculate kinetic energy
+      
+      if(isw.eq.2)then
+
+c     rigid body contribution to stress tensor
+
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     apply thermostat for second stage and calculate kinetic energy
+      
+        call nvtqscl
+     x    (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,sigma,
+     x    hstep,qmass,taut,chit,conint)
+
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+        if(lmetadyn.and.keyshl.eq.1)then
+          if(mxnode.gt.1)call merge
+     x      (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+          call nvtscale_shl
+     x      (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x      taut,chit_shl,conint)      
+        endif
+        
+        engke=engfke+engtrn
+
+c     conserved quantity less kinetic and potential energy terms
+        
+        consv=conint+0.5d0*qmass*chit**2
+        
+c     metadynamics shell thermostat
+        
+        if(lmetadyn.and.keyshl.eq.1)then
+          consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+        
+      endif
+
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     restore forces if isw = 2
+
+      if(isw.eq.2)then
+
+        do i=1,natms
+
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+
+        enddo
+      
+      endif
+
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(dtx,dty,dtz,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      if(isw.eq.2)then
+        deallocate(fxo,fyo,fzo,stat=fail(7))
+      endif
+      
+      return
+      end subroutine nvtqvv_h2
+
+      subroutine nptqvv_b2
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,engke,engrot,press,taut,taup,sigma,
+     x  tolnce,tstep,vircom,vircon,elrc,virlrc,virtot,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     npt ensemble - Berendsen thermostat and barostat 
+c     (n.b. not symplectic)
+c     
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith   sep 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jg,jr
+      integer id,ifre,jrs,icyc,mxshk,idum,ig,ntpatm
+      integer iter,mxiter
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon,engtke,engtrn
+      real(8) vaa,vbb,vcc,opx,opy,opz,ftx,fty,ftz,volm0
+      real(8) fmx,fmy,fmz,tqx,tqy,tqz,tq0,tq1,tq2,tq3,taut,sigma,chit
+      real(8) volm,elrc0,elrc,virlrc0,virlrc,scale,psyst,virtot,chip
+      real(8) beta,press,taup,engfke,vzero
+
+      integer, parameter :: nnn=13
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),cell0(9),uni(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+
+      save newstep,newjob,volm0,elrc0,virlrc0,dens0
+      save p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./,beta/7.3728d-3/
+      
+c     set array alocation error flags
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+c     assign initial parameters
+
+      if(newjob)then
+
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2180)
+        
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+        newjob=.false.
+
+      endif
+      
+c     allocate working arrays
+      
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(gxo(msgrp),gyo(msgrp),gzo(msgrp),stat=fail(3))
+
+      endif
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+
+      endif
+      allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(8))
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(9))
+      allocate(vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate(gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(11))
+      allocate(b0(msgrp),b1(msgrp),b2(msgrp),b3(msgrp),
+     x  stat=fail(12))
+      allocate(c0(msgrp),c1(msgrp),c2(msgrp),c3(msgrp),
+     x  stat=fail(13))
+
+c     check array allocation error flags
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2190)
+      enddo
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+      
+c     store key config data at start of time step
+      
+      if(isw.eq.1)then
+        
+c     cell parameters
+        
+        vzero=volm
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+        
+c     atom positions
+
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+          
+        enddo
+
+c     rigid body positions
+
+        j=0
+        do i=igrp1,igrp2
+          
+          j=j+1
+          gxo(j)=gcmx(i)
+          gyo(j)=gcmy(i)
+          gzo(j)=gcmz(i)
+
+        enddo
+        
+      endif
+
+c     store free atom velocities
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+
+c     store rigid body quaternions, momenta and cartesian velocities
+
+      j=0
+      do i=igrp1,igrp2
+
+        j=j+1
+        b0(j)=q0(i)
+        b1(j)=q1(i)
+        b2(j)=q2(i)
+        b3(j)=q3(i)
+        c0(j)=p0(i)
+        c1(j)=p1(i)
+        c2(j)=p2(i)
+        c3(j)=p3(i)
+        gvxo(j)=gvxx(i)
+        gvyo(j)=gvyy(i)
+        gvzo(j)=gvzz(i)
+
+      enddo
+
+c     store forces
+
+      do i=1,natms
+        
+        fxo(i)=fxx(i)
+        fyo(i)=fyy(i)
+        fzo(i)=fzz(i)
+        
+      enddo
+
+      if(isw.eq.1)then
+        
+c     calculate kinetic energy
+        
+        engfke=getkinf(ntfree,idnode,mxnode)
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engke=engfke+engtrn
+        
+      endif
+      
+c     -------------- start of barostat iteration cycle -----------------
+      
+      mxiter=1
+      if(isw.eq.1.and.ntcons.gt.0)mxiter=3
+      do iter=1,mxiter
+        
+        if(isw.eq.1)then
+          
+c     restore cell parameters
+          
+          volm=vzero
+          do i=1,9
+            cell(i)=cell0(i)
+          enddo
+          
+c     calculate system pressure
+          
+          vircon=-(strcns(1)+strcns(5)+strcns(9))
+          psyst=(2.d0*engke-virtot-vircon-vircom)/(3.d0*volm)
+          
+c     apply Berendsen barostat
+          
+          chip=1.d0+beta*tstep*(psyst-press)/taup
+          chip=1.d0
+          scale=chip**(1.d0/3.d0)
+          volm=chip*volm
+          
+c     reset cell parameters for new volume
+          
+          do i=1,9
+            cell(i)=scale*cell(i)
+          enddo
+          
+c     reset constraint virial
+          
+          vircon=0.d0
+          do i=1,9
+            strcns(i)=0.d0
+          enddo
+          
+        endif
+
+c     -------------- start of shake iteration cycle -------------------
+        
+        icyc=0
+        mxshk=1
+        safe=.false.
+        newstep=.true.
+        if(ntcons.gt.0)mxshk=mxshak
+        do while(.not.safe.and.icyc.lt.mxshk)
+          
+          icyc=icyc+1
+          
+c     update velocities of free atoms 1/2 timestep
+          
+          j=0
+          do ifre=ifre1,ifre2
+            
+            j=j+1
+            i=lstfre(ifre)
+            vxx(i)=vxo(j)+(pt5*tstep*rmass(i))*fxx(i)
+            vyy(i)=vyo(j)+(pt5*tstep*rmass(i))*fyy(i)
+            vzz(i)=vzo(j)+(pt5*tstep*rmass(i))*fzz(i)
+            
+          enddo
+
+c     *************  rigid body motion ****************************
+
+c     operations common to first and second stages
+
+          jg=0
+          jr=0
+          do ig=igrp1,igrp2
+            
+c     fmx,fmy,fmz represent force on c.o.m.
+            
+            jrs=jr
+            fmx=0.d0
+            fmy=0.d0
+            fmz=0.d0
+            id=lstgtp(ig)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              fmx=fmx+fxx(i)
+              fmy=fmy+fyy(i)
+              fmz=fmz+fzz(i)
+              
+            enddo
+
+c     current rotational matrix
+            
+            jg=jg+1
+            call getrotmat(b0(jg),b1(jg),b2(jg),b3(jg),rot)
+
+c     calculate torque in principal frame
+
+            jr=jrs
+            ftx=0.d0
+            fty=0.d0
+            ftz=0.d0
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+              fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+              ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+              
+            enddo
+            tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+            tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+            tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+            
+c     calculate quaternion torques
+
+            tq0=2.0d0*(-b1(jg)*tqx-b2(jg)*tqy-b3(jg)*tqz)
+            tq1=2.0d0*( b0(jg)*tqx-b3(jg)*tqy+b2(jg)*tqz)
+            tq2=2.0d0*( b3(jg)*tqx+b0(jg)*tqy-b1(jg)*tqz)
+            tq3=2.0d0*(-b2(jg)*tqx+b1(jg)*tqy+b0(jg)*tqz)
+
+c     update quaternion momentum by half timestep
+
+            p0(ig)=c0(jg)+tq0*pt5*tstep
+            p1(ig)=c1(jg)+tq1*pt5*tstep
+            p2(ig)=c2(jg)+tq2*pt5*tstep
+            p3(ig)=c3(jg)+tq3*pt5*tstep
+
+c     update centre of mass velocity by half timestep
+
+            gvxx(ig)=gvxo(jg)+fmx*pt5*tstep/gmass(id)
+            gvyy(ig)=gvyo(jg)+fmy*pt5*tstep/gmass(id)
+            gvzz(ig)=gvzo(jg)+fmz*pt5*tstep/gmass(id)
+            
+          enddo
+          
+c     first stage of velocity verlet algorithm
+
+          if(isw.eq.1)then
+
+            jg=0
+            do ig=igrp1,igrp2
+
+              jg=jg+1
+
+c     update centre of mass position by full time step
+              
+              gcmx(ig)=scale*gxo(jg)+tstep*gvxx(ig)
+              gcmy(ig)=scale*gyo(jg)+tstep*gvyy(ig)
+              gcmz(ig)=scale*gzo(jg)+tstep*gvzz(ig)
+              
+c     calculate rotation of rigid groups: nosquish algorithm
+              
+              q0(ig)=b0(jg)
+              q1(ig)=b1(jg)
+              q2(ig)=b2(jg)
+              q3(ig)=b3(jg)
+              call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+              
+            enddo
+
+c     new atomic positions for atoms in rigid bodies - relative to com
+            
+            k=0
+            do ig=igrp1,igrp2
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+              id=lstgtp(ig)
+              do j=1,numgsit(id)
+                
+                k=k+1
+                i=lstme(k)
+                xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x            rot(3)*gzz(id,j)+gcmx(ig)
+                yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x            rot(6)*gzz(id,j)+gcmy(ig)
+                zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x            rot(9)*gzz(id,j)+gcmz(ig)
+                
+              enddo
+              
+            enddo
+
+c     update positions of free particles to full time step
+            
+            do ifre=ifre1,ifre2
+              
+              i=lstfre(ifre)
+              xxx(i)=scale*xxo(i)+tstep*vxx(i)
+              yyy(i)=scale*yyo(i)+tstep*vyy(i)
+              zzz(i)=scale*zzo(i)+tstep*vzz(i)
+              
+            enddo
+
+c     merge atom positions
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply rattle corrections to bond constraints
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+              
+              call qrattle_r
+     x          (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x          nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x          dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+              
+            endif
+            
+c     end of first stage 
+            
+          endif
+
+c     second stage of velocity verlet algorithm
+          
+          if(isw.eq.2)then
+
+            jr=0
+            do ig=igrp1,igrp2
+              
+c     new angular momenta and velocities
+
+              opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x          q3(ig)*p2(ig)-q2(ig)*p3(ig))
+              opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x          q0(ig)*p2(ig)+q1(ig)*p3(ig))
+              opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x          q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+              id=lstgtp(ig)
+
+              omx(ig)=opx*rotinx(id,2)
+              omy(ig)=opy*rotiny(id,2)
+              omz(ig)=opz*rotinz(id,2)
+
+c     new rotational matrix
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     new atomic velocites
+              
+              do j=1,numgsit(id)
+                
+                jr=jr+1
+                i=lstrgd(jr)
+                
+c     new atomic velocites in body frame
+
+                vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+                vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+                vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+                
+c     new atomic velocites in lab frame
+                
+                vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+                vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+                vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+                
+              enddo
+              
+            enddo
+            
+c     merge velocities and forces from all nodes
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)then
+                
+                call merge1
+     x            (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+                call merge1
+     x            (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+                
+              endif
+
+c     correct constraint bond velocities using rattle
+
+              call qrattle_v
+     x          (newstep,safe,lshmov,idnode,mxnode,natms,
+     x          nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x          xxt,yyt,zzt)
+
+            endif
+            
+c     end of second stage
+            
+          endif
+          
+          newstep=.false.
+          
+        enddo
+
+c     check shake convergence
+        
+        if(.not.safe)call error(idnode,105)
+        
+c     sum constraint virial and stress across processors
+      
+        if(mxnode.gt.1.and.isw.eq.1)then
+          
+          buffer(1)=vircon
+          call gdsum(buffer(1),1,buffer(2))
+          vircon=buffer(1)
+          call gdsum(strcns,9,buffer)
+          
+        endif
+
+c     -------------- end of shake iteration cycle -------------------
+
+c     rigid body contribution to stress tensor
+
+        if(isw.eq.2)call bodystress
+     x    (idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     restore  forces
+          
+        do i=1,natms
+          
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+          
+        enddo
+
+c     -------------- end of barostat iteration cycle ----------------
+        
+      enddo
+      
+      if(isw.eq.1)then
+
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        
+        do k=1,ntpatm
+          dens(k)=dens0(k)*(volm0/volm)
+        enddo
+        
+c     construct scaling tensor for tethered bonds
+        
+        do i=1,9
+          eta(i)=uni(i)*scale
+        enddo
+        
+      endif
+      
+      if(isw.eq.2)then
+        
+c     calculate kinetic energy
+      
+        engfke=getkinf(ntfree,idnode,mxnode)      
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engtke=engfke+engtrn+engrot
+        engke=engfke+engtrn
+        
+c     apply Berendsen thermostat - taut is the relaxation time
+        
+        chit=sqrt(1.d0+tstep/taut*(sigma/engtke-1.d0))
+        
+        engke=engke*chit**2
+        engtrn=engtrn*chit**2
+        engrot=engrot*chit**2
+
+c     thermostat velocities of free particles
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          if(lstfrz(i).ne.0)then
+            
+            vxx(i)=chit*vxx(i)
+            vyy(i)=chit*vyy(i)
+            vzz(i)=chit*vzz(i)
+            
+          endif
+          
+        enddo
+        
+c     thermostat rigid body velocities
+        
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          omx(ig)=chit*omx(ig)
+          omy(ig)=chit*omy(ig)
+          omz(ig)=chit*omz(ig)
+          gvxx(ig)=chit*gvxx(ig)
+          gvyy(ig)=chit*gvyy(ig)
+          gvzz(ig)=chit*gvzz(ig)
+          
+        enddo
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+
+      endif
+      
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(dtx,dty,dtz,fxo,fyo,fzo,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      
+      return
+      end subroutine nptqvv_b2
+
+      subroutine nptqvv_h2
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x  ntcons,ntpatm,ntfree,ntshl,keyshl,tstep,taut,taup,sigma,
+     x  temp,chip,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x  vircom,vircon,virtot,virlrc,volm,press,chit_shl,sigma_shl)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     npt ensemble - nose-hoover thermostat Molec Phys 87 (1996) 1117
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith april 2005
+c     adapted     d.quigley : metadynamics
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jr
+      integer id,ifre,icyc,mxshk,idum,ig,ntpatm
+      integer jcyc,iter,mxiter
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) engtrn,vaa,vbb,vcc,opx,opy,opz,engfke
+      real(8) taut,taup,sigma,chit,hstep,qmass,conint,consv
+      real(8) cxx,cyy,czz,scale,virtot,press,chip,temp
+      real(8) volm,pmass,totmas,qstep,fstep,volm0,elrc
+      real(8) virlrc,elrc0,virlrc0,chit0,chip0,vzero,cons0
+
+      integer, parameter :: nnn=16
+      integer, parameter :: ncyc=5
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),cell0(9),com(3),vom(3),uni(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: vx1(:),vy1(:),vz1(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: oxo(:),oyo(:),ozo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gvx1(:),gvy1(:),gvz1(:)
+
+c     metadynamics shell thermostat variables
+
+      integer ntshl,keyshl
+      real(8) sigma_shl
+
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+
+c     end metadynamics shell thermostat variables
+      
+      save newstep,newjob,p0,p1,p2,p3,hstep,fstep,qmass,ifre1,ifre2
+      save igrp1,igrp2,volm0,elrc0,virlrc0,qstep,dens0,totmas
+      save pmass
+
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      data newjob/.true./
+      
+c     set array allocation error flags
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+c     assign initial parameters
+
+      if(newjob)then
+        
+c     store intitial parameters
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        hstep=0.5d0*tstep
+        fstep=0.5d0*tstep/dble(ncyc)
+        qstep=0.25d0*tstep/dble(ncyc)
+        
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2220)
+
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+
+c     total system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+
+c     nose-hoover thermostat and barostat inertia parameter
+        
+        qmass=2.d0*sigma*taut**2
+        pmass=2.d0*sigma*taup**2
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+        newjob=.false.
+
+      endif
+
+      if(ntcons.gt.0)safe=.false.
+
+c     allocate working arrays
+
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(gxo(mxgrp),gyo(mxgrp),gzo(mxgrp),stat=fail(3))
+
+      endif
+      if(ntcons.gt.0)then
+        
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+        
+      endif
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(8))
+      allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(9))
+      allocate(vx1(mxatms),vy1(mxatms),vz1(mxatms),stat=fail(10))
+      allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(11))
+      allocate(oxo(mxatms),oyo(mxatms),ozo(mxatms),stat=fail(12))
+      allocate(b0(mxgrp),b1(mxgrp),b2(mxgrp),b3(mxgrp),
+     x  stat=fail(13))
+      allocate(c0(mxgrp),c1(mxgrp),c2(mxgrp),c3(mxgrp),
+     x  stat=fail(14))
+      allocate(gvxo(mxgrp),gvyo(mxgrp),gvzo(mxgrp),stat=fail(15))
+      allocate(gvx1(mxgrp),gvy1(mxgrp),gvz1(mxgrp),stat=fail(16))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2230)
+      enddo
+      
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     store key config data at start of timestep
+
+      vzero=volm
+      chit0=chit
+      chip0=chip
+      cons0=conint
+      do i=1,9
+        cell0(i)=cell(i)
+      enddo
+
+      if(isw.eq.1)then
+        
+c     remove system centre of mass velocity
+        
+        call getvom(natms,idnode,mxnode,totmas,vom)
+        
+        do i=1,natms
+          
+          vxx(i)=vxx(i)-vom(1)
+          vyy(i)=vyy(i)-vom(2)
+          vzz(i)=vzz(i)-vom(3)
+          
+        enddo
+        
+        do ig=1,ngrp
+          
+          gvxx(ig)=gvxx(ig)-vom(1)
+          gvyy(ig)=gvyy(ig)-vom(2)
+          gvzz(ig)=gvzz(ig)-vom(3)
+          
+        enddo
+
+c     store atom positions
+        
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+          
+        enddo
+        
+c     store rigid body positions
+        
+        do ig=1,ngrp
+          
+          gxo(ig)=gcmx(ig)
+          gyo(ig)=gcmy(ig)
+          gzo(ig)=gcmz(ig)
+          
+        enddo
+        
+      endif
+      
+c     store free atom velocities
+
+      do i=1,natms
+        
+        vxo(i)=vxx(i)
+        vyo(i)=vyy(i)
+        vzo(i)=vzz(i)
+        
+      enddo
+
+c     store forces
+
+      do i=1,natms
+        
+        fxo(i)=fxx(i)
+        fyo(i)=fyy(i)
+        fzo(i)=fzz(i)
+        
+      enddo
+      
+c     store rigid body quaternions, angular and cartesian velocities
+
+      do ig=1,ngrp
+        
+        b0(ig)=q0(ig)
+        b1(ig)=q1(ig)
+        b2(ig)=q2(ig)
+        b3(ig)=q3(ig)
+        oxo(ig)=omx(ig)
+        oyo(ig)=omy(ig)
+        ozo(ig)=omz(ig)
+        gvxo(ig)=gvxx(ig)
+        gvyo(ig)=gvyy(ig)
+        gvzo(ig)=gvzz(ig)
+
+      enddo
+      
+c     iteration necessary if ntcons > 0 and isw=1
+
+      mxiter=1
+      if(isw.eq.1.and.ntcons.gt.0)mxiter=3
+      do iter=1,mxiter
+
+c     integration of barostat and thermostat (part 1)
+        
+        if(isw.eq.1)then
+          
+c     restore cell parameters
+
+          volm=vzero
+          chit=chit0
+          chip=chip0
+          conint=cons0
+          do i=1,9
+            cell(i)=cell0(i)
+          enddo
+
+c     restore free atom velocities
+          
+          do i=1,natms
+            
+            vxx(i)=vxo(i)
+            vyy(i)=vyo(i)
+            vzz(i)=vzo(i)
+            
+          enddo
+
+c     restore rigid body quaternions angular and cartesian velocities
+
+          do ig=1,ngrp
+            
+            omx(ig)=oxo(ig)
+            omy(ig)=oyo(ig)
+            omz(ig)=ozo(ig)
+            gvxx(ig)=gvxo(ig)
+            gvyy(ig)=gvyo(ig)
+            gvzz(ig)=gvzo(ig)
+            
+          enddo
+          
+c     current constraint virial
+
+          vircon=-(strcns(1)+strcns(5)+strcns(9))
+
+          do jcyc=1,ncyc
+            
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply npt barostat
+            
+            call nptqscl_p
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,fstep,pmass,
+     x        chip,chit,volm,press,vircon,virtot,vircom)
+
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+          
+c     translational kinetic energy
+
+          engke=engfke+engtrn
+          
+c     scale cell vectors - isotropic
+          
+          scale=(volm/vzero)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+          
+c     reset constraint virial and stress
+          
+          vircon=0.d0
+          do i=1,9
+            strcns(i)=0.d0
+          enddo
+          
+c     calculate quaternion momenta
+          
+          do ig=igrp1,igrp2
+            
+            id=lstgtp(ig)
+            opx=omx(ig)*rotinx(id,1)
+            opy=omy(ig)*rotiny(id,1)
+            opz=omz(ig)*rotinz(id,1)
+            p0(ig)=2.0d0*(-b1(ig)*opx-b2(ig)*opy-b3(ig)*opz)
+            p1(ig)=2.0d0*( b0(ig)*opx-b3(ig)*opy+b2(ig)*opz)
+            p2(ig)=2.0d0*( b3(ig)*opx+b0(ig)*opy-b1(ig)*opz)
+            p3(ig)=2.0d0*(-b2(ig)*opx+b1(ig)*opy+b0(ig)*opz)
+            
+          enddo
+          
+        endif
+        
+c     store intermediate velocities
+
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          vx1(i)=vxx(i)
+          vy1(i)=vyy(i)
+          vz1(i)=vzz(i)
+          
+        enddo
+        do ig=igrp1,igrp2
+          
+          c0(ig)=p0(ig)
+          c1(ig)=p1(ig)
+          c2(ig)=p2(ig)
+          c3(ig)=p3(ig)
+          gvx1(ig)=gvxx(ig)
+          gvy1(ig)=gvyy(ig)
+          gvz1(ig)=gvzz(ig)
+          
+        enddo
+
+c     -------------- start of shake iteration cycle -------------------
+        
+        icyc=0
+        mxshk=1
+        safe=.false.
+        newstep=.true.
+        if(ntcons.gt.0)mxshk=mxshak
+        do while(.not.safe.and.icyc.lt.mxshk)
+          
+          icyc=icyc+1
+          
+c     update velocities of free atoms 1/2 timestep
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            vxx(i)=vx1(i)+hstep*rmass(i)*fxx(i)
+            vyy(i)=vy1(i)+hstep*rmass(i)*fyy(i)
+            vzz(i)=vz1(i)+hstep*rmass(i)*fzz(i)
+            
+          enddo
+          
+c     *************  rigid body motion ****************************
+          
+c     restore rigid body quaternions, angular momenta and velocities
+
+          do ig=igrp1,igrp2
+            
+            q0(ig)=b0(ig)
+            q1(ig)=b1(ig)
+            q2(ig)=b2(ig)
+            q3(ig)=b3(ig)
+            p0(ig)=c0(ig)
+            p1(ig)=c1(ig)
+            p2(ig)=c2(ig)
+            p3(ig)=c3(ig)
+            gvxx(ig)=gvx1(ig)
+            gvyy(ig)=gvy1(ig)
+            gvzz(ig)=gvz1(ig)
+            
+          enddo
+
+c     calculate new rigid body velocities
+
+          call rotate_omega
+     x      (idnode,mxnode,ngrp,hstep,p0,p1,p2,p3,dtx,dty,dtz)
+
+c     first stage of velocity verlet algorithm
+
+          if(isw.eq.1)then
+            
+c     calculate system centre of mass
+            
+            call getcom(natms,idnode,mxnode,totmas,com)
+            
+c     update centre of mass position by full time step
+      
+            do ig=igrp1,igrp2
+              
+              cxx=gxo(ig)-com(1)
+              cyy=gyo(ig)-com(2)
+              czz=gzo(ig)-com(3)
+              gcmx(ig)=gxo(ig)+tstep*(gvxx(ig)+chip*cxx)
+              gcmy(ig)=gyo(ig)+tstep*(gvyy(ig)+chip*cyy)
+              gcmz(ig)=gzo(ig)+tstep*(gvzz(ig)+chip*czz)
+              
+c     calculate rotation of rigid groups: nosquish algorithm
+              
+              call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+              
+            enddo
+            
+c     merge group coms from all nodes
+            
+            if(mxnode.gt.1)call merge
+     x        (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+            
+c     new atomic positions for atoms in rigid bodies - relative to com
+            
+            k=0
+            do ig=igrp1,igrp2
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+              id=lstgtp(ig)
+              do j=1,numgsit(id)
+                
+                k=k+1
+                i=lstme(k)
+                xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x            rot(3)*gzz(id,j)+gcmx(ig)
+                yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x            rot(6)*gzz(id,j)+gcmy(ig)
+                zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x            rot(9)*gzz(id,j)+gcmz(ig)
+                
+              enddo
+              
+            enddo
+            
+c     update positions of free particles to full time step
+            
+            do ifre=ifre1,ifre2
+              
+              i=lstfre(ifre)
+              cxx=xxo(i)-com(1)
+              cyy=yyo(i)-com(2)
+              czz=zzo(i)-com(3)
+              xxx(i)=xxo(i)+tstep*(vxx(i)+chip*cxx)
+              yyy(i)=yyo(i)+tstep*(vyy(i)+chip*cyy)
+              zzz(i)=zzo(i)+tstep*(vzz(i)+chip*czz)
+              
+            enddo
+
+c     merge atom positions
+
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply rattle corrections to bond constraints
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+              
+              call qrattle_r
+     x          (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x          nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x          dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+              
+            endif
+
+c     end of first stage 
+            
+          endif
+          
+c     second stage of velocity verlet algorithm
+          
+          if(isw.eq.2)then
+            
+            jr=0
+            do ig=igrp1,igrp2
+              
+c     new angular momenta and velocities
+
+              opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x          q3(ig)*p2(ig)-q2(ig)*p3(ig))
+              opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x          q0(ig)*p2(ig)+q1(ig)*p3(ig))
+              opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x          q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+              id=lstgtp(ig)
+
+              omx(ig)=opx*rotinx(id,2)
+              omy(ig)=opy*rotiny(id,2)
+              omz(ig)=opz*rotinz(id,2)
+              
+c     new rotational matrix
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     new atomic velocites
+              
+              do j=1,numgsit(id)
+                
+                jr=jr+1
+                i=lstrgd(jr)
+                
+c     new atomic velocites in body frame
+
+                vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+                vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+                vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+                
+c     new atomic velocites in lab frame
+                
+                vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+                vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+                vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+                
+              enddo
+              
+            enddo
+            
+c     merge velocities and forces from all nodes
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)then
+
+                call merge1
+     x            (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+                call merge1
+     x            (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+                
+              endif
+
+c     correct constraint bond velocities using rattle
+
+              call qrattle_v
+     x          (newstep,safe,lshmov,idnode,mxnode,natms,
+     x          nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x          xxt,yyt,zzt)
+
+            endif
+            
+c     end of second stage
+            
+          endif
+          
+          newstep=.false.
+          
+        enddo
+
+c     check shake convergence
+        
+        if(.not.safe)call error(idnode,105)
+
+c     sum constraint virial and stress across processors
+      
+        if(mxnode.gt.1.and.isw.eq.1)then
+          
+          buffer(1)=vircon
+          call gdsum(buffer(1),1,buffer(2))
+          vircon=buffer(1)
+          call gdsum(strcns,9,buffer)
+          
+        endif
+
+c     -------------- end of shake iteration cycle -------------------
+        
+c     rigid body contribution to stress tensor
+        
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+        
+c     integration of barostat and thermostat (part 2)
+        
+        if(isw.eq.2)then
+
+c     current constraint virial
+
+          vircon=-(strcns(1)+strcns(5)+strcns(9))
+
+          do jcyc=1,ncyc
+            
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply npt barostat
+            
+            call nptqscl_p
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,fstep,pmass,
+     x        chip,chit,volm,press,vircon,virtot,vircom)
+
+c     integrate and apply npt thermostat
+            
+            call nptqscl_t
+     x        (idnode,mxnode,ntfree,ngrp,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chip,chit,conint)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+          
+c     translational kinetic energy
+
+          engke=engfke+engtrn
+
+c     scale cell vectors - isotropic
+          
+          scale=(volm/vzero)**(1.d0/3.d0)
+          do i=1,9
+            cell(i)=cell0(i)*scale
+          enddo
+          
+        endif
+
+c     restore  forces
+        
+        do i=1,natms
+          
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+          
+        enddo
+
+c     -------------- end of barostat iteration cycle ----------------
+
+      enddo
+
+      if(isw.eq.2)then
+
+c     calculate conserved variable
+
+        consv=conint+0.5d0*qmass*chit**2+press*volm
+     x    +0.5d0*pmass*chip**2
+        
+c     metadynamics shell thermostat
+
+        if(lmetadyn.and.keyshl.eq.1)then
+          consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+        
+c     merge velocity arrays
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+          
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)        
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+        
+      endif
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+      
+c     construct scaling tensor (for tethered atoms)
+      
+      do i=1,9
+        eta(i)=chip*uni(i)
+      enddo
+      
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     exchange position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(oxo,oyo,ozo,dtx,dty,dtz,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      deallocate(fxo,fyo,fzo,stat=fail(7))
+      
+      return
+      end subroutine nptqvv_h2
+
+      subroutine nstqvv_b2
+     x  (safe,lshmov,isw,imcon,idnode,mxnode,natms,ngrp,nscons,
+     x  ntcons,ntfree,ntpatm,mode,engke,engrot,press,taut,taup,sigma,
+     x  tolnce,tstep,vircom,vircon,elrc,virlrc,volm)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     nst ensemble - Berendsen thermostat and barostat 
+c     (n.b. not symplectic)
+c     
+c     isothermal compressibility (beta) set to that of liquid water
+c     = 0.007372 dlpoly units
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith   sep 2005
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jg,jr
+      integer id,ifre,icyc,mxshk,idum,ig,ntpatm,mode
+      integer iter,mxiter,jrs
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon,engtke
+      real(8) engtrn,taut,sigma,chit
+      real(8) vaa,vbb,vcc,opx,opy,opz,ftx,fty,ftz,volm0
+      real(8) fmx,fmy,fmz,tqx,tqy,tqz,tq0,tq1,tq2,tq3
+      real(8) volm,elrc0,elrc,virlrc0,virlrc
+      real(8) beta,press,taup,engfke,hstep,vzero
+
+      integer, parameter :: nnn=13
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),uni(9),celp(10)
+      real(8) cell0(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+
+      save newstep,newjob,volm0,elrc0,virlrc0,dens0
+      save p0,p1,p2,p3,ifre1,ifre2,igrp1,igrp2,hstep
+
+      data newjob/.true./,beta/7.3728d-3/
+      data uni/1.d0,0.d0,0.d0,0.d0,1.d0,0.d0,0.d0,0.d0,1.d0/
+      
+c     set array alocation error flags
+      
+      do i=1,nnn
+        fail(i)=0
+      enddo
+      
+c     assign initial parameters
+
+      if(newjob)then
+
+c     timestep parameters
+        
+        hstep=pt5*tstep
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+        
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2260)
+        
+c     store initial values of volume and long range corrections
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+
+        newjob=.false.
+
+      endif
+      
+c     allocate working arrays
+      
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(gxo(msgrp),gyo(msgrp),gzo(msgrp),stat=fail(3))
+
+      endif
+      if(ntcons.gt.0)then
+
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+
+      endif
+      allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(8))
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(9))
+      allocate(vxo(msatms),vyo(msatms),vzo(msatms),stat=fail(10))
+      allocate(gvxo(msgrp),gvyo(msgrp),gvzo(msgrp),stat=fail(11))
+      allocate(b0(msgrp),b1(msgrp),b2(msgrp),b3(msgrp),
+     x  stat=fail(12))
+      allocate(c0(msgrp),c1(msgrp),c2(msgrp),c3(msgrp),
+     x  stat=fail(13))
+
+c     check array allocation error flags
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2270)
+      enddo
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+      
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     calculate quaternion momenta at start of time step
+
+      if(isw.eq.1)then
+
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          opx=omx(ig)*rotinx(id,1)
+          opy=omy(ig)*rotiny(id,1)
+          opz=omz(ig)*rotinz(id,1)
+          p0(ig)=2.0d0*(-q1(ig)*opx-q2(ig)*opy-q3(ig)*opz)
+          p1(ig)=2.0d0*( q0(ig)*opx-q3(ig)*opy+q2(ig)*opz)
+          p2(ig)=2.0d0*( q3(ig)*opx+q0(ig)*opy-q1(ig)*opz)
+          p3(ig)=2.0d0*(-q2(ig)*opx+q1(ig)*opy+q0(ig)*opz)
+          
+        enddo
+
+      endif
+      
+c     store key config data at start of time step
+      
+      if(isw.eq.1)then
+
+c     cell parameters
+        
+        vzero=volm
+        do i=1,9
+          cell0(i)=cell(i)
+        enddo
+        
+c     atom positions
+
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+          
+        enddo
+
+c     rigid body positions
+
+        j=0
+        do i=igrp1,igrp2
+          
+          j=j+1
+          gxo(j)=gcmx(i)
+          gyo(j)=gcmy(i)
+          gzo(j)=gcmz(i)
+
+        enddo
+
+      endif
+
+c     store free atom velocities
+      
+      j=0
+      do ifre=ifre1,ifre2
+        
+        j=j+1
+        i=lstfre(ifre)
+        vxo(j)=vxx(i)
+        vyo(j)=vyy(i)
+        vzo(j)=vzz(i)
+        
+      enddo
+
+c     store rigid body quaternions, momenta and cartesian velocities
+
+      j=0
+      do i=igrp1,igrp2
+
+        j=j+1
+        b0(j)=q0(i)
+        b1(j)=q1(i)
+        b2(j)=q2(i)
+        b3(j)=q3(i)
+        c0(j)=p0(i)
+        c1(j)=p1(i)
+        c2(j)=p2(i)
+        c3(j)=p3(i)
+        gvxo(j)=gvxx(i)
+        gvyo(j)=gvyy(i)
+        gvzo(j)=gvzz(i)
+
+      enddo
+
+c     store forces
+
+      do i=1,natms
+        
+        fxo(i)=fxx(i)
+        fyo(i)=fyy(i)
+        fzo(i)=fzz(i)
+        
+      enddo
+      
+c     extract previous constraint terms from stress tensor
+
+      if(isw.eq.1)then
+        
+        do i=1,9
+          stress(i)=stress(i)-strcns(i)
+        enddo
+
+      endif
+
+c     -------------- start of barostat iteration cycle -----------------
+      
+      mxiter=1
+      if(isw.eq.1.and.ntcons.gt.0)mxiter=3
+      do iter=1,mxiter
+        
+        do i=1,9
+          eta(i)=uni(i)
+        enddo
+        
+        if(isw.eq.1)then
+          
+c     restore cell parameters
+          
+          volm=vzero
+          do i=1,9
+            cell(i)=cell0(i)
+          enddo
+          
+c     calculate Berendsen barostat
+          
+          do i=1,9
+            eta(i)=tstep*beta*((stress(i)+strcns(i))/volm-
+     x        press*uni(i))/taup+uni(i)
+          enddo
+          if(mode.gt.0)then
+            eta(3)=0.d0
+            eta(6)=0.d0
+            eta(7)=0.d0
+            eta(8)=0.d0
+            if(mode.lt.3)then
+              eta(2)=0.d0
+              eta(4)=0.d0
+              if(mode.eq.2)then
+                eta(1)=0.5d0*(eta(1)+eta(5))
+                eta(5)=eta(1)
+              endif
+            endif
+          endif
+          
+c     reset cell parameters for new volume
+          
+          call mat_mul(eta,cell,cell)
+          
+c     calculate new volume
+          
+          call dcell(cell,celp)
+          volm=celp(10)
+
+c     reset constraint virial
+        
+          vircon=0.d0
+          
+          do i=1,9
+            strcns(i)=0.d0
+          enddo
+          
+        endif
+        
+c     -------------- start of shake iteration cycle -------------------
+        
+        icyc=0
+        mxshk=1
+        safe=.false.
+        newstep=.true.
+        if(ntcons.gt.0)mxshk=mxshak
+        do while(.not.safe.and.icyc.lt.mxshk)
+          
+          icyc=icyc+1
+          
+c     update velocities of free atoms 1/2 timestep
+          
+          j=0
+          do ifre=ifre1,ifre2
+            
+            j=j+1
+            i=lstfre(ifre)
+            vxx(i)=vxo(j)+hstep*rmass(i)*fxx(i)
+            vyy(i)=vyo(j)+hstep*rmass(i)*fyy(i)
+            vzz(i)=vzo(j)+hstep*rmass(i)*fzz(i)
+            
+          enddo
+          
+c     *************  rigid body motion ****************************
+          
+c     operations common to first and second stages
+          
+          jg=0
+          jr=0
+          do ig=igrp1,igrp2
+              
+c     fmx,fmy,fmz represent force on c.o.m.
+            
+            jrs=jr
+            fmx=0.d0
+            fmy=0.d0
+            fmz=0.d0
+            id=lstgtp(ig)
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              fmx=fmx+fxx(i)
+              fmy=fmy+fyy(i)
+              fmz=fmz+fzz(i)
+              
+            enddo
+            
+c     current rotational matrix
+            
+            jg=jg+1
+            call getrotmat(b0(jg),b1(jg),b2(jg),b3(jg),rot)
+            
+c     calculate torque in principal frame
+            
+            jr=jrs
+            ftx=0.d0
+            fty=0.d0
+            ftz=0.d0
+            do j=1,numgsit(id)
+              
+              jr=jr+1
+              i=lstrgd(jr)
+              ftx=ftx+dty(jr)*fzz(i)-dtz(jr)*fyy(i)
+              fty=fty+dtz(jr)*fxx(i)-dtx(jr)*fzz(i)
+              ftz=ftz+dtx(jr)*fyy(i)-dty(jr)*fxx(i)
+
+            enddo
+
+            tqx=ftx*rot(1)+fty*rot(4)+ftz*rot(7)
+            tqy=ftx*rot(2)+fty*rot(5)+ftz*rot(8)
+            tqz=ftx*rot(3)+fty*rot(6)+ftz*rot(9)
+            
+c     calculate quaternion torques
+            
+            tq0=2.0d0*(-b1(jg)*tqx-b2(jg)*tqy-b3(jg)*tqz)
+            tq1=2.0d0*( b0(jg)*tqx-b3(jg)*tqy+b2(jg)*tqz)
+            tq2=2.0d0*( b3(jg)*tqx+b0(jg)*tqy-b1(jg)*tqz)
+            tq3=2.0d0*(-b2(jg)*tqx+b1(jg)*tqy+b0(jg)*tqz)
+            
+c     update quaternion momentum by half timestep
+            
+            p0(ig)=c0(jg)+tq0*hstep
+            p1(ig)=c1(jg)+tq1*hstep
+            p2(ig)=c2(jg)+tq2*hstep
+            p3(ig)=c3(jg)+tq3*hstep
+            
+c     update centre of mass velocity by half timestep
+            
+            gvxx(ig)=gvxo(jg)+fmx*hstep/gmass(id)
+            gvyy(ig)=gvyo(jg)+fmy*hstep/gmass(id)
+            gvzz(ig)=gvzo(jg)+fmz*hstep/gmass(id)
+            
+          enddo
+          
+c     first stage of velocity verlet algorithm
+          
+          if(isw.eq.1)then
+            
+            jg=0
+            do ig=igrp1,igrp2
+              
+              jg=jg+1
+              
+c     update centre of mass position by full time step
+              
+              gcmx(ig)=tstep*gvxx(ig)+
+     x          eta(1)*gxo(jg)+eta(4)*gyo(jg)+eta(7)*gzo(jg)
+              gcmy(ig)=tstep*gvyy(ig)+
+     x          eta(2)*gxo(jg)+eta(5)*gyo(jg)+eta(8)*gzo(jg)
+              gcmz(ig)=tstep*gvzz(ig)+
+     x          eta(3)*gxo(jg)+eta(6)*gyo(jg)+eta(9)*gzo(jg)
+              
+c     calculate rotation of rigid groups: nosquish algorithm
+              
+              q0(ig)=b0(jg)
+              q1(ig)=b1(jg)
+              q2(ig)=b2(jg)
+              q3(ig)=b3(jg)
+              call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+              
+            enddo
+
+c     new atomic positions for atoms in rigid bodies - relative to com
+          
+            k=0
+            do ig=igrp1,igrp2
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+              id=lstgtp(ig)
+              do j=1,numgsit(id)
+                
+                k=k+1
+                i=lstme(k)
+                xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x            rot(3)*gzz(id,j)+gcmx(ig)
+                yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x            rot(6)*gzz(id,j)+gcmy(ig)
+                zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x            rot(9)*gzz(id,j)+gcmz(ig)
+
+              enddo
+              
+            enddo
+            
+c     update positions of free particles to full time step
+            
+            do ifre=ifre1,ifre2
+              
+              i=lstfre(ifre)
+              xxx(i)=tstep*vxx(i)+
+     x          eta(1)*xxo(i)+eta(4)*yyo(i)+eta(7)*zzo(i)
+              yyy(i)=tstep*vyy(i)+
+     x          eta(2)*xxo(i)+eta(5)*yyo(i)+eta(8)*zzo(i)
+              zzz(i)=tstep*vzz(i)+
+     x          eta(3)*xxo(i)+eta(6)*yyo(i)+eta(9)*zzo(i)
+              
+            enddo
+            
+c     merge atom positions
+            
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+            
+c     apply rattle corrections to bond constraints
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)call merge1
+     x            (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+              call qrattle_r
+     x          (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x          nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x          dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+              
+            endif
+            
+c     end of first stage 
+            
+          endif
+
+c     second stage of velocity verlet algorithm
+          
+          if(isw.eq.2)then
+            
+            jr=0
+            do ig=igrp1,igrp2
+              
+c     new angular momenta and velocities
+              
+              opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x          q3(ig)*p2(ig)-q2(ig)*p3(ig))
+              opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x          q0(ig)*p2(ig)+q1(ig)*p3(ig))
+              opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x          q1(ig)*p2(ig)+q0(ig)*p3(ig))
+              
+              id=lstgtp(ig)
+              
+              omx(ig)=opx*rotinx(id,2)
+              omy(ig)=opy*rotiny(id,2)
+              omz(ig)=opz*rotinz(id,2)
+              
+c     new rotational matrix
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+              
+c     new atomic velocites
+              
+              do j=1,numgsit(id)
+                
+                jr=jr+1
+                i=lstrgd(jr)
+                
+c     new atomic velocites in body frame
+                
+                vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+                vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+                vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+                
+c     new atomic velocites in lab frame
+                
+                vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+                vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+                vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+                
+              enddo
+              
+            enddo
+            
+c     merge velocities and forces from all nodes
+            
+            if(ntcons.gt.0)then
+            
+              if(mxnode.gt.1)then
+                
+                call merge1
+     x            (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+                call merge1
+     x            (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+                
+              endif
+              
+c     correct constraint bond velocities using rattle
+              
+              call qrattle_v
+     x          (newstep,safe,lshmov,idnode,mxnode,natms,
+     x          nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x          xxt,yyt,zzt)
+              
+            endif
+            
+c     end of second stage
+            
+          endif
+          
+          newstep=.false.
+          
+        enddo
+
+c     check shake convergence
+        
+        if(.not.safe)call error(idnode,105)
+        
+c     sum constraint virial and stress across processors
+        
+        if(mxnode.gt.1.and.isw.eq.1)then
+          
+          buffer(1)=vircon
+          call gdsum(buffer(1),1,buffer(2))
+          vircon=buffer(1)
+          call gdsum(strcns,9,buffer)
+          
+        endif
+
+c     -------------- end of shake iteration cycle -------------------
+      
+c     rigid body contribution to stress tensor
+
+        if(isw.eq.2)call bodystress
+     x    (idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+
+c     restore  forces
+        
+        do i=1,natms
+          
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+          
+        enddo
+
+c     -------------- end of barostat iteration cycle ----------------
+        
+      enddo
+      
+      if(isw.eq.1)then
+
+c     adjust long range corrections and number density
+        
+        elrc=elrc0*(volm0/volm)
+        virlrc=virlrc0*(volm0/volm)
+        
+        do k=1,ntpatm
+          dens(k)=dens0(k)*(volm0/volm)
+        enddo
+        
+      endif
+      
+c     calculate kinetic energy
+      
+      if(isw.eq.2)then
+        
+        engfke=getkinf(ntfree,idnode,mxnode)      
+        call getking(ngrp,idnode,mxnode,engtrn,engrot)
+        engtke=engfke+engtrn+engrot
+        engke=engfke+engtrn
+        
+c     apply Berendsen thermostat - taut is the relaxation time
+        
+        chit=sqrt(1.d0+tstep/taut*(sigma/engtke-1.d0))
+        
+        engke=engke*chit**2
+        engtrn=engtrn*chit**2
+        engrot=engrot*chit**2
+
+c     thermostat velocities of free particles
+        
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          if(lstfrz(i).ne.0)then
+            
+            vxx(i)=chit*vxx(i)
+            vyy(i)=chit*vyy(i)
+            vzz(i)=chit*vzz(i)
+            
+          endif
+          
+        enddo
+        
+c     thermostat rigid body velocities
+        
+        do ig=igrp1,igrp2
+          
+          id=lstgtp(ig)
+          omx(ig)=chit*omx(ig)
+          omy(ig)=chit*omy(ig)
+          omz(ig)=chit*omz(ig)
+          gvxx(ig)=chit*gvxx(ig)
+          gvyy(ig)=chit*gvyy(ig)
+          gvzz(ig)=chit*gvzz(ig)
+          
+        enddo
+        
+c     kinetic contribution to stress tensor
+        
+        call kinstressf(ntfree,idnode,mxnode,strkin)
+        call kinstressg(ngrp,idnode,mxnode,strgrp)
+        
+c     add contributions to stress tensor
+        
+        do i=1,9
+          stress(i)=stress(i)+strbod(i)+strcns(i)+strkin(i)+strgrp(i)
+        enddo
+        
+      endif
+      
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(dtx,dty,dtz,fxo,fyo,fzo,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      
+      return
+      end subroutine nstqvv_b2
+
+      subroutine nstqvv_h2
+     x  (safe,lshmov,isw,idnode,mxnode,natms,imcon,ngrp,nscons,
+     x  ntcons,ntpatm,ntfree,mode,ntshl,keyshl,tstep,taut,taup,
+     x  sigma,temp,chit,consv,conint,engke,engrot,elrc,tolnce,
+     x  vircom,vircon,virlrc,volm,press,chit_shl,sigma_shl)
+      
+c***********************************************************************
+c     
+c     dlpoly subroutine to integrate rigid body equations of motion
+c     using the symplectic no_squish quaternion algorithm of 
+c     miller et al j.chem.phys 116 (2002) 8649
+c     plus bond constraints -  including rigid body sites linked
+c     by constraint sites (qrattle algorithm)
+c     
+c     nst ensemble - nose-hoover thermostat Molec Phys 87 (1996) 1117
+c     
+c     parallel replicated data version : block data
+c     
+c     omx,omy,omz=angular velocity in body fixed frame (principal axes)
+c     rotinx,y,z =rotational inertia in body fixed frame
+c     
+c     copyright daresbury laboratory
+c     author      w.smith sept 2005
+c     adapted     d. quigley : metadynamics
+c     
+c**********************************************************************
+
+      implicit none
+
+      logical newstep,safe,lshmov,newjob
+
+      integer isw,imcon,idnode,mxnode,natms,ngrp,nscons,ntcons
+      integer ntfree,i,j,k,igrp1,igrp2,igrp,ifre1,ifre2,jr
+      integer id,ifre,icyc,mxshk,idum,ig,ntpatm,mode
+      integer jcyc,iter,mxiter
+
+      real(8) engke,engrot,tolnce,tstep,vircom,vircon
+      real(8) engtrn,engfke
+      real(8) vaa,vbb,vcc,opx,opy,opz
+      real(8) taut,taup,sigma,chit,hstep,qmass,conint,consv
+      real(8) cxx,cyy,czz,press,chip2,temp
+      real(8) volm,pmass,totmas,qstep,fstep,volm0,elrc
+      real(8) virlrc,elrc0,virlrc0,chit0,vzero,cons0
+
+      integer, parameter :: nnn=16
+      integer, parameter :: ncyc=5
+      real(8), parameter :: pt5=0.5d0
+
+      integer fail(nnn)
+      real(8) rot(9),strkin(9),strgrp(9),com(3),vom(3)
+      real(8) cell0(9),eta0(9),stres0(9)
+
+      real(8), allocatable :: dens0(:)
+      real(8), allocatable :: xxo(:),yyo(:),zzo(:)
+      real(8), allocatable :: vxo(:),vyo(:),vzo(:)
+      real(8), allocatable :: vx1(:),vy1(:),vz1(:)
+      real(8), allocatable :: fxo(:),fyo(:),fzo(:)
+      real(8), allocatable :: gxo(:),gyo(:),gzo(:)
+      real(8), allocatable :: oxo(:),oyo(:),ozo(:)
+      real(8), allocatable :: dxx(:),dyy(:),dzz(:)
+      real(8), allocatable :: txx(:),tyy(:),tzz(:)
+      real(8), allocatable :: xxt(:),yyt(:),zzt(:)
+      real(8), allocatable :: dxt(:),dyt(:),dzt(:)
+      real(8), allocatable :: dtx(:),dty(:),dtz(:)
+      real(8), allocatable :: b0(:),b1(:),b2(:),b3(:)
+      real(8), allocatable :: c0(:),c1(:),c2(:),c3(:)
+      real(8), allocatable :: p0(:),p1(:),p2(:),p3(:)
+      real(8), allocatable :: gvxo(:),gvyo(:),gvzo(:)
+      real(8), allocatable :: gvx1(:),gvy1(:),gvz1(:)
+      
+c     metadynamics shell thermostat variables
+      
+      integer ntshl,keyshl
+      real(8) sigma_shl
+      
+      logical,save :: lfirst=.true.
+      real(8)      :: chit_shl  
+      real(8),save :: qmass_shl
+      real(8)      :: shlke
+      
+c     end metadynamics shell thermostat variables
+      
+      save newstep,newjob,p0,p1,p2,p3,hstep,fstep,qmass,ifre1,ifre2
+      save igrp1,igrp2,volm0,elrc0,virlrc0,qstep,dens0,totmas
+      save pmass
+
+      data newjob/.true./
+      
+c     set array allocation error flags
+
+      do i=1,nnn
+        fail(i)=0
+      enddo
+
+c     assign initial parameters
+
+      if(newjob)then
+        
+c     store intitial parameters
+        
+        volm0=volm
+        elrc0=elrc
+        virlrc0=virlrc
+        hstep=0.5d0*tstep
+        fstep=0.5d0*tstep/dble(ncyc)
+        qstep=0.25d0*tstep/dble(ncyc)
+        
+c     allocate density storage array
+
+        fail(1)=0
+        allocate(dens0(mxatyp),stat=fail(1))
+        if(fail(1).gt.0)call error(idnode,2220)
+
+        do i=1,ntpatm
+          dens0(i)=dens(i)
+        enddo
+        
+c     total system mass
+        
+        totmas=getmass(natms,idnode,mxnode)
+
+c     nose-hoover thermostat and barostat inertia parameter
+        
+        qmass=2.d0*sigma*taut**2
+        pmass=2.d0*sigma*taup**2
+        
+c     free atom block indices
+        
+        ifre1=(idnode*ntfree)/mxnode+1
+        ifre2=((idnode+1)*ntfree)/mxnode
+        
+c     group block indices
+        
+        igrp1=(idnode*ngrp)/mxnode+1
+        igrp2=((idnode+1)*ngrp)/mxnode
+        
+c     check work arrays are large enough
+        
+        safe=(igrp2-igrp1+1.le.msgrp) 
+        if(mxnode.gt.1) call gstate(safe)
+        if(.not.safe)then 
+          igrp=igrp2-igrp1+1
+          call gimax(igrp,1,idum)
+          if(idnode.eq.0) write(nrite,*) ' make msgrp >=',igrp
+          call  error(idnode,506)
+        endif
+
+        allocate(p0(mxgrp),p1(mxgrp),p2(mxgrp),p3(mxgrp),stat=fail(1))
+        newjob=.false.
+
+      endif
+
+      if(ntcons.gt.0)safe=.false.
+
+c     allocate working arrays
+
+      if(isw.eq.1)then
+
+        allocate(xxo(mxatms),yyo(mxatms),zzo(mxatms),stat=fail(2))
+        allocate(gxo(mxgrp),gyo(mxgrp),gzo(mxgrp),stat=fail(3))
+
+      endif
+      if(ntcons.gt.0)then
+        
+        allocate(dxx(mxcons),dyy(mxcons),dzz(mxcons),stat=fail(4))
+        allocate(txx(mxatms),tyy(mxatms),tzz(mxatms),stat=fail(5))
+        allocate(xxt(mxatms),yyt(mxatms),zzt(mxatms),stat=fail(6))
+        allocate(dxt(mxcons),dyt(mxcons),dzt(mxcons),stat=fail(7))
+        
+      endif
+      allocate(dtx(mxatms),dty(mxatms),dtz(mxatms),stat=fail(8))
+      allocate(vxo(mxatms),vyo(mxatms),vzo(mxatms),stat=fail(9))
+      allocate(vx1(mxatms),vy1(mxatms),vz1(mxatms),stat=fail(10))
+      allocate(fxo(mxatms),fyo(mxatms),fzo(mxatms),stat=fail(11))
+      allocate(oxo(mxatms),oyo(mxatms),ozo(mxatms),stat=fail(12))
+      allocate(b0(mxgrp),b1(mxgrp),b2(mxgrp),b3(mxgrp),
+     x  stat=fail(13))
+      allocate(c0(mxgrp),c1(mxgrp),c2(mxgrp),c3(mxgrp),
+     x  stat=fail(14))
+      allocate(gvxo(mxgrp),gvyo(mxgrp),gvzo(mxgrp),stat=fail(15))
+      allocate(gvx1(mxgrp),gvy1(mxgrp),gvz1(mxgrp),stat=fail(16))
+
+      do i=1,nnn
+        if(fail(i).gt.0)call error(idnode,2230)
+      enddo
+
+      if(lmetadyn.and.lfirst.and.(ntshl>0))then
+        if(idnode.eq.0)then
+          write(*,*)"Warning - Metadynamics Modification"
+          write(*,*)"========================="
+          write(*,*)"Coupling core-shell motion thermostat at 1 K"
+        endif
+        lfirst=.false.
+c     use same relaxation time for global and core-shell?
+        qmass_shl=2.d0*sigma_shl*taut**2
+      endif
+      
+c     construct current bond vectors
+      
+      if(ntcons.gt.0)then
+
+        do k=1,nscons
+          
+          i=listcon(k,2)
+          j=listcon(k,3)
+          dxx(k)=xxx(i)-xxx(j)
+          dyy(k)=yyy(i)-yyy(j)
+          dzz(k)=zzz(i)-zzz(j)
+          
+        enddo
+
+        call images(imcon,0,1,nscons,cell,dxx,dyy,dzz)
+
+      endif
+
+c     atom displacement from rigid body centre of mass
+
+      jr=0
+      do ig=igrp1,igrp2
+        
+        id=lstgtp(ig)
+        
+        do j=1,numgsit(id)
+          
+          jr=jr+1
+          i=lstrgd(jr)
+          
+          dtx(jr)=xxx(i)-gcmx(ig)
+          dty(jr)=yyy(i)-gcmy(ig)
+          dtz(jr)=zzz(i)-gcmz(ig)
+          
+        enddo
+        
+      enddo
+
+c     periodic boundary condition for displacement vectors
+
+      call images(imcon,0,1,jr,cell,dtx,dty,dtz)
+      
+c     store key config data at start of timestep
+
+      vzero=volm
+      chit0=chit
+      cons0=conint
+      do i=1,9
+
+        cell0(i)=cell(i)
+        eta0(i)=eta(i)
+        stres0(i)=stress(i)
+        
+      enddo
+
+      if(isw.eq.1)then
+        
+c     remove system centre of mass velocity
+        
+        call getvom(natms,idnode,mxnode,totmas,vom)
+        
+        do i=1,natms
+          
+          vxx(i)=vxx(i)-vom(1)
+          vyy(i)=vyy(i)-vom(2)
+          vzz(i)=vzz(i)-vom(3)
+          
+        enddo
+        
+        do ig=1,ngrp
+          
+          gvxx(ig)=gvxx(ig)-vom(1)
+          gvyy(ig)=gvyy(ig)-vom(2)
+          gvzz(ig)=gvzz(ig)-vom(3)
+          
+        enddo
+
+c     store atom positions
+        
+        do i=1,natms
+          
+          xxo(i)=xxx(i)
+          yyo(i)=yyy(i)
+          zzo(i)=zzz(i)
+          
+        enddo
+        
+c     store rigid body positions
+        
+        do ig=1,ngrp
+          
+          gxo(ig)=gcmx(ig)
+          gyo(ig)=gcmy(ig)
+          gzo(ig)=gcmz(ig)
+          
+        enddo
+        
+      endif
+      
+c     store free atom velocities
+
+      do i=1,natms
+        
+        vxo(i)=vxx(i)
+        vyo(i)=vyy(i)
+        vzo(i)=vzz(i)
+        
+      enddo
+
+c     store forces
+
+      do i=1,natms
+        
+        fxo(i)=fxx(i)
+        fyo(i)=fyy(i)
+        fzo(i)=fzz(i)
+        
+      enddo
+      
+c     store rigid body quaternions, angular and cartesian velocities
+
+      do ig=1,ngrp
+        
+        b0(ig)=q0(ig)
+        b1(ig)=q1(ig)
+        b2(ig)=q2(ig)
+        b3(ig)=q3(ig)
+        oxo(ig)=omx(ig)
+        oyo(ig)=omy(ig)
+        ozo(ig)=omz(ig)
+        gvxo(ig)=gvxx(ig)
+        gvyo(ig)=gvyy(ig)
+        gvzo(ig)=gvzz(ig)
+
+      enddo
+      
+c     iteration necessary if ntcons > 0 and isw=1
+      
+      mxiter=1
+      if(isw.eq.1.and.ntcons.gt.0)mxiter=3
+      do iter=1,mxiter
+
+c     integration of barostat and thermostat (part 1)
+
+        if(isw.eq.1)then
+
+c     restore cell parameters
+
+          volm=vzero
+          chit=chit0
+          conint=cons0
+          do i=1,9
+
+            cell(i)=cell0(i)
+            eta(i)=eta0(i)
+            
+          enddo
+
+c     restore free atom velocities
+          
+          do i=1,natms
+            
+            vxx(i)=vxo(i)
+            vyy(i)=vyo(i)
+            vzz(i)=vzo(i)
+            
+          enddo
+
+c     restore rigid body quaternions angular and cartesian velocities
+
+          do ig=1,ngrp
+            
+            omx(ig)=oxo(ig)
+            omy(ig)=oyo(ig)
+            omz(ig)=ozo(ig)
+            gvxx(ig)=gvxo(ig)
+            gvyy(ig)=gvyo(ig)
+            gvzz(ig)=gvzo(ig)
+            
+          enddo
+          
+c     kinetic contributions to stress tensor
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)        
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+
+          do jcyc=1,ncyc
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t2
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chit,conint,strkin,strgrp)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply nst barostat
+            
+            call nstqscl_p2
+     x        (idnode,mxnode,ntfree,ngrp,mode,fstep,pmass,chit,press,
+     x        volm,strkin,strgrp)
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t2
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chit,conint,strkin,strgrp)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+          
+c     translational kinetic energy
+
+          engke=engfke+engtrn
+          
+c     reset constraint virial and stress
+
+          vircon=0.d0
+          do i=1,9
+
+            stress(i)=stress(i)-strcns(i)-strbod(i)
+            strcns(i)=0.d0
+
+          enddo
+          
+c     calculate quaternion momenta
+          
+          do ig=igrp1,igrp2
+            
+            id=lstgtp(ig)
+            opx=omx(ig)*rotinx(id,1)
+            opy=omy(ig)*rotiny(id,1)
+            opz=omz(ig)*rotinz(id,1)
+            p0(ig)=2.0d0*(-b1(ig)*opx-b2(ig)*opy-b3(ig)*opz)
+            p1(ig)=2.0d0*( b0(ig)*opx-b3(ig)*opy+b2(ig)*opz)
+            p2(ig)=2.0d0*( b3(ig)*opx+b0(ig)*opy-b1(ig)*opz)
+            p3(ig)=2.0d0*(-b2(ig)*opx+b1(ig)*opy+b0(ig)*opz)
+            
+          enddo
+          
+        endif
+        
+c     store intermediate velocities
+
+        do ifre=ifre1,ifre2
+          
+          i=lstfre(ifre)
+          vx1(i)=vxx(i)
+          vy1(i)=vyy(i)
+          vz1(i)=vzz(i)
+          
+        enddo
+        do ig=igrp1,igrp2
+          
+          c0(ig)=p0(ig)
+          c1(ig)=p1(ig)
+          c2(ig)=p2(ig)
+          c3(ig)=p3(ig)
+          gvx1(ig)=gvxx(ig)
+          gvy1(ig)=gvyy(ig)
+          gvz1(ig)=gvzz(ig)
+          
+        enddo
+
+c     -------------- start of shake iteration cycle -------------------
+        
+        icyc=0
+        mxshk=1
+        safe=.false.
+        newstep=.true.
+        if(ntcons.gt.0)mxshk=mxshak
+        
+        do while(.not.safe.and.icyc.lt.mxshk)
+          
+          icyc=icyc+1
+          
+c     update velocities of free atoms 1/2 timestep
+          
+          do ifre=ifre1,ifre2
+            
+            i=lstfre(ifre)
+            vxx(i)=vx1(i)+hstep*rmass(i)*fxx(i)
+            vyy(i)=vy1(i)+hstep*rmass(i)*fyy(i)
+            vzz(i)=vz1(i)+hstep*rmass(i)*fzz(i)
+            
+          enddo
+          
+c     *************  rigid body motion ****************************
+          
+c     restore rigid body quaternions, angular momenta and velocities
+
+          do ig=igrp1,igrp2
+            
+            q0(ig)=b0(ig)
+            q1(ig)=b1(ig)
+            q2(ig)=b2(ig)
+            q3(ig)=b3(ig)
+            p0(ig)=c0(ig)
+            p1(ig)=c1(ig)
+            p2(ig)=c2(ig)
+            p3(ig)=c3(ig)
+            gvxx(ig)=gvx1(ig)
+            gvyy(ig)=gvy1(ig)
+            gvzz(ig)=gvz1(ig)
+            
+          enddo
+          
+c     calculate new rigid body velocities
+
+          call rotate_omega
+     x      (idnode,mxnode,ngrp,hstep,p0,p1,p2,p3,dtx,dty,dtz)
+
+c     first stage of velocity verlet algorithm
+
+          if(isw.eq.1)then
+            
+c     calculate system centre of mass
+            
+            call getcom(natms,idnode,mxnode,totmas,com)
+
+c     update centre of mass position by full time step
+            
+            do ig=igrp1,igrp2
+
+              cxx=gxo(ig)-com(1)
+              cyy=gyo(ig)-com(2)
+              czz=gzo(ig)-com(3)
+              gcmx(ig)=gxo(ig)+
+     x          tstep*(gvxx(ig)+eta(1)*cxx+eta(4)*cyy+eta(7)*czz)
+              gcmy(ig)=gyo(ig)+
+     x          tstep*(gvyy(ig)+eta(2)*cxx+eta(5)*cyy+eta(8)*czz)
+              gcmz(ig)=gzo(ig)+
+     x          tstep*(gvzz(ig)+eta(3)*cxx+eta(6)*cyy+eta(9)*czz)
+
+c     calculate rotation of rigid groups: nosquish algorithm
+              
+              call nosquish(ig,tstep,q0,q1,q2,q3,p0,p1,p2,p3)
+              
+            enddo
+            
+c     merge group coms from all nodes
+
+            if(mxnode.gt.1)call merge
+     x        (idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+
+c     new atomic positions for atoms in rigid bodies - relative to com
+            
+            k=0
+            do ig=igrp1,igrp2
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+              
+              id=lstgtp(ig)
+              do j=1,numgsit(id)
+                
+                k=k+1
+                i=lstme(k)
+                xxx(i)=rot(1)*gxx(id,j)+rot(2)*gyy(id,j)+
+     x            rot(3)*gzz(id,j)+gcmx(ig)
+                yyy(i)=rot(4)*gxx(id,j)+rot(5)*gyy(id,j)+
+     x            rot(6)*gzz(id,j)+gcmy(ig)
+                zzz(i)=rot(7)*gxx(id,j)+rot(8)*gyy(id,j)+
+     x            rot(9)*gzz(id,j)+gcmz(ig)
+                
+              enddo
+              
+            enddo
+            
+c     update positions of free particles to full time step
+            
+            do ifre=ifre1,ifre2
+              
+              i=lstfre(ifre)
+              cxx=xxo(i)-com(1)
+              cyy=yyo(i)-com(2)
+              czz=zzo(i)-com(3)
+              xxx(i)=xxo(i)+
+     x          tstep*(vxx(i)+eta(1)*cxx+eta(4)*cyy+eta(7)*czz)
+              yyy(i)=yyo(i)+
+     x          tstep*(vyy(i)+eta(2)*cxx+eta(5)*cyy+eta(8)*czz)
+              zzz(i)=zzo(i)+
+     x          tstep*(vzz(i)+eta(3)*cxx+eta(6)*cyy+eta(9)*czz)
+              
+            enddo
+
+c     merge atom positions
+
+            if(mxnode.gt.1)call merge1
+     x        (idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+
+c     apply rattle corrections to bond constraints
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)call merge1
+     x          (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+
+              call qrattle_r
+     x          (newstep,safe,lshmov,idnode,imcon,mxnode,natms,
+     x          nscons,tolnce,tstep,vircon,dxx,dyy,dzz,dxt,dyt,
+     x          dzt,txx,tyy,tzz,xxt,yyt,zzt,strcns)
+              
+            endif
+
+c     end of first stage 
+
+          endif
+
+c     second stage of velocity verlet algorithm
+          
+          if(isw.eq.2)then
+            
+            jr=0
+            do ig=igrp1,igrp2
+              
+c     new angular momenta and velocities
+
+              opx=pt5*(-q1(ig)*p0(ig)+q0(ig)*p1(ig)+
+     x          q3(ig)*p2(ig)-q2(ig)*p3(ig))
+              opy=pt5*(-q2(ig)*p0(ig)-q3(ig)*p1(ig)+
+     x          q0(ig)*p2(ig)+q1(ig)*p3(ig))
+              opz=pt5*(-q3(ig)*p0(ig)+q2(ig)*p1(ig)-
+     x          q1(ig)*p2(ig)+q0(ig)*p3(ig))
+
+              id=lstgtp(ig)
+
+              omx(ig)=opx*rotinx(id,2)
+              omy(ig)=opy*rotiny(id,2)
+              omz(ig)=opz*rotinz(id,2)
+              
+c     new rotational matrix
+              
+              call getrotmat(q0(ig),q1(ig),q2(ig),q3(ig),rot)
+
+c     new atomic velocites
+              
+              do j=1,numgsit(id)
+                
+                jr=jr+1
+                i=lstrgd(jr)
+                
+c     new atomic velocites in body frame
+
+                vaa=omy(ig)*gzz(id,j)-omz(ig)*gyy(id,j)
+                vbb=omz(ig)*gxx(id,j)-omx(ig)*gzz(id,j)
+                vcc=omx(ig)*gyy(id,j)-omy(ig)*gxx(id,j)
+                
+c     new atomic velocites in lab frame
+                
+                vxx(i)=rot(1)*vaa+rot(2)*vbb+rot(3)*vcc+gvxx(ig)
+                vyy(i)=rot(4)*vaa+rot(5)*vbb+rot(6)*vcc+gvyy(ig)
+                vzz(i)=rot(7)*vaa+rot(8)*vbb+rot(9)*vcc+gvzz(ig)
+                
+              enddo
+              
+            enddo
+            
+c     merge velocities and forces from all nodes
+            
+            if(ntcons.gt.0)then
+              
+              if(mxnode.gt.1)then
+
+                call merge1
+     x            (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+                call merge1
+     x            (idnode,mxnode,natms,lstme,fxx,fyy,fzz,buffer)
+                
+              endif
+
+c     correct constraint bond velocities using rattle
+
+              call qrattle_v
+     x          (newstep,safe,lshmov,idnode,mxnode,natms,
+     x          nscons,tolnce,tstep,dxx,dyy,dzz,txx,tyy,tzz,
+     x          xxt,yyt,zzt)
+
+            endif
+            
+c     end of second stage
+            
+          endif
+          
+          newstep=.false.
+          
+        enddo
+
+c     check shake convergence
+        
+        if(.not.safe)call error(idnode,105)
+        
+c     sum constraint virial and stress across processors
+        
+        if(mxnode.gt.1.and.isw.eq.1)then
+          
+          buffer(1)=vircon
+          call gdsum(buffer(1),1,buffer(2))
+          vircon=buffer(1)
+          call gdsum(strcns,9,buffer)
+          
+        endif
+        
+c     -------------- end of shake iteration cycle -------------------
+
+c     calculate rigid body contribution to stress tensor
+          
+        call bodystress(idnode,mxnode,ngrp,vircom,strbod,dtx,dty,dtz)
+          
+c     add new constraint terms to stress tensor
+          
+        if(isw.eq.1)then
+
+          do i=1,9
+            stress(i)=stress(i)+strcns(i)+strbod(i)
+          enddo
+        
+        endif
+
+c     integration of barostat and thermostat (part 2)
+        
+        if(isw.eq.2)then
+          
+c     kinetic contributions to stress tensor
+          
+          call kinstressf(ntfree,idnode,mxnode,strkin)        
+          call kinstressg(ngrp,idnode,mxnode,strgrp)
+          
+c     add kinetic and body contributions to stress tensor
+          
+          do i=1,9
+            stress(i)=stres0(i)+strkin(i)+strgrp(i)+strbod(i)+strcns(i)
+          enddo
+
+          do jcyc=1,ncyc
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t2
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chit,conint,strkin,strgrp)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+c     integrate and apply nst barostat
+            
+            call nstqscl_p2
+     x        (idnode,mxnode,ntfree,ngrp,mode,fstep,pmass,chit,press,
+     x        volm,strkin,strgrp)
+            
+c     integrate and apply nst thermostat
+            
+            call nstqscl_t2
+     x        (idnode,mxnode,ntfree,ngrp,mode,engfke,engtrn,engrot,temp,
+     x        sigma,qstep,pmass,qmass,taut,chit,conint,strkin,strgrp)
+            
+c     metadynamics shell thermostat
+c     ====================================================
+c     Must first merge update velocities as the core-shell
+c     velocites are not distributed according to the same
+c     rules.
+c     ====================================================
+            if(lmetadyn.and.keyshl.eq.1)then
+              if(mxnode.gt.1)call merge
+     x          (idnode,mxnode,natms,mxbuff,vxx,vyy,vzz,buffer)
+              call nvtscale_shl
+     x          (idnode,mxnode,ntshl,shlke,sigma_shl,hstep,qmass_shl,
+     x          taut,chit_shl,conint)      
+            endif  
+            
+          enddo
+          
+c     translational kinetic energy
+          
+          engke=engfke+engtrn
+
+c     sum up all contributions to stress tensor
+          
+          do i=1,9
+            stress(i)=stres0(i)+strkin(i)+strgrp(i)+strbod(i)+strcns(i)
+          enddo
+          
+        endif
+
+c     restore forces
+
+        do i=1,natms
+          
+          fxx(i)=fxo(i)
+          fyy(i)=fyo(i)
+          fzz(i)=fzo(i)
+          
+        enddo
+        
+c     -------------- end of barostat iteration cycle ----------------
+
+      enddo
+
+      if(isw.eq.2)then
+
+c     calculate conserved variable
+
+        chip2=sdot0(9,eta,eta)
+        if(mode.eq.2)chip2=chip2-eta(1)**2
+        consv=conint+0.5d0*qmass*chit**2+0.5d0*pmass*chip2+press*volm
+        
+c     metadynamics shell thermostat
+
+        if(lmetadyn.and.keyshl.eq.1)then
+          consv=consv+0.5d0*qmass_shl*chit_shl**2
+        endif
+
+c     merge velocity arrays
+        
+        if(mxnode.gt.1)call merge1
+     x    (idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     adjust long range corrections and number density
+      
+      elrc=elrc0*(volm0/volm)
+      virlrc=virlrc0*(volm0/volm)
+      do k=1,ntpatm
+        dens(k)=dens0(k)*(volm0/volm)
+      enddo
+      
+      if(mxnode.gt.1)then
+
+c     merge new group coordinates and velocities
+
+        if(isw.eq.1)
+     x    call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+        call merge(idnode,mxnode,ngrp,mxbuff,gvxx,gvyy,gvzz,buffer)
+        
+c     merge new atomic coordinates and velocities
+        
+        if(isw.eq.1)
+     x    call merge1(idnode,mxnode,natms,lstme,xxx,yyy,zzz,buffer)
+        call merge1(idnode,mxnode,natms,lstme,vxx,vyy,vzz,buffer)
+        
+      endif
+
+c     periodic boundary condition
+          
+      if(isw.eq.2)then
+        
+        call images(imcon,idnode,mxnode,natms,cell,xxx,yyy,zzz)
+        call images(imcon,idnode,mxnode,ngrp,cell,gcmx,gcmy,gcmz)
+        
+c     merge position data
+        
+        if(mxnode.gt.1)then
+          
+          call merge(idnode,mxnode,natms,mxbuff,xxx,yyy,zzz,buffer)
+          call merge(idnode,mxnode,ngrp,mxbuff,gcmx,gcmy,gcmz,buffer)
+          
+        endif
+        
+      endif
+      
+c     deallocate working arrays
+
+      deallocate(gvxo,gvyo,gvzo,vxo,vyo,vzo,stat=fail(1))
+      deallocate(b0,b1,b2,b3,c0,c1,c2,c3,stat=fail(2))
+      deallocate(dtx,dty,dtz,stat=fail(3))
+      if(isw.eq.1)then
+        deallocate(xxo,yyo,zzo,gxo,gyo,gzo,stat=fail(4))
+      endif
+      if(ntcons.gt.0)then
+
+        deallocate(dxx,dyy,dzz,txx,tyy,tzz,stat=fail(5))
+        deallocate(dxt,dyt,dzt,xxt,yyt,zzt,stat=fail(6))
+
+      endif
+      if(isw.eq.2)then
+        deallocate(fxo,fyo,fzo,stat=fail(7))
+      endif
+      
+      return
+      end subroutine nstqvv_h2
+      
+      end module vv_rotation2_module
